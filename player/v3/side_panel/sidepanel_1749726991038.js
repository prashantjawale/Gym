/** @returns {void} */
function noop() {}

function run(fn) {
	return fn();
}

function blank_object() {
	return Object.create(null);
}

/**
 * @param {Function[]} fns
 * @returns {void}
 */
function run_all(fns) {
	fns.forEach(run);
}

/**
 * @param {any} thing
 * @returns {thing is Function}
 */
function is_function(thing) {
	return typeof thing === 'function';
}

/** @returns {boolean} */
function safe_not_equal(a, b) {
	return a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';
}

let src_url_equal_anchor;

/**
 * @param {string} element_src
 * @param {string} url
 * @returns {boolean}
 */
function src_url_equal(element_src, url) {
	if (element_src === url) return true;
	if (!src_url_equal_anchor) {
		src_url_equal_anchor = document.createElement('a');
	}
	// This is actually faster than doing URL(..).href
	src_url_equal_anchor.href = url;
	return element_src === src_url_equal_anchor.href;
}

/** @returns {boolean} */
function is_empty(obj) {
	return Object.keys(obj).length === 0;
}

function subscribe(store, ...callbacks) {
	if (store == null) {
		for (const callback of callbacks) {
			callback(undefined);
		}
		return noop;
	}
	const unsub = store.subscribe(...callbacks);
	return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}

/**
 * Get the current value from a store by subscribing and immediately unsubscribing.
 *
 * https://svelte.dev/docs/svelte-store#get
 * @template T
 * @param {import('../store/public.js').Readable<T>} store
 * @returns {T}
 */
function get_store_value(store) {
	let value;
	subscribe(store, (_) => (value = _))();
	return value;
}

function null_to_empty(value) {
	return value == null ? '' : value;
}

/**
 * @param {Node} target
 * @param {Node} node
 * @returns {void}
 */
function append(target, node) {
	target.appendChild(node);
}

/**
 * @param {Node} target
 * @param {string} style_sheet_id
 * @param {string} styles
 * @returns {void}
 */
function append_styles(target, style_sheet_id, styles) {
	const append_styles_to = get_root_for_style(target);
	if (!append_styles_to.getElementById(style_sheet_id)) {
		const style = element('style');
		style.id = style_sheet_id;
		style.textContent = styles;
		append_stylesheet(append_styles_to, style);
	}
}

/**
 * @param {Node} node
 * @returns {ShadowRoot | Document}
 */
function get_root_for_style(node) {
	if (!node) return document;
	const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
	if (root && /** @type {ShadowRoot} */ (root).host) {
		return /** @type {ShadowRoot} */ (root);
	}
	return node.ownerDocument;
}

/**
 * @param {ShadowRoot | Document} node
 * @param {HTMLStyleElement} style
 * @returns {CSSStyleSheet}
 */
function append_stylesheet(node, style) {
	append(/** @type {Document} */ (node).head || node, style);
	return style.sheet;
}

/**
 * @param {Node} target
 * @param {Node} node
 * @param {Node} [anchor]
 * @returns {void}
 */
function insert(target, node, anchor) {
	target.insertBefore(node, anchor || null);
}

/**
 * @param {Node} node
 * @returns {void}
 */
function detach(node) {
	if (node.parentNode) {
		node.parentNode.removeChild(node);
	}
}

/**
 * @returns {void} */
function destroy_each(iterations, detaching) {
	for (let i = 0; i < iterations.length; i += 1) {
		if (iterations[i]) iterations[i].d(detaching);
	}
}

/**
 * @template {keyof HTMLElementTagNameMap} K
 * @param {K} name
 * @returns {HTMLElementTagNameMap[K]}
 */
function element(name) {
	return document.createElement(name);
}

/**
 * @template {keyof SVGElementTagNameMap} K
 * @param {K} name
 * @returns {SVGElement}
 */
function svg_element(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

/**
 * @param {string} data
 * @returns {Text}
 */
function text(data) {
	return document.createTextNode(data);
}

/**
 * @returns {Text} */
function space() {
	return text(' ');
}

/**
 * @returns {Text} */
function empty() {
	return text('');
}

/**
 * @param {EventTarget} node
 * @param {string} event
 * @param {EventListenerOrEventListenerObject} handler
 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
 * @returns {() => void}
 */
function listen(node, event, handler, options) {
	node.addEventListener(event, handler, options);
	return () => node.removeEventListener(event, handler, options);
}

/**
 * @returns {(event: any) => any} */
function prevent_default(fn) {
	return function (event) {
		event.preventDefault();
		// @ts-ignore
		return fn.call(this, event);
	};
}

/**
 * @returns {(event: any) => any} */
function stop_propagation(fn) {
	return function (event) {
		event.stopPropagation();
		// @ts-ignore
		return fn.call(this, event);
	};
}

/**
 * @param {Element} node
 * @param {string} attribute
 * @param {string} [value]
 * @returns {void}
 */
function attr(node, attribute, value) {
	if (value == null) node.removeAttribute(attribute);
	else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}

/**
 * @returns {void} */
function set_custom_element_data(node, prop, value) {
	const lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first
	if (lower in node) {
		node[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;
	} else if (prop in node) {
		node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
	} else {
		attr(node, prop, value);
	}
}

/**
 * @param {Element} element
 * @returns {ChildNode[]}
 */
function children(element) {
	return Array.from(element.childNodes);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @returns {void}
 */
function set_data(text, data) {
	data = '' + data;
	if (text.data === data) return;
	text.data = /** @type {string} */ (data);
}

/**
 * @returns {void} */
function set_input_value(input, value) {
	input.value = value == null ? '' : value;
}

/**
 * @returns {void} */
function set_style(node, key, value, important) {
	if (value == null) {
		node.style.removeProperty(key);
	} else {
		node.style.setProperty(key, value, '');
	}
}

/**
 * @returns {void} */
function toggle_class(element, name, toggle) {
	// The `!!` is required because an `undefined` flag means flipping the current state.
	element.classList.toggle(name, !!toggle);
}

/**
 * @template T
 * @param {string} type
 * @param {T} [detail]
 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
 * @returns {CustomEvent<T>}
 */
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
	return new CustomEvent(type, { detail, bubbles, cancelable });
}
/** */
class HtmlTag {
	/**
	 * @private
	 * @default false
	 */
	is_svg = false;
	/** parent for creating node */
	e = undefined;
	/** html tag nodes */
	n = undefined;
	/** target */
	t = undefined;
	/** anchor */
	a = undefined;
	constructor(is_svg = false) {
		this.is_svg = is_svg;
		this.e = this.n = null;
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	c(html) {
		this.h(html);
	}

	/**
	 * @param {string} html
	 * @param {HTMLElement | SVGElement} target
	 * @param {HTMLElement | SVGElement} anchor
	 * @returns {void}
	 */
	m(html, target, anchor = null) {
		if (!this.e) {
			if (this.is_svg)
				this.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));
			/** #7364  target for <template> may be provided as #document-fragment(11) */ else
				this.e = element(
					/** @type {keyof HTMLElementTagNameMap} */ (
						target.nodeType === 11 ? 'TEMPLATE' : target.nodeName
					)
				);
			this.t =
				target.tagName !== 'TEMPLATE'
					? target
					: /** @type {HTMLTemplateElement} */ (target).content;
			this.c(html);
		}
		this.i(anchor);
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	h(html) {
		this.e.innerHTML = html;
		this.n = Array.from(
			this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes
		);
	}

	/**
	 * @returns {void} */
	i(anchor) {
		for (let i = 0; i < this.n.length; i += 1) {
			insert(this.t, this.n[i], anchor);
		}
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	p(html) {
		this.d();
		this.h(html);
		this.i(this.a);
	}

	/**
	 * @returns {void} */
	d() {
		this.n.forEach(detach);
	}
}

/**
 * @typedef {Node & {
 * 	claim_order?: number;
 * 	hydrate_init?: true;
 * 	actual_end_child?: NodeEx;
 * 	childNodes: NodeListOf<NodeEx>;
 * }} NodeEx
 */

/** @typedef {ChildNode & NodeEx} ChildNodeEx */

/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

/**
 * @typedef {ChildNodeEx[] & {
 * 	claim_info?: {
 * 		last_index: number;
 * 		total_claimed: number;
 * 	};
 * }} ChildNodeArray
 */

let current_component;

/** @returns {void} */
function set_current_component(component) {
	current_component = component;
}

function get_current_component() {
	if (!current_component) throw new Error('Function called outside component initialization');
	return current_component;
}

/**
 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
 * it can be called from an external module).
 *
 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
 *
 * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).
 *
 * https://svelte.dev/docs/svelte#onmount
 * @template T
 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
 * @returns {void}
 */
function onMount(fn) {
	get_current_component().$$.on_mount.push(fn);
}

/**
 * Schedules a callback to run immediately before the component is unmounted.
 *
 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
 * only one that runs inside a server-side component.
 *
 * https://svelte.dev/docs/svelte#ondestroy
 * @param {() => any} fn
 * @returns {void}
 */
function onDestroy(fn) {
	get_current_component().$$.on_destroy.push(fn);
}

/**
 * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).
 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
 *
 * Component events created with `createEventDispatcher` create a
 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
 * property and can contain any type of data.
 *
 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
 * ```ts
 * const dispatch = createEventDispatcher<{
 *  loaded: never; // does not take a detail argument
 *  change: string; // takes a detail argument of type string, which is required
 *  optional: number | null; // takes an optional detail argument of type number
 * }>();
 * ```
 *
 * https://svelte.dev/docs/svelte#createeventdispatcher
 * @template {Record<string, any>} [EventMap=any]
 * @returns {import('./public.js').EventDispatcher<EventMap>}
 */
function createEventDispatcher() {
	const component = get_current_component();
	return (type, detail, { cancelable = false } = {}) => {
		const callbacks = component.$$.callbacks[type];
		if (callbacks) {
			// TODO are there situations where events could be dispatched
			// in a server (non-DOM) environment?
			const event = custom_event(/** @type {string} */ (type), detail, { cancelable });
			callbacks.slice().forEach((fn) => {
				fn.call(component, event);
			});
			return !event.defaultPrevented;
		}
		return true;
	};
}

// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
/**
 * @param component
 * @param event
 * @returns {void}
 */
function bubble(component, event) {
	const callbacks = component.$$.callbacks[event.type];
	if (callbacks) {
		// @ts-ignore
		callbacks.slice().forEach((fn) => fn.call(this, event));
	}
}

const dirty_components = [];
const binding_callbacks = [];

let render_callbacks = [];

const flush_callbacks = [];

const resolved_promise = /* @__PURE__ */ Promise.resolve();

let update_scheduled = false;

/** @returns {void} */
function schedule_update() {
	if (!update_scheduled) {
		update_scheduled = true;
		resolved_promise.then(flush);
	}
}

/** @returns {void} */
function add_render_callback(fn) {
	render_callbacks.push(fn);
}

/** @returns {void} */
function add_flush_callback(fn) {
	flush_callbacks.push(fn);
}

// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
const seen_callbacks = new Set();

let flushidx = 0; // Do *not* move this inside the flush() function

/** @returns {void} */
function flush() {
	// Do not reenter flush while dirty components are updated, as this can
	// result in an infinite loop. Instead, let the inner flush handle it.
	// Reentrancy is ok afterwards for bindings etc.
	if (flushidx !== 0) {
		return;
	}
	const saved_component = current_component;
	do {
		// first, call beforeUpdate functions
		// and update components
		try {
			while (flushidx < dirty_components.length) {
				const component = dirty_components[flushidx];
				flushidx++;
				set_current_component(component);
				update(component.$$);
			}
		} catch (e) {
			// reset dirty state to not end up in a deadlocked state and then rethrow
			dirty_components.length = 0;
			flushidx = 0;
			throw e;
		}
		set_current_component(null);
		dirty_components.length = 0;
		flushidx = 0;
		while (binding_callbacks.length) binding_callbacks.pop()();
		// then, once components are updated, call
		// afterUpdate functions. This may cause
		// subsequent updates...
		for (let i = 0; i < render_callbacks.length; i += 1) {
			const callback = render_callbacks[i];
			if (!seen_callbacks.has(callback)) {
				// ...so guard against infinite loops
				seen_callbacks.add(callback);
				callback();
			}
		}
		render_callbacks.length = 0;
	} while (dirty_components.length);
	while (flush_callbacks.length) {
		flush_callbacks.pop()();
	}
	update_scheduled = false;
	seen_callbacks.clear();
	set_current_component(saved_component);
}

/** @returns {void} */
function update($$) {
	if ($$.fragment !== null) {
		$$.update();
		run_all($$.before_update);
		const dirty = $$.dirty;
		$$.dirty = [-1];
		$$.fragment && $$.fragment.p($$.ctx, dirty);
		$$.after_update.forEach(add_render_callback);
	}
}

/**
 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
 * @param {Function[]} fns
 * @returns {void}
 */
function flush_render_callbacks(fns) {
	const filtered = [];
	const targets = [];
	render_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));
	targets.forEach((c) => c());
	render_callbacks = filtered;
}

const outroing = new Set();

/**
 * @type {Outro}
 */
let outros;

/**
 * @returns {void} */
function group_outros() {
	outros = {
		r: 0,
		c: [],
		p: outros // parent group
	};
}

/**
 * @returns {void} */
function check_outros() {
	if (!outros.r) {
		run_all(outros.c);
	}
	outros = outros.p;
}

/**
 * @param {import('./private.js').Fragment} block
 * @param {0 | 1} [local]
 * @returns {void}
 */
function transition_in(block, local) {
	if (block && block.i) {
		outroing.delete(block);
		block.i(local);
	}
}

/**
 * @param {import('./private.js').Fragment} block
 * @param {0 | 1} local
 * @param {0 | 1} [detach]
 * @param {() => void} [callback]
 * @returns {void}
 */
function transition_out(block, local, detach, callback) {
	if (block && block.o) {
		if (outroing.has(block)) return;
		outroing.add(block);
		outros.c.push(() => {
			outroing.delete(block);
			if (callback) {
				if (detach) block.d(1);
				callback();
			}
		});
		block.o(local);
	} else if (callback) {
		callback();
	}
}

/** @typedef {1} INTRO */
/** @typedef {0} OUTRO */
/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

/**
 * @typedef {Object} Outro
 * @property {number} r
 * @property {Function[]} c
 * @property {Object} p
 */

/**
 * @typedef {Object} PendingProgram
 * @property {number} start
 * @property {INTRO|OUTRO} b
 * @property {Outro} [group]
 */

/**
 * @typedef {Object} Program
 * @property {number} a
 * @property {INTRO|OUTRO} b
 * @property {1|-1} d
 * @property {number} duration
 * @property {number} start
 * @property {number} end
 * @property {Outro} [group]
 */

// general each functions:

function ensure_array_like(array_like_or_iterator) {
	return array_like_or_iterator?.length !== undefined
		? array_like_or_iterator
		: Array.from(array_like_or_iterator);
}

// keyed each functions:

/** @returns {void} */
function destroy_block(block, lookup) {
	block.d(1);
	lookup.delete(block.key);
}

/** @returns {any[]} */
function update_keyed_each(
	old_blocks,
	dirty,
	get_key,
	dynamic,
	ctx,
	list,
	lookup,
	node,
	destroy,
	create_each_block,
	next,
	get_context
) {
	let o = old_blocks.length;
	let n = list.length;
	let i = o;
	const old_indexes = {};
	while (i--) old_indexes[old_blocks[i].key] = i;
	const new_blocks = [];
	const new_lookup = new Map();
	const deltas = new Map();
	const updates = [];
	i = n;
	while (i--) {
		const child_ctx = get_context(ctx, list, i);
		const key = get_key(child_ctx);
		let block = lookup.get(key);
		if (!block) {
			block = create_each_block(key, child_ctx);
			block.c();
		} else {
			// defer updates until all the DOM shuffling is done
			updates.push(() => block.p(child_ctx, dirty));
		}
		new_lookup.set(key, (new_blocks[i] = block));
		if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
	}
	const will_move = new Set();
	const did_move = new Set();
	/** @returns {void} */
	function insert(block) {
		transition_in(block, 1);
		block.m(node, next);
		lookup.set(block.key, block);
		next = block.first;
		n--;
	}
	while (o && n) {
		const new_block = new_blocks[n - 1];
		const old_block = old_blocks[o - 1];
		const new_key = new_block.key;
		const old_key = old_block.key;
		if (new_block === old_block) {
			// do nothing
			next = new_block.first;
			o--;
			n--;
		} else if (!new_lookup.has(old_key)) {
			// remove old block
			destroy(old_block, lookup);
			o--;
		} else if (!lookup.has(new_key) || will_move.has(new_key)) {
			insert(new_block);
		} else if (did_move.has(old_key)) {
			o--;
		} else if (deltas.get(new_key) > deltas.get(old_key)) {
			did_move.add(new_key);
			insert(new_block);
		} else {
			will_move.add(old_key);
			o--;
		}
	}
	while (o--) {
		const old_block = old_blocks[o];
		if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
	}
	while (n) insert(new_blocks[n - 1]);
	run_all(updates);
	return new_blocks;
}

/** @returns {void} */
function bind(component, name, callback) {
	const index = component.$$.props[name];
	if (index !== undefined) {
		component.$$.bound[index] = callback;
		callback(component.$$.ctx[index]);
	}
}

/** @returns {void} */
function create_component(block) {
	block && block.c();
}

/** @returns {void} */
function mount_component(component, target, anchor) {
	const { fragment, after_update } = component.$$;
	fragment && fragment.m(target, anchor);
	// onMount happens before the initial afterUpdate
	add_render_callback(() => {
		const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
		// if the component was destroyed immediately
		// it will update the `$$.on_destroy` reference to `null`.
		// the destructured on_destroy may still reference to the old array
		if (component.$$.on_destroy) {
			component.$$.on_destroy.push(...new_on_destroy);
		} else {
			// Edge case - component was destroyed immediately,
			// most likely as a result of a binding initialising
			run_all(new_on_destroy);
		}
		component.$$.on_mount = [];
	});
	after_update.forEach(add_render_callback);
}

/** @returns {void} */
function destroy_component(component, detaching) {
	const $$ = component.$$;
	if ($$.fragment !== null) {
		flush_render_callbacks($$.after_update);
		run_all($$.on_destroy);
		$$.fragment && $$.fragment.d(detaching);
		// TODO null out other refs, including component.$$ (but need to
		// preserve final state?)
		$$.on_destroy = $$.fragment = null;
		$$.ctx = [];
	}
}

/** @returns {void} */
function make_dirty(component, i) {
	if (component.$$.dirty[0] === -1) {
		dirty_components.push(component);
		schedule_update();
		component.$$.dirty.fill(0);
	}
	component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
}

// TODO: Document the other params
/**
 * @param {SvelteComponent} component
 * @param {import('./public.js').ComponentConstructorOptions} options
 *
 * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.
 * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.
 * This will be the `add_css` function from the compiled component.
 *
 * @returns {void}
 */
function init(
	component,
	options,
	instance,
	create_fragment,
	not_equal,
	props,
	append_styles = null,
	dirty = [-1]
) {
	const parent_component = current_component;
	set_current_component(component);
	/** @type {import('./private.js').T$$} */
	const $$ = (component.$$ = {
		fragment: null,
		ctx: [],
		// state
		props,
		update: noop,
		not_equal,
		bound: blank_object(),
		// lifecycle
		on_mount: [],
		on_destroy: [],
		on_disconnect: [],
		before_update: [],
		after_update: [],
		context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
		// everything else
		callbacks: blank_object(),
		dirty,
		skip_bound: false,
		root: options.target || parent_component.$$.root
	});
	append_styles && append_styles($$.root);
	let ready = false;
	$$.ctx = instance
		? instance(component, options.props || {}, (i, ret, ...rest) => {
				const value = rest.length ? rest[0] : ret;
				if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
					if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
					if (ready) make_dirty(component, i);
				}
				return ret;
		  })
		: [];
	$$.update();
	ready = true;
	run_all($$.before_update);
	// `false` as a special case of no DOM component
	$$.fragment = create_fragment ? create_fragment($$.ctx) : false;
	if (options.target) {
		if (options.hydrate) {
			// TODO: what is the correct type here?
			// @ts-expect-error
			const nodes = children(options.target);
			$$.fragment && $$.fragment.l(nodes);
			nodes.forEach(detach);
		} else {
			// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
			$$.fragment && $$.fragment.c();
		}
		if (options.intro) transition_in(component.$$.fragment);
		mount_component(component, options.target, options.anchor);
		flush();
	}
	set_current_component(parent_component);
}

/**
 * Base class for Svelte components. Used when dev=false.
 *
 * @template {Record<string, any>} [Props=any]
 * @template {Record<string, any>} [Events=any]
 */
class SvelteComponent {
	/**
	 * ### PRIVATE API
	 *
	 * Do not use, may change at any time
	 *
	 * @type {any}
	 */
	$$ = undefined;
	/**
	 * ### PRIVATE API
	 *
	 * Do not use, may change at any time
	 *
	 * @type {any}
	 */
	$$set = undefined;

	/** @returns {void} */
	$destroy() {
		destroy_component(this, 1);
		this.$destroy = noop;
	}

	/**
	 * @template {Extract<keyof Events, string>} K
	 * @param {K} type
	 * @param {((e: Events[K]) => void) | null | undefined} callback
	 * @returns {() => void}
	 */
	$on(type, callback) {
		if (!is_function(callback)) {
			return noop;
		}
		const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
		callbacks.push(callback);
		return () => {
			const index = callbacks.indexOf(callback);
			if (index !== -1) callbacks.splice(index, 1);
		};
	}

	/**
	 * @param {Partial<Props>} props
	 * @returns {void}
	 */
	$set(props) {
		if (this.$$set && !is_empty(props)) {
			this.$$.skip_bound = true;
			this.$$set(props);
			this.$$.skip_bound = false;
		}
	}
}

/**
 * @typedef {Object} CustomElementPropDefinition
 * @property {string} [attribute]
 * @property {boolean} [reflect]
 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
 */

// generated during release, do not modify

const PUBLIC_VERSION = '4';

if (typeof window !== 'undefined')
	// @ts-ignore
	(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);

const subscriber_queue = [];

/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 *
 * https://svelte.dev/docs/svelte-store#writable
 * @template T
 * @param {T} [value] initial value
 * @param {import('./public.js').StartStopNotifier<T>} [start]
 * @returns {import('./public.js').Writable<T>}
 */
function writable(value, start = noop) {
	/** @type {import('./public.js').Unsubscriber} */
	let stop;
	/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */
	const subscribers = new Set();
	/** @param {T} new_value
	 * @returns {void}
	 */
	function set(new_value) {
		if (safe_not_equal(value, new_value)) {
			value = new_value;
			if (stop) {
				// store is ready
				const run_queue = !subscriber_queue.length;
				for (const subscriber of subscribers) {
					subscriber[1]();
					subscriber_queue.push(subscriber, value);
				}
				if (run_queue) {
					for (let i = 0; i < subscriber_queue.length; i += 2) {
						subscriber_queue[i][0](subscriber_queue[i + 1]);
					}
					subscriber_queue.length = 0;
				}
			}
		}
	}

	/**
	 * @param {import('./public.js').Updater<T>} fn
	 * @returns {void}
	 */
	function update(fn) {
		set(fn(value));
	}

	/**
	 * @param {import('./public.js').Subscriber<T>} run
	 * @param {import('./private.js').Invalidator<T>} [invalidate]
	 * @returns {import('./public.js').Unsubscriber}
	 */
	function subscribe(run, invalidate = noop) {
		/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */
		const subscriber = [run, invalidate];
		subscribers.add(subscriber);
		if (subscribers.size === 1) {
			stop = start(set, update) || noop;
		}
		run(value);
		return () => {
			subscribers.delete(subscriber);
			if (subscribers.size === 0 && stop) {
				stop();
				stop = null;
			}
		};
	}
	return { set, update, subscribe };
}

let rootScope = {};

/*global GmCXt*/
//Global States
let Gm = {};

Gm.activeView = writable("");
Gm.user = writable({});
Gm.accessToken = writable('');
Gm.organization = writable({});
Gm.tours = writable([]);
Gm.appOnDomain = writable({});
Gm.loggedIn = writable(false);
Gm.appData = writable([]);
Gm.allGuides = writable([]);
Gm.activeAppData = writable({});
Gm.activeAppId = writable("");
Gm.allCategories = writable([]);
Gm.subCategories = writable({});
Gm.breadCrumb = writable([]);
Gm.breadcrumbCategories = writable([]);
Gm.validatedSegments = writable({});
Gm.isSidePanelApp = writable(false);
Gm.isPageReloaded = writable(false);
Gm.guidePlayTracker = writable({});

Gm.showPlayer = writable(false);
Gm.accessibility = writable(false);
Gm.isMediaPlayerOn = writable(false);
Gm.pageTitle = writable();
Gm.route = writable('Home');
Gm.urlParts = writable({});
Gm.partUrl = {};
Gm.appList = writable([]);
Gm.CurrentPage = writable('currentpage');
Gm.currentTour = writable({});
Gm.dialogBox = writable({});
Gm.showModal = writable({});
Gm.publishedTours = writable({});
Gm.CurrentPageTours = writable([]);
Gm.MyGuidePageTours = writable([]);
Gm.parent = writable();
Gm.categoryTours = writable([]);
Gm.childCategories = writable();
Gm.isNotificationReqd = writable(true);
Gm.dShowAgain = writable(false);
Gm.wLater = writable(false);
Gm.loading = writable(false);
Gm.activeSortFilterStore = writable();
Gm.searchTours = writable([]);
Gm.selectedBranch = writable(false);
Gm.selectedLang = writable("default");
Gm.lanDropDownVisible = writable(false);
Gm.miniPlayer = writable(false);
Gm.showNoTour = writable(false);
Gm.isTaskListVisible = writable(false);
Gm.params = writable({});
Gm.routeAction = writable({});
Gm.filters  = writable({});
Gm.statusBar = writable('');
Gm.labels = writable(rootScope.labels);
Gm.slideState = writable({});
Gm.slideshowInstance = writable({});
Gm.isTourListRefresh=writable(false);
Gm.allTaskList= writable([]);
Gm.taskListCount = writable(0);
Gm.searchTerm = writable('');
Gm.stepEditMode = writable(false);
Gm.stepOperationMode = writable(GmCXt.STEP_VIEW_OPERATION);
Gm.activeStepId = writable();
Gm.panelAlignment = writable('right');
Gm.imagePaintRef = writable({});

/*global GmCXt*/


let mgError = {};

function isContextError(err) {
    err = err.toString();
    if (err && err.indexOf("Extension context invalidated") !== -1) {
        return true;
    } else {
        return false;
    }
}

mgError.show = function(e, source) {
    if (isContextError(e)) {
        e = rootScope.labels.extensionContextError;
    }
    let msg = e + (source ? ' (Error: ' + source + ') ' : '');
    rootScope.showPopup(msg,'', 'error');
};

mgError.try = function(fun, source) {

    try {
        return fun();
    } catch (e) {
        mgError.show(e, source);
    }
};

function showErrorMsg(msg, code) {
    Gm.loading.set(false);
    rootScope.settingsLoader = false;

    if (code) {
        msg = msg + ' (Error: ' + code + ')';
    }
    rootScope.showPopup(msg,'', 'alert');
}

mgError.on = function(data,cb) {
    rootScope.isApiCallOn = false;
    if (data != null) {

        let c = parseInt(data.code);

        if (c === 2036 && (data.url.indexOf('user/signout') > 0 || data.url.indexOf('user/token') > 0)) {
            rootScope.clearSession();
            GmCXt.showWidget();
            return false;
        }

        let errMsg = "";

        switch (true) {
        case (c === 3044):
            showErrorMsg(rootScope.labels.segmentationRequired, c);
            break;

        case (c === 1001):
            showErrorMsg(rootScope.labels.notAutorised, c);
            break;

        case (c === 1003):
            errMsg = rootScope.labels[1003] + '(Error:' + c + ')';
            rootScope.showPopup(errMsg, function() {
                rootScope.clearSession("1003: Access token invalid");
            }, 'error');
            break;

        case (c === 1007):
            rootScope.getAccessTokenFromRefreshToken(cb,data);
            break;

        case (c === 1005):
            if (data.message[0] === "Organization not found") {
                showErrorMsg(rootScope.labels.orgError, c);
            } else {
                showErrorMsg(rootScope.labels[c], c);
            }
            break;

        case (c === 1009):
            showErrorMsg(rootScope.labels.signInVerifyYourEmail, c);
            break;

        case (c === 2001):
            rootScope.loginInvalidCred = true;
            break;

        case (c === 3045):
            break;

        case (c === 3061):
            showErrorMsg(rootScope.labels[c]);
            break;

        case (c === 2004):
            errMsg = rootScope.labels[2004] + '(Error:' + c + ')';
            rootScope.showPopup(errMsg, function() {
                rootScope.clearSession("2004: Session Expired");
            }, 'error');
            break;

        case (c === 3063):
            if (data && data.url.indexOf("task_list") === -1) {
                showErrorMsg(rootScope.labels.applicationJsonError, c);
            }
            break;
        case (c === 2200):
        case (c === 405):
        case (c === 3008):
        case (c === 1019):
        case (c === 2044):
        case (c === 3068):
        case (c === 1017):
        case (c === 1018):
        case (c === 2000):
        case (c === 429):
        case (c >= 2002 && c <= 2099):
        case (c >= 3000 && c <= 3099):
        case (c >= 4000 && c <= 4099):

            showErrorMsg(rootScope.labels[c], c);
            break;

        case (c === 1014):
            GmCXt.redirect('#/maintenance');
            break;

        case (c === 403 && data.message[0] === GmCXt.unknownError):
            showErrorMsg(rootScope.labels.lostInternetConnection, c);
            break;

        default:
            rootScope.showPopup(rootScope.labels.apiError, function() {
                let user = GmCXt.user;
                if (user || GmCXt.onPrem()) {
                    GmCXt.redirect('#/home/currentpage');
                }
            }, 'error');
            break;
        }
    } else {
        showErrorMsg(rootScope.labels.lostInternetConnection, c);
    }
};

let api$1 = {};

api$1.user = function() {
    return GmCXt.user;
};
api$1.orgId = function() {
    return api$1.user().organization_id;
};

api$1.appId = function() {
    return GmCXt.activeAppId;
};

api$1.getHeaders = function(params) {

    let host = "";

    if (!GmCXt.isEmpty(GmCXt.urlParts)) {
        host = GmCXt.urlParts.host;
    }

    let headers = {
        'Content-Type': 'application/json',
        'x-mg-host': host,
        'x-mg-source': GmCXt.conf.appName,
        'x-mg-orgId': ''
    };

    let accessToken = '';
    let refreshToken = '';
    let user = GmCXt.user;

    if (user && user.accesstoken) accessToken = user.accesstoken;
    if (user && user.refreshtoken) refreshToken = user.refreshtoken;

    if (params.serviceName && ((params.serviceName.indexOf('user/signout') !== -1) || (params.serviceName.indexOf('user/token') !== -1))) {

        headers.RefreshToken = refreshToken;

    } else if (params.serviceName && params.serviceName.indexOf('user/sso/login') !== -1) {

        headers.Authorization = params.data.myGuideOrgKey;
        delete params.data.myGuideOrgKey;

    } else if (params.serviceName === 'user/sso/autologin') {

        headers.Authorization = params.data.myGuideOrgKey;
        delete params.data.myGuideOrgKey;

    } else if (params.serviceName === 'user/signin/edcast') {

        headers.EdcastToken = params.data.EdcastToken;
        delete params.data.EdcastToken;

    } else {
        headers.AccessToken = accessToken;
    }

    headers.appType = GmCXt.conf.appType;

    if (user) {
        headers.userId = user.user_id;
        headers.orgId = user.organization_id;
        headers['x-mg-orgId'] = user.organization_id;
    }

    return headers;
};

api$1.fetch = function(obj) {
    return new Promise(function(resolve, reject) {
        fetch(obj.url, {
            method: obj.method,
            headers: obj.headers,
            body: JSON.stringify(obj.data)
        }).then(response => {
            resolve(response.json());
        }).catch(function(error) {
            if (error.stack) error.data = GmCXt.getCodeError();
            reject(error.data);
        });    });
};



api$1.xhrDesktopApp = function(param) {

    return new Promise(function(resolve, reject) {
        mg$.ajax({
            url: param.url,
            data: param.data,
            method: param.method,
            success: function(result) {
                if (result) resolve(result);
            },
            error: function(e) {
                reject(e);
            }
        });
    });
};

function processApi(data, cb) {
    let sName = data.url.replace(GmCXt.conf.webServiceUrl, '');
    if (sName.indexOf("?") !== -1) {
        sName = sName.split("?")[0];
    }
    let params = {
        serviceName: sName,
        method: data.method_type,
        data: data.params,
        onSuccess: cb
    };
    if (data.method_type === "GET") {
        api$1.get_(params).then((r) => {
            if (cb) cb(r);
        });
    } else {
        if (cb) {
            params.onSuccess = cb;
        }
        api$1.post_(params);
    }
}

api$1.get_ = function(params) {

    let ob = {
        url: GmCXt.conf.webServiceUrl + params.serviceName,
        method: params.method,
        headers: api$1.getHeaders(params),
        params: params.data
    };

    function addParamsOnFailApi(d) {
        d.url = ob.url;
        d.params = ob.params;
        d.method_type = ob.method;
        if (params.onSuccess) d.successCb = params.onSuccess;
        return d;
    }

    function processApiCb(data) {
        processApi(data, params.cb);
    }

    function onFail(d) {
        if (!d) d = GmCXt.getDefaultError();
        d = addParamsOnFailApi(d);
        Gm.loading.set(false);
        if (d.code === 1007) {
            mgError.on(d, processApiCb);
        } else if (d.code !== 3033) {
            mgError.on(d);
        }
    }

    return new Promise(function(resolve, reject) {

        ob.url = GmCXt.getSearchURL(ob.url, params.data);

        api$1.fetch(ob).then(function success(result) {

            if (!rootScope.isAppJsonCalling) {
                Gm.loading.set(false);
            }

            let data = result;

            if (!data) return;

            if (data.error) {
                onFail(data);
                reject(data);
                return;
            }

            data = GmCXt.validateDataModel(data, GmCXt.model.api);

            if (params.onSuccess) {
                resolve(params.onSuccess(result));
            } else {
                resolve(result);
            }

        }).catch(function(error) {
            if (error && error.stack) {
                error.data = GmCXt.getCodeError();
                onFail(error.data);
            } else {
                onFail();
            }
        });
    });
};

api$1.get = function(params) {

    if (params.data.isDeskReq) {

        delete params.data.isDeskReq;
        return api$1.get_(params);
    } else {
        rootScope.isFetchingCdn = false;

        return rootScope.checkCdnSignature().then(function() {
            return api$1.get_(params);
        });
    }
};

api$1.getJSONUrlCDNSignature = function(url, cb) {
    let params = {
        serviceName: "file/presigned/url",
        method: "GET",
        data: {
            organization_id: api$1.orgId(),
            url: url
        },
        serviceType: '',
        cb: cb
    };
    return api$1.get_(params).then(cb);
};

api$1.getCDN = function(url) {
    if (GmCXt.isAWS()) {
        if (!url.includes(GmCXt.conf.jsonStorageUrl)) {
            url = GmCXt.conf.jsonStorageUrl + GmCXt.orgBucket + '/' + url;
        }
        return api$1.getJSONUrlCDNSignature(url).then(function(data) {
            return new Promise(function(resolve, reject) {
                fetch(data.data.url)
                    .then((response) => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json(); // Parse response body as JSON
                    })
                    .then((jsonData) => {
                        resolve(jsonData);
                    })
                    .catch((error) => {
                        reject(error);
                    });
            });
        }).catch(function(e) {

        });
    } else {
        return rootScope.checkCdnSignature().then(function() {

            if (!GmCXt.onPrem()) {
                url = addCdnUrl(url);
            }
            return new Promise(function(resolve, reject) {
                fetch(url)
                    .then((response) => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json(); // Parse response body as JSON
                    })
                    .then((jsonData) => {
                        resolve(jsonData);
                    })
                    .catch((error) => {
                        reject(error);
                    });
            });
        });
    }
};

api$1.post_ = function(params) {

    let httpObject = {
        url: GmCXt.conf.webServiceUrl + params.serviceName,
        method: params.method,
        headers: api$1.getHeaders(params),
        data: params.data
    };

    function addParamsOnFailApi(d) {
        d.url = httpObject.url;
        d.params = httpObject.data;
        d.method_type = httpObject.method;
        return d;
    }

    function processApiCb(data) {
        processApi(data, params.onSuccess);
    }

    function onFail(data) {
        if (!data) data = GmCXt.getDefaultError();

        data = addParamsOnFailApi(data);
        if (data.code === 1007) {
            mgError.on(data, processApiCb);
        } else if (data.code !== 3033) {
            mgError.on(data);
        }

        if (params.onFail) params.onFail(data);
    }

    api$1.fetch(httpObject).then(function(result) {
        Gm.loading.set(false);
        rootScope.uploadInProgress = false;

        let data = result;
        if (!data.error) {
            if (params.onSuccess) {

                if (params.signIn === true) {
                    if (result.data.token) {
                        result = GmCXt.validateDataModel(result.data.token, GmCXt.model.token);
                    } else if (result.data.orgs) {
                        result = result.data;
                    } else {
                        result = GmCXt.validateDataModel(result.data.user, GmCXt.model.user);
                    }
                }

                params.onSuccess(result);
            }
        } else {
            onFail(data);
        }
    }).catch(function(err) {
        if (err) {
            if (err.stack) {
                err.data = GmCXt.getCodeError();
            }
            onFail(err.data);
        } else {
            console.error('Error in api.post');
        }
    });
};

api$1.post = function(params) {
    rootScope.checkCdnSignature().then(function() {
        api$1.post_(params);
    });
};

api$1.userApiKeySignin = function(data, successCb, onFail) {
    let serviceName = GmCXt.getCustomerSpecificURL("user/sso/login");
    serviceName = serviceName + '?mg_source_name=' + GmCXt.conf.appConfig.customer;

    let params = {
        serviceName: serviceName,
        method: 'POST',
        data: data,
        onSuccess: successCb,
        onFail: onFail,
        signIn: true
    };

    api$1.post(params);
};

api$1.userOrgKeySignin = function(data, successCb, onFail) {
    let params = {
        serviceName: 'user/sso/autologin',
        method: 'POST',
        data: data,
        onSuccess: successCb,
        onFail: onFail,
        signIn: true
    };

    api$1.post(params);
};

api$1.userTranscation = function(data, successCb, onFail) {
    let params = {
        serviceName: 'user/transaction',
        method: 'POST',
        data: data,
        onSuccess: successCb,
        onFail: onFail
    };

    api$1.post(params);
};

api$1.userSignIn = function(data, successCb, onFail) {

    let params = {
        serviceName: 'user/signin',
        method: 'POST',
        data: data,
        onSuccess: successCb,
        onFail: onFail,
        signIn: true
    };

    api$1.post(params);
};

api$1.userSignOut = function(successCb) {
    let serviceName = 'user/signout?mg_source_name=' + GmCXt.conf.appConfig.customer;

    let params = {
        serviceName: serviceName,
        method: 'POST',
        serviceType: '',
        data: {},
        onSuccess: successCb
    };

    api$1.post(params);
};

api$1.verifyUser = function(data, successCb, onFail) {
    let params = {
        serviceName: 'user/verify',
        method: 'POST',
        data: data,
        onSuccess: successCb,
        onFail: onFail,
        signIn: true
    };

    api$1.post(params);
};

api$1.forgetPassword = function(data, successCb, onFail) {
    let params = {
        serviceName: 'user/password/reset',
        method: 'GET',
        data: data,
        cb: successCb
    };

    api$1.get(params).then(successCb);
};

api$1.changePassword = function(data, successCb) {
    let params = {
        serviceName: 'user/password',
        method: 'PUT',
        data: data,
        onSuccess: successCb
    };

    api$1.post(params);
};

api$1.resetPassword = function(data, successCb) {
    let params = {
        serviceName: 'user/resetpassword',
        method: 'POST',
        data: data,
        onSuccess: successCb
    };

    api$1.post(params);
};

api$1.resendOTP = function(data, successCb) {
    let params = {
        serviceName: "user/otp/resend",
        method: "POST",
        data: data,
        serviceType: '',
        onSuccess: successCb,
        signIn: true
    };

    return api$1.post_(params);
};

api$1.getAccessToken = function(successCb) {

    let params = {
        serviceName: GmCXt.getCustomerSpecificURL('user/token'),
        method: 'GET',
        serviceType: "",
        data: {
            force_update: true,
            mg_source_name: GmCXt.conf.appConfig.customer
        }
    };

    function cb(r) {
        let data = {};
        if (r.data.data) {
            data = r.data.data;
        } else {
            data = r.data;
        }
        let result = GmCXt.validateDataModel(data, GmCXt.model.userToken);
        successCb(result);
    }
    params.cb = cb;

    api$1.get_(params).then(cb);
};

api$1.callGetCdnSignature = function(data, cb) {
    let params = {
        serviceName: 'organization/signature',
        method: 'GET',
        serviceType: "",
        data: data,
        cb: cb
    };

    api$1.get_(params).then(cb);
};

api$1.getUserList = function(data, cb) {
    data.organization_id = api$1.orgId();
    let params = {
        serviceName: "user/list",
        method: "GET",
        data: data,
        serviceType: '',
        cb: cb
    };

    Gm.loading.set(true);
    api$1.get_(params).then(cb);
};

api$1.getOrganization = function(cb, spinnerFlag) {
    let params = {
        serviceName: "organization",
        method: "GET",
        data: {
            organization_id: api$1.orgId()
        },
        serviceType: ''
    };
    Gm.loading.set(spinnerFlag);

    function successCb(r) {
        GmCXt.validateApiResp(cb,
            params.serviceName,
            r.data.organization,
            GmCXt.model.organization);
    }
    params.cb = successCb;
    api$1.get_(params).then(successCb);
};

api$1.getDomains = function(cb) {
    let params = {
        serviceName: "organization/domain",
        method: "GET",
        data: {
            organization_id: api$1.orgId()
        },
        serviceType: '',
        cb: cb
    };

    api$1.get_(params).then(cb);
};

api$1.sendMsgToMyBot = function(data) {

    let params = {
        url: 'http://localhost:11311/' + data.url,
        data: '',
        method: 'GET'
    };

    if (data.method) {
        params.method = data.method;
    }

    if (data.info) {
        params.data = {
            info: JSON.stringify(data.info)
        };
    }

    return api$1.xhrDesktopApp(params).catch(function(e) {
        GmCXt.log(1, "ERROR: failed to connect Desktop app", e);
    });
};


api$1.postUserProfile = function(data, cb) {
    data.organization_id = api$1.orgId();
    let params = {
        serviceName: "user",
        method: "PUT",
        serviceType: "",
        data: data,
        onSuccess: cb
    };

    api$1.post(params);
};

function addCdnUrl(json) {
    let u = GmCXt.conf.jsonStorageUrl + GmCXt.orgBucket + '/' + json;
    let user = api$1.user();
    if (user) {
        return u + user.cdn_signature + '&v=' + Date();
    } else {
        return u;
    }
}

api$1.getTourCDN = function(tourId, cb, errorCb) {
    let url = 'tours/tour-' + tourId + '.json';

    api$1.getCDN(url).then(function(data) {
        if (data) {
            let tour = GmCXt.validateDataModel(data, GmCXt.model.guide);
            tour = GmCXt.migrateTour(tour);

            rootScope.updateTourToStorage(false, tour);

            if (cb) cb(tour);
        }
    }).catch(function(e) {
        if (errorCb) errorCb();
    });
};

api$1.getCategoryListStorage = function(params, cb) {
    new Promise(function(resolve, reject) {

        let resPromise = function(cats) {

            if (!GmCXt.inPlayer && params.is_publish) {
                cats = rootScope.filterPublished(cats);
            }

            if (cats && cats.length) {
                cats = cats.sort(function(a, b) {
                    return a.category_order - b.category_order;
                });
                cats = cats.slice(params.offset, params.limit + params.offset);
            }
            resolve(cats);
        };

        if (params.parent_id) {
            let categories = [];

            if (!GmCXt.isEmpty(rootScope.subCategoryStore)) {
                categories = rootScope.subCategoryStore['cat_' + params.parent_id];
            }
            resPromise(categories);

        } else {
            resPromise(rootScope.categoryStore);
        }

    }).then(cb);
};



api$1.getCategoryDetails = function(data, successCb, appId) {

    let params = {
        serviceName: 'category',
        method: 'GET',
        serviceType: "",
        data: data
    };

    let cb = function(cat) {

        GmCXt.log(70, 'ADD CATEGORY TO GLOBLE: ' + GmCXt.categoryLog(cat));

        rootScope.addCategory(cat);
        rootScope.updateCategoryInStorgae(cat);

        successCb(cat);

    };

    let apiCallCb = function(r) {
        GmCXt.validateApiResp(cb, params.serviceName, r, GmCXt.model.category);
    };

    let apiCall = function() {
        api$1.get(params).then(function(r) {
            apiCallCb(r.data.category);
        });
    };

    if (GmCXt.inPlayer) {
        let url = "json/categories/" + data.category_id + ".json";
        if (GmCXt.isAWS()) {
            let appJsonURL = GmCXt.conf.jsonStorageUrl + GmCXt.orgBucket + '/' + url;
            return api$1.getCDNJSON(appJsonURL, apiCall)
                .then(apiCallCb)
                .catch(function() {
                    apiCall();
                });
        } else {
            return api$1.getJSONFromCDN(url, apiCall)
                .then(apiCallCb)
                .catch(function() {
                    apiCall();
                });
        }


    } else {
        apiCall();
    }
};

api$1.getCategoryDetailsStorage = function(data, cb, forceApi, appId) {

    if (forceApi) {
        api$1.getCategoryDetails(data, cb, appId, forceApi);
    } else {
        new Promise(function(resolve, reject) {

            let processSubCat = function() {
                let category = [];
                rootScope.subCategoryStore.forEach(function(subCat) {
                    subCat.forEach(function(cat) {
                        if (parseInt(cat.category_id) === parseInt(data.category_id)) {
                            category.push(cat);
                        }
                    });
                });
                resolve(category[0]);
            };

            let category = rootScope.categoryStore.filter(function(category) {
                return parseInt(category.category_id) === parseInt(data.category_id);
            });

            if (!category.length) {
                processSubCat();
            } else {
                resolve(category[0]);
            }

        }).then(cb);
    }

};

api$1.getTourList = function(data, cb, appId) {

    data.application_id = appId || api$1.appId();

    if (GmCXt.isMirrorApp()) {
        data.application_id = GmCXt.getBaseAppId();
    }

    data.organization_id = api$1.orgId();

    if (rootScope.notDefaultLang()) {
        data.language = rootScope.language;
    }

    if (GmCXt.getLXPLang()) {
        data.language = GmCXt.getLXPLang();
    }

    let params = {
        serviceName: 'tour/list',
        method: 'GET',
        serviceType: "",
        data: data
    };

    function tourCb(tours, pin_tours) {

        if (!appId) {
            tours = rootScope.filterGuideByEnv(tours);

            GmCXt.log(70, 'ADD TOURS TO VARIABLE: ', tours);

            rootScope.addTourList(data.category_id, tours);

            rootScope.updateToursInCategoryStorage(category_id, tours);
        }

        cb(tours, pin_tours);
    }

    function onSuccessCb(r) {
        GmCXt.validateApiResp(tourCb,
            params.serviceName,
            r.data.tours,
            GmCXt.model.guides,
            r.data.pin_tours);
    }
    params.cb = onSuccessCb;

    api$1.get(params).then(onSuccessCb).catch(function() {});

};

api$1.getTourListStorage = function(data, cb, forceApi, appId) {

    if (forceApi) {
        api$1.getTourList(data, cb, appId);
    } else {
        new Promise(function(resolve, reject) {

            let resPromise = function(ts) {

                if (ts) {

                    ts = ts.sort(function(a, b) {
                        return a.tour_order - b.tour_order;
                    });
                    ts = ts.slice(data.offset, data.limit + data.offset);
                }

                resolve(ts);
            };

            let filterBySearchText = function(tours_) {
                if (GmCXt.inPlayer) {
                    tours_ = rootScope.filterGuideByEnv(tours_);
                } else if (data.published_guides === "1") {
                    tours_ = rootScope.filterPublished(tours_);
                } else if (data.published_guides === "0") {
                    tours_ = rootScope.filterUnpublished(tours_);
                }

                // Filter by search text, on search page
                if (data.search_text) {
                    let searchText = data.search_text.toLowerCase();

                    tours_ = rootScope.publishedTours.filter(function(tour) {

                        if (tour.application_id === data.app_id) {
                            let title = tour.tour_title;
                            let description = tour.tour_description;
                            if (tour.language_data && tour.language_data[rootScope.language] && rootScope.notDefaultLang()) {
                                title = tour.language_data[rootScope.language].tour_title;
                                description = tour.language_data[rootScope.language].tour_description;
                            }
                            return (rootScope.filterGuide(title, searchText, tour.tour_id, description));
                        }
                    });
                    resPromise(tours_);
                } else {
                    resPromise(tours_);
                }
            };

            let tours = [];

            // Filter by category, on tour list page.
            if (data.category_id) {
                let t = rootScope.allTourList['cat_' + data.category_id];
                for (let i in t) {
                    tours.push(t[i]);
                }
            }

            filterBySearchText(tours);

        }).then(cb);
    }

};

api$1.getContextualTourStorage = function(data, cb) {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            resolve(rootScope.validateAllRulesExceptSelectEl(rootScope.publishedTours).tours);
        }, 1000);
    }).then(cb);
};

api$1.getContextualTour = function(data, cb) {

    function tourCb(tours) {
        if (GmCXt.FT.isPlayer) {
            tours = rootScope.filterGuideByEnv(tours);
        }
        rootScope.addTourList(false, tours);
        GmCXt.contextualApiParams = {};
        cb(tours);
    }

    let onSuccess = function(r) {
        GmCXt.validateApiResp(tourCb,
            'tour/contextual',
            r.data.tours,
            GmCXt.model.guides);
    };

    if (GmCXt.getLXPLang()) {
        data.language = GmCXt.getLXPLang();
    } else if (rootScope.language && rootScope.language.indexOf('en-') === -1 && !GmCXt.isFalse(rootScope.language)) {
        data.language = rootScope.language;
    }

    data.organization_id = api$1.orgId();

    data.application_id = api$1.appId();

    if (GmCXt.isMirrorApp()) {
        data.application_id = GmCXt.getBaseAppId();
    }

    api$1.getContextualTourStorage(data, function(tours) {
        if (tours && tours.length) {
            cb(tours);
        } else {
            if (!GmCXt.inPlayer) {

                if (GmCXt.isEmpty(GmCXt.contextualApiParams) ||
					(Object.values(data).toString() !== Object.values(GmCXt.contextualApiParams).toString())
                ) {
                    let params = {
                        serviceName: 'tour/contextual',
                        method: 'POST',
                        serviceType: "",
                        data: data,
                        onSuccess: onSuccess
                    };

                    api$1.post_(params);

                    GmCXt.contextualApiParams = data;
                }
            } else {
                cb(tours);
            }
        }
    });
};

api$1.getJSONUrlWithSignature = function(url) {
    return api$1.getJSONUrlCDNSignature(url).then(function(data) {
        return new Promise(function(resolve, reject) {
            fetch(data.data.url)
                .then((response) => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json(); // Parse response body as JSON
                })
                .then((jsonData) => {
                    resolve(jsonData);
                })
                .catch((error) => {
                    reject(error);
                });
        });
    }).catch(function(e) {

    });
};

api$1.getJSONFromCDN = function(url, apiCall) {
    return api$1.getCDN(url).catch(function(e) {

        Gm.loading.set(false);

        if (e.status === 404) {
            rootScope.cdn404 = true;
        } else if (e.status === 403) {
            rootScope.cdn403 = true;
        }
        if (apiCall) apiCall();
    });
};

api$1.getCDNJSON = function(url, apiCall) {
    return api$1.getJSONUrlWithSignature(url).catch(function(e) {

        Gm.loading.set(false);

        if (e.status === 404) {
            rootScope.cdn404 = true;
        } else if (e.status === 403) {
            rootScope.cdn403 = true;
        }
        if (apiCall) apiCall();
    });
};

api$1.getTours = function(data, cb) {
    data.organization_id = api$1.orgId();

    let params = {
        serviceName: "tours",
        method: "GET",
        serviceType: "",
        data: data
    };

    function tourCb(tours) {
        if (GmCXt.FT.isPlayer) {
            tours = rootScope.filterGuideByEnv(tours);
        }
        cb(tours);
    }

    function onSuccess(r) {
        GmCXt.validateApiResp(tourCb,
            params.serviceName,
            r.data.tours,
            GmCXt.model.guides
        );
    }

    params.cb = onSuccess;

    api$1.get(params).then(onSuccess);
};

api$1.getTaskList = function() {

    rootScope.taskListApiCalled = true;

    let data = {
        application_id: api$1.appId(),
        organization_id: api$1.orgId(),
        limit: 10,
        offset: 0,
        search: ''
    };

    let params = {
        serviceName: "task_list/json",
        method: "GET",
        data: data
    };

    return new Promise(function(resolve, reject) {
        function cb(r) {
            if (!r) {
                api$1.get(params).then(function(result) {
                    resolve(result.data);
                });
            } else {
                resolve(r);
            }
        }

        if (GmCXt.inPlayer) {
            let url = "json/task_list/app-" + data.application_id + ".json";
            if (GmCXt.isAWS()) {
                let taskJsonURL = GmCXt.conf.jsonStorageUrl + GmCXt.orgBucket + '/' + url;
                api$1.getCDNJSON(taskJsonURL)
                    .then(cb)
                    .catch(function() {
                        api$1.get(params).then(function(result) {
                            resolve(result.data);
                        });
                    });
            } else {
                api$1.getJSONFromCDN(url)
                    .then(cb)
                    .catch(function() {
                        api$1.get(params).then(function(result) {
                            resolve(result.data);
                        });
                    });
            }

        } else {
            api$1.get(params).then(function(result) {
                resolve(result.data);
            });
        }
    });
};

api$1.getTaskDetails = function(id) {

    let data = {
        id: id
    };

    let params = {
        serviceName: "task_list/user/stats",
        method: "GET",
        data: data
    };

    return api$1.get(params);
};

api$1.getTaskListDetails = function() {

    let data = {
        application_id: api$1.appId(),
        organization_id: api$1.orgId()
    };

    let params = {
        serviceName: "task_list/user/stats/list",
        method: "GET",
        data: data
    };

    return api$1.get(params);
};

api$1.getTaskFolderDetails = function(id) {

    let data = {
        folder_id: id
    };

    let params = {
        serviceName: "task_list/content",
        method: "GET",
        data: data
    };

    return api$1.get(params);
};

api$1.markTaskGuideComplete = function(obj, cb) {
    let data = {
        "task_list_id": obj.task_id,
        "user_id": api$1.user().user_id,
        "guide_id": obj.guide_id
    };

    let params = {
        serviceName: "task_list/task/complete",
        method: 'POST',
        serviceType: "",
        data: data,
        onSuccess: cb
    };
    return api$1.post(params);
};

api$1.getAllLanguages = function() {
    let url = GmCXt.conf.staticContentPath + "json/languages.json";
    return new Promise(function(resolve, reject) {
        fetch(url)
            .then((response) => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json(); // Parse response body as JSON
            })
            .then((jsonData) => {
                resolve(jsonData);
            })
            .catch((error) => {
                reject(error);
            });
    });
};

api$1.getAppDetails = function(id, cb) {

    let data = {
        application_id: id
    };

    let params = {
        serviceName: "application",
        method: "GET",
        data: data
    };

    function successCb(r) {
        GmCXt.validateApiResp(cb,
            params.serviceName,
            r.data.application,
            GmCXt.model.application);
    }
    params.cb = successCb;

    api$1.get(params).then(successCb);
};

api$1.getOrgJson = function() {

    Gm.loading.set(true);

    if (GmCXt.inPlayer) {
        let url = 'json/org_info.json';
        if (GmCXt.isAWS()) {
            let orgJsonURL = GmCXt.conf.jsonStorageUrl + GmCXt.orgBucket + '/json/org_info.json';
            return api$1.getCDNJSON(orgJsonURL);
        } else {
            return api$1.getJSONFromCDN(url);
        }

    } else {

        let params = {
            serviceName: "organization/info/json",
            method: "GET",
            data: {
                organization_id: api$1.orgId()
            },
            serviceType: ''
        };

        return api$1.get_(params);
    }
};

api$1.getAppJson = function(id) {

    Gm.loading.set(true);

    if (GmCXt.inPlayer) {
        let url = 'json/app-' + id + '.json';
        if (GmCXt.isAWS()) {
            let appJsonURL = GmCXt.conf.jsonStorageUrl + GmCXt.orgBucket + '/' + url;
            return api$1.getCDNJSON(appJsonURL);
        } else {
            return api$1.getJSONFromCDN(url);
        }

    } else {
        let params = {
            serviceName: "application/json",
            method: "GET",
            data: {
                application_id: id
            },
            serviceType: ''
        };

        return api$1.get_(params);
    }
};

api$1.getSearchTourList = function(data, cb, doNotFilter) {

    new Promise(function(resolve, reject) {
        let searchText = data.search_text;
        let matchingTours = [];
        let category_id = data.category_id;
        for (let i = 0; i < rootScope.publishedTours.length; i++) {
            let tour = rootScope.publishedTours[i];
            if ((typeof category_id === 'undefined' || category_id === tour.category_id) && ((tour.tour_title && tour.tour_title.toLowerCase().includes(searchText.toLowerCase())) || (tour.keywords && tour.keywords.toLowerCase().indexOf(searchText.toLowerCase()) > -1))) {
                matchingTours.push(tour);
            }
        }
        matchingTours.sort(function(a, b) {
            return a.tour_title.localeCompare(b.tour_title);
        });
        resolve(matchingTours);
    }).then(cb)
        .catch(function() {
            rootScope.goBack();
        });

};

let api = {};

api.user = api$1.user;

api.orgId = api$1.orgId;

api.appId = api$1.appId;

api.getHeaders = api$1.getHeaders;

api.fetch = api$1.fetch;

api.xhrDesktopApp = api$1.xhrDesktopApp;

api.get_ = api$1.get_;

api.get = api$1.get;

api.getCDN = api$1.getCDN;

api.getJSONUrlWithSignature = api$1.getJSONUrlWithSignature;

api.post_ = api$1.post_;

api.post = api$1.post;

api.userSignIn = api$1.userSignIn;

api.userApiKeySignin = api$1.userApiKeySignin;

api.userOrgKeySignin = api$1.userOrgKeySignin;

api.userSignOut = api$1.userSignOut;

api.verifyUser = api$1.verifyUser;

api.forgetPassword = api$1.forgetPassword;

api.changePassword = api$1.changePassword;

api.resetPassword = api$1.resetPassword;

api.getCdnSignature = api$1.callGetCdnSignature;

api.getAccessToken = api$1.getAccessToken;

api.getOrganization = api$1.getOrganization;

api.getDomains = api$1.getDomains;

api.sendMsgToMyBot = api$1.sendMsgToMyBot;

api.postUserProfile = api$1.postUserProfile;

api.getCategoryList = api$1.getCategoryListStorage;

api.getCategoryDetails = api$1.getCategoryDetails;

api.getTourList = api$1.getTourListStorage;

api.searchTours = api$1.getSearchTourList;

api.getContextualTour = api$1.getContextualTour;

api.getOrgJson = api$1.getOrgJson;

api.getJSONUrlCDNSignature = api$1.getJSONUrlCDNSignature;
api.getAppJson = api$1.getAppJson;

api.resendOTP = api$1.resendOTP;

api.getTours = api$1.getTours;

api.getTaskList = api$1.getTaskList;

api.getTaskDetails = api$1.getTaskDetails;

api.getTaskFolderDetails = api$1.getTaskFolderDetails;

api.getTaskListDetails = api$1.getTaskListDetails;

api.markTaskGuideComplete = api$1.markTaskGuideComplete;
api.getAllLanguages = api$1.getAllLanguages;
api.getAppDetails = api$1.getAppDetails;

api.getUserList = api$1.getUserList;

api.getTourFromCDNorJSON = function(o, cb, ecb) {
    if(o && o.tour_id && o.tour_id !== "undefined") {
        api.getTourCDN(o.tour_id, function(t) {
            if (!GmCXt.isEmpty(t)) {
                cb(t);
            } else {
                api.getTourJson(o.tour_id, cb, ecb);
            }
        }, function() {
            api.getTourJson(o.tour_id, cb, ecb);
        });
    }
};

api.getTour = function(o, cb, ecb) {

    let tour = rootScope.getTourFromId(o.tour_id, o.category_id);

    if (tour && !GmCXt.isEmpty(tour.steps)) {
        cb(tour);

    } else if (GmCXt.inPlayer) {
        api.getTourFromCDNorJSON(o, cb, ecb);
    } 
};

api.getTourJson = function(tourId, cb, ecb) {

    function onSuccess(r) {
        if (r.data) {
            let tour = GmCXt.validateDataModel(r.data, GmCXt.model.guide);
            rootScope.updateTourToStorage(false, tour);
            cb(tour);
        } else if (ecb) {
            ecb();
        }
    }

    function onFail(r) {
        GmCXt.log(1, "Tour not found" + tourId);
        ecb();
    }

    let params = {
        serviceName: "tour/json",
        method: "GET",
        data: {
            tour_id: tourId
        },
        serviceType: '',
        onSuccess: onSuccess,
        onFail: onFail,
    };

    Gm.loading.set(true);
    api.get(params);
};

api.getTourCDN = function(tourId, cb, errorCb) {
    let url = 'tours/tour-' + tourId + '.json';
    api.getCDN(url).then(function(data) {
        if (data) {
            let tour = GmCXt.validateDataModel(data, GmCXt.model.guide);
            tour = GmCXt.migrateTour(tour);

            rootScope.updateTourToStorage(false, tour);

            if (cb) cb(tour);
        }
    }).catch(function(e) {
        if (errorCb) errorCb();
    });
};

api.updateUser = function(data, successCb) {

    let organization = GmCXt.organization;
    data.organization_id = organization.organization_id;
    let user = data;
    if (typeof user.settings !== "string") {
        user.settings = JSON.stringify(data.settings);
    }
    let params = {
        serviceName: "user",
        method: "PUT",
        serviceType: "",
        data: user,
        onSuccess: successCb
    };


    api.post(params);

};

/* src/components/NotificationModal.svelte generated by Svelte v4.2.20 */

function add_css$4(target) {
	append_styles(target, "svelte-el5s5i", "dialog.svelte-el5s5i{width:460px;height:276px;border-radius:6px 6px 6px 6px;border:none;inset:unset;top:58px;right:20px;padding:0;overflow:hidden}dialog.svelte-el5s5i::backdrop{background:rgba(0, 0, 0, 0.3)}dialog[open].svelte-el5s5i{animation:svelte-el5s5i-zoom 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)}@keyframes svelte-el5s5i-zoom{from{transform:scale(0.95)}to{transform:scale(1)}}dialog[open].svelte-el5s5i::backdrop{animation:svelte-el5s5i-fade 0.2s ease-out}@keyframes svelte-el5s5i-fade{from{opacity:0}to{opacity:1}}.mgPlayerJSTest_push-notification-info-wrapper.svelte-el5s5i{background:#ffffff;border-radius:6px;&:hover {\n\t\t\t& .mgPlayerJSTest_title-tooltip-wrapper {\n\t\t\t\tdisplay: none !important;\n\t\t\t}\n\t\t};&.mgPlayerJSTest_push-notification-info-micro-player {\n\t\t\twidth: 370px;\n\t\t\ttop: 38px;\n\n\t\t\t& .mgPlayerJSTest_notification-info-tabs-wrapper {\n\t\t\t\t& .mgPlayerJSTest_notification-info-tab {\n\t\t\t\t\t&:hover {\n\t\t\t\t\t\t& .mgPlayerJSTest_title-tooltip-wrapper {\n\t\t\t\t\t\t\tmax-width: 350px !important;\n\t\t\t\t\t\t\tmax-height: 119px;\n\t\t\t\t\t\t\toverflow: hidden;\n\t\t\t\t\t\t\tright: -175px;\n\t\t\t\t\t\t\tfont-weight: normal !important;\n\t\t\t\t\t\t\tdisplay: block !important;\n\n\t\t\t\t\t\t\t&.mgPlayerJSTest_title-tooltip-align-left {\n\t\t\t\t\t\t\t\tleft: -175px;\n\t\t\t\t\t\t\t\tright: initial;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t& .mgPlayerJSTest_tooltip-title {\n\t\t\t\t\t\t\t\twhite-space: initial;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};& .mgPlayerJSTest_push-dropdown-pointer {\n\t\t\tcontent: '';\n\t\t\tposition: fixed;\n\t\t\ttop: 52px;\n\t\t\tleft: 429px;\n\t\t\tbox-sizing: border-box;\n\t\t\tborder: 9px solid #ffffff;\n\t\t\tborder-color: transparent transparent #ffffff #ffffff;\n\t\t\ttransform: rotate(135deg);\n\t\t\tbox-shadow: -2px 1px 5px -1px rgba(0, 0, 0, 0.4);\n\t\t\tz-index: -1;\n\t\t};& .mgPlayerJSTest_push-pointer-positon {\n\t\t\tright: 87px !important;\n\t\t\tleft: unset !important;\n\t\t};& .mgPlayerJSTest_notification-overlay-wrapper {\n\t\t\tposition: fixed;\n\t\t\ttop: 62px;\n\t\t\tleft: 0px;\n\t\t\tz-index: -1;\n\t\t\twidth: 100%;\n\t\t\theight: 100%;\n\t\t\tbackground: rgba(10, 10, 10, 0.3);\n\t\t\tcursor: default;\n\t\t};& .mgPlayerJSTest_notification-info-header-wrapper {\n\t\t\theight: 61px;\n\t\t\tbackground: #ffffff;\n\t\t\tborder-radius: 6px 6px 0px 0px;\n\t\t\tborder-bottom: 1px solid #e6e6e6;\n\n\t\t\t& .mgPlayerJSTest_notification-close {\n\t\t\t\twidth: 15px;\n\t\t\t\theight: 15px;\n\t\t\t}\n\t\t};& .mgPlayerJSTest_notification-info-tabs-wrapper {\n\t\t\twidth: 100%;\n\t\t\theight: 50px;\n\t\t\tbackground: #ffffff;\n\t\t\tpadding: 3px;\n\n\t\t\t& .mgPlayerJSTest_notification-info-tab {\n\t\t\t\twidth: 50%;\n\t\t\t\tcolor: #555555;\n\t\t\t\ttext-transform: uppercase;\n\t\t\t\tborder-bottom: 1px solid transparent;\n\t\t\t\tfont-size: 12px;\n\t\t\t\tmargin: 0 15px;\n\n\t\t\t\t&:hover {\n\t\t\t\t\t& .mgPlayerJSTest_title-tooltip-wrapper {\n\t\t\t\t\t\tmax-width: 435px !important;\n\t\t\t\t\t\tmax-height: 119px;\n\t\t\t\t\t\toverflow: hidden;\n\t\t\t\t\t\tright: -215px;\n\t\t\t\t\t\tfont-weight: normal !important;\n\t\t\t\t\t\tdisplay: block !important;\n\t\t\t\t\t\ttext-transform: none;\n\n\t\t\t\t\t\t&.mgPlayerJSTest_title-tooltip-align-left {\n\t\t\t\t\t\t\tleft: -220px;\n\t\t\t\t\t\t\tright: initial;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t& .mgPlayerJSTest_tooltip-title {\n\t\t\t\t\t\t\twhite-space: initial;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t&:hover,\n\t\t\t\t&.mgPlayerJSTest_notification-active-tab {\n\t\t\t\t\tborder-bottom: 1px solid var(--mg-primary);\n\t\t\t\t}\n\t\t\t}\n\t\t};& .mgPlayerJSTest_notification-guide-details-wrapper {\n\t\t\theight: 170px;\n\t\t\tbackground: #ffffff;\n\t\t\tborder-radius: 0px 0px 6px 6px;\n\t\t\tpadding-bottom: 30px;\n\n\t\t\t& .mgPlayerJSTest_notification-guide-details {\n\t\t\t\theight: 42px;\n\t\t\t\tbox-shadow: rgba(0, 0, 0, 0.0980392) 0px 2px 3px -2px;\n\n\t\t\t\t& .mgPlayerJSTest_title-tooltip-wrapper {\n\t\t\t\t\tfont-weight: normal !important;\n\t\t\t\t\tdisplay: none !important;\n\t\t\t\t\tmax-width: 90% !important;\n\n\t\t\t\t\t& .mgPlayerJSTest_tooltip-title {\n\t\t\t\t\t\twhite-space: normal;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t&:hover {\n\t\t\t\t\t& .mgPlayerJSTest_notification-guide-details-overlay {\n\t\t\t\t\t\tdisplay: flex;\n\t\t\t\t\t}\n\n\t\t\t\t\t& .mgPlayerJSTest_title-tooltip-wrapper {\n\t\t\t\t\t\tfont-weight: normal !important;\n\t\t\t\t\t\tdisplay: block !important;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t& .mgPlayerJSTest_notification-guide-details-overlay {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\ttop: 0px;\n\t\t\t\t\tleft: 0px;\n\t\t\t\t\tjustify-content: flex-end;\n\t\t\t\t\talign-items: center;\n\n\t\t\t\t\t& .mgPlayerJSTest_details-overlay-wrapper {\n\t\t\t\t\t\tbackground: #e7f5ff;\n\t\t\t\t\t\topacity: 0.3;\n\t\t\t\t\t\tposition: absolute;\n\t\t\t\t\t\ttop: 0px;\n\t\t\t\t\t\tleft: 0px;\n\t\t\t\t\t}\n\n\t\t\t\t\t& .mgPlayerJSTest_details-overlay-action-wrapper {\n\t\t\t\t\t\tmax-width: 170px;\n\n\t\t\t\t\t\t& .mgPlayerJSTest_action-show-again-icon {\n\t\t\t\t\t\t\twidth: 17px;\n\t\t\t\t\t\t\theight: 20px;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t& .mgPlayerJSTest_action-show-again-btn {\n\t\t\t\t\t\t\tmin-width: 84px;\n\t\t\t\t\t\t\theight: 20px;\n\t\t\t\t\t\t\tborder-radius: 30px;\n\t\t\t\t\t\t\toverflow: hidden;\n\t\t\t\t\t\t\twhite-space: nowrap;\n\t\t\t\t\t\t\tpadding: 0px 10px;\n\t\t\t\t\t\t\ttext-overflow: ellipsis;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t& .mgPlayerJSTest_notification-guide-icon {\n\t\t\t\t\twidth: 24px;\n\t\t\t\t\theight: 24px;\n\n\t\t\t\t\t& svg {\n\t\t\t\t\t\twidth: 100%;\n\t\t\t\t\t\theight: 100%;\n\n\t\t\t\t\t\t& rect {\n\t\t\t\t\t\t\tstroke: var(--mg-primary);\n\t\t\t\t\t\t\tfill: var(--mg-primary-hover) !important;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t& path {\n\t\t\t\t\t\t\tfill: var(--mg-primary);\n\t\t\t\t\t\t\tstroke: var(--mg-primary);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t& .mgPlayerJSTest_notification-guide-title {\n\t\t\t\t\twidth: 250px;\n\n\t\t\t\t\t& .mgPlayerJSTest_not-guide-title {\n\t\t\t\t\t\twidth: 70% !important;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .mgPlayerJSTest_no-guide-msg-wrapper {\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t\tbackground: #ffffff;\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 0px;\n\t\t\t\tleft: 0px;\n\n\t\t\t\t& .mgPlayerJSTest_icon-oops {\n\t\t\t\t\tmargin-bottom: 10px;\n\n\t\t\t\t\t& svg {\n\t\t\t\t\t\twidth: 80px;\n\t\t\t\t\t\theight: 80px;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}}");
}

function get_each_context$c(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	child_ctx[23] = i;
	return child_ctx;
}

function get_each_context_1$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	child_ctx[23] = i;
	return child_ctx;
}

// (117:0) {#if pushNotificationDropdown}
function create_if_block$q(ctx) {
	let dialog_1;
	let wmgPlayerJSTest_9;
	let wmgPlayerJSTest_8;
	let wmgPlayerJSTest_0;
	let t0;
	let wmgPlayerJSTest_1;
	let t1;
	let wmgPlayerJSTest_2;
	let h3;
	let t3;
	let button0;
	let raw_value = rootScope.svgs.close_push + "";
	let t4;
	let wmgPlayerJSTest_7;
	let button1;
	let t5_value = rootScope.labels.dontShowAgain + "";
	let t5;
	let t6;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_3;
	let t8;
	let button2;
	let t9_value = rootScope.labels.watchLater + "";
	let t9;
	let t10;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_5;
	let t16;
	let t17;
	let mounted;
	let dispose;
	let if_block0 = /*dShowAgain*/ ctx[2] && create_if_block_4$i(ctx);
	let if_block1 = /*wLater*/ ctx[3] && create_if_block_1$m(ctx);

	return {
		c() {
			dialog_1 = element("dialog");
			wmgPlayerJSTest_9 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t1 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			h3 = element("h3");
			h3.textContent = `${rootScope.labels.pushNotification}`;
			t3 = space();
			button0 = element("button");
			t4 = space();
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			button1 = element("button");
			t5 = text(t5_value);
			t6 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3.textContent = `${rootScope.labels.tooltipDontShowAgain}`;
			t8 = space();
			button2 = element("button");
			t9 = text(t9_value);
			t10 = space();
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5.textContent = `${rootScope.labels.tooltipWatchLater1} ${GmCXt.getSleepTime(rootScope.labels)} ${rootScope.labels.tooltipWatchLater2}`;
			t16 = space();
			if (if_block0) if_block0.c();
			t17 = space();
			if (if_block1) if_block1.c();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_push-dropdown-pointer");
			toggle_class(wmgPlayerJSTest_0, "mgPlayerJSTest_push-pointer-positon", !GmCXt.isLXP());
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_notification-overlay-wrapper");
			attr(h3, "class", "mgPlayerJSTest_notification-title mgPlayerJSTest_text-color-dark mgPlayerJSTest_font-weight-550 mgPlayerJSTest_font-size-18 mgPlayerJSTest_no-margin");
			attr(h3, "aria-label", rootScope.labels.pushNotification);
			attr(h3, "tabindex", "0");
			attr(button0, "id", "mgPlayerJSTest_icon-close-push-notif-dropdown");
			attr(button0, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_notification-close mgPlayerJSTest_position-relative mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer");
			attr(button0, "aria-label", "close push notification dropdown");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_notification-info-header-wrapper mgPlayerJSTest_width-100 mgPlayerJSTest_padding-20 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left mgPlayerJSTest_notification-tabs-tooltip mgPlayerJSTest_margin-tb-10");
			attr(button1, "id", "mgPlayerJSTest_label-notification-list-dshow-again");
			attr(button1, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_notification-info-tab mgPlayerJSTest_height-100 mgPlayerJSTest_font-weight-700 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_position-relative");
			toggle_class(button1, "mgPlayerJSTest_notification-active-tab", /*dShowAgain*/ ctx[2]);
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left mgPlayerJSTest_notification-tabs-tooltip mgPlayerJSTest_margin-tb-10 mgPlayerJSTest_title-tooltip-align-left");
			attr(button2, "id", "mgPlayerJSTest_label-notification-list-wlater");
			attr(button2, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_notification-info-tab mgPlayerJSTest_height-100 mgPlayerJSTest_font-weight-700 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_position-relative");
			toggle_class(button2, "mgPlayerJSTest_notification-active-tab", /*wLater*/ ctx[3]);
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_notification-info-tabs-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");

			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_push-notification-info-wrapper mgPlayerJSTest_z-index mgPlayerJSTest_z-index-max mgPlayerJSTest_cursor mgPlayerJSTest_cursor-default " + (rootScope.isMicroPlayer
			? 'mgPlayerJSTest_push-notification-info-micro-player'
			: '') + " svelte-el5s5i");

			attr(dialog_1, "id", "svelte-notification-modal");
			attr(dialog_1, "role", "region");
			attr(dialog_1, "aria-labelledby", rootScope.labels.pushNotification);
			attr(dialog_1, "class", "svelte-el5s5i");
		},
		m(target, anchor) {
			insert(target, dialog_1, anchor);
			append(dialog_1, wmgPlayerJSTest_9);
			append(wmgPlayerJSTest_9, wmgPlayerJSTest_8);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_8, t0);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_8, t1);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, h3);
			append(wmgPlayerJSTest_2, t3);
			append(wmgPlayerJSTest_2, button0);
			button0.innerHTML = raw_value;
			append(wmgPlayerJSTest_8, t4);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_7, button1);
			append(button1, t5);
			append(button1, t6);
			append(button1, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_7, t8);
			append(wmgPlayerJSTest_7, button2);
			append(button2, t9);
			append(button2, t10);
			append(button2, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_8, t16);
			if (if_block0) if_block0.m(wmgPlayerJSTest_8, null);
			append(wmgPlayerJSTest_8, t17);
			if (if_block1) if_block1.m(wmgPlayerJSTest_8, null);
			/*dialog_1_binding*/ ctx[14](dialog_1);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*click_handler_1*/ ctx[9]),
					listen(button1, "click", /*click_handler_2*/ ctx[10]),
					listen(button2, "click", /*click_handler_3*/ ctx[11]),
					listen(wmgPlayerJSTest_9, "click", stop_propagation(/*click_handler*/ ctx[8])),
					listen(dialog_1, "close", /*close_handler*/ ctx[15])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*dShowAgain*/ 4) {
				toggle_class(button1, "mgPlayerJSTest_notification-active-tab", /*dShowAgain*/ ctx[2]);
			}

			if (dirty & /*wLater*/ 8) {
				toggle_class(button2, "mgPlayerJSTest_notification-active-tab", /*wLater*/ ctx[3]);
			}

			if (/*dShowAgain*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$i(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_8, t17);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*wLater*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$m(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_8, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(dialog_1);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*dialog_1_binding*/ ctx[14](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (189:4) {#if dShowAgain}
function create_if_block_4$i(ctx) {
	let wmgPlayerJSTest_;
	let t;
	let if_block0 = /*notifications*/ ctx[4]?.doNotShowTour && create_if_block_6$g(ctx);
	let if_block1 = (!/*notifications*/ ctx[4] || /*notifications*/ ctx[4]?.doNotShowTour?.length === 0) && create_if_block_5$h();

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_notification-guide-details-wrapper mgPlayerJSTest_width-100 mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y mgPlayerJSTest_position-relative");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			if (if_block1) if_block1.m(wmgPlayerJSTest_, null);
		},
		p(ctx, dirty) {
			if (/*notifications*/ ctx[4]?.doNotShowTour) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_6$g(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!/*notifications*/ ctx[4] || /*notifications*/ ctx[4]?.doNotShowTour?.length === 0) {
				if (if_block1) ; else {
					if_block1 = create_if_block_5$h();
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (193:6) {#if notifications?.doNotShowTour}
function create_if_block_6$g(ctx) {
	let each_1_anchor;
	let each_value_1 = ensure_array_like(/*notifications*/ ctx[4].doNotShowTour);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*showAgain, notifications*/ 80) {
				each_value_1 = ensure_array_like(/*notifications*/ ctx[4].doNotShowTour);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (194:7) {#each notifications.doNotShowTour as tour, index}
function create_each_block_1$5(ctx) {
	let wmgPlayerJSTest_8;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.default_guide + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let t1_value = /*tour*/ ctx[21].tour_title + "";
	let t1;
	let t2;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_3;
	let t3_value = /*tour*/ ctx[21].tour_title + "";
	let t3;
	let t4;
	let wmgPlayerJSTest_7;
	let wmgPlayerJSTest_5;
	let t5;
	let wmgPlayerJSTest_6;
	let button;
	let t7;
	let mounted;
	let dispose;

	function click_handler_4() {
		return /*click_handler_4*/ ctx[12](/*tour*/ ctx[21], /*index*/ ctx[23]);
	}

	return {
		c() {
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			t2 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t3 = text(t3_value);
			t4 = space();
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			t5 = space();
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			button = element("button");
			button.textContent = `${rootScope.labels.showAgain}`;
			t7 = space();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_notification-guide-icon mgPlayerJSTest_position-relative");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_text-overflow-ellipsis mgPlayerJSTest_text-color-dark " + (rootScope.isMicroPlayer ? 'mgPlayerJSTest_not-guide-title' : ''));
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_notification-guide-title mgPlayerJSTest_margin-lr-10");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-right mgPlayerJSTest_margin-lr-10");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_details-overlay-wrapper mgPlayerJSTest_width-100 mgPlayerJSTest_height-100 mgPlayerJSTest_z-index mgPlayerJSTest_z-index-1");
			attr(button, "id", "mgPlayerJSTest_label-show-again");
			attr(button, "class", "mgPlayerJSTest_action-show-again-btn mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_theme-background mgPlayerJSTest_text-color-white mgPlayerJSTest_font-size-12 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer mgPlayerJSTest_lbl-btn");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_details-overlay-action-wrapper mgPlayerJSTest_height-100 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between mgPlayerJSTest_z-index mgPlayerJSTest_z-index-2");
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_notification-guide-details-overlay mgPlayerJSTest_width-100 mgPlayerJSTest_height-100 mgPlayerJSTest_padding-lr-20");
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_notification-guide-details mgPlayerJSTest_width-100 mgPlayerJSTest_padding-lr-20 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-start mgPlayerJSTest_position-relative");
			attr(wmgPlayerJSTest_8, "tabindex", "0");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_8, anchor);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_8, t0);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t1);
			append(wmgPlayerJSTest_8, t2);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, t3);
			append(wmgPlayerJSTest_8, t4);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_7, t5);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, button);
			append(wmgPlayerJSTest_8, t7);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_4);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*notifications*/ 16 && t1_value !== (t1_value = /*tour*/ ctx[21].tour_title + "")) set_data(t1, t1_value);
			if (dirty & /*notifications*/ 16 && t3_value !== (t3_value = /*tour*/ ctx[21].tour_title + "")) set_data(t3, t3_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_8);
			}

			mounted = false;
			dispose();
		}
	};
}

// (233:6) {#if !notifications || notifications?.doNotShowTour?.length === 0}
function create_if_block_5$h(ctx) {
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.no_guides_image + "";
	let t0;
	let wmgPlayerJSTest_1;
	let t2;
	let wmgPlayerJSTest_2;

	return {
		c() {
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = "Oops!";
			t2 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2.textContent = `${rootScope.labels.noGuidesOnThisTab}`;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_icon-oops mgPlayerJSTest_inline-block-vm mgPlayerJSTest_text-align-center");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_icon-text mgPlayerJSTest_text-align-center mgPlayerJSTest_font-weight-550");
			attr(wmgPlayerJSTest_1, "tabindex", "0");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_text-align-center mgPlayerJSTest_margin-tb-5");
			attr(wmgPlayerJSTest_2, "tabindex", "0");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_oops-wrapper mgPlayerJSTest_text-align-center");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_no-guide-msg-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_4, anchor);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_3, t2);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_4);
			}
		}
	};
}

// (248:4) {#if wLater}
function create_if_block_1$m(ctx) {
	let wmgPlayerJSTest_;
	let t;
	let if_block0 = /*notifications*/ ctx[4]?.snoozeTour && create_if_block_3$j(ctx);
	let if_block1 = (!/*notifications*/ ctx[4] || /*notifications*/ ctx[4]?.snoozeTour?.length === 0) && create_if_block_2$l();

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_notification-guide-details-wrapper mgPlayerJSTest_width-100 mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y mgPlayerJSTest_position-relative");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			if (if_block1) if_block1.m(wmgPlayerJSTest_, null);
		},
		p(ctx, dirty) {
			if (/*notifications*/ ctx[4]?.snoozeTour) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$j(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!/*notifications*/ ctx[4] || /*notifications*/ ctx[4]?.snoozeTour?.length === 0) {
				if (if_block1) ; else {
					if_block1 = create_if_block_2$l();
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (252:6) {#if notifications?.snoozeTour}
function create_if_block_3$j(ctx) {
	let each_1_anchor;
	let each_value = ensure_array_like(/*notifications*/ ctx[4].snoozeTour);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*watchAgain, notifications*/ 144) {
				each_value = ensure_array_like(/*notifications*/ ctx[4].snoozeTour);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$c(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$c(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (253:7) {#each notifications.snoozeTour as tour, index}
function create_each_block$c(ctx) {
	let wmgPlayerJSTest_8;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.default_guide + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let t1_value = /*tour*/ ctx[21].tour_title + "";
	let t1;
	let t2;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_3;
	let t3_value = /*tour*/ ctx[21].tour_title + "";
	let t3;
	let t4;
	let wmgPlayerJSTest_7;
	let wmgPlayerJSTest_5;
	let t5;
	let wmgPlayerJSTest_6;
	let button;
	let t7;
	let mounted;
	let dispose;

	function click_handler_5() {
		return /*click_handler_5*/ ctx[13](/*tour*/ ctx[21], /*index*/ ctx[23]);
	}

	return {
		c() {
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			t2 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t3 = text(t3_value);
			t4 = space();
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			t5 = space();
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			button = element("button");
			button.textContent = `${rootScope.labels.showAgain}`;
			t7 = space();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_notification-guide-icon mgPlayerJSTest_position-relative");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_text-overflow-ellipsis mgPlayerJSTest_text-color-dark " + (rootScope.isMicroPlayer ? 'mgPlayerJSTest_not-guide-title' : ''));
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_notification-guide-title mgPlayerJSTest_margin-lr-10");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-right mgPlayerJSTest_margin-lr-10");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_details-overlay-wrapper mgPlayerJSTest_width-100 mgPlayerJSTest_height-100 mgPlayerJSTest_z-index mgPlayerJSTest_z-index-1");
			attr(button, "id", "mgPlayerJSTest_label-watch-again");
			attr(button, "class", "mgPlayerJSTest_action-show-again-btn mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_theme-background mgPlayerJSTest_text-color-white mgPlayerJSTest_font-size-12 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer mgPlayerJSTest_primary-color mgPlayerJSTest_bg-color mgPlayerJSTest_lbl-btn");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_details-overlay-action-wrapper mgPlayerJSTest_height-100 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between mgPlayerJSTest_z-index mgPlayerJSTest_z-index-2");
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_notification-guide-details-overlay mgPlayerJSTest_width-100 mgPlayerJSTest_height-100 mgPlayerJSTest_padding-lr-20");
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_notification-guide-details mgPlayerJSTest_width-100 mgPlayerJSTest_padding-lr-20 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-start mgPlayerJSTest_position-relative");
			attr(wmgPlayerJSTest_8, "tabindex", "0");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_8, anchor);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_8, t0);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t1);
			append(wmgPlayerJSTest_8, t2);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, t3);
			append(wmgPlayerJSTest_8, t4);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_7, t5);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, button);
			append(wmgPlayerJSTest_8, t7);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_5);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*notifications*/ 16 && t1_value !== (t1_value = /*tour*/ ctx[21].tour_title + "")) set_data(t1, t1_value);
			if (dirty & /*notifications*/ 16 && t3_value !== (t3_value = /*tour*/ ctx[21].tour_title + "")) set_data(t3, t3_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_8);
			}

			mounted = false;
			dispose();
		}
	};
}

// (292:6) {#if !notifications || notifications?.snoozeTour?.length === 0}
function create_if_block_2$l(ctx) {
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.no_guides_image + "";
	let t0;
	let wmgPlayerJSTest_1;
	let t2;
	let wmgPlayerJSTest_2;

	return {
		c() {
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = "Oops!";
			t2 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2.textContent = `${rootScope.labels.noGuidesOnThisTab}`;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_icon-oops mgPlayerJSTest_inline-block-vm mgPlayerJSTest_text-align-center");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_icon-text mgPlayerJSTest_text-align-center mgPlayerJSTest_font-weight-550");
			attr(wmgPlayerJSTest_1, "tabindex", "0");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_text-align-center mgPlayerJSTest_margin-tb-5");
			attr(wmgPlayerJSTest_2, "tabindex", "0");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_oops-wrapper mgPlayerJSTest_text-align-center");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_no-guide-msg-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_4, anchor);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_3, t2);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_4);
			}
		}
	};
}

function create_fragment$v(ctx) {
	let if_block_anchor;
	let if_block = /*pushNotificationDropdown*/ ctx[0] && create_if_block$q(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*pushNotificationDropdown*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$q(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function instance$u($$self, $$props, $$invalidate) {
	let notifications;
	let { pushNotificationDropdown } = $$props;
	let dialog; // HTMLDialogElement
	let dShowAgain;
	let wLater;
	let user;

	// let app = GmCXt.activeAppData.application_id;
	get_store_value(Gm.notificationsGuides);

	// GC.storage
	// 	.getObjSync(`notifications_${app}`, GC.storage.INDEXEDDB)
	// 	.then((res) => {
	// 		notifications = (res && res.value && res.value) || notifications;
	// 	});
	const dShowAgainSubscriber = Gm.dShowAgain.subscribe(value => {
		$$invalidate(2, dShowAgain = value);
	});

	const wLaterSubscriber = Gm.wLater.subscribe(value => {
		$$invalidate(3, wLater = value);
	});

	user = rootScope.user;

	function notificationList(tabName) {
		setDefaultPushList();
		Gm[tabName].set(true);

		GmCXt.timeout(
			function () {
				if (GmCXt.isPlayer()) {
					rootScope.bindPlayerTheme();
				}
			},
			0
		);
	}

	function setDefaultPushList() {
		Gm.dShowAgain.set(false);
		Gm.wLater.set(false);
	}

	function showAgain(tour_id, index) {
		GmCXt.getAllFromStorage(['toursClosed', 'tourIdArray']).then(function (st) {
			let viewGuideNot = {};

			if (GmCXt.isAnonymousUser()) {
				viewGuideNot = st.tourIdArray || {};
			} else {
				let user = GmCXt.createDeepCopy(GmCXt.user);
				viewGuideNot = user.settings.viewed_guide_notifications || {};
			}

			function onSuccess(response) {
				rootScope.saveUser(GmCXt.user);
			} // GmCXt.validateDataModel(user, false, Constants.USER_MODEL);
			// GC.storage.setObjSync(GC.storage.USERDATAKEY, user);

			if (viewGuideNot[tour_id]) {
				if (!GmCXt.isAnonymousUser()) {
					delete viewGuideNot[tour_id];
					GmCXt.user.settings.viewed_guide_notifications = viewGuideNot;

					if (GmCXt.user.signin_user_email) {
						let data = {
							email_id: GmCXt.user.signin_user_email,
							settings: JSON.stringify(user.settings),
							organization_id: GmCXt.user.organization_id
						};

						GmCXt.setAnonymousUserPrefrence(data).then(onSuccess);
					} else {
						user.settings = JSON.stringify(user.settings);
						api.postUserProfile(user, onSuccess);
					}
				} else {
					GmCXt.updateNotiDoNotShow(tour_id);
				}

				notifications.doNotShowTour.splice(index, 1);
				$$invalidate(4, notifications = { ...notifications });
			}
		});
	}

	function watchAgain(tour_id, index) {
		notifications.snoozeTour.splice(index, 1);
		$$invalidate(4, notifications = { ...notifications });
		GmCXt.updateNotiWatchLater(tour_id);
	}

	notificationList('wLater');

	onDestroy(() => {
		dShowAgainSubscriber();
		wLaterSubscriber();
	});

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler_1 = () => dialog.close();
	const click_handler_2 = () => notificationList('dShowAgain');
	const click_handler_3 = () => notificationList('wLater');
	const click_handler_4 = (tour, index) => showAgain(tour.tour_id, index);
	const click_handler_5 = (tour, index) => watchAgain(tour.tour_id, index);

	function dialog_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			dialog = $$value;
			$$invalidate(1, dialog);
		});
	}

	const close_handler = () => $$invalidate(0, pushNotificationDropdown = false);

	$$self.$$set = $$props => {
		if ('pushNotificationDropdown' in $$props) $$invalidate(0, pushNotificationDropdown = $$props.pushNotificationDropdown);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*dialog, pushNotificationDropdown*/ 3) {
			//$: translatedTours = $translateTours(notification);
			if (dialog && pushNotificationDropdown) dialog.showModal();
		}
	};

	$$invalidate(4, notifications = rootScope.notifications);

	return [
		pushNotificationDropdown,
		dialog,
		dShowAgain,
		wLater,
		notifications,
		notificationList,
		showAgain,
		watchAgain,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		dialog_1_binding,
		close_handler
	];
}

class NotificationModal extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$u, create_fragment$v, safe_not_equal, { pushNotificationDropdown: 0 }, add_css$4);
	}
}

/*global GmCXt*/



const logoutServ = {};

logoutServ.logout = function(source) {
    Gm.loading.set(true);

    source = source || "user";

    GmCXt.log(1, "User logged out: " + source);

    rootScope.videoUploadMessage = false;
    rootScope.uploadProgressBar = false;
    Gm.statusBar.set("logoutServ");

    rootScope.uploadInProgress = false;

    rootScope.closeAppPopup();

    if (rootScope.isElectron) {
        GmCXt.stopVideoStep_();
    } else {
        let m = {
        	action: "mgPlayerJSTest_action:stop_video_upload_in_background",
        };
        GmCXt.sendMessageToBackgroundService(m);
    }

    function onSuccess(response) {
        logoutServ.clearSession(source);
        GmCXt.showWidget();
        GmCXt.removeChatIcon();
        rootScope.hideCurrentPageGuidesIndicator();
        Gm.loading.set(false);
    }

    if(source === "logout_button_click"){
        api.userSignOut(onSuccess);
    } else {
        onSuccess();
    }

};

logoutServ.clearSession = function(s) {

    let restartLoginInterval = false;

    let user = GmCXt.user;
    if (user && !GmCXt.isEmpty(user)) {

        rootScope.showPlayer = false;
        rootScope.initPlayerMode(true);

        GmCXt.clearIndexedDb(GmCXt.conf.appName + GmCXt.conf.env + 'DB');

        if (s !== "user"){
            restartLoginInterval = true;
        }

    }

    // Read dual auth token, before clearing storage
    GmCXt.getFromStorage('dual_auth_token').then(function(dualAuthToken) {

        GmCXt.getFromStorage('lastSsoRedirectTime').then(function(lastSsoTime) {

            GmCXt.resetStorage();

            if (dualAuthToken) {
                GmCXt.saveToStorage('dual_auth_token', rootScope.thirtyDaysInSeconds);
            }

            if (lastSsoTime) {
                GmCXt.saveToStorage('lastSsoRedirectTime', lastSsoTime);
            }
        });
        GmCXt.getFromStorage('triggerSsoAfterFiveMins').then(function(val) {
    		GmCXt.saveToStorage('triggerSsoAfterFiveMins', val);
        });
    });

    if (rootScope.browserLang) {
        GmCXt.mgActiveLang = rootScope.browserLang;
        GmCXt.removeFromStorage('activeLang');
        Gm.selectedLang.set(rootScope.browserLang);
        GmCXt.language = rootScope.browserLang;
	    GmCXt.saveToStorage('activeLang', rootScope.browserLang);
    } else {
        GmCXt.mgActiveLang = false;
        Gm.selectedLang.set('');
        GmCXt.removeFromStorage('activeLang');
    }
    rootScope.language = false;
    GmCXt.language = false;
    GmCXt.activeAppId = false;
    GmCXt.removeFromStorage('confirmLinkGuidePub');
    rootScope.taskList = [];
    GmCXt.removeFromDapStorage('taskList');
    rootScope.updateLabels();

    rootScope.copiedStep = false;
    rootScope.copiedTour = false;
    rootScope.edLogin = false;
    Gm.loading.set(false);
    Gm.miniPlayer.set(false);

    rootScope.chatBot = false;
    rootScope.chatBotMin = false;
    rootScope.user = false;
    GmCXt.organization = false;
    rootScope.enableTranslation = false;
    rootScope.activeSortFilter = "";
    rootScope.descOrder = false;
    rootScope.contextTours = {};
    rootScope.uploadStepProgressBar = false;
    rootScope.pendingStepCount = -1;
	

    GmCXt.enableTranslation = false;
    rootScope.publishedTours = [];

    rootScope.resetCreatorData();

    GmCXt.edCandidates = null;

    rootScope.uploadProgressBar = false;
    Gm.statusBar.set("logout");
    rootScope.videoUploadMessage = false;

    GmCXt.user = {};
    GmCXt.organization = {};

    GmCXt.showWidget();

    rootScope.resetAppData();

    let data={
        startInterval: restartLoginInterval
    };

    GmCXt.clearDataOnLogout(data);
    GmCXt.sendMessageToAllWindows("mgPlayerJSTest_action:empty_user_on_logout_in_iframes", {});
	
    rootScope.navBarVisible = false;
    rootScope.hidePanelOverlay();

    let m = {
    	action: "mgPlayerJSTest_action:stop_sync_interval",
    };
    GmCXt.sendMessageToBackgroundService(m);

    if (GmCXt.isExtension()) {
        GmCXt.storage().set({
            "login_state": false
        });
    }

    function clearStore() {
        Gm.user.set({});
        Gm.accessToken.set('');
        Gm.organization.set({});
        Gm.tours.set([]);
        Gm.appOnDomain.set({});
        Gm.loggedIn.set(false);
        Gm.appData.set([]);
        Gm.allGuides.set([]);
        Gm.activeAppData.set({});
        Gm.activeAppId.set("");
        Gm.allCategories.set([]);
        Gm.subCategories.set({});
        Gm.breadCrumb.set([]);
        Gm.breadcrumbCategories.set([]);
        Gm.validatedSegments.set({});
        Gm.isPageReloaded.set(false);
        Gm.guidePlayTracker.set({});

        Gm.showPlayer.set(false);
        Gm.accessibility.set(false);
        Gm.isMediaPlayerOn.set(false);
        Gm.appList.set([]);
        Gm.currentTour.set({});
        Gm.dialogBox.set({});
        Gm.showModal.set({});
        Gm.publishedTours.set({});
        Gm.CurrentPageTours.set([]);
        Gm.MyGuidePageTours.set([]);
        Gm.parent.set();
        Gm.categoryTours.set([]);
        Gm.childCategories.set();
        Gm.isNotificationReqd.set(true);
        Gm.dShowAgain.set(false);
        Gm.wLater.set(false);
        Gm.loading.set(false);
        Gm.activeSortFilterStore.set();
        Gm.searchTours.set([]);
        Gm.selectedBranch.set(false);
        Gm.lanDropDownVisible.set(false);
        Gm.miniPlayer.set(false);
        Gm.showNoTour.set(false);
        Gm.isTaskListVisible.set(false);
        Gm.params.set({});
        Gm.routeAction.set({});
        Gm.filters.set({});
        Gm.statusBar.set('');
        Gm.labels.set(rootScope.labels);
        Gm.slideState.set({});
        Gm.slideshowInstance.set({});
        Gm.isTourListRefresh.set(false);
        Gm.allTaskList.set([]);
        Gm.taskListCount.set(0);
        Gm.searchTerm.set('');
        Gm.stepEditMode.set('');
    	Gm.stepOperationMode.set(GmCXt.STEP_VIEW_OPERATION);
    }

  	GmCXt.storage().remove(['user', 'userList', 'organization', 'activeAppId',
        'segmentGroupData', 'taskList', 'currentPage', 'breadCrumb'])
        .then(function() {
            rootScope.setCurrentPage('');
            rootScope.setActivePage('signin');
            GmCXt.activeAppId = false;
            GmCXt.appList = {};
            GmCXt.user = {};
            GmCXt.updateGlobalUser({});
            rootScope.taskList = [];
            rootScope.userList = {};
            GmCXt.updateGlobalOrg({});
            let o = GmCXt.organization;
            GmCXt.organization = o;
            clearStore();
        });
    GmCXt.removeFromDapStorage('appData');


    if (restartLoginInterval && (rootScope.appConfig.login.SSO || GmCXt.isMyGuide()) && GmCXt.isPlayer() && rootScope.isAllowedDomain()) {
        if (GmCXt.urlParts) {
            rootScope.signInWithSso();
        }
    }
};

/* src/components/UserMenu.svelte generated by Svelte v4.2.20 */

function get_each_context$b(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[52] = list[i];
	return child_ctx;
}

// (310:1) {#if get(Gm.activeView) !== 'signin'}
function create_if_block_32$1(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (!/*rootScope*/ ctx[0].isMicroPlayer) return create_if_block_33$1;
		return create_else_block_1$4;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if_block.d(detaching);
		}
	};
}

// (325:2) {:else}
function create_else_block_1$4(ctx) {
	let h4;
	let t_value = /*rootScope*/ ctx[0].labels.miniPlayerHelp + "";
	let t;

	return {
		c() {
			h4 = element("h4");
			t = text(t_value);
			attr(h4, "class", "mgPlayerJSTest_theme-mplayer-header-title mgPlayerJSTest_font-size-16 mgPlayerJSTest_float-left mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_text-overflow-ellipsis mgPlayerJSTest_no-margin");
		},
		m(target, anchor) {
			insert(target, h4, anchor);
			append(h4, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.miniPlayerHelp + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(h4);
			}
		}
	};
}

// (311:2) {#if !rootScope.isMicroPlayer}
function create_if_block_33$1(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let img;
	let img_src_value;
	let img_alt_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			img = element("img");
			attr(img, "id", "mgPlayerJSTest_header-brand-logo");
			attr(img, "class", "mgPlayerJSTest_logo-image mgPlayerJSTest_width-height-auto mgPlayerJSTest_max-width-height-100 mgPlayerJSTest_custom-image");
			if (!src_url_equal(img.src, img_src_value = /*currBrandLogo*/ ctx[3])) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = /*rootScope*/ ctx[0].labels.brandLogo);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_logo-wrapper mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_panel-brand-logo-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_margin-l-10");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, img);

			if (!mounted) {
				dispose = listen(img, "error", /*error_handler*/ ctx[20]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*currBrandLogo*/ 8 && !src_url_equal(img.src, img_src_value = /*currBrandLogo*/ ctx[3])) {
				attr(img, "src", img_src_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && img_alt_value !== (img_alt_value = /*rootScope*/ ctx[0].labels.brandLogo)) {
				attr(img, "alt", img_alt_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			mounted = false;
			dispose();
		}
	};
}

// (337:2) {#if stepOperationMode !== GmCXt.STEP_VIEW_OPERATION}
function create_if_block_29$2(ctx) {
	let wmgPlayerJSTest_2;
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;

	let t1_value = (/*panelAlignment*/ ctx[6] === 'left'
	? /*rootScope*/ ctx[0].labels.movePanelToRight
	: /*rootScope*/ ctx[0].labels.movePanelToLeft) + "";

	let t1;

	function select_block_type_1(ctx, dirty) {
		if (/*panelAlignment*/ ctx[6] === 'right') return create_if_block_30$2;
		if (/*panelAlignment*/ ctx[6] === 'left') return create_if_block_31$1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			if (if_block) if_block.c();
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-center mgPlayerJSTest_margin-tb-10");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_move-panel-btn-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer mgPlayerJSTest_show-text-tooltip");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			if (if_block) if_block.m(wmgPlayerJSTest_2, null);
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t1);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(wmgPlayerJSTest_2, t0);
				}
			}

			if (dirty[0] & /*panelAlignment, rootScope*/ 65 && t1_value !== (t1_value = (/*panelAlignment*/ ctx[6] === 'left'
			? /*rootScope*/ ctx[0].labels.movePanelToRight
			: /*rootScope*/ ctx[0].labels.movePanelToLeft) + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			if (if_block) {
				if_block.d();
			}
		}
	};
}

// (348:40) 
function create_if_block_31$1(ctx) {
	let button;
	let button_aria_label_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			attr(button, "id", "mgPlayerJSTest_move-panel-btn-right");
			attr(button, "class", "mgPlayerJSTest_move-panel-btn mgPlayerJSTest_move-panel-btn-right mgPlayerJSTest_lbl-btn mgPlayerJSTest_position-center");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.movePanelToRight);
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_1*/ ctx[22]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.movePanelToRight)) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (341:4) {#if panelAlignment === 'right'}
function create_if_block_30$2(ctx) {
	let button;
	let button_aria_label_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			attr(button, "id", "mgPlayerJSTest_move-panel-btn-left");
			attr(button, "class", "mgPlayerJSTest_move-panel-btn mgPlayerJSTest_move-panel-btn-left mgPlayerJSTest_lbl-btn mgPlayerJSTest_position-center");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.movePanelToLeft);
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[21]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.movePanelToLeft)) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (364:2) {#if stepOperationMode === GmCXt.STEP_VIEW_OPERATION}
function create_if_block_24$3(ctx) {
	let wmgPlayerJSTest_2;
	let button0;
	let raw0_value = /*rootScope*/ ctx[0].svgs.accessibility + "";
	let button0_aria_label_value;
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t1_value = /*rootScope*/ ctx[0].labels.accessibility + "";
	let t1;
	let wmgPlayerJSTest_2_class_value;
	let t2;
	let show_if_3 = get_store_value(Gm.activeView) !== 'signin' && get_store_value(Gm.activeView) !== 'forgotpwd' && get_store_value(Gm.activeView) !== 'chatbot' && get_store_value(Gm.activeView) !== 'taskList';
	let t3;
	let show_if_2 = get_store_value(Gm.activeView) !== 'signin' && get_store_value(Gm.activeView) !== 'forgotpwd';
	let t4;
	let show_if_1 = get_store_value(Gm.activeView) !== 'signin' && get_store_value(Gm.activeView) !== 'forgotpwd' && GmCXt.isPlayer();
	let t5;
	let show_if = get_store_value(Gm.activeView) !== 'signin' && get_store_value(Gm.activeView) !== 'forgotpwd' && !GmCXt.isLXP() && !/*hideNavForAnonymous*/ ctx[12]();
	let t6;
	let wmgPlayerJSTest_5;
	let button1;
	let raw1_value = /*rootScope*/ ctx[0].svgs.close_panel + "";
	let button1_aria_label_value;
	let t7;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_3;
	let t8_value = /*rootScope*/ ctx[0].labels.closePanel + "";
	let t8;
	let wmgPlayerJSTest_5_class_value;
	let mounted;
	let dispose;
	let if_block0 = show_if_3 && create_if_block_28$2(ctx);
	let if_block1 = show_if_2 && create_if_block_27$2(ctx);
	let if_block2 = show_if_1 && create_if_block_26$2(ctx);
	let if_block3 = show_if && create_if_block_25$3(ctx);

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			button0 = element("button");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			if (if_block3) if_block3.c();
			t6 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			button1 = element("button");
			t7 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t8 = text(t8_value);
			attr(button0, "id", "mgPlayerJSTest_icon-accessibility");
			attr(button0, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_accessibility-btn mgPlayerJSTest_position-center " + (GmCXt.accessibility ? 'mgPlayerJSTest_accessibility-btn-active' : ''));
			attr(button0, "aria-label", button0_aria_label_value = /*rootScope*/ ctx[0].labels.accessibility);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-center mgPlayerJSTest_margin-tb-10");

			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_accessibility-btn-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer mgPlayerJSTest_show-text-tooltip " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_header-icon-micro-wrapper'
			: ''));

			attr(button1, "id", "mgPlayerJSTest_icon-close-app-panel");
			attr(button1, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_close-panel-btn mgPlayerJSTest_position-center");
			attr(button1, "aria-label", button1_aria_label_value = /*rootScope*/ ctx[0].labels.closePanel);
			attr(button1, "type", "button");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-center mgPlayerJSTest_margin-tb-10");

			attr(wmgPlayerJSTest_5, "class", wmgPlayerJSTest_5_class_value = "mgPlayerJSTest_header-icon mgPlayerJSTest_close-panel-btn-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer mgPlayerJSTest_show-text-tooltip " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_header-icon-micro-wrapper'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, button0);
			button0.innerHTML = raw0_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t1);
			insert(target, t2, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t3, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t5, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert(target, t6, anchor);
			insert(target, wmgPlayerJSTest_5, anchor);
			append(wmgPlayerJSTest_5, button1);
			button1.innerHTML = raw1_value;
			append(wmgPlayerJSTest_5, t7);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, t8);

			if (!mounted) {
				dispose = [
					listen(button0, "click", function () {
						if (is_function(/*rootScope*/ ctx[0].setAccessibility)) /*rootScope*/ ctx[0].setAccessibility.apply(this, arguments);
					}),
					listen(button1, "click", function () {
						if (is_function(/*rootScope*/ ctx[0].closeAppPanel)) /*rootScope*/ ctx[0].closeAppPanel.apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*rootScope*/ 1 && raw0_value !== (raw0_value = /*rootScope*/ ctx[0].svgs.accessibility + "")) button0.innerHTML = raw0_value;
			if (dirty[0] & /*rootScope*/ 1 && button0_aria_label_value !== (button0_aria_label_value = /*rootScope*/ ctx[0].labels.accessibility)) {
				attr(button0, "aria-label", button0_aria_label_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && t1_value !== (t1_value = /*rootScope*/ ctx[0].labels.accessibility + "")) set_data(t1, t1_value);

			if (dirty[0] & /*rootScope*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_accessibility-btn-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer mgPlayerJSTest_show-text-tooltip " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_header-icon-micro-wrapper'
			: ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}

			if (show_if_3) if_block0.p(ctx, dirty);
			if (show_if_2) if_block1.p(ctx, dirty);
			if (show_if_1) if_block2.p(ctx, dirty);
			if (show_if) if_block3.p(ctx, dirty);
			if (dirty[0] & /*rootScope*/ 1 && raw1_value !== (raw1_value = /*rootScope*/ ctx[0].svgs.close_panel + "")) button1.innerHTML = raw1_value;
			if (dirty[0] & /*rootScope*/ 1 && button1_aria_label_value !== (button1_aria_label_value = /*rootScope*/ ctx[0].labels.closePanel)) {
				attr(button1, "aria-label", button1_aria_label_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && t8_value !== (t8_value = /*rootScope*/ ctx[0].labels.closePanel + "")) set_data(t8, t8_value);

			if (dirty[0] & /*rootScope*/ 1 && wmgPlayerJSTest_5_class_value !== (wmgPlayerJSTest_5_class_value = "mgPlayerJSTest_header-icon mgPlayerJSTest_close-panel-btn-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer mgPlayerJSTest_show-text-tooltip " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_header-icon-micro-wrapper'
			: ''))) {
				attr(wmgPlayerJSTest_5, "class", wmgPlayerJSTest_5_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
				detach(t2);
				detach(t3);
				detach(t4);
				detach(t5);
				detach(t6);
				detach(wmgPlayerJSTest_5);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d(detaching);
			if (if_block2) if_block2.d(detaching);
			if (if_block3) if_block3.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (385:3) {#if get(Gm.activeView) !== 'signin' && get(Gm.activeView) !== 'forgotpwd' && get(Gm.activeView) !== 'chatbot' && get(Gm.activeView) !== 'taskList'}
function create_if_block_28$2(ctx) {
	let wmgPlayerJSTest_2;
	let button;
	let raw_value = /*rootScope*/ ctx[0].svgs.refresh + "";
	let button_aria_label_value;
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t1_value = /*rootScope*/ ctx[0].labels.refresh + "";
	let t1;
	let wmgPlayerJSTest_2_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			attr(button, "id", "mgPlayerJSTest_icon-refresh-alldata");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.refresh);
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_refresh-btn mgPlayerJSTest_position-center");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-center mgPlayerJSTest_margin-tb-10");

			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_header-icon mgPlayerJSTest_refresh-btn-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer mgPlayerJSTest_show-text-tooltip " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_header-icon-micro-wrapper'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t1);

			if (!mounted) {
				dispose = listen(button, "click", /*onRefresh*/ ctx[16]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.refresh + "")) button.innerHTML = raw_value;
			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.refresh)) {
				attr(button, "aria-label", button_aria_label_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && t1_value !== (t1_value = /*rootScope*/ ctx[0].labels.refresh + "")) set_data(t1, t1_value);

			if (dirty[0] & /*rootScope*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_header-icon mgPlayerJSTest_refresh-btn-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer mgPlayerJSTest_show-text-tooltip " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_header-icon-micro-wrapper'
			: ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			mounted = false;
			dispose();
		}
	};
}

// (405:3) {#if get(Gm.activeView) !== 'signin' && get(Gm.activeView) !== 'forgotpwd'}
function create_if_block_27$2(ctx) {
	let wmgPlayerJSTest_2;
	let a;
	let button;
	let raw_value = /*rootScope*/ ctx[0].svgs.help_center + "";
	let button_aria_label_value;
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t1_value = /*rootScope*/ ctx[0].labels.helpCenter + "";
	let t1;
	let wmgPlayerJSTest_2_class_value;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			a = element("a");
			button = element("button");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			attr(button, "id", "mgPlayerJSTest_icon-help-center");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.helpCenter);
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_help-center-btn mgPlayerJSTest_position-center");
			attr(a, "href", getHelpCenterUrl());
			attr(a, "target", "_blank");
			attr(a, "rel", "noopener noreferrer");
			attr(a, "tabindex", "-1");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-center mgPlayerJSTest_margin-tb-10");

			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_header-icon mgPlayerJSTest_help-center-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer mgPlayerJSTest_show-text-tooltip " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_header-icon-micro-wrapper'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, a);
			append(a, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t1);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.help_center + "")) button.innerHTML = raw_value;
			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.helpCenter)) {
				attr(button, "aria-label", button_aria_label_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && t1_value !== (t1_value = /*rootScope*/ ctx[0].labels.helpCenter + "")) set_data(t1, t1_value);

			if (dirty[0] & /*rootScope*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_header-icon mgPlayerJSTest_help-center-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer mgPlayerJSTest_show-text-tooltip " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_header-icon-micro-wrapper'
			: ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}
		}
	};
}

// (426:3) {#if get(Gm.activeView) !== 'signin' && get(Gm.activeView) !== 'forgotpwd' && GmCXt.isPlayer()}
function create_if_block_26$2(ctx) {
	let wmgPlayerJSTest_2;
	let button;
	let raw_value = /*rootScope*/ ctx[0].svgs.bell + "";
	let button_aria_label_value;
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t1_value = /*rootScope*/ ctx[0].labels.pushNotification + "";
	let t1;
	let wmgPlayerJSTest_2_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			attr(button, "id", "mgPlayerJSTest_icon-show-push-notif-dropdown");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_bell-btn mgPlayerJSTest_position-center");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.pushNotification);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-center mgPlayerJSTest_margin-tb-10");

			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_header-icon mgPlayerJSTest_bell-btn-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer mgPlayerJSTest_show-text-tooltip " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_header-icon-micro-wrapper'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t1);

			if (!mounted) {
				dispose = listen(button, "click", /*showNotificationModal*/ ctx[10]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.bell + "")) button.innerHTML = raw_value;
			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.pushNotification)) {
				attr(button, "aria-label", button_aria_label_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && t1_value !== (t1_value = /*rootScope*/ ctx[0].labels.pushNotification + "")) set_data(t1, t1_value);

			if (dirty[0] & /*rootScope*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_header-icon mgPlayerJSTest_bell-btn-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer mgPlayerJSTest_show-text-tooltip " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_header-icon-micro-wrapper'
			: ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			mounted = false;
			dispose();
		}
	};
}

// (448:3) {#if get(Gm.activeView) !== 'signin' && get(Gm.activeView) !== 'forgotpwd' && !GmCXt.isLXP() && !hideNavForAnonymous()}
function create_if_block_25$3(ctx) {
	let wmgPlayerJSTest_2;
	let button;
	let raw_value = /*rootScope*/ ctx[0].svgs.navbar + "";
	let button_aria_label_value;
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t1_value = /*rootScope*/ ctx[0].labels.navigationMenu + "";
	let t1;
	let wmgPlayerJSTest_2_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			attr(button, "id", "mgPlayerJSTest_icon-open-navbar");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_navigation-btn mgPlayerJSTest_position-center");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.navigationMenu);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-center mgPlayerJSTest_margin-tb-10");

			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_header-icon mgPlayerJSTest_navigation-btn-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer mgPlayerJSTest_show-text-tooltip " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_header-icon-micro-wrapper'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t1);

			if (!mounted) {
				dispose = listen(button, "click", /*toggleNavBar*/ ctx[9]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.navbar + "")) button.innerHTML = raw_value;
			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.navigationMenu)) {
				attr(button, "aria-label", button_aria_label_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && t1_value !== (t1_value = /*rootScope*/ ctx[0].labels.navigationMenu + "")) set_data(t1, t1_value);

			if (dirty[0] & /*rootScope*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_header-icon mgPlayerJSTest_navigation-btn-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer mgPlayerJSTest_show-text-tooltip " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_header-icon-micro-wrapper'
			: ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			mounted = false;
			dispose();
		}
	};
}

// (489:0) {#if rootScope.navBarVisible && get(Gm.activeView) !== 'signin'}
function create_if_block$p(ctx) {
	let wmgPlayerJSTest_9;
	let t0;
	let button;
	let raw_value = /*rootScope*/ ctx[0].svgs.navBar + "";
	let t1;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_0;
	let show_if_5 = /*user*/ ctx[1].image_url.indexOf('guest_icon') >= 0 || /*user*/ ctx[1].image_url.indexOf('png') == -1;
	let t2;
	let show_if_4 = /*user*/ ctx[1].image_url.indexOf('guest_icon') == -1 && /*user*/ ctx[1].image_url.indexOf('png') >= 0;
	let t3;
	let wmgPlayerJSTest_3;
	let show_if_3 = /*user*/ ctx[1].user_email.indexOf('anonymous') == -1;
	let t4;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let t5_value = /*user*/ ctx[1].role.replace('_', ' ').replace(/\b\w/g, func$1) + "";
	let t5;
	let t6;
	let wmgPlayerJSTest_8;
	let show_if_2 = !GmCXt.isPlayer();
	let t7;
	let t8;
	let show_if_1 = !GmCXt.isPlayer();
	let t9;
	let t10;
	let wmgPlayerJSTest_7;
	let show_if = /*rootScope*/ ctx[0].showLogoutBtn() && !/*user*/ ctx[1].signedInWithSso;
	let t11;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_5;
	let t12_value = /*rootScope*/ ctx[0].labels.versionText + "";
	let t12;
	let t13;
	let t14_value = GmCXt.conf.version + "";
	let t14;
	let mounted;
	let dispose;
	let if_block0 = /*loading*/ ctx[4] && create_if_block_23$3();
	let if_block1 = show_if_5 && create_if_block_22$3(ctx);
	let if_block2 = show_if_4 && create_if_block_21$3(ctx);
	let if_block3 = show_if_3 && create_if_block_19$5(ctx);
	let if_block4 = show_if_2 && create_if_block_15$7(ctx);
	let if_block5 = !/*rootScope*/ ctx[0].maintenance && create_if_block_9$c(ctx);
	let if_block6 = show_if_1 && create_if_block_3$i(ctx);
	let if_block7 = /*rootScope*/ ctx[0].jsonEditor && create_if_block_2$k(ctx);
	let if_block8 = show_if && create_if_block_1$l(ctx);

	return {
		c() {
			wmgPlayerJSTest_9 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			button = element("button");
			t1 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			if (if_block3) if_block3.c();
			t4 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t5 = text(t5_value);
			t6 = space();
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			if (if_block4) if_block4.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			t9 = space();
			if (if_block7) if_block7.c();
			t10 = space();
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			if (if_block8) if_block8.c();
			t11 = space();
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			t12 = text(t12_value);
			t13 = space();
			t14 = text(t14_value);
			attr(button, "id", "mgPlayerJSTest_icon-close-navbar");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_navbar-close mgPlayerJSTest_inline-block-vm mgPlayerJSTest_cursor-pointer");
			attr(button, "aria-label", "Close NavBar");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_profile-picture mgPlayerJSTest_position-relative mgPlayerJSTest_border-radius-50 mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_user-role mgPlayerJSTest_text-color-light mgPlayerJSTest_inline-block-vm mgPlayerJSTest_text-capitalize mgPlayerJSTest_float-left mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_1, "tabindex", "0");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_user-role-wrapper mgPlayerJSTest_margin-tb-5");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_user-info-wrapper mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_manage-user-profile-wrapper mgPlayerJSTest_width-100 mgPlayerJSTest_primary-color mgPlayerJSTest_border-color");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_version-text mgPlayerJSTest_text-color-light");
			attr(wmgPlayerJSTest_5, "tabindex", "0");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_product-details-wrapper");
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_manage-settings-wrapper mgPlayerJSTest_logout-wrapper mgPlayerJSTest_width-100");
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_player-nav-menu mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y");
			attr(wmgPlayerJSTest_9, "id", "mgPlayerJSTest_side-navbar-container");
			attr(wmgPlayerJSTest_9, "class", "mgPlayerJSTest_side-navbar-container");
			attr(wmgPlayerJSTest_9, "role", "region");
			attr(wmgPlayerJSTest_9, "aria-label", "Menu");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_9, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_9, null);
			append(wmgPlayerJSTest_9, t0);
			append(wmgPlayerJSTest_9, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_9, t1);
			append(wmgPlayerJSTest_9, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_0);
			if (if_block1) if_block1.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t2);
			if (if_block2) if_block2.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_4, t3);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			if (if_block3) if_block3.m(wmgPlayerJSTest_3, null);
			append(wmgPlayerJSTest_3, t4);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t5);
			append(wmgPlayerJSTest_9, t6);
			append(wmgPlayerJSTest_9, wmgPlayerJSTest_8);
			if (if_block4) if_block4.m(wmgPlayerJSTest_8, null);
			append(wmgPlayerJSTest_8, t7);
			if (if_block5) if_block5.m(wmgPlayerJSTest_8, null);
			append(wmgPlayerJSTest_8, t8);
			if (if_block6) if_block6.m(wmgPlayerJSTest_8, null);
			append(wmgPlayerJSTest_8, t9);
			if (if_block7) if_block7.m(wmgPlayerJSTest_8, null);
			append(wmgPlayerJSTest_8, t10);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_7);
			if (if_block8) if_block8.m(wmgPlayerJSTest_7, null);
			append(wmgPlayerJSTest_7, t11);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_5, t12);
			append(wmgPlayerJSTest_5, t13);
			append(wmgPlayerJSTest_5, t14);

			if (!mounted) {
				dispose = listen(button, "click", /*toggleNavBar*/ ctx[9]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*loading*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_23$3();
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_9, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.navBar + "")) button.innerHTML = raw_value;			if (dirty[0] & /*user*/ 2) show_if_5 = /*user*/ ctx[1].image_url.indexOf('guest_icon') >= 0 || /*user*/ ctx[1].image_url.indexOf('png') == -1;

			if (show_if_5) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_22$3(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_0, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*user*/ 2) show_if_4 = /*user*/ ctx[1].image_url.indexOf('guest_icon') == -1 && /*user*/ ctx[1].image_url.indexOf('png') >= 0;

			if (show_if_4) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_21$3(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_0, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty[0] & /*user*/ 2) show_if_3 = /*user*/ ctx[1].user_email.indexOf('anonymous') == -1;

			if (show_if_3) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_19$5(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_3, t4);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (dirty[0] & /*user*/ 2 && t5_value !== (t5_value = /*user*/ ctx[1].role.replace('_', ' ').replace(/\b\w/g, func$1) + "")) set_data(t5, t5_value);
			if (show_if_2) if_block4.p(ctx, dirty);

			if (!/*rootScope*/ ctx[0].maintenance) {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block_9$c(ctx);
					if_block5.c();
					if_block5.m(wmgPlayerJSTest_8, t8);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (show_if_1) if_block6.p(ctx, dirty);

			if (/*rootScope*/ ctx[0].jsonEditor) {
				if (if_block7) {
					if_block7.p(ctx, dirty);
				} else {
					if_block7 = create_if_block_2$k(ctx);
					if_block7.c();
					if_block7.m(wmgPlayerJSTest_8, t10);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}

			if (dirty[0] & /*rootScope, user*/ 3) show_if = /*rootScope*/ ctx[0].showLogoutBtn() && !/*user*/ ctx[1].signedInWithSso;

			if (show_if) {
				if (if_block8) {
					if_block8.p(ctx, dirty);
				} else {
					if_block8 = create_if_block_1$l(ctx);
					if_block8.c();
					if_block8.m(wmgPlayerJSTest_7, t11);
				}
			} else if (if_block8) {
				if_block8.d(1);
				if_block8 = null;
			}

			if (dirty[0] & /*rootScope*/ 1 && t12_value !== (t12_value = /*rootScope*/ ctx[0].labels.versionText + "")) set_data(t12, t12_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_9);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (if_block7) if_block7.d();
			if (if_block8) if_block8.d();
			mounted = false;
			dispose();
		}
	};
}

// (491:2) {#if loading}
function create_if_block_23$3(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let img;
	let img_src_value;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			img = element("img");
			attr(img, "class", "mgPlayerJSTest_loader-image");
			if (!src_url_equal(img.src, img_src_value = GmCXt.loader())) attr(img, "src", img_src_value);
			attr(img, "alt", "loader");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_ege-loader-wrapper-spinner");
			attr(wmgPlayerJSTest_1, "id", "ege-spinner");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_ege-loader-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, img);
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}
		}
	};
}

// (509:4) {#if user.image_url.indexOf('guest_icon') >= 0 || user.image_url.indexOf('png') == -1}
function create_if_block_22$3(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "mgPlayerJSTest_position-center mgPlayerJSTest_border-radius-50");
			if (!src_url_equal(img.src, img_src_value = "" + (GmCXt.conf.staticContentPath + "user_admin.png"))) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = /*user*/ ctx[1].first_name);
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*user*/ 2 && img_alt_value !== (img_alt_value = /*user*/ ctx[1].first_name)) {
				attr(img, "alt", img_alt_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}
		}
	};
}

// (516:4) {#if user.image_url.indexOf('guest_icon') == -1 && user.image_url.indexOf('png') >= 0}
function create_if_block_21$3(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "mgPlayerJSTest_position-center mgPlayerJSTest_custom-image mgPlayerJSTest_border-radius-50");
			if (!src_url_equal(img.src, img_src_value = /*user*/ ctx[1].image_url + GmCXt.getCdnSign())) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = /*user*/ ctx[1].first_name);
			attr(img, "tabindex", "0");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*user*/ 2 && !src_url_equal(img.src, img_src_value = /*user*/ ctx[1].image_url + GmCXt.getCdnSign())) {
				attr(img, "src", img_src_value);
			}

			if (dirty[0] & /*user*/ 2 && img_alt_value !== (img_alt_value = /*user*/ ctx[1].first_name)) {
				attr(img, "alt", img_alt_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}
		}
	};
}

// (526:4) {#if user.user_email.indexOf('anonymous') == -1}
function create_if_block_19$5(ctx) {
	let wmgPlayerJSTest_;

	function select_block_type_2(ctx, dirty) {
		if ((/*user*/ ctx[1].first_name + /*user*/ ctx[1].last_name).length > 15) return create_if_block_20$4;
		return create_else_block$d;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if_block.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_user-name mgPlayerJSTest_text-capitalize mgPlayerJSTest_theme-color mgPlayerJSTest_font-size-16 mgPlayerJSTest_line-clamp mgPlayerJSTest_line-clamp-1");
			attr(wmgPlayerJSTest_, "tabindex", "0");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if_block.m(wmgPlayerJSTest_, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(wmgPlayerJSTest_, null);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if_block.d();
		}
	};
}

// (539:6) {:else}
function create_else_block$d(ctx) {
	let t0_value = /*user*/ ctx[1].first_name + "";
	let t0;
	let t1;
	let t2_value = /*user*/ ctx[1].last_name + "";
	let t2;

	return {
		c() {
			t0 = text(t0_value);
			t1 = text(" ");
			t2 = text(t2_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*user*/ 2 && t0_value !== (t0_value = /*user*/ ctx[1].first_name + "")) set_data(t0, t0_value);
			if (dirty[0] & /*user*/ 2 && t2_value !== (t2_value = /*user*/ ctx[1].last_name + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(t2);
			}
		}
	};
}

// (531:6) {#if (user.first_name + user.last_name).length > 15}
function create_if_block_20$4(ctx) {
	let t0_value = /*user*/ ctx[1].first_name + "";
	let t0;
	let t1;
	let t2_value = /*user*/ ctx[1].last_name + "";
	let t2;
	let t3;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t4_value = /*user*/ ctx[1].first_name + "";
	let t4;
	let t5;
	let t6_value = /*user*/ ctx[1].last_name + "";
	let t6;

	return {
		c() {
			t0 = text(t0_value);
			t1 = text(" ");
			t2 = text(t2_value);
			t3 = text("...\n\n\t\t\t\t\t\t\t");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t4 = text(t4_value);
			t5 = text(" ");
			t6 = text(t6_value);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-center mgPlayerJSTest_margin-tb-10");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
			insert(target, t3, anchor);
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t4);
			append(wmgPlayerJSTest_0, t5);
			append(wmgPlayerJSTest_0, t6);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*user*/ 2 && t0_value !== (t0_value = /*user*/ ctx[1].first_name + "")) set_data(t0, t0_value);
			if (dirty[0] & /*user*/ 2 && t2_value !== (t2_value = /*user*/ ctx[1].last_name + "")) set_data(t2, t2_value);
			if (dirty[0] & /*user*/ 2 && t4_value !== (t4_value = /*user*/ ctx[1].first_name + "")) set_data(t4, t4_value);
			if (dirty[0] & /*user*/ 2 && t6_value !== (t6_value = /*user*/ ctx[1].last_name + "")) set_data(t6, t6_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(t2);
				detach(t3);
				detach(wmgPlayerJSTest_1);
			}
		}
	};
}

// (556:3) {#if !GmCXt.isPlayer()}
function create_if_block_15$7(ctx) {
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[0].svgs.manageAccount + "";
	let t0;
	let h4;
	let t1_value = /*rootScope*/ ctx[0].labels.account + "";
	let t1;
	let t2;
	let show_if_1 = /*rootScope*/ ctx[0].guideSegmentation && /*rootScope*/ ctx[0].isOwner() && !/*rootScope*/ ctx[0].isWestpac && !/*rootScope*/ ctx[0].hideMirrorAppCtrl();
	let t3;
	let show_if = /*rootScope*/ ctx[0].isOwnerOrAppAdmin() && !/*rootScope*/ ctx[0].hideMirrorAppCtrl();
	let t4;
	let if_block0 = show_if_1 && create_if_block_18$5(ctx);
	let if_block1 = show_if && create_if_block_17$5(ctx);
	let if_block2 = !GmCXt.FT.smbApp && create_if_block_16$6(ctx);

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			h4 = element("h4");
			t1 = text(t1_value);
			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			if (if_block2) if_block2.c();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_settings-section-header-icon");
			attr(h4, "class", "mgPlayerJSTest_settings-section-header-title mgPlayerJSTest_no-margin");
			attr(h4, "tabindex", "0");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_settings-section-header");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_manage-settings-wrapper mgPlayerJSTest_width-100");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_settings-outer-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, h4);
			append(h4, t1);
			append(wmgPlayerJSTest_2, t2);
			if (if_block0) if_block0.m(wmgPlayerJSTest_2, null);
			append(wmgPlayerJSTest_2, t3);
			if (if_block1) if_block1.m(wmgPlayerJSTest_2, null);
			append(wmgPlayerJSTest_2, t4);
			if (if_block2) if_block2.m(wmgPlayerJSTest_2, null);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.manageAccount + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if (dirty[0] & /*rootScope*/ 1 && t1_value !== (t1_value = /*rootScope*/ ctx[0].labels.account + "")) set_data(t1, t1_value);
			if (dirty[0] & /*rootScope*/ 1) show_if_1 = /*rootScope*/ ctx[0].guideSegmentation && /*rootScope*/ ctx[0].isOwner() && !/*rootScope*/ ctx[0].isWestpac && !/*rootScope*/ ctx[0].hideMirrorAppCtrl();

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_18$5(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_2, t3);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*rootScope*/ 1) show_if = /*rootScope*/ ctx[0].isOwnerOrAppAdmin() && !/*rootScope*/ ctx[0].hideMirrorAppCtrl();

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_17$5(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_2, t4);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!GmCXt.FT.smbApp) if_block2.p(ctx, dirty);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};
}

// (568:6) {#if rootScope.guideSegmentation && rootScope.isOwner() && !rootScope.isWestpac && !rootScope.hideMirrorAppCtrl()}
function create_if_block_18$5(ctx) {
	let button;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.manageSegments + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_1;
	let raw_value = /*rootScope*/ ctx[0].svgs.externalLink + "";
	let button_aria_label_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_item-label mgPlayerJSTest_text-color-light mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_item-icon mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm");
			attr(button, "id", "mgPlayerJSTest_icon-change-pass");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_setting-item mgPlayerJSTest_cursor-pointer");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.manageSegments);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(button, t1);
			append(button, wmgPlayerJSTest_1);
			wmgPlayerJSTest_1.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(/*rootScope*/ ctx[0].openManageSegments)) /*rootScope*/ ctx[0].openManageSegments.apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.manageSegments + "")) set_data(t0, t0_value);
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.externalLink + "")) wmgPlayerJSTest_1.innerHTML = raw_value;
			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.manageSegments)) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (584:6) {#if rootScope.isOwnerOrAppAdmin() && !rootScope.hideMirrorAppCtrl()}
function create_if_block_17$5(ctx) {
	let button0;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.manageSurvey + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_1;
	let raw0_value = /*rootScope*/ ctx[0].svgs.externalLink + "";
	let button0_aria_label_value;
	let t2;
	let button1;
	let wmgPlayerJSTest_2;
	let t3_value = /*rootScope*/ ctx[0].labels.manageKeywords + "";
	let t3;
	let t4;
	let wmgPlayerJSTest_3;
	let raw1_value = /*rootScope*/ ctx[0].svgs.externalLink + "";
	let button1_aria_label_value;
	let t5;
	let button2;
	let wmgPlayerJSTest_4;
	let t6_value = /*rootScope*/ ctx[0].labels.findAndReplace + "";
	let t6;
	let button2_aria_label_value;
	let mounted;
	let dispose;

	return {
		c() {
			button0 = element("button");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t2 = space();
			button1 = element("button");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t3 = text(t3_value);
			t4 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t5 = space();
			button2 = element("button");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			t6 = text(t6_value);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_item-label mgPlayerJSTest_text-color-light mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_item-icon mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm");
			attr(button0, "id", "mgPlayerJSTest_icon-change-pass");
			attr(button0, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_setting-item mgPlayerJSTest_cursor-pointer");
			attr(button0, "aria-label", button0_aria_label_value = /*rootScope*/ ctx[0].labels.manageSurvey);
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_item-label mgPlayerJSTest_text-color-light mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_item-icon mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm");
			attr(button1, "id", "mgPlayerJSTest_icon-change-pass");
			attr(button1, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_setting-item mgPlayerJSTest_cursor-pointer");
			attr(button1, "aria-label", button1_aria_label_value = /*rootScope*/ ctx[0].labels.manageKeywords);
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_item-label mgPlayerJSTest_text-color-light mgPlayerJSTest_inline-block-vm");
			attr(button2, "id", "mgPlayerJSTest_icon-find-n-replace");
			attr(button2, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_setting-item mgPlayerJSTest_cursor-pointer");
			attr(button2, "aria-label", button2_aria_label_value = /*rootScope*/ ctx[0].labels.findAndReplace);
		},
		m(target, anchor) {
			insert(target, button0, anchor);
			append(button0, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(button0, t1);
			append(button0, wmgPlayerJSTest_1);
			wmgPlayerJSTest_1.innerHTML = raw0_value;
			insert(target, t2, anchor);
			insert(target, button1, anchor);
			append(button1, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, t3);
			append(button1, t4);
			append(button1, wmgPlayerJSTest_3);
			wmgPlayerJSTest_3.innerHTML = raw1_value;
			insert(target, t5, anchor);
			insert(target, button2, anchor);
			append(button2, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, t6);

			if (!mounted) {
				dispose = [
					listen(button0, "click", function () {
						if (is_function(/*rootScope*/ ctx[0].openSurveyAnalyticsPortal)) /*rootScope*/ ctx[0].openSurveyAnalyticsPortal.apply(this, arguments);
					}),
					listen(button1, "click", function () {
						if (is_function(/*rootScope*/ ctx[0].openManageKeywords)) /*rootScope*/ ctx[0].openManageKeywords.apply(this, arguments);
					}),
					listen(button2, "click", /*click_handler_2*/ ctx[23])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.manageSurvey + "")) set_data(t0, t0_value);
			if (dirty[0] & /*rootScope*/ 1 && raw0_value !== (raw0_value = /*rootScope*/ ctx[0].svgs.externalLink + "")) wmgPlayerJSTest_1.innerHTML = raw0_value;
			if (dirty[0] & /*rootScope*/ 1 && button0_aria_label_value !== (button0_aria_label_value = /*rootScope*/ ctx[0].labels.manageSurvey)) {
				attr(button0, "aria-label", button0_aria_label_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && t3_value !== (t3_value = /*rootScope*/ ctx[0].labels.manageKeywords + "")) set_data(t3, t3_value);
			if (dirty[0] & /*rootScope*/ 1 && raw1_value !== (raw1_value = /*rootScope*/ ctx[0].svgs.externalLink + "")) wmgPlayerJSTest_3.innerHTML = raw1_value;
			if (dirty[0] & /*rootScope*/ 1 && button1_aria_label_value !== (button1_aria_label_value = /*rootScope*/ ctx[0].labels.manageKeywords)) {
				attr(button1, "aria-label", button1_aria_label_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && t6_value !== (t6_value = /*rootScope*/ ctx[0].labels.findAndReplace + "")) set_data(t6, t6_value);

			if (dirty[0] & /*rootScope*/ 1 && button2_aria_label_value !== (button2_aria_label_value = /*rootScope*/ ctx[0].labels.findAndReplace)) {
				attr(button2, "aria-label", button2_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button0);
				detach(t2);
				detach(button1);
				detach(t5);
				detach(button2);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (625:6) {#if !GmCXt.FT.smbApp}
function create_if_block_16$6(ctx) {
	let button;
	let wmgPlayerJSTest_;
	let t_value = /*rootScope*/ ctx[0].labels.changePassword + "";
	let t;
	let button_aria_label_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_item-label mgPlayerJSTest_text-color-light mgPlayerJSTest_inline-block-vm");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_setting-item mgPlayerJSTest_cursor-pointer");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.changePassword);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, wmgPlayerJSTest_);
			append(wmgPlayerJSTest_, t);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_3*/ ctx[24]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.changePassword + "")) set_data(t, t_value);

			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.changePassword)) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (644:3) {#if !rootScope.maintenance}
function create_if_block_9$c(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[0].svgs.settings + "";
	let t0;
	let h4;
	let t1_value = /*rootScope*/ ctx[0].labels.userPref + "";
	let t1;
	let t2;
	let show_if = /*showLangTransDD*/ ctx[11]();
	let t3;
	let if_block0 = show_if && create_if_block_11$b(ctx);
	let if_block1 = (GmCXt.FT.creatorApp || /*rootScope*/ ctx[0].playerMode) && create_if_block_10$b(ctx);

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			h4 = element("h4");
			t1 = text(t1_value);
			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_settings-section-header-icon mgPlayerJSTest_settings-icon");
			attr(h4, "class", "mgPlayerJSTest_settings-section-header-title mgPlayerJSTest_no-margin");
			attr(h4, "tabindex", "0");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_settings-section-header");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_manage-settings-wrapper mgPlayerJSTest_width-100");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, h4);
			append(h4, t1);
			append(wmgPlayerJSTest_2, t2);
			if (if_block0) if_block0.m(wmgPlayerJSTest_2, null);
			append(wmgPlayerJSTest_2, t3);
			if (if_block1) if_block1.m(wmgPlayerJSTest_2, null);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.settings + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if (dirty[0] & /*rootScope*/ 1 && t1_value !== (t1_value = /*rootScope*/ ctx[0].labels.userPref + "")) set_data(t1, t1_value);
			if (show_if) if_block0.p(ctx, dirty);

			if (GmCXt.FT.creatorApp || /*rootScope*/ ctx[0].playerMode) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_10$b(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_2, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (655:5) {#if showLangTransDD()}
function create_if_block_11$b(ctx) {
	let wmgPlayerJSTest_4;
	let button0;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].selectedLanguage + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_1;
	let raw_value = /*rootScope*/ ctx[0].svgs.langExpand + "";
	let wmgPlayerJSTest_1_class_value;
	let button0_aria_label_value;
	let t2;
	let wmgPlayerJSTest_3;
	let button1;
	let wmgPlayerJSTest_2;
	let t3;
	let t4_value = /*rootScope*/ ctx[0].browserLang + "";
	let t4;
	let t5;
	let t6;
	let show_if = /*rootScope*/ ctx[0].selectLanguage();
	let button1_class_value;
	let button1_aria_label_value;
	let t7;
	let mounted;
	let dispose;
	let if_block = show_if && create_if_block_14$7(ctx);
	let each_value = ensure_array_like(/*rootScope*/ ctx[0].languages);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
	}

	return {
		c() {
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			button0 = element("button");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			button1 = element("button");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t3 = text("Browser Default (");
			t4 = text(t4_value);
			t5 = text(")");
			t6 = space();
			if (if_block) if_block.c();
			t7 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_item-label mgPlayerJSTest_text-color-light mgPlayerJSTest_inline-block-vm mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_dropdown-collapse-expand mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm " + /*dd_class*/ ctx[7]);
			attr(button0, "id", "mgPlayerJSTest_label-navbar-lang-selection");
			attr(button0, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_setting-item mgPlayerJSTest_dropdown-item mgPlayerJSTest_cursor-pointer mgPlayerJSTest_lang-selection");
			attr(button0, "aria-label", button0_aria_label_value = /*rootScope*/ ctx[0].selectedLanguage);
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_lang-name mgPlayerJSTest_inline-block-vm mgPlayerJSTest_font-size-14");
			attr(button1, "id", "mgPlayerJSTest_label-navbar-lang-dropdown");
			attr(button1, "class", button1_class_value = "mgPlayerJSTest_lbl-btn mgPlayerJSTest_lang-item mgPlayerJSTest_cursor-pointer lang-active mgPlayerJSTest_width-100 " + /*dd_userPrefLang*/ ctx[8]);
			attr(button1, "aria-label", button1_aria_label_value = "Browser Default (" + /*rootScope*/ ctx[0].browserLang + ")");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_lang-dropdown-wrapper mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y mgPlayerJSTest_z-index mgPlayerJSTest_z-index-max");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_manage-lang-setting-wrapper mgPlayerJSTest_position-relative");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_4, anchor);
			append(wmgPlayerJSTest_4, button0);
			append(button0, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(button0, t1);
			append(button0, wmgPlayerJSTest_1);
			wmgPlayerJSTest_1.innerHTML = raw_value;
			append(wmgPlayerJSTest_4, t2);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, button1);
			append(button1, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, t3);
			append(wmgPlayerJSTest_2, t4);
			append(wmgPlayerJSTest_2, t5);
			append(button1, t6);
			if (if_block) if_block.m(button1, null);
			append(wmgPlayerJSTest_3, t7);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(wmgPlayerJSTest_3, null);
				}
			}

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*langDropdown*/ ctx[13]),
					listen(button1, "click", /*click_handler_4*/ ctx[25])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].selectedLanguage + "")) set_data(t0, t0_value);
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.langExpand + "")) wmgPlayerJSTest_1.innerHTML = raw_value;
			if (dirty[0] & /*dd_class*/ 128 && wmgPlayerJSTest_1_class_value !== (wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_dropdown-collapse-expand mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm " + /*dd_class*/ ctx[7])) {
				attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && button0_aria_label_value !== (button0_aria_label_value = /*rootScope*/ ctx[0].selectedLanguage)) {
				attr(button0, "aria-label", button0_aria_label_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && t4_value !== (t4_value = /*rootScope*/ ctx[0].browserLang + "")) set_data(t4, t4_value);
			if (dirty[0] & /*rootScope*/ 1) show_if = /*rootScope*/ ctx[0].selectLanguage();

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_14$7(ctx);
					if_block.c();
					if_block.m(button1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*dd_userPrefLang*/ 256 && button1_class_value !== (button1_class_value = "mgPlayerJSTest_lbl-btn mgPlayerJSTest_lang-item mgPlayerJSTest_cursor-pointer lang-active mgPlayerJSTest_width-100 " + /*dd_userPrefLang*/ ctx[8])) {
				attr(button1, "class", button1_class_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && button1_aria_label_value !== (button1_aria_label_value = "Browser Default (" + /*rootScope*/ ctx[0].browserLang + ")")) {
				attr(button1, "aria-label", button1_aria_label_value);
			}

			if (dirty[0] & /*rootScope, changeLang*/ 16385) {
				each_value = ensure_array_like(/*rootScope*/ ctx[0].languages);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$b(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$b(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(wmgPlayerJSTest_3, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_4);
			}

			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (681:9) {#if rootScope.selectLanguage()}
function create_if_block_14$7(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = /*rootScope*/ ctx[0].svgs.langSelect + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_lang-select mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.langSelect + "")) wmgPlayerJSTest_.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (689:9) {#if lang.language.length != 0}
function create_if_block_12$9(ctx) {
	let button;
	let wmgPlayerJSTest_;
	let t0_value = /*lang*/ ctx[52].name + "";
	let t0;
	let t1;
	let t2;
	let button_class_value;
	let button_aria_label_value;
	let mounted;
	let dispose;
	let if_block = /*rootScope*/ ctx[0].selectedLanguage == /*lang*/ ctx[52].name && /*rootScope*/ ctx[0].userPrefLang && create_if_block_13$8(ctx);

	return {
		c() {
			button = element("button");
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_lang-name mgPlayerJSTest_inline-block-vm");
			attr(button, "id", "mgPlayerJSTest_label-change-lang");

			attr(button, "class", button_class_value = "mgPlayerJSTest_lbl-btn mgPlayerJSTest_lang-item mgPlayerJSTest_cursor-pointer lang-active " + (/*rootScope*/ ctx[0].selectedLanguage == /*lang*/ ctx[52].name && /*rootScope*/ ctx[0].userPrefLang
			? 'mgPlayerJSTest_lang-selected'
			: ''));

			attr(button, "aria-label", button_aria_label_value = /*lang*/ ctx[52].name);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, wmgPlayerJSTest_);
			append(wmgPlayerJSTest_, t0);
			append(button, t1);
			if (if_block) if_block.m(button, null);
			append(button, t2);

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(/*changeLang*/ ctx[14](/*lang*/ ctx[52]))) /*changeLang*/ ctx[14](/*lang*/ ctx[52]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*lang*/ ctx[52].name + "")) set_data(t0, t0_value);

			if (/*rootScope*/ ctx[0].selectedLanguage == /*lang*/ ctx[52].name && /*rootScope*/ ctx[0].userPrefLang) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_13$8(ctx);
					if_block.c();
					if_block.m(button, t2);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*rootScope*/ 1 && button_class_value !== (button_class_value = "mgPlayerJSTest_lbl-btn mgPlayerJSTest_lang-item mgPlayerJSTest_cursor-pointer lang-active " + (/*rootScope*/ ctx[0].selectedLanguage == /*lang*/ ctx[52].name && /*rootScope*/ ctx[0].userPrefLang
			? 'mgPlayerJSTest_lang-selected'
			: ''))) {
				attr(button, "class", button_class_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*lang*/ ctx[52].name)) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (702:11) {#if rootScope.selectedLanguage == lang.name && rootScope.userPrefLang}
function create_if_block_13$8(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = /*rootScope*/ ctx[0].svgs.langSelect + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_lang-select mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm mgPlayerJSTest_margin-lr-10");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.langSelect + "")) wmgPlayerJSTest_.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (688:8) {#each rootScope.languages as lang}
function create_each_block$b(ctx) {
	let if_block_anchor;
	let if_block = /*lang*/ ctx[52].language.length != 0 && create_if_block_12$9(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*lang*/ ctx[52].language.length != 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_12$9(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (714:5) {#if GmCXt.FT.creatorApp || rootScope.playerMode}
function create_if_block_10$b(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.playerMode + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_1;
	let label;
	let input;
	let t2;
	let button;
	let button_aria_label_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			label = element("label");
			input = element("input");
			t2 = space();
			button = element("button");
			attr(wmgPlayerJSTest_0, "id", "mgPlayerJSTest_label-player-mode");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_item-label mgPlayerJSTest_text-color-light mgPlayerJSTest_player-mode-setting mgPlayerJSTest_inline-block-vm mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_0, "tabindex", "0");
			attr(input, "class", "mgPlayerJSTest_user-pref-scope");
			attr(input, "type", "checkbox");
			attr(input, "aria-labelledby", "mgPlayerJSTest_label-player-mode");
			attr(button, "class", "mgPlayerJSTest_custom-slider mgPlayerJSTest_user-pref-scope mgPlayerJSTest_lbl-btn");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.playerMode);
			attr(label, "class", "mgPlayerJSTest_custom-checkbox");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_option-checkbox");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_setting-item");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_2, t1);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, label);
			append(label, input);
			input.checked = /*rootScope*/ ctx[0].showPlayer;
			append(label, t2);
			append(label, button);

			if (!mounted) {
				dispose = [
					listen(input, "change", /*input_change_handler*/ ctx[26]),
					listen(input, "change", /*change_handler*/ ctx[27]),
					listen(button, "click", /*click_handler_5*/ ctx[28])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.playerMode + "")) set_data(t0, t0_value);

			if (dirty[0] & /*rootScope*/ 1) {
				input.checked = /*rootScope*/ ctx[0].showPlayer;
			}

			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.playerMode)) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (753:3) {#if !GmCXt.isPlayer()}
function create_if_block_3$i(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[0].svgs.iconMore + "";
	let t0;
	let h4;
	let t1_value = /*rootScope*/ ctx[0].labels.more + "";
	let t1;
	let t2;
	let t3;
	let show_if_3 = /*rootScope*/ ctx[0].hasCreatorAccess() && GmCXt.FT.manageAccount && !/*rootScope*/ ctx[0].isCreator();
	let t4;
	let show_if_2 = /*rootScope*/ ctx[0].hasCreatorAccess() && !/*rootScope*/ ctx[0].isCreator();
	let t5;
	let show_if_1 = (/*rootScope*/ ctx[0].isOwnerOrAppAdmin() || /*rootScope*/ ctx[0].isCreator()) && !GmCXt.FT.smbApp;
	let t6;
	let show_if = /*rootScope*/ ctx[0].hasCreatorAccess() && !/*rootScope*/ ctx[0].isCreator();
	let if_block0 = GmCXt.FT.taskStatus && create_if_block_8$e(ctx);
	let if_block1 = show_if_3 && create_if_block_7$e(ctx);
	let if_block2 = show_if_2 && create_if_block_6$f(ctx);
	let if_block3 = show_if_1 && create_if_block_5$g(ctx);
	let if_block4 = show_if && create_if_block_4$h(ctx);

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			h4 = element("h4");
			t1 = text(t1_value);
			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			if (if_block3) if_block3.c();
			t6 = space();
			if (if_block4) if_block4.c();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_settings-section-header-icon");
			attr(h4, "class", "mgPlayerJSTest_settings-section-header-title mgPlayerJSTest_no-margin");
			attr(h4, "tabindex", "0");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_settings-section-header");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_manage-settings-wrapper mgPlayerJSTest_width-100");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, h4);
			append(h4, t1);
			append(wmgPlayerJSTest_2, t2);
			if (if_block0) if_block0.m(wmgPlayerJSTest_2, null);
			append(wmgPlayerJSTest_2, t3);
			if (if_block1) if_block1.m(wmgPlayerJSTest_2, null);
			append(wmgPlayerJSTest_2, t4);
			if (if_block2) if_block2.m(wmgPlayerJSTest_2, null);
			append(wmgPlayerJSTest_2, t5);
			if (if_block3) if_block3.m(wmgPlayerJSTest_2, null);
			append(wmgPlayerJSTest_2, t6);
			if (if_block4) if_block4.m(wmgPlayerJSTest_2, null);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.iconMore + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if (dirty[0] & /*rootScope*/ 1 && t1_value !== (t1_value = /*rootScope*/ ctx[0].labels.more + "")) set_data(t1, t1_value);
			if (GmCXt.FT.taskStatus) if_block0.p(ctx, dirty);
			if (dirty[0] & /*rootScope*/ 1) show_if_3 = /*rootScope*/ ctx[0].hasCreatorAccess() && GmCXt.FT.manageAccount && !/*rootScope*/ ctx[0].isCreator();

			if (show_if_3) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_7$e(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_2, t4);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*rootScope*/ 1) show_if_2 = /*rootScope*/ ctx[0].hasCreatorAccess() && !/*rootScope*/ ctx[0].isCreator();

			if (show_if_2) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_6$f(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_2, t5);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty[0] & /*rootScope*/ 1) show_if_1 = (/*rootScope*/ ctx[0].isOwnerOrAppAdmin() || /*rootScope*/ ctx[0].isCreator()) && !GmCXt.FT.smbApp;

			if (show_if_1) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_5$g(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_2, t6);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (dirty[0] & /*rootScope*/ 1) show_if = /*rootScope*/ ctx[0].hasCreatorAccess() && !/*rootScope*/ ctx[0].isCreator();

			if (show_if) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_4$h(ctx);
					if_block4.c();
					if_block4.m(wmgPlayerJSTest_2, null);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
		}
	};
}

// (762:5) {#if GmCXt.FT.taskStatus}
function create_if_block_8$e(ctx) {
	let button;
	let wmgPlayerJSTest_;
	let t_value = /*rootScope*/ ctx[0].labels.taskStatus + "";
	let t;
	let button_aria_label_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_item-label mgPlayerJSTest_text-color-light mgPlayerJSTest_inline-block-vm");
			attr(button, "id", "mgPlayerJSTest_label-task-status");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_setting-item mgPlayerJSTest_cursor-pointer");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.taskStatus);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, wmgPlayerJSTest_);
			append(wmgPlayerJSTest_, t);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_6*/ ctx[29]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.taskStatus + "")) set_data(t, t_value);

			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.taskStatus)) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (779:5) {#if rootScope.hasCreatorAccess() && GmCXt.FT.manageAccount && !rootScope.isCreator()}
function create_if_block_7$e(ctx) {
	let wmgPlayerJSTest_2;
	let button;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.manageAccount + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_1;
	let raw_value = /*rootScope*/ ctx[0].svgs.externalLink + "";
	let button_aria_label_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			button = element("button");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_item-label mgPlayerJSTest_text-color-light mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_item-icon mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm");
			attr(button, "id", "mgPlayerJSTest_label-analytics-portal");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_setting-item mgPlayerJSTest_cursor-pointer");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.manageAccount);
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_manage-settings-wrapper mgPlayerJSTest_width-100");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, button);
			append(button, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(button, t1);
			append(button, wmgPlayerJSTest_1);
			wmgPlayerJSTest_1.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(/*rootScope*/ ctx[0].openAdminPortal())) /*rootScope*/ ctx[0].openAdminPortal().apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.manageAccount + "")) set_data(t0, t0_value);
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.externalLink + "")) wmgPlayerJSTest_1.innerHTML = raw_value;
			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.manageAccount)) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			mounted = false;
			dispose();
		}
	};
}

// (797:5) {#if rootScope.hasCreatorAccess() && !rootScope.isCreator()}
function create_if_block_6$f(ctx) {
	let wmgPlayerJSTest_2;
	let button;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.customizationCenter + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_1;
	let raw_value = /*rootScope*/ ctx[0].svgs.externalLink + "";
	let button_aria_label_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			button = element("button");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_item-label mgPlayerJSTest_text-color-light mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_item-icon mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm");
			attr(button, "id", "mgPlayerJSTest_label-analytics-portal");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_setting-item mgPlayerJSTest_cursor-pointer");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.customizationCenter);
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_manage-settings-wrapper mgPlayerJSTest_width-100");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, button);
			append(button, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(button, t1);
			append(button, wmgPlayerJSTest_1);
			wmgPlayerJSTest_1.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(/*rootScope*/ ctx[0].openCustCenter())) /*rootScope*/ ctx[0].openCustCenter().apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.customizationCenter + "")) set_data(t0, t0_value);
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.externalLink + "")) wmgPlayerJSTest_1.innerHTML = raw_value;
			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.customizationCenter)) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			mounted = false;
			dispose();
		}
	};
}

// (815:5) {#if (rootScope.isOwnerOrAppAdmin() || rootScope.isCreator()) && !GmCXt.FT.smbApp}
function create_if_block_5$g(ctx) {
	let wmgPlayerJSTest_2;
	let button;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.analyticsPortal + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_1;
	let raw_value = /*rootScope*/ ctx[0].svgs.externalLink + "";
	let button_aria_label_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			button = element("button");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_item-label mgPlayerJSTest_text-color-light mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_item-icon mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm");
			attr(button, "id", "mgPlayerJSTest_label-analytics-portal");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_setting-item mgPlayerJSTest_cursor-pointer");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.analyticsPortal);
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_manage-settings-wrapper mgPlayerJSTest_width-100");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, button);
			append(button, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(button, t1);
			append(button, wmgPlayerJSTest_1);
			wmgPlayerJSTest_1.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_7*/ ctx[30]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.analyticsPortal + "")) set_data(t0, t0_value);
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.externalLink + "")) wmgPlayerJSTest_1.innerHTML = raw_value;
			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.analyticsPortal)) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			mounted = false;
			dispose();
		}
	};
}

// (834:5) {#if rootScope.hasCreatorAccess() && !rootScope.isCreator()}
function create_if_block_4$h(ctx) {
	let wmgPlayerJSTest_2;
	let a;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.defaultMiniPlayerHelp + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_1;
	let raw_value = /*rootScope*/ ctx[0].svgs.externalLink + "";
	let wmgPlayerJSTest_1_aria_label_value;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			a = element("a");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_item-label mgPlayerJSTest_text-color-light mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_icon-help-center");
			attr(wmgPlayerJSTest_1, "aria-label", wmgPlayerJSTest_1_aria_label_value = /*rootScope*/ ctx[0].labels.defaultMiniPlayerHelp);
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_item-icon mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm");
			attr(a, "class", "mgPlayerJSTest_setting-item mgPlayerJSTest_cursor-pointer mgPlayerJSTest_text-decoration-none mgPlayerJSTest_box-sizing mgPlayerJSTest_border-box");
			attr(a, "href", getHelpCenterUrl());
			attr(a, "target", "_blank");
			attr(a, "rel", "noopener noreferrer");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_manage-settings-wrapper mgPlayerJSTest_width-100");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, a);
			append(a, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(a, t1);
			append(a, wmgPlayerJSTest_1);
			wmgPlayerJSTest_1.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.defaultMiniPlayerHelp + "")) set_data(t0, t0_value);
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.externalLink + "")) wmgPlayerJSTest_1.innerHTML = raw_value;
			if (dirty[0] & /*rootScope*/ 1 && wmgPlayerJSTest_1_aria_label_value !== (wmgPlayerJSTest_1_aria_label_value = /*rootScope*/ ctx[0].labels.defaultMiniPlayerHelp)) {
				attr(wmgPlayerJSTest_1, "aria-label", wmgPlayerJSTest_1_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}
		}
	};
}

// (858:3) {#if rootScope.jsonEditor}
function create_if_block_2$k(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[0].svgs.edit + "";
	let t0;
	let h4;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			h4 = element("h4");
			h4.textContent = "Edit Org JSON";
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_json-editor-icon mgPlayerJSTest_settings-section-header-icon");
			attr(h4, "class", "mgPlayerJSTest_settings-section-header-title mgPlayerJSTest_no-margin");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_settings-section-header");
			attr(wmgPlayerJSTest_2, "id", "mgPlayerJSTest_icon-edit-org-json");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_manage-settings-wrapper mgPlayerJSTest_width-100 mgPlayerJSTest_cursor-pointer");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, h4);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_2, "click", function () {
					if (is_function(/*rootScope*/ ctx[0].editJson(/*org*/ ctx[2], 'org'))) /*rootScope*/ ctx[0].editJson(/*org*/ ctx[2], 'org').apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.edit + "")) wmgPlayerJSTest_0.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			mounted = false;
			dispose();
		}
	};
}

// (873:4) {#if rootScope.showLogoutBtn() && !user.signedInWithSso}
function create_if_block_1$l(ctx) {
	let button;
	let wmgPlayerJSTest_;
	let t_value = /*rootScope*/ ctx[0].labels.logoutBtn + "";
	let t;
	let button_aria_label_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_item-label mgPlayerJSTest_text-color-light mgPlayerJSTest_inline-block-vm");
			attr(button, "id", "mgPlayerJSTest_label-logout-btn");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_setting-item mgPlayerJSTest_cursor-pointer");
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.logoutBtn);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, wmgPlayerJSTest_);
			append(wmgPlayerJSTest_, t);

			if (!mounted) {
				dispose = listen(button, "click", logoutServ.logout);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.logoutBtn + "")) set_data(t, t_value);

			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.logoutBtn)) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

function create_fragment$u(ctx) {
	let wmgPlayerJSTest_1;
	let show_if_1 = get_store_value(Gm.activeView) !== 'signin';
	let t0;
	let wmgPlayerJSTest_0;
	let t1;
	let t2;
	let show_if = /*rootScope*/ ctx[0].navBarVisible && get_store_value(Gm.activeView) !== 'signin';
	let if_block3_anchor;
	let if_block0 = show_if_1 && create_if_block_32$1(ctx);
	let if_block1 = /*stepOperationMode*/ ctx[5] !== GmCXt.STEP_VIEW_OPERATION && create_if_block_29$2(ctx);
	let if_block2 = /*stepOperationMode*/ ctx[5] === GmCXt.STEP_VIEW_OPERATION && create_if_block_24$3(ctx);
	let if_block3 = show_if && create_if_block$p(ctx);

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			if_block3_anchor = empty();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_float-right");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_width-100");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			if (if_block1) if_block1.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t1);
			if (if_block2) if_block2.m(wmgPlayerJSTest_0, null);
			insert(target, t2, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert(target, if_block3_anchor, anchor);
		},
		p(ctx, dirty) {
			if (show_if_1) if_block0.p(ctx, dirty);

			if (/*stepOperationMode*/ ctx[5] !== GmCXt.STEP_VIEW_OPERATION) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_29$2(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_0, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*stepOperationMode*/ ctx[5] === GmCXt.STEP_VIEW_OPERATION) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_24$3(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_0, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty[0] & /*rootScope*/ 1) show_if = /*rootScope*/ ctx[0].navBarVisible && get_store_value(Gm.activeView) !== 'signin';

			if (show_if) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block$p(ctx);
					if_block3.c();
					if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
				detach(t2);
				detach(if_block3_anchor);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d(detaching);
		}
	};
}

function getHelpCenterUrl() {
	let os = GmCXt.getOrgSettings();
	let url;

	if (!GmCXt.isEmpty(os) && !GmCXt.isEmpty(os.helpUrl)) {
		url = GmCXt.addHttpIfMissing(os.helpUrl);
	}

	return url
	? url
	: GmCXt.model.organization.settings._obj.helpUrl._default;
}

const func$1 = c => c.toUpperCase();

function instance$t($$self, $$props, $$invalidate) {
	let user = {};
	let org = {};
	let lanDropDownVisible = false;
	let currBrandLogo = '';
	let loading = false;
	let { unique = {} } = $$props;
	let stepOperationMode = get_store_value(Gm.stepOperationMode);
	let panelAlignment = 'right';

	const panelAlignmentSubscriber = Gm.panelAlignment.subscribe(value => {
		$$invalidate(6, panelAlignment = value);
	});

	const currentPageSubscriber = Gm.CurrentPage.subscribe(value => {
	});

	let unSubscribe = Gm.selectedLang.subscribe(value => {
	});

	let unSubscribeDropdown = Gm.lanDropDownVisible.subscribe(value => {
		$$invalidate(19, lanDropDownVisible = value);
	});

	let loaderSubscriber = Gm.loading.subscribe(val => {
		$$invalidate(4, loading = val);
	});

	const stepEditModeSubscriber = Gm.stepEditMode.subscribe(value => {
	});

	const stepOperationModeSubscriber = Gm.stepOperationMode.subscribe(value => {
		$$invalidate(5, stepOperationMode = value);
	});

	displayLoginBtn();

	function displayLoginBtn() {
		rootScope.showLogoutBtn();
	}

	function setNavBarHeight() {
		if (rootScope.navBarVisible) {
			mg$('.mgPlayerJSTest_player-nav-menu').css({
				height: window.innerHeight - mg$('.mgPlayerJSTest_manage-user-profile-wrapper').innerHeight() - mg$('.mgPlayerJSTest_logout-wrapper').innerHeight() - 30
			});
		}
	}

	mg$(window).on('resize', setNavBarHeight);

	function toggleNavBar() {
		rootScope.addPanelOverlay();
		$$invalidate(0, rootScope.navBarVisible = mg$('#mgPlayerJSTest_side-navbar-container').is(':visible'), rootScope);

		if (rootScope.navBarVisible) {
			$$invalidate(0, rootScope.navBarVisible = false, rootScope);
			rootScope.hidePanelOverlay();
		} else {
			$$invalidate(0, rootScope.navBarVisible = true, rootScope);
			rootScope.showPanelOverlay();

			GmCXt.timeout(
				function () {
					setNavBarHeight();
				},
				500
			);
		}
	}

	onMount(() => {
		$$invalidate(2, org = GmCXt.organization);
		unSubscribe();
		rootScope.language;

		if (GmCXt.isPlayer()) {
			rootScope.bindPlayerTheme();
		}
	});

	user = rootScope.user;

	function showNotificationModal() {
		new NotificationModal({
				target: document.body,
				props: { pushNotificationDropdown: true }
			});
	}

	const showLangTransDD = function () {
		if (rootScope.enableTranslation && rootScope.languages.length > 1) {
			return true;
		} else {
			return false;
		}
	};

	const checkTranslation = function () {
		if (GmCXt.organization) {
			const as = GmCXt.organization.admin_settings;

			if (as.guide_translation && as.language_settings && as.language_settings.translations.length) {
				return true;
			}
		}

		return false;
	};

	const hideNavForAnonymous = function () {
		if (GmCXt.isPlayer() && user && user.user_email.indexOf('anonymous') !== -1 && !checkTranslation()) {
			return true;
		}

		return false;
	};

	const hideLanguDropdown = function (event) {
		event.stopPropagation();
		$$invalidate(19, lanDropDownVisible = false);
		mg$('.mgPlayerJSTest_lang-dropdown-wrapper').slideUp(100);
	};

	const hideUserPrefDropdown = function (event) {
		event.stopPropagation();
		mg$('.mgPlayerJSTest_setting-dropdown-userPref').slideUp(100);
	};

	const langDropdown = function (event) {
		event.stopPropagation();

		if (lanDropDownVisible) {
			hideLanguDropdown(event);
		} else {
			$$invalidate(19, lanDropDownVisible = true);
			mg$('.mgPlayerJSTest_lang-dropdown-wrapper').slideDown(200);
		}

		hideUserPrefDropdown(event);
		setNavBarHeight();
	};

	const refreshHeader = function (argument) {
		let u = GmCXt.user;

		if (!GmCXt.isEmpty(u)) {
			rootScope.checkAppList().then(function () {
				if (!GmCXt.isEmpty(GmCXt.appList) && GmCXt.activeAppId) {
					$$invalidate(0, rootScope.selectedApp = GmCXt.appList['app:' + GmCXt.activeAppId].title, rootScope);
				}
			});

			$$invalidate(3, currBrandLogo = GmCXt.brandLogo());

			$$invalidate(3, currBrandLogo = rootScope.currBrandLogo
			? rootScope.currBrandLogo
			: currBrandLogo);
		}
	};

	const changeLang = lang => {
		if (lang) {
			if (lang.language && lang.language.indexOf('en-') !== -1) {
				$$invalidate(0, rootScope.contextTours = [], rootScope);
			}

			Gm.selectedLang.set(lang.language);
		} else {
			Gm.selectedLang.set('default');
			$$invalidate(0, rootScope.contextTours = [], rootScope);
		}

		if (!lang || !lang.name) {
			lang = rootScope.defaultLang;

			rootScope.languages.filter(function (item) {
				if (item.language === rootScope.browserLang) {
					lang = item;
				}
			});

			GmCXt.saveToStorage('userPrefLang', false);
			$$invalidate(0, rootScope.userPrefLang = false, rootScope);
		} else {
			GmCXt.saveToStorage('userPrefLang', lang.language);
			$$invalidate(0, rootScope.userPrefLang = lang.language, rootScope);
		}

		$$invalidate(0, rootScope.language = lang.language, rootScope);
		GmCXt.language = lang.language;
		GmCXt.saveToStorage('activeLang', lang.language);
		GmCXt.saveToStorage('activeVoice', lang.voice);
		$$invalidate(0, rootScope.languageVoice = lang.voice, rootScope);
		$$invalidate(0, rootScope.selectedLanguage = lang.name, rootScope);
		rootScope.updateLabels();
		rootScope.resetNotificationData();
		rootScope.setNotifTours();
		refreshHeader();
		$$invalidate(19, lanDropDownVisible = false);
		mg$('.mgPlayerJSTest_lang-dropdown-wrapper').slideUp(100);
		GmCXt.refreshView = true;
		$$invalidate(18, unique = {});
		Gm.labels.set(rootScope.labels);

		// Gm.loading.set(true);
		toggleNavBar();

		if (GmCXt.FT.creatorApp) {
			rootScope.setCurrentPage('allguides');
			Gm.breadCrumb.set([]);
			$$invalidate(0, rootScope.refreshAllGuides = true, rootScope);
		}
	};

	const hideUserImageDropDown = function () {
		mg$('.ege-login-logout-wrapper').slideUp(200);
		mg$('.ege-user-image-wrapper').removeClass('active');
	};

	const performAction = (action, step) => {
		Gm.loading.set(true);
		toggleNavBar();

		switch (action) {
			case 'findNReplace':
				goToFindNreplace(step);
				break;
		}

		hideUserImageDropDown();
	};

	const goToFindNreplace = function (step) {
		Gm.activeView.set('findNReplace');

		if (step && step.step_settings && step.step_settings.element) {
			Gm.routeAction.set({
				action: 'findNReplace',
				data: {
					auto_jquery: step.step_settings.element.criteria.auto_jquery,
					jquery_selector: step.step_settings.element.criteria.jquery_selector
				}
			});
		}
	};

	const stepRouteActionSubscriber = Gm.routeAction.subscribe(value => {
		if (value && value.action === 'stepFindNReplace' && value.data) {
			performAction('findNReplace', value.data.step);
		}
	});

	const onRefresh = () => {
		Gm.loading.set(true);

		if (get_store_value(Gm.activeView) === 'taskStatus') {
			rootScope.setActivePage('taskStatus');
			return;
		}

		refreshHeader();
		rootScope.refreshAllData();
	};

	function alignPanel(direction) {
		$$invalidate(6, panelAlignment = direction);
		Gm.panelAlignment.set(direction);

		if (panelAlignment === 'left') {
			mg$('.mgPlayerJSTest_ege-panel').css({ left: '0', right: 'initial' });
		} else if (panelAlignment === 'right') {
			mg$('.mgPlayerJSTest_ege-panel').css({ right: '0', left: 'initial' });
		}
	}

	onMount(refreshHeader);

	onDestroy(() => {
		currentPageSubscriber();
		panelAlignmentSubscriber();
		unSubscribeDropdown();
		loaderSubscriber();
		stepEditModeSubscriber();
		stepOperationModeSubscriber();
		stepRouteActionSubscriber();
	});

	let dd_class = '';
	let dd_userPrefLang = '';

	const error_handler = e => {
		e.target.src = rootScope.staticContentPath + 'myguide.png';
	};

	const click_handler = () => alignPanel('left');
	const click_handler_1 = () => alignPanel('right');
	const click_handler_2 = () => performAction('findNReplace');

	const click_handler_3 = () => {
		Gm.loading.set(true);
		Gm.activeView.set('changePw');
		toggleNavBar();
	};

	const click_handler_4 = () => changeLang('');

	function input_change_handler() {
		rootScope.showPlayer = this.checked;
		$$invalidate(0, rootScope);
	}

	const change_handler = () => {
		Gm.loading.set(true);
		rootScope.togglePlayerMode();
		toggleNavBar();
	};

	const click_handler_5 = () => {
		Gm.loading.set(true);
		$$invalidate(0, rootScope.showPlayer = !rootScope.showPlayer, rootScope);
		rootScope.togglePlayerMode();
		toggleNavBar();
	};

	const click_handler_6 = () => {
		Gm.loading.set(true);
		Gm.activeView.set('taskStatus');
		toggleNavBar();
	};

	const click_handler_7 = () => rootScope.isCreator()
	? rootScope.openSurveyAnalyticsPortal()
	: rootScope.openAppAnalyticsPortal();

	$$self.$$set = $$props => {
		if ('unique' in $$props) $$invalidate(18, unique = $$props.unique);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*lanDropDownVisible*/ 524288) {
			$$invalidate(7, dd_class = lanDropDownVisible ? 'mgPlayerJSTest_rotate-180' : '');
		}

		if ($$self.$$.dirty[0] & /*rootScope*/ 1) {
			$$invalidate(8, dd_userPrefLang = !rootScope.userPrefLang ? 'mgPlayerJSTest_lang-selected' : '');
		}
	};

	return [
		rootScope,
		user,
		org,
		currBrandLogo,
		loading,
		stepOperationMode,
		panelAlignment,
		dd_class,
		dd_userPrefLang,
		toggleNavBar,
		showNotificationModal,
		showLangTransDD,
		hideNavForAnonymous,
		langDropdown,
		changeLang,
		performAction,
		onRefresh,
		alignPanel,
		unique,
		lanDropDownVisible,
		error_handler,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		input_change_handler,
		change_handler,
		click_handler_5,
		click_handler_6,
		click_handler_7
	];
}

class UserMenu extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$t, create_fragment$u, safe_not_equal, { unique: 18 }, null, [-1, -1]);
	}
}

/* src/components/Header.svelte generated by Svelte v4.2.20 */

function create_if_block$o(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t;
	let img;
	let img_src_value;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t = space();
			img = element("img");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_inline-block-vm");
			attr(img, "id", "mgPlayerJSTest_header-widget-icon");
			attr(img, "class", "mgPlayerJSTest_header-widget-icon");
			attr(img, "alt", "Cornerstone");
			if (!src_url_equal(img.src, img_src_value = rootScope.getBasePath('common/img/logo-admin.png'))) attr(img, "src", img_src_value);
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_header-banner-wrapper mgPlayerJSTest_position-relative");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = /*loginBanner*/ ctx[0];
			append(wmgPlayerJSTest_1, t);
			append(wmgPlayerJSTest_1, img);
		},
		p(ctx, dirty) {
			if (dirty & /*loginBanner*/ 1) wmgPlayerJSTest_0.innerHTML = /*loginBanner*/ ctx[0];		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}
		}
	};
}

function create_fragment$t(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let usermenu;
	let t;
	let current;
	usermenu = new UserMenu({});
	let if_block = (rootScope.currentView == 'login-view' || rootScope.currentView == 'forgot-password-view') && create_if_block$o(ctx);

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			create_component(usermenu.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_width-100");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_panel-header-wrapper mgPlayerJSTest_width-100 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
			toggle_class(wmgPlayerJSTest_1, "mgPlayerJSTest_bg-white", rootScope.isMicroPlayer);
			toggle_class(wmgPlayerJSTest_1, "mgPlayerJSTest_panel-header-micro-wrapper", rootScope.isMicroPlayer);
			attr(wmgPlayerJSTest_2, "id", "mgPlayerJSTest_ege-header");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_ege-panel-header");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			mount_component(usermenu, wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_2, t);
			if (if_block) if_block.m(wmgPlayerJSTest_2, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (rootScope.currentView == 'login-view' || rootScope.currentView == 'forgot-password-view') if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(usermenu.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(usermenu.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			destroy_component(usermenu);
			if (if_block) if_block.d();
		}
	};
}

function instance$s($$self, $$props, $$invalidate) {
	let loginBanner = '';

	function setLoginBanner() {
		fetch(rootScope.getBasePath('common/img/login_header.svg')).then(response => {
			return response.text();
		}).then(html => {
			$$invalidate(0, loginBanner = html);
		});
	}

	onMount(() => {
		setLoginBanner();
	});

	return [loginBanner];
}

class Header extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$s, create_fragment$t, safe_not_equal, {});
	}
}

/* src/components/Captcha.svelte generated by Svelte v4.2.20 */

function create_if_block$n(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_.textContent = `${rootScope.labels.captchaError}`;
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_input-captcha-error");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_error-input-wrapper captcha-error-wrapper active");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

function create_fragment$s(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let i;
	let t0;
	let t1;
	let button;
	let raw_value = rootScope.svgs.refresh + "";
	let t2;
	let input;
	let t3;
	let mounted;
	let dispose;
	let if_block = /*showCaptchaError*/ ctx[0] && create_if_block$n();

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			i = element("i");
			t0 = text(/*captchaText*/ ctx[3]);
			t1 = space();
			button = element("button");
			t2 = space();
			input = element("input");
			t3 = space();
			if (if_block) if_block.c();
			attr(i, "id", "mgPlayerJSTest_captcha-image");
			attr(i, "selectable", "False");
			attr(button, "id", "autorenew");
			attr(button, "aria-label", rootScope.labels.refresh);
			attr(button, "class", "mgPlayerJSTest_captcha-refresh-btn mgPlayerJSTest_lbl-btn mgPlayerJSTest_lbl-btn-refresh mgPlayerJSTest_refresh-btn");
			attr(button, "type", "button");
			attr(input, "id", "mgPlayerJSTest_input-captcha");
			attr(input, "class", "mgPlayerJSTest_input-captcha-text mgPlayerJSTest_font-size-16 mgPlayerJSTest_ege-inline-block-vm");
			attr(input, "placeholder", rootScope.labels.placeholderEnterCaptcha);
			input.required = true;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_input-captcha mgPlayerJSTest_margin-tb-10 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_flex-direction-column");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, i);
			append(i, t0);
			append(wmgPlayerJSTest_0, t1);
			append(wmgPlayerJSTest_0, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_0, t2);
			append(wmgPlayerJSTest_0, input);
			set_input_value(input, /*captchaInput*/ ctx[2]);
			/*input_binding*/ ctx[8](input);
			append(wmgPlayerJSTest_1, t3);
			if (if_block) if_block.m(wmgPlayerJSTest_1, null);

			if (!mounted) {
				dispose = [
					listen(button, "click", /*generate*/ ctx[4]),
					listen(input, "input", /*input_input_handler*/ ctx[7]),
					listen(input, "change", /*validateCaptcha*/ ctx[5]),
					listen(input, "focus", /*focus_handler*/ ctx[9])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*captchaText*/ 8) set_data(t0, /*captchaText*/ ctx[3]);

			if (dirty & /*captchaInput*/ 4 && input.value !== /*captchaInput*/ ctx[2]) {
				set_input_value(input, /*captchaInput*/ ctx[2]);
			}

			if (/*showCaptchaError*/ ctx[0]) {
				if (if_block) ; else {
					if_block = create_if_block$n();
					if_block.c();
					if_block.m(wmgPlayerJSTest_1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			/*input_binding*/ ctx[8](null);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$r($$self, $$props, $$invalidate) {
	let { captchaValid = false } = $$props;
	let { showCaptchaError } = $$props;
	let { inputCaptchaRef } = $$props;
	let captchaInput;
	let captchaText;

	function generate() {
		$$invalidate(2, captchaInput = '');
		$$invalidate(6, captchaValid = false);
		$$invalidate(3, captchaText = '');
		let uniquechar = '';
		let randomchar = '0123456789ABCDEFGHJKLMNOPQRSTUVWXYZabdfghijkmnopqrstuvwxyz';

		for (let i = 0; i < 6; i++) {
			uniquechar += randomchar.charAt(Math.random() * randomchar.length);
		}

		$$invalidate(3, captchaText = uniquechar);
	}

	function validateCaptcha() {
		$$invalidate(6, captchaValid = false);

		if (captchaText === captchaInput) {
			$$invalidate(6, captchaValid = true);
			Gm.loading.set(false);
		}
	}

	generate();

	function input_input_handler() {
		captchaInput = this.value;
		$$invalidate(2, captchaInput);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputCaptchaRef = $$value;
			$$invalidate(1, inputCaptchaRef);
		});
	}

	const focus_handler = () => $$invalidate(0, showCaptchaError = false);

	$$self.$$set = $$props => {
		if ('captchaValid' in $$props) $$invalidate(6, captchaValid = $$props.captchaValid);
		if ('showCaptchaError' in $$props) $$invalidate(0, showCaptchaError = $$props.showCaptchaError);
		if ('inputCaptchaRef' in $$props) $$invalidate(1, inputCaptchaRef = $$props.inputCaptchaRef);
	};

	return [
		showCaptchaError,
		inputCaptchaRef,
		captchaInput,
		captchaText,
		generate,
		validateCaptcha,
		captchaValid,
		input_input_handler,
		input_binding,
		focus_handler
	];
}

class Captcha extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$r, create_fragment$s, safe_not_equal, {
			captchaValid: 6,
			showCaptchaError: 0,
			inputCaptchaRef: 1
		});
	}
}

let logAll = [] ;

let logLog = function(){
    console.log(JSON.stringify(logAll));
};

let stopCapture = function(logs) {
    logs = logs || logAll;
    let data = JSON.stringify(logs, null, 2);
    let blob = new Blob([data], { type: 'text/plain' });
    let url = URL.createObjectURL(blob);
    let a = document.createElement('a');
    a.href = url;
    a.download = 'console_logs.txt';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};

/* src/components/Footer.svelte generated by Svelte v4.2.20 */

function create_if_block_8$d(ctx) {
	let wmgPlayerJSTest_;
	let span0;
	let t2;
	let span1;
	let t4;
	let a0;
	let t5_value = (/*labels*/ ctx[2]?.privacyPolicy || rootScope.labels.privacyPolicy) + "";
	let t5;
	let a0_aria_label_value;
	let t6;
	let span2;
	let t8;
	let a1;
	let t9_value = (/*labels*/ ctx[2]?.termsOfService || rootScope.labels.termsOfService) + "";
	let t9;
	let a1_aria_label_value;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			span0 = element("span");
			span0.textContent = `© ${rootScope.brandName}`;
			t2 = space();
			span1 = element("span");
			span1.textContent = "|";
			t4 = space();
			a0 = element("a");
			t5 = text(t5_value);
			t6 = space();
			span2 = element("span");
			span2.textContent = "|";
			t8 = space();
			a1 = element("a");
			t9 = text(t9_value);
			attr(span1, "class", "footer-text-separator");
			attr(a0, "id", "mgPlayerJSTest_footer-privacy-policy");
			attr(a0, "href", rootScope.config.privacyPolicyUrl);
			attr(a0, "target", "_blank");
			attr(a0, "aria-label", a0_aria_label_value = /*labels*/ ctx[2]?.privacyPolicy || rootScope.labels.privacyPolicy);
			attr(a0, "rel", "noopener noreferrer");
			attr(span2, "class", "footer-text-separator");
			attr(a1, "id", "mgPlayerJSTest_footer-terms-of-service");
			attr(a1, "href", rootScope.config.termsURL);
			attr(a1, "target", "_blank");
			attr(a1, "aria-label", a1_aria_label_value = /*labels*/ ctx[2]?.termsOfService || rootScope.labels.termsOfService);
			attr(a1, "rel", "noopener noreferrer");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_footer-panel-copyright-text");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, span0);
			append(wmgPlayerJSTest_, t2);
			append(wmgPlayerJSTest_, span1);
			append(wmgPlayerJSTest_, t4);
			append(wmgPlayerJSTest_, a0);
			append(a0, t5);
			append(wmgPlayerJSTest_, t6);
			append(wmgPlayerJSTest_, span2);
			append(wmgPlayerJSTest_, t8);
			append(wmgPlayerJSTest_, a1);
			append(a1, t9);
		},
		p(ctx, dirty) {
			if (dirty & /*labels*/ 4 && t5_value !== (t5_value = (/*labels*/ ctx[2]?.privacyPolicy || rootScope.labels.privacyPolicy) + "")) set_data(t5, t5_value);

			if (dirty & /*labels*/ 4 && a0_aria_label_value !== (a0_aria_label_value = /*labels*/ ctx[2]?.privacyPolicy || rootScope.labels.privacyPolicy)) {
				attr(a0, "aria-label", a0_aria_label_value);
			}

			if (dirty & /*labels*/ 4 && t9_value !== (t9_value = (/*labels*/ ctx[2]?.termsOfService || rootScope.labels.termsOfService) + "")) set_data(t9, t9_value);

			if (dirty & /*labels*/ 4 && a1_aria_label_value !== (a1_aria_label_value = /*labels*/ ctx[2]?.termsOfService || rootScope.labels.termsOfService)) {
				attr(a1, "aria-label", a1_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (87:1) {#if GmCXt.isPlayer() && enableSendFeedback()}
function create_if_block_4$g(ctx) {
	let wmgPlayerJSTest_;
	let show_if = !GmCXt.isMicroPlayer();
	let t;
	let if_block0 = show_if && create_if_block_7$d();

	function select_block_type(ctx, dirty) {
		if (/*feedBackSetting*/ ctx[0].feedback_type == 'email') return create_if_block_5$f;
		if (/*feedBackSetting*/ ctx[0].feedback_type == 'url') return create_if_block_6$e;
	}

	let current_block_type = select_block_type(ctx);
	let if_block1 = current_block_type && current_block_type(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_footer-panel-copyright-text mgPlayerJSTest_footer-send-feedback");
			toggle_class(wmgPlayerJSTest_, "mgPlayerJSTest_footer-send-feedback-mp", GmCXt.isMicroPlayer());
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			if (if_block1) if_block1.m(wmgPlayerJSTest_, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if (if_block1) if_block1.d(1);
				if_block1 = current_block_type && current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_, null);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block0) if_block0.d();

			if (if_block1) {
				if_block1.d();
			}
		}
	};
}

// (92:3) {#if !GmCXt.isMicroPlayer()}
function create_if_block_7$d(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "|";
			attr(span, "class", "footer-text-separator");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (103:52) 
function create_if_block_6$e(ctx) {
	let button;
	let t_value = (/*labels*/ ctx[2]?.sendFeedback || rootScope.labels.sendFeedback) + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t = text(t_value);
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_cursor-pointer");
			attr(button, "aria-label", rootScope.labels.sendFeedback);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*openFeedbackUrl*/ ctx[4]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*labels*/ 4 && t_value !== (t_value = (/*labels*/ ctx[2]?.sendFeedback || rootScope.labels.sendFeedback) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (95:3) {#if feedBackSetting.feedback_type == 'email'}
function create_if_block_5$f(ctx) {
	let button;
	let t_value = (/*labels*/ ctx[2]?.sendFeedback || rootScope.labels.sendFeedback) + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t = text(t_value);
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_cursor-pointer");
			attr(button, "aria-label", rootScope.labels.sendFeedback);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*onSendFeedbackClick*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*labels*/ 4 && t_value !== (t_value = (/*labels*/ ctx[2]?.sendFeedback || rootScope.labels.sendFeedback) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (115:1) {#if GmCXt.isMicroPlayer()}
function create_if_block$m(ctx) {
	let wmgPlayerJSTest_;
	let t0;
	let t1;
	let if_block0 = !rootScope.currentPageOnly && create_if_block_3$h();
	let if_block1 = (/*currentPage*/ ctx[1] === 'currentpage' || /*currentPage*/ ctx[1] === 'currentPageSearchPage') && !rootScope.currentPageOnly && create_if_block_2$j(ctx);
	let if_block2 = (/*currentPage*/ ctx[1] === 'allguides' || /*currentPage*/ ctx[1] === 'allguidesSearchPage') && create_if_block_1$k(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_footer-panel-copyright-text");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t0);
			if (if_block1) if_block1.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t1);
			if (if_block2) if_block2.m(wmgPlayerJSTest_, null);
		},
		p(ctx, dirty) {
			if ((/*currentPage*/ ctx[1] === 'currentpage' || /*currentPage*/ ctx[1] === 'currentPageSearchPage') && !rootScope.currentPageOnly) {
				if (if_block1) ; else {
					if_block1 = create_if_block_2$j(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*currentPage*/ ctx[1] === 'allguides' || /*currentPage*/ ctx[1] === 'allguidesSearchPage') {
				if (if_block2) ; else {
					if_block2 = create_if_block_1$k(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};
}

// (117:3) {#if !rootScope.currentPageOnly}
function create_if_block_3$h(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "|";
			attr(span, "class", "footer-text-separator");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (120:3) {#if (currentPage === 'currentpage' || currentPage === 'currentPageSearchPage') && !rootScope.currentPageOnly}
function create_if_block_2$j(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			button.textContent = `${rootScope.labels.allGuides}`;
			attr(button, "id", "mgPlayerJSTest_go-to-all-guides");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_cursor-pointer");
			attr(button, "aria-label", rootScope.labels.allGuides);
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[5]);
				mounted = true;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (133:3) {#if currentPage === 'allguides' || currentPage === 'allguidesSearchPage'}
function create_if_block_1$k(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			button.textContent = `${rootScope.labels.currentPage}`;
			attr(button, "id", "mgPlayerJSTest_go-to-current-page");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_cursor-pointer");
			attr(button, "aria-label", rootScope.labels.currentPage);
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_1*/ ctx[6]);
				mounted = true;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

function create_fragment$r(ctx) {
	let wmgPlayerJSTest_1;
	let show_if_2 = !GmCXt.isMicroPlayer();
	let t0;
	let show_if_1 = GmCXt.isPlayer() && enableSendFeedback();
	let t1;
	let show_if = GmCXt.isMicroPlayer();
	let t2;
	let wmgPlayerJSTest_0;
	let if_block0 = show_if_2 && create_if_block_8$d(ctx);
	let if_block1 = show_if_1 && create_if_block_4$g(ctx);
	let if_block2 = show_if && create_if_block$m(ctx);

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_ege-clear");
			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_footer-panel-container");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_footer-panel");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t0);
			if (if_block1) if_block1.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t1);
			if (if_block2) if_block2.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t2);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
		},
		p(ctx, [dirty]) {
			if (show_if_2) if_block0.p(ctx, dirty);
			if (show_if_1) if_block1.p(ctx, dirty);
			if (show_if) if_block2.p(ctx, dirty);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};
}

function enableSendFeedback() {
	if (GmCXt.getAppSetting('enable_send_feedback')) {
		return true;
	} else {
		return false;
	}
}

function instance$q($$self, $$props, $$invalidate) {
	let feedBackSetting = {};
	let feedback_url = '';
	let currentPage = false;
	let labels = get_store_value(Gm.labels);

	function onSendFeedbackClick() {
		GmCXt.closeAppPanel();
		GmCXt.addFeedBackToolbar();

		GmCXt.timeout(
			function () {
				GmCXt.captureScreenForFeedback(feedBackSetting.feedback_email);
			},
			100
		);
	}

	const labelSubscriber = Gm.labels.subscribe(value => {
		$$invalidate(2, labels = value);
	});

	let unsubscribe = Gm.CurrentPage.subscribe(val => {
		$$invalidate(1, currentPage = val);
	});

	function openFeedbackUrl() {
		window.open(feedback_url, '_blank', 'noopener,noreferrer');
	}

	onMount(() => {
		$$invalidate(0, feedBackSetting = GmCXt.getBrandingSetting());

		if (feedBackSetting.feedback_url && feedBackSetting.feedback_url.indexOf('http') === -1) {
			feedback_url = 'https://' + feedBackSetting.feedback_url;
		} else {
			feedback_url = feedBackSetting.feedback_url;
		}
	});

	onDestroy(() => {
		unsubscribe();
		labelSubscriber();
	});

	const click_handler = () => {
		rootScope.setCurrentPage('allguides');
		Gm.breadCrumb.set([]);
	};

	const click_handler_1 = () => {
		rootScope.setCurrentPage('currentpage');
		Gm.breadCrumb.set([]);
	};

	return [
		feedBackSetting,
		currentPage,
		labels,
		onSendFeedbackClick,
		openFeedbackUrl,
		click_handler,
		click_handler_1
	];
}

class Footer extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$q, create_fragment$r, safe_not_equal, {});
	}
}

/*global GmCXt,mg$*/

let modal = {};

modal.addPublishActions = function(onOk) {

    let self = modal;
    let envs = rootScope.appEnvs;

    function updateMessage() {
        let msg = rootScope.labels.guideWillPubIn;
        let showMsg = false;
        let envStr = "";

        mg$('.mgPlayerJSTest_active-progress').each(function(index, element) {
            showMsg = true;
            let en = mg$(element).text();
            if (!envStr) {
                envStr = en;
            } else {
                envStr = envStr + ", " + en;
            }
        });

        if(isPublishedOnTopEnv()){
            mg$("#publishMsg").text(rootScope.labels.guideIsPubIn + envStr);
        }
        else if (showMsg) {
            mg$('#publishMsg').text(msg + envStr);
        } else {
            mg$('#publishMsg').text('');
        }


    }

    function toggleActive(e) {
        let k = envs.indexOf(e.currentTarget.id);
        mg$("#mgPlayerJSTest_checkbox-tour-schedule-pub").prop('checked', false);
        mg$(".mgPlayerJSTest_pub-date-container").hide();

        if (mg$(e.currentTarget).hasClass('mgPlayerJSTest_active-progress')) {
            mg$(e.currentTarget).removeClass('mgPlayerJSTest_active-progress');
            mg$(".mgPlayerJSTest_pub-schedule-checkbox-container").hide();
            if (k === 0) {
                mg$('.ege-publish').addClass("mgPlayerJSTest_disabled");
            }else {
                mg$('.ege-publish').removeClass("mgPlayerJSTest_disabled");
            }
            var j = k + 1;
            while (j < envs.length) {
                mg$('#' + envs[j]).removeClass('mgPlayerJSTest_active-progress');
                j++;
            }

        } else {
            mg$(e.currentTarget).addClass('mgPlayerJSTest_active-progress');
            mg$('.ege-publish').removeClass("mgPlayerJSTest_disabled");
            if (k > 0) {
                var j = 0;
                while (j < k) {
                    mg$('#' + envs[j]).addClass('mgPlayerJSTest_active-progress');
                    j++;
                }
            }
            if (envs[k] === envs[envs.length - 1]) {
                mg$(".mgPlayerJSTest_pub-schedule-checkbox-container").show();
            }
        }

        if(isPublishedOnTopEnv()){
            mg$('.ege-publish').addClass("mgPlayerJSTest_disabled");
        }
        updateMessage();
    }

    for (let i = 0; i < envs.length; i++) {
        mg$('#' + envs[i]).on('click', toggleActive);
    }

    mg$('.ege-publish').off('click').on('click', function() {

        let env = [];
        mg$('.mgPlayerJSTest_active-progress').each(function(index, element) {
            env.push(mg$(element).attr('id'));
        });
        let guideActiveEnv = getGuideActiveEnvs();

        if (!rootScope.guideEnvs || env.length > guideActiveEnv.length) {

            if (!env.length && rootScope.publishStatus === "publish") {
                return;
            }
            onOk(env, "publish");

        } else {
            let lastEnv = env[env.length - 1];
            let lastEnvIdx = rootScope.appEnvs.indexOf(lastEnv);

            if (lastEnvIdx >= 0) {

                let unpubList = rootScope.appEnvs.slice(lastEnvIdx + 1);
                if (unpubList.length) {
                    onOk(unpubList, 'unpublish');
                }
            }
        }

        self.close();
        localStorage.setItem(GmCXt.prevEnv, env);

    });

    mg$('.ege-cancel-btn').off('click').on('click', function() {
        self.close();
    });

    mg$('.mgPlayerJSTest_popup-close').off('click').on('click', function() {
        self.close();
    });
};

modal.attachPopupActions = function(onOk, onCancel, onPreview) {
    let self = modal;

    mg$('.mgPlayerJSTest_overlay-container').off('click').on('click', function(e) {
        self.close();
        if (onCancel) {
            onCancel();
        }
    });

    mg$('.ege-ok-btn').off('click').on('click', function() {
        let el = document.getElementById("mgPlayerJSTest_donot-show-cb");
        if (el) {
            GmCXt.saveToStorage('confirmLinkGuidePub', el.checked);
        }
        self.close();
        if (onOk) {
            onOk();
        }
    });

    mg$('.ege-ok-json-update').off('click').on('click', function() {
        onOk();
    });

    mg$('.ege-ok-btn-radio').off('click').on('click', function() {

        let envs = mg$('.env');

        let envVal = '';

        if (envs) {
            envVal = mg$('.env:checked').val();
        }

        if (envVal) {
            onOk(envVal);
            self.close();
        }
    });

    mg$('.mgPlayerJSTest_ege-option-btn').off('click').on('click', function() {
        if (onPreview)
            onPreview();
        self.close();
    });

    mg$('.ege-cancel-btn').off('click').on('click', function() {
        if (onCancel)
            onCancel();
        self.close();
    });

    mg$('.mgPlayerJSTest_ege-popup-close').off('click').on('click', function() {
        if (onCancel)
            onCancel();
        self.close();
    });

    mg$('#mgPlayerJSTest_resusme-guide-close-button').off('click').on('click', function() {
        self.close();
    });

    mg$('.ege-update-btn').off('click').on('click', function() {
        let audioText = mg$('#audio-text-area').val();
        audioText = audioText.trim();

        if (!audioText.length) {
            mg$('#audio-text-area').addClass('empty-textarea');
            return true;
        }

        if (onOk)
            onOk(audioText);
        self.close();
    });

    mg$('.ege-email-submit-btn').off('click').on('click', function() {
        let email_id = mg$('.mgPlayerJSTest_ege-popup-email-input').val().trim();

        if (!email_id.length) {
            mg$('.mgPlayerJSTest_ege-popup-error-msg').show();
            return true;
        }

        if (onOk)
            onOk(email_id);
        self.close();
    });

    mg$('.ege-otp-submit-btn').off('click').on('click', function() {
        let email_id = mg$('.mgPlayerJSTest_ege-popup-email-input-confirm').val().trim();
        let otp = mg$('.mgPlayerJSTest_ege-popup-confirm-otp').val().trim();

        if (!otp.length) {
            mg$('.mgPlayerJSTest_ege-popup-error-msg').show();
            return true;
        }

        if (onOk)
            onOk(email_id, otp);
        self.close();
    });

    if (mg$('#audio-text-area').length) {
        mg$('#audio-text-area').on('focus', function(e) {
            mg$(e.target).removeClass('empty-textarea');
        });
    }

    if (mg$('#preview-link').length) {
        mg$('#preview-link').off('click').on('click', function() {
            let audioText = mg$('#audio-text-area').val();
            audioText = audioText.trim();
            if (onPreview && audioText.length)
                onPreview(audioText);
        });
    }

    mg$('.ege-link-guide').off('click').on('click', function() {

        let guideID = mg$('#ruleTypeGuide').val();
        guideID = guideID.trim();

        if (!guideID.length) {
            mg$('.mgPlayerJSTest_ege-popup-error-msg').show();
            return true;
        }

        // var tourViewPage = angular.element('#mgPlayerJSTest_tour-view-page-container').scope();
        rootScope.step.step_screen = mg$("#ruleTypeGuide option:selected").attr('data-image');
        rootScope.step.step_description = mg$("#ruleTypeGuide option:selected").attr('data-description');
        if (rootScope.step.step_screen) ; else {
            rootScope.step.step_screen = "1";
        }
        if (rootScope.step.step_description) ; else {
            rootScope.step.step_description = " ";
        }

        rootScope.step.step_title = mg$("#ruleTypeGuide option:selected").text();
        rootScope.step.step_settings = "{'tour_id' :" + mg$('#ruleTypeGuide').val() + "}";

        let stepObj = {};
        stepObj.tour_id = mg$('#ruleTypeGuide').val();
        rootScope.step.step_settings = JSON.stringify(stepObj);
        let data = {};
        data = Object.assign({}, rootScope.step);

        data.step_screen = rootScope.step.step_screen;
        rootScope.step.step_order - 1;
    // tourViewPage.createStep(viewStep);
    // self.createStep(tourViewPage, onOk);
    });

    mg$('.mgPlayerJSTest_modal-view-more').off('click').on('click', function() {
        mg$(".mgPlayerJSTest_info-msg").show();
        mg$('.mgPlayerJSTest_modal-view-more').hide();
    });

    mg$('.ege-csv-ok-btn').off('click').on('click', function() {

        let files = mg$('#mgPlayerJSTest_input-csv')[0].files;

        let parsedata = [];

        let getParseCsvData = function(data) {
            let newLinebrk = data.split("\n");

            for (let i = 0; i < newLinebrk.length; i++) {
                if (newLinebrk[i] !== '')
                    parsedata.push(newLinebrk[i].split(","));
            }
        };

        if (files && files[0]) {
            let myFile = files[0];
            let reader = new FileReader();

            reader.onload = function(e) {

                let csvData = e.target.result;
                getParseCsvData(csvData); // calling function for parse csv data 

                onOk(parsedata);
            };

            reader.readAsBinaryString(myFile);
        } else {
            onOk();
        }

        self.close();

    });
};

modal.createStep = function(tourViewPage, onOk) {
    let self = modal;

    function onSuccess(response) {
        let data = response.data.data;
        self.close();
        Gm.loading.set(false);
        let viewStep = {};
        viewStep.stepIndex = rootScope.step.step_order - 1;
        viewStep.step = data.step;
        tourViewPage.createStepCompleted(viewStep);
        if (onOk) onOk(response.data.data);
    }
    api.stepCreate(rootScope.step, onSuccess);
};

function getGuideActiveEnvs() {
    let filteredEnvs = [];
    if (rootScope.guideEnvs && rootScope.guideEnvs.length) {
        for (let i = 0; i < rootScope.guideEnvs.length; i++) {
            let env = rootScope.guideEnvs[i];
            if (rootScope.appEnvs && rootScope.appEnvs.includes(env)) {
                filteredEnvs.push(env);
            }
        }
    }
    return filteredEnvs;
}

function reselectElem() {
    let msg = {
        action: 'mgPlayerJSTest_action:reselect_edit_step_element,task:edit_step'
    };
    GmCXt.handleReselectEl(msg);
}

function reselectBeacon() {
    GmCXt.handleReselectBeacon();
}

modal.editStepOptions = function(btn1) {
    let label = rootScope.labels.lblNotFoundInPage;
    let action = '';
    let btn = '';
    let okBtn = rootScope.labels.ok;
    let popupType = 'mgPlayerJSTest_popup-warning';
    let popupHeaderIcon = rootScope.svgs.popupWarning;
    let closeButton = "<wmgPlayerJSTest_ class='mgPlayerJSTest_popup-btn-close ege-cancel-btn'>" + rootScope.svgs.popupClose + "</wmgPlayerJSTest_>";

    if (btn1 === 'Reselect element') {
        label = rootScope.labels.lblReselectElem;
        btn = "<wmgPlayerJSTest_ id='mgPlayerJSTest_btn-ok-edit-step-popup' class='ege-ok-btn mgPlayerJSTest_btn-default mgPlayerJSTest_ege-inline-block-vt mgPlayerJSTest_ege-redirect-btn'>" + btn1 + "</wmgPlayerJSTest_>";
        action = reselectElem;
        okBtn = rootScope.labels.btnCancel;
    } else if (btn1 === "Reselect beacon") {
        label = rootScope.labels.lblReselectBeacon;
        btn = "<wmgPlayerJSTest_ id='mgPlayerJSTest_btn-ok-edit-step-popup' class='ege-ok-btn mgPlayerJSTest_btn-default mgPlayerJSTest_ege-inline-block-vt mgPlayerJSTest_ege-redirect-btn'>" + btn1 + "</wmgPlayerJSTest_>";
        action = reselectBeacon;
        okBtn = rootScope.labels.btnCancel;
    }

    let str = "<wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-container'></wmgPlayerJSTest_>" +
    " 	<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup " + popupType + "'> " +
    "       <wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-wrapper'>" +
    "	" + closeButton + "	" +
    "	       <wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon-wrapper'><wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon'>" + popupHeaderIcon + "</wmgPlayerJSTest_></wmgPlayerJSTest_>" +
    "       </wmgPlayerJSTest_>" +
    "		<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-title-wrapper mgPlayerJSTest_display-none'>" +
    "		</wmgPlayerJSTest_>" +
    "		<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-content-wrapper mgPlayerJSTest_font-size-17'>" + label + "</wmgPlayerJSTest_>" +
    "		<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-btn-wrapper'>" + btn +
    "			<wmgPlayerJSTest_ id='mgPlayerJSTest_btn-cancel-edit-step-popup' class='mgPlayerJSTest_btn-default mgPlayerJSTest_btn-large ege-ok-btn mgPlayerJSTest_ege-inline-block-vt'>" + okBtn +
    "		</wmgPlayerJSTest_>" +
    "	</wmgPlayerJSTest_>" +
    " </wmgPlayerJSTest_> ";

    mg$('.mgPlayerJSTest_ege-panel').append(str);
    modal.attachPopupActions(action, false);
};

modal.open = function(label, type, onOk, onCancel, infoMsg, popupHideTime, modalTitle) {

    if (typeof label !== "string") {
        label = "Unknown error!";
    }

    let cancelBtn = "";
    let okBtn = rootScope.labels.ok;
    let canBtn = rootScope.labels.btnCancel;
    let popupType = "";
    let popupHeaderIcon = "";
    let infoMsgHTML = "";
    let radio = "";
    let closeButton = "<wmgPlayerJSTest_ class='mgPlayerJSTest_popup-btn-close ege-cancel-btn'>" + rootScope.svgs.popupClose + "</wmgPlayerJSTest_>";
    let checkBox = "";
    let modalTitleEle = "";

    if (infoMsg) {
        infoMsgHTML = "<span class='mgPlayerJSTest_info-msg-container'>" +
      "<span class='mgPlayerJSTest_modal-view-more'>" + rootScope.labels.viewMore + "</span>" +
      "<br><label class='mgPlayerJSTest_info-msg'>" + infoMsg + "</label>" +
      "</span>";
    }

    if (rootScope.labels.guidePublishWarning === label) {
        checkBox = "<wmgPlayerJSTest_ class= 'mgPlayerJSTest_donot-show-popup'>" + "<input id='mgPlayerJSTest_donot-show-cb' type= 'checkbox' class='mgPlayerJSTest_input-checkbox-custom' />" + "<label class='mgPlayerJSTest_info-msg-donot-show-popup'>" + "Do not show this pop up again" + "</label>" + "</wmgPlayerJSTest_>";
    }

    if (type === "yesno") {
        okBtn = "Yes";
        canBtn = "No";
    }

    if (type === "tourPlay") {
        okBtn = rootScope.labels.startOver;
        canBtn = rootScope.labels.yesResume;
        closeButton = "<button id='mgPlayerJSTest_resusme-guide-close-button' class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_popup-upload-close mgPlayerJSTest_ege-popup-close mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer mgPlayerJSTest_display-flex mgPlayerJSTest_justify-content-flex-end mgPlayerJSTest_padding-15' aria-label='Close' >" + rootScope.svgs.popupClose + "</button>";
    }

    if (type === "tourPlay" || type === "info" || type === "") {
        popupType = "mgPlayerJSTest_popup-info";
        popupHeaderIcon = rootScope.svgs.popupInfo;
    }

    if (type === "alert") {
        popupType = "mgPlayerJSTest_popup-error";
        popupHeaderIcon = rootScope.svgs.popupError;
    }

    if (type === "success") {
        popupType = "mgPlayerJSTest_popup-success";
        popupHeaderIcon = rootScope.svgs.popupSuccess;
    }

    if (type === "warning") {
        popupType = "mgPlayerJSTest_popup-warning";
        popupHeaderIcon = rootScope.svgs.popupWarning;
    }

    if (type === "confirm" || type === "copy" || type === "yesno" || type === "domain") {
        popupType = "mgPlayerJSTest_popup-warning";
        popupHeaderIcon = rootScope.svgs.popupWarning;
    }

    if (type === "tourPlay") {
        cancelBtn = "<button id='mgPlayerJSTest_btn-cancel-tour-play-popup' class='ege-cancel-btn mgPlayerJSTest_btn-default mgPlayerJSTest_ege-inline-block-vt' aria-label='" + canBtn + "' >" + canBtn + "</button>";
    }

    let okbutton = "<button id='mgPlayerJSTest_btn-ok-common-popup' class='ege-ok-btn mgPlayerJSTest_btn-default mgPlayerJSTest_btn-large mgPlayerJSTest_ege-inline-block-vt' aria-label='" + okBtn + "' >" + okBtn + "</button>";

    if (type === "domain") {

        let appEnvs = [];
        let app_envs = GmCXt.getActiveAppSetting().app_env || rootScope.defaultAppEnv;
        for (var i in app_envs) {
            if (app_envs[i].checked) {
                appEnvs.push(i);
            }
        }

        if (appEnvs.length) {

            let arrOfEnv = [];
            let checked = "";

            for (var i = 0; i < appEnvs.length; i++) {
                checked = rootScope.highestEnv === appEnvs[i] ? "checked" : "";

                arrOfEnv.push('<wmgPlayerJSTest_ class="mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_padding-5"><input type="radio" name="env" value=' + appEnvs[i] + ' class="env mgPlayerJSTest_ege-popup-radio mgPlayerJSTest_inline-block-vt mgPlayerJSTest_input-radio-custom"' + checked + '/>' +
          '<span class="mgPlayerJSTest_ege-popup-radio-text">' +
          rootScope.updateEnvNames(appEnvs[i]) + '</span></wmgPlayerJSTest_>');
            }

            radio = '<br><wmgPlayerJSTest_ class="mgPlayerJSTest_ege-inline-block-vm mgPlayerJSTest_display-flex mgPlayerJSTest_justify-content-center mgPlayerJSTest_flex-wrap mgPlayerJSTest_padding-lr-15">' + arrOfEnv.join('') + ' </wmgPlayerJSTest_><br>';

            okbutton = "<button class='ege-ok-btn-radio mgPlayerJSTest_btn-default mgPlayerJSTest_ege-inline-block-vt' aria-label='" + okBtn + "' >" + okBtn + "</button>";

        }
    }

    if (type === 'copy') {
        okBtn = rootScope.labels.copy;
    }

    let catUnPubMsg = "";
    if (rootScope.categoryIsUnPublished) {

        let message = '';
        let rl = rootScope.labels;

        if (label === rl.tourpublishMsg2) {
            message = rl.tooltipPublishWarningMessage;
        } else {
            message = rl.guidePublishWarningMessage;
        }

        catUnPubMsg = "<wmgPlayerJSTest_ class='mgPlayerJSTest_popup-content-info'>" + message + "</wmgPlayerJSTest_>";

        rootScope.categoryIsUnPublished = false;
    }

    if (GmCXt.isDefined(modalTitle)) {
        modalTitleEle = "<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-title-wrapper'>" + modalTitle + "</wmgPlayerJSTest_>";
    }

    let str = " <wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-container'></wmgPlayerJSTest_>" +
    " <wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup " + popupType + "'> " +
    "   <wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-wrapper'>" +
    "	" + closeButton + "	" +
    "	   <wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon-wrapper'><wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon'>" + popupHeaderIcon + "</wmgPlayerJSTest_></wmgPlayerJSTest_>" +
    "   </wmgPlayerJSTest_>" +
    modalTitleEle +
    "	<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-content-wrapper mgPlayerJSTest_font-size-17'>" + label + infoMsgHTML + "</wmgPlayerJSTest_>" +
    " " + catUnPubMsg + " " +
    radio +
    checkBox +
    "	<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-btn-wrapper'>" +
    "" + okbutton + "" +
    "" + cancelBtn + "" +

    "	</wmgPlayerJSTest_>" +

    " </wmgPlayerJSTest_> ";

    if (rootScope.isAutoConfigPanelOpen) {
        mg$('.mgPlayerJSTest_ege-panel-auto').append(str);
    } else {
        mg$('.mgPlayerJSTest_ege-panel').append(str);
    }

    modal.attachPopupActions(onOk, onCancel, false);

    setTimeout(function() {
        mg$("#mgPlayerJSTest_btn-ok-common-popup").focus();
    }, 500);

    if (popupHideTime) {
        setTimeout(function() {
            mg$('.mgPlayerJSTest_overlay-container').remove();
            mg$('.mgPlayerJSTest_ege-popup').remove();
        }, popupHideTime);
    }
};

modal.openCategoryDelete = function(label, onOk, onCancel) {
    let okBtn = "OK";
    let popupType = 'mgPlayerJSTest_popup-warning';
    let popupHeaderIcon = rootScope.svgs.popupWarning;
    let closeButton = "<wmgPlayerJSTest_ id='mgPlayerJSTest_btn-cancel-cat-del-popup' class='mgPlayerJSTest_popup-btn-close ege-cancel-btn'>" + rootScope.svgs.popupClose + "</wmgPlayerJSTest_>";

    let str = " <wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-container'></wmgPlayerJSTest_>" +
    " <wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup " + popupType + "'> " +
    "   <wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-wrapper'>" +
    "	" + closeButton + "	" +
    "	   <wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon-wrapper'><wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon'>" + popupHeaderIcon + "</wmgPlayerJSTest_></wmgPlayerJSTest_>" +
    "   </wmgPlayerJSTest_>" +
    "	<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-content-wrapper mgPlayerJSTest_font-size-17'>" + rootScope.labels.deleteFolder + ": <b>" + label.name + "</b></wmgPlayerJSTest_>" +
    "   <wmgPlayerJSTest_ class='mgPlayerJSTest_popup-content-info'>" + label.msg + "</wmgPlayerJSTest_>" +
    "	<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-btn-wrapper'>" +
    "		<wmgPlayerJSTest_ id='mgPlayerJSTest_btn-ok-cat-del-popup' class='ege-ok-btn mgPlayerJSTest_btn-default mgPlayerJSTest_btn-large mgPlayerJSTest_ege-inline-block-vt'>" + okBtn + "</wmgPlayerJSTest_>" +
    "	</wmgPlayerJSTest_>" +
    " </wmgPlayerJSTest_> ";

    mg$('.mgPlayerJSTest_ege-panel').append(str);

    modal.attachPopupActions(onOk, onCancel, false);
};

modal.openJsonEdit = function(data, type, onOk, onCancel) {
    let okBtn = "Save";
    let cancelBtn = "Cancel";
    let popupType = 'mgPlayerJSTest_popup-warning';

    let str = "<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup " + popupType + "'> " +
    "	<pre id='mgPlayerJSTest_json-editor'></pre>" +
    "	<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-btn-wrapper'>" +
    "		<wmgPlayerJSTest_ id='mgPlayerJSTest_btn-ok-json-edit-popup' class='ege-ok-json-update mgPlayerJSTest_btn-default mgPlayerJSTest_ege-inline-block-vt'>" + okBtn + "</wmgPlayerJSTest_>" +
    "       <wmgPlayerJSTest_ id='mgPlayerJSTest_btn-cancel-json-edit-popup' class='ege-cancel-btn mgPlayerJSTest_btn-default mgPlayerJSTest_ege-inline-block-vt'>" + cancelBtn + "</wmgPlayerJSTest_>" +
    "	</wmgPlayerJSTest_>" +
    " </wmgPlayerJSTest_> ";

    mg$('.mgPlayerJSTest_ege-panel').append(str);

    modal.attachPopupActions(onOk, onCancel, false);
};

modal.openGuideLink = function(label, type, onOk, onCancel) {
    rootScope.step = {};
    let tourData = label.data;
    Gm.loading.set(true);
    let data = {
        tour_id: tourData.tour.tour_id,
        step_title: '',
        step_description: '',
        step_type: 'guide',
        step_target_type: 'na',
        step_target_name: 'na',
        step_settings: 'na',
        step_image: "0",
        step_screen: "0",
        step_url: 'na',
        step_audio_text: 'na',
        step_video_id: "0",
        step_audio: "0",
        step_order: parseInt(tourData.order)
    };
    rootScope.step = data;
    let self = modal;
    let cancelBtn = "";

    setTimeout(function() {
        Gm.loading.set(false);
    }, 200);

    let params = {
        category_id: tourData.tour.category_id,
        limit: 100,
        offset: 0
    };

    let str = " <wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-container'></wmgPlayerJSTest_>";

    function cb(_tours) {

        let option = '';
        _tours.forEach(function(value, key) {
            if (value.tour_id !== tourData.tour.tour_id &&
        parseInt(value.step_count) > 0 &&
        value.tour_type === tourData.tour_type) {

                option += '<option value="' + value.tour_id +
          '" data-category_id="' + value.category_id +
          '"  data-description="' + value.tour_description +
          '" data-image="' + value.tour_image +
          '" data-screenImage="' + value.tour_image + '">' +
          value.tour_title +
          '</option>';
            }
        });
        str += " <wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-link-guide'> " +
      "	<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-header'>" + rootScope.labels.guideLinkMessage + "</wmgPlayerJSTest_>" +
      "	<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-close'>" +
      '<svg version="1.1" id="Capa_1" x="0px" y="0px"' +
      'viewBox="0 0 50 50" style="enable-background:new 0 0 50 50;" xml:space="preserve">' +
      '<g>' +
      '<g>' +
      '<path d="M46,4C44.9,3,43.2,3,42.1,4L25,21.2L7.9,4C6.8,3,5.1,3,4,4S3,6.8,4,7.9L21.2,25L4,42.1C3,43.2,3,44.9,4,46' +
      'c0.5,0.5,1.2,0.8,1.9,0.8s1.4-0.3,1.9-0.8L25,28.8L42.1,46c0.5,0.5,1.2,0.8,1.9,0.8c0.7,0,1.4-0.3,1.9-0.8c1.1-1.1,1.1-2.8,0-3.8' +
      'L28.8,25L46,7.9C47,6.8,47,5.1,46,4z"/>' +
      '</g>' +
      '</g>' +
      '</svg>' +
      "	</wmgPlayerJSTest_>" +
      "	<wmgPlayerJSTest_ class='mgPlayerJSTest_selectbox-wrapper'>" +
      "      	<select class='mgPlayerJSTest_create-step-selectbox-select' id='ruleTypeGuide'>" +
      "      		<option value=''>" + rootScope.labels.select + "</option>" +
      "     		" + option + " " +
      "     	</select>" +
      "	</wmgPlayerJSTest_>" +
      "	<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-error-msg'>" + rootScope.labels.selectGuideBeforeSubmit + "</wmgPlayerJSTest_>" +
      "	<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-btn-wrapper'>" +
      "       <wmgPlayerJSTest_ class='mgPlayerJSTest_btn-default mgPlayerJSTest_ege-inline-block-vt'>" + rootScope.labels.btnLink + "</wmgPlayerJSTest_>" +
      "       <wmgPlayerJSTest_ class='mgPlayerJSTest_btn-default mgPlayerJSTest_btn-neutral mgPlayerJSTest_ege-inline-block-vt'>" + rootScope.labels.btnCancel + "</wmgPlayerJSTest_>" +
      "	</wmgPlayerJSTest_>" +
      " </wmgPlayerJSTest_> ";
        mg$('.mgPlayerJSTest_ege-panel').append(str);

        self.attachPopupActions(onOk, cancelBtn, onCancel);
    }

    api.getTourList(params, cb);
};

modal.openDoItPopup = function(onOk, modalTitle) {

    let closeButton = "<wmgPlayerJSTest_ class='mgPlayerJSTest_popup-btn-close ege-cancel-btn'>" + rootScope.svgs.popupClose + "</wmgPlayerJSTest_>";
    let modalTitleEle = '';

    if (GmCXt.isDefined(modalTitle)) {
        modalTitleEle = "<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-title-wrapper'>" + modalTitle + "</wmgPlayerJSTest_>";
    }

    let str = " <wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-container'></wmgPlayerJSTest_>" +
    "	<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup mgPlayerJSTest_popup-info'> " +
    "   	<wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-wrapper'>" +
    "		" + closeButton + "	" +
    "	  	 	<wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon-wrapper'><wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon'>" + rootScope.svgs.popupInfo + "</wmgPlayerJSTest_></wmgPlayerJSTest_>" +
    "   	</wmgPlayerJSTest_>" +
    modalTitleEle +
    "		<wmgPlayerJSTest_ class='mgPlayerJSTest_image-file-input-wrapper'>" +
    "			<input id='mgPlayerJSTest_input-csv' title='Upload CSV' type='file' tabindex='-1' name='inputData' accept='.csv'>" +
    "		</wmgPlayerJSTest_> " +
    "		<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-btn-wrapper'>" +
    "			<wmgPlayerJSTest_ id='mgPlayerJSTest_btn-ok-doit-popup' class='ege-csv-ok-btn mgPlayerJSTest_btn-default mgPlayerJSTest_btn-large mgPlayerJSTest_ege-inline-block-vt'>" + rootScope.labels.ok + "</wmgPlayerJSTest_>" +
    "		</wmgPlayerJSTest_>" +
    " 	</wmgPlayerJSTest_> ";

    mg$('.mgPlayerJSTest_ege-panel').append(str);

    modal.attachPopupActions(onOk);
};

function close() {
    mg$('.mgPlayerJSTest_overlay-container').remove();
    mg$('.mgPlayerJSTest_ege-popup').remove();
    mg$('.mgPlayerJSTest_ege-popup-link-guide').remove();
    mg$('.mgPlayerJSTest_category-delete-popup').remove();
}

modal.close = function() {
    close();
};

function getDefaultScheduleOptions() {
    let obj = {};
    let currDate = new Date();
    let month = currDate.getMonth() + 1;
    if (month < 10) {
        month = '0' + month;
    }
    let day = currDate.getDate();
    let year = currDate.getFullYear();

    day = (currDate.getDate() > 9) ? currDate.getDate() : "0" + currDate.getDate();
    let hrs = (currDate.getHours() > 9) ? currDate.getHours() : "0" + currDate.getHours();
    let mins = (currDate.getMinutes() > 9) ? currDate.getMinutes() : "0" + currDate.getMinutes();

    let minDateRange = year + '-' + month + '-' + day; //new Date().toISOString().slice(0, 16); //new Date().toISOString().split('T')[0];
    let minTimeRange = hrs + ':' + mins;

    obj.default_date = minDateRange;
    obj.default_time = minTimeRange;


    return obj;
}

function getSchedulePubHTML() {
    let option = getDefaultScheduleOptions();
    let html = "";
    html = "<wmgPlayerJSTest_ class='mgPlayerJSTest_pub-schedule-checkbox-container mgPlayerJSTest_process-msg mgPlayerJSTest_width-100 mgPlayerJSTest_text-align-center mgPlayerJSTest_padding-lr-15'>" +
    "<input id='mgPlayerJSTest_checkbox-tour-schedule-pub' class='mgPlayerJSTest_inline-block-vm mgPlayerJSTest_input-checkbox-custom' type='checkbox' name='pub-schedule-enable'>" +
    "<label class='mgPlayerJSTest_inline-block-vm'>" + rootScope.labels.schedulePublishCheckbox + "</label>" +
    "</wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_pub-date-container'>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_pub-date-label'> " + rootScope.labels.date +
    "</wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_>" +
    "<input min='" + option.default_date + "' type='date' id='mgPlayerJSTest_pub-schedule-date' name='mgPlayerJSTest_pub-schedule-date' value='" + option.default_date + "'  class='mgPlayerJSTest_input-text mgPlayerJSTest_input-type-text'>" +
    "</wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_pub-date-label'> " + rootScope.labels.time +
    "</wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_>" +
    "<input min='" + option.default_time + "' type='time' id='mgPlayerJSTest_pub-schedule-time' name='mgPlayerJSTest_pub-schedule-date' value='" + option.default_time + "'  class='mgPlayerJSTest_input-text mgPlayerJSTest_input-type-text'>" +
    "</wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_invalid-pub-time mgPlayerJSTest_error-input-wrapper'> " + rootScope.labels.invalidTimeLabel + " </wmgPlayerJSTest_>" +
    "</wmgPlayerJSTest_>";

    return html;
}

function checkTimeValidity() {
    let selectedDate = mg$('#mgPlayerJSTest_pub-schedule-date').val() + "T" + mg$('#mgPlayerJSTest_pub-schedule-time').val();
    if (Date.parse(selectedDate) < Date.now()) {
        mg$(".mgPlayerJSTest_invalid-pub-time").show();
    } else {
        mg$(".mgPlayerJSTest_invalid-pub-time").hide();
    }
}

modal.publishNoEnv = function(tour, onOk, modalTitle) {

    rootScope.guideEnvs = tour.tour_settings.app_publish_env;

    rootScope.guideEnvs || [];

    if (rootScope.guideEnvs === undefined && tour.is_published) {
        rootScope.appEnvs;
    }

    if (!tour.is_published) {
        localStorage.getItem(GmCXt.prevEnv);
    }

    rootScope.appEnvs;

    let closeButton = "<wmgPlayerJSTest_ class='mgPlayerJSTest_popup-btn-close ege-cancel-btn'>" + rootScope.svgs.popupClose + "</wmgPlayerJSTest_>";
    let modalTitleEle = '';

    if (GmCXt.isDefined(modalTitle)) {
        modalTitleEle = "<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-title-wrapper'>" + modalTitle + "</wmgPlayerJSTest_>";
    }

    let str = " <wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-container'></wmgPlayerJSTest_>" +
    " <wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup mgPlayerJSTest_popup-info'> " +
    "   <wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-wrapper'>" +
    "	" + closeButton + "	" +
    "	   <wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon-wrapper'><wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon'>" + rootScope.svgs.popupInfo + "</wmgPlayerJSTest_></wmgPlayerJSTest_>" +
    "   </wmgPlayerJSTest_>" +
    modalTitleEle +
    getSchedulePubHTML() +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-btn-wrapper'>" +
    "<button id='mgPlayerJSTest_btn-ok-publish-popup' class='ege-publish mgPlayerJSTest_btn-default mgPlayerJSTest_btn-large mgPlayerJSTest_ege-inline-block-vt'>" + rootScope.labels.publish + "</button>" +
    "</wmgPlayerJSTest_>" +
    "</wmgPlayerJSTest_> ";

    mg$('.mgPlayerJSTest_ege-panel').append(str);



    mg$(".mgPlayerJSTest_pub-schedule-checkbox-container").show();



    mg$('#mgPlayerJSTest_pub-schedule-date').change(function(e) {
        checkTimeValidity();
    });

    mg$('#mgPlayerJSTest_pub-schedule-time').change(function(e) {
        checkTimeValidity();
    });

    mg$('#mgPlayerJSTest_checkbox-tour-schedule-pub').off('click').on('click', function() {
        if (mg$("#mgPlayerJSTest_checkbox-tour-schedule-pub").is(":checked")) {
            mg$(".mgPlayerJSTest_pub-date-container").show();
        } else {
            mg$(".mgPlayerJSTest_pub-date-container").hide();
        }
    });


    mg$('#mgPlayerJSTest_btn-ok-publish-popup').off('click').on('click', function() {
        onOk();
        close();
    });


    mg$('.mgPlayerJSTest_popup-btn-close').off('click').on('click', function(e) {
        close();
    });


    Gm.loading.set(false);
};

modal.publish = function(tour, onOk, modalTitle) {

    rootScope.guideEnvs = tour.tour_settings.app_publish_env;

    let envNames = rootScope.guideEnvs || [];

    if (rootScope.guideEnvs === undefined && tour.is_published) {
        envNames = rootScope.appEnvs;
    }

    if (!tour.is_published) {
        envNames = localStorage.getItem(GmCXt.prevEnv);
    }

    let envs = rootScope.appEnvs;
    let arrOfEnv = [];

    let closeButton = "<wmgPlayerJSTest_ class='mgPlayerJSTest_popup-btn-close ege-cancel-btn'>" + rootScope.svgs.popupClose + "</wmgPlayerJSTest_>";

    arrOfEnv.push('<wmgPlayerJSTest_ class="mgPlayerJSTest_guide-progress-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-flex-end">' +
    '<wmgPlayerJSTest_ id=' + envs[0] + ' class="mgPlayerJSTest_guide-progress-val">' +
    '<wmgPlayerJSTest_ class="mgPlayerJSTest_guide-progress-label mgPlayerJSTest_text-align-center mgPlayerJSTest_font-size-13">' +
    rootScope.updateEnvNames(envs[0]) +
    '</wmgPlayerJSTest_>' +
    '</wmgPlayerJSTest_>' +
    '</wmgPlayerJSTest_> ');

    for (i = 1; i < envs.length; i++) {
        arrOfEnv.push("<wmgPlayerJSTest_ class='mgPlayerJSTest_hr'></wmgPlayerJSTest_>" + '<wmgPlayerJSTest_ class="mgPlayerJSTest_guide-progress-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-flex-end mgPlayerJSTest_ele-width">' +
      '<wmgPlayerJSTest_ id=' + envs[i] + ' class="mgPlayerJSTest_guide-progress-val">' +
      '<wmgPlayerJSTest_ class="mgPlayerJSTest_guide-progress-label mgPlayerJSTest_text-align-center mgPlayerJSTest_font-size-13">' +
      rootScope.updateEnvNames(envs[i]) +
      '</wmgPlayerJSTest_>' +
      '</wmgPlayerJSTest_>' +
      '</wmgPlayerJSTest_> ');

    }

    let msg = '';
    let modalTitleEle = '';

    if (GmCXt.isDefined(modalTitle)) {
        modalTitleEle = "<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-title-wrapper'>" + modalTitle + "</wmgPlayerJSTest_>";
    }

    let str = " <wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-container'></wmgPlayerJSTest_>" +
    " <wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup mgPlayerJSTest_popup-info'> " +
    "   <wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-wrapper'>" +
    "	" + closeButton + "	" +
    "	   <wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon-wrapper'><wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon'>" + rootScope.svgs.popupInfo + "</wmgPlayerJSTest_></wmgPlayerJSTest_>" +
    "   </wmgPlayerJSTest_>" +
    modalTitleEle +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_guide-progress-container mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-start mgPlayerJSTest_justify-content-center'>" +
    arrOfEnv.join('') +
    "</wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_process-msg mgPlayerJSTest_width-100 mgPlayerJSTest_text-align-center mgPlayerJSTest_padding-lr-15' id='publishMsg'>" + msg + "</wmgPlayerJSTest_>" +
    getSchedulePubHTML() +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-btn-wrapper'>" +
    "<button id='mgPlayerJSTest_btn-ok-publish-popup' class='ege-publish mgPlayerJSTest_btn-default mgPlayerJSTest_btn-large mgPlayerJSTest_ege-inline-block-vt mgPlayerJSTest_disabled'>" + rootScope.labels.publish + "</button>" +
    "</wmgPlayerJSTest_>" +
    "</wmgPlayerJSTest_> ";

    mg$('.mgPlayerJSTest_ege-panel').append(str);



    for (var i = 0; i < envs.length; i++) {
        if (envNames.indexOf(envs[i]) !== -1) {
            mg$('.ege-publish').removeClass("mgPlayerJSTest_disabled");
            mg$('#' + envs[i]).addClass('mgPlayerJSTest_active-progress');
            for (let j = i - 1; j >= 0; j--) {
                mg$('.ege-publish').removeClass("mgPlayerJSTest_disabled");
                mg$('#' + envs[j]).addClass('mgPlayerJSTest_active-progress');
            }
        }
    }

    for (var i = 0; i < envNames.length; i++) {
        if (rootScope.appEnvs.indexOf(envNames[i]) !== -1) {
            let en = rootScope.updateEnvNames(envNames[i]);

            if (!msg) {
                msg = rootScope.labels.guideIsPubIn + en;
            } else {
                msg += ", " + en;
            }
        }
    }

    if (msg) {
        mg$('#publishMsg').text(msg);
    }

    let activeEnv = envNames;

    if (typeof envNames === 'string') {
        activeEnv = envNames.split(',');
    }

    if (activeEnv.length === envs.length) {
        mg$(".mgPlayerJSTest_pub-schedule-checkbox-container").show();
    } else {
        mg$(".mgPlayerJSTest_pub-schedule-checkbox-container").hide();
    }

    mg$('#mgPlayerJSTest_pub-schedule-date').change(function(e) {
        checkTimeValidity();
    });

    mg$('#mgPlayerJSTest_pub-schedule-time').change(function(e) {
        checkTimeValidity();
    });

    mg$('#mgPlayerJSTest_checkbox-tour-schedule-pub').off('click').on('click', function() {
        if (mg$("#mgPlayerJSTest_checkbox-tour-schedule-pub").is(":checked")) {
            mg$(".mgPlayerJSTest_pub-date-container").show();
        } else {
            mg$(".mgPlayerJSTest_pub-date-container").hide();
        }
    });


    Gm.loading.set(false);

    if(isPublishedOnTopEnv()){
        mg$('.ege-publish').addClass("mgPlayerJSTest_disabled");
    }

    modal.addPublishActions(onOk);
};

modal.scheduled = function(tour, onOk, modalTitle) {

    rootScope.guideEnvs = tour.tour_settings.app_publish_env;

    rootScope.guideEnvs || [];

    if (rootScope.guideEnvs === undefined && tour.is_published) {
        rootScope.appEnvs;
    }

    if (!tour.is_published) {
        localStorage.getItem(GmCXt.prevEnv);
    }

    let envs = rootScope.appEnvs;

    let closeButton = "<wmgPlayerJSTest_ class='mgPlayerJSTest_popup-btn-close ege-cancel-btn'>" + rootScope.svgs.popupClose + "</wmgPlayerJSTest_>";

    let date = new Date(tour.tour_settings.visibilitytimestamp);

    let month = date.getMonth() + 1;
    if (month < 10) {
        month = '0' + month;
    }
    let day = date.getDate();
    let year = date.getFullYear();

    (date.getHours() > 10) ? date.getHours() : "0" + date.getHours();
    (date.getMinutes() > 10) ? date.getMinutes() : "0" + date.getMinutes();

    let schDate = day + '/' + month + '/' + year; //new Date().toISOString().slice(0, 16); //new Date().toISOString().split('T')[0];
    let schTime = date.toLocaleString('en-US', {
        hour: 'numeric',
        minute: 'numeric',
        hour12: true
    });

    let modalTitleEle = '';

    if (GmCXt.isDefined(modalTitle)) {
        modalTitleEle = "<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup-title-wrapper'>" + modalTitle + "</wmgPlayerJSTest_>";
    }



    let str = " <wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-container'></wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-popup mgPlayerJSTest_popup-info'> " +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-wrapper'>" + closeButton +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon-wrapper'><wmgPlayerJSTest_ class='mgPlayerJSTest_popup-header-icon'>" + rootScope.svgs.popupInfo + "</wmgPlayerJSTest_></wmgPlayerJSTest_>" +
    "</wmgPlayerJSTest_>" +
    modalTitleEle +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_schedule-popup-container'>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_schedule-popup-container-inner'>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_schedule-popup-header-title'>" + rootScope.updateEnvNames(envs[envs.length - 1]) +
    "</wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_padding-10'>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_padding-5 mgPlayerJSTest_display-inline-block'>" + rootScope.labels.scheduleDateLabel +
    "</wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_padding-5 mgPlayerJSTest_display-inline-block mgPlayerJSTest_float-right'>" + schDate +
    "</wmgPlayerJSTest_>" +
    "</wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_hr'></wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_padding-10'>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_padding-5 mgPlayerJSTest_display-inline-block'>" + rootScope.labels.scheduleTimeLabel +
    "</wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_padding-5 mgPlayerJSTest_display-inline-block mgPlayerJSTest_float-right'>" + schTime +
    "</wmgPlayerJSTest_>" +
    "</wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_hr'></wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_padding-10'>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_padding-5 mgPlayerJSTest_display-inline-block'>" + rootScope.labels.status +
    "</wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_padding-5 mgPlayerJSTest_display-inline-block mgPlayerJSTest_float-right'> " + rootScope.labels.scheduleLabel +
    "</wmgPlayerJSTest_>" +
    "</wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_hr'></wmgPlayerJSTest_>" +
    "<wmgPlayerJSTest_ class='mgPlayerJSTest_cancel-schedule'>" +
    "<button type='button' class='mgPlayerJSTest_cancel-schedule-btn mgPlayerJSTest_lbl-btn'>" + rootScope.labels.cancelSchedule + "</button>" +
    "</wmgPlayerJSTest_>" +
    "</wmgPlayerJSTest_>" +
    "</wmgPlayerJSTest_>" +
    "</wmgPlayerJSTest_>";

    mg$('.mgPlayerJSTest_ege-panel').append(str);


    mg$('.mgPlayerJSTest_cancel-schedule-btn').off('click').on('click', function(e) {
        rootScope.changeStatus(tour, 'unpublish');
        close();
    });

    mg$('.mgPlayerJSTest_popup-btn-close').off('click').on('click', function(e) {
        close();
    });

    Gm.loading.set(false);
};


function isPublishedOnTopEnv(){
    if(rootScope.guideEnvs && mg$('.mgPlayerJSTest_active-progress').length === rootScope.guideEnvs.length){
        return true;
    } 
    else {
        return false;
    } 
}

/* src/components/SignIn.svelte generated by Svelte v4.2.20 */

function get_each_context$a(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[53] = list[i];
	return child_ctx;
}

// (332:0) {#if showLoginForm && !showOrgList}
function create_if_block_8$c(ctx) {
	let wmgPlayerJSTest_1;
	let t0;
	let wmgPlayerJSTest_0;
	let form;
	let h2;
	let t1_value = /*rootScope*/ ctx[0].brandName + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*showCredError*/ ctx[17] && create_if_block_12$8(ctx);
	let if_block1 = /*rootScope*/ ctx[0].appConfig.login.guideme === 1 && create_if_block_10$a(ctx);
	let if_block2 = /*rootScope*/ ctx[0].appConfig.login.SSO === 1 && create_if_block_9$b(ctx);

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			form = element("form");
			h2 = element("h2");
			t1 = text(t1_value);
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			attr(h2, "class", "mgPlayerJSTest_font-size-26 mgPlayerJSTest_text-align-center mgPlayerJSTest_margin-30");
			attr(form, "name", "form.signin");
			attr(form, "method", "post");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_signin-page-wrapper");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_ege-panel-main-container mgPlayerJSTest_signin-page-container mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y mgPlayerJSTest_no-padding");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, form);
			append(form, h2);
			append(h2, t1);
			append(form, t2);
			if (if_block1) if_block1.m(form, null);
			append(form, t3);
			if (if_block2) if_block2.m(form, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*showCredError*/ ctx[17]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_12$8(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_1, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if ((!current || dirty[0] & /*rootScope*/ 1) && t1_value !== (t1_value = /*rootScope*/ ctx[0].brandName + "")) set_data(t1, t1_value);

			if (/*rootScope*/ ctx[0].appConfig.login.guideme === 1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*rootScope*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_10$a(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(form, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*rootScope*/ ctx[0].appConfig.login.SSO === 1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_9$b(ctx);
					if_block2.c();
					if_block2.m(form, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};
}

// (334:2) {#if showCredError}
function create_if_block_12$8(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t_value = /*rootScope*/ ctx[0].labels.invalidLoginCred + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_invalid-log-error-wrapper mgPlayerJSTest_font-size-14 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_width-100 mgPlayerJSTest_text-align-center mgPlayerJSTest_margin-tb-15");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.invalidLoginCred + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}
		}
	};
}

// (348:4) {#if rootScope.appConfig.login.guideme === 1}
function create_if_block_10$a(ctx) {
	let wmgPlayerJSTest_11;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.placeholderEmail + "";
	let t0;
	let t1;
	let input0;
	let input0_placeholder_value;
	let t2;
	let wmgPlayerJSTest_1;
	let t3_value = /*rootScope*/ ctx[0].labels.emailError + "";
	let t3;
	let t4;
	let wmgPlayerJSTest_5;
	let wmgPlayerJSTest_3;
	let t5_value = /*rootScope*/ ctx[0].labels.placeholderPassword + "";
	let t5;
	let t6;
	let input1;
	let input1_placeholder_value;
	let t7;
	let wmgPlayerJSTest_4;
	let t8_value = /*rootScope*/ ctx[0].labels.passwordError + "";
	let t8;
	let t9;
	let t10;
	let wmgPlayerJSTest_7;
	let t11;
	let wmgPlayerJSTest_8;
	let button0;
	let t12_value = /*rootScope*/ ctx[0].labels.loginTitle + "";
	let t12;
	let t13;
	let wmgPlayerJSTest_9;
	let button1;
	let t14_value = /*rootScope*/ ctx[0].labels.forgotPass + "";
	let t14;
	let t15;
	let wmgPlayerJSTest_10;
	let current;
	let mounted;
	let dispose;
	let if_block = !/*rootScope*/ ctx[0].config.hideCaptcha && create_if_block_11$a(ctx);

	return {
		c() {
			wmgPlayerJSTest_11 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			input0 = element("input");
			t2 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t3 = text(t3_value);
			t4 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t5 = text(t5_value);
			t6 = space();
			input1 = element("input");
			t7 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			t8 = text(t8_value);
			t9 = space();
			if (if_block) if_block.c();
			t10 = space();
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			t11 = space();
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			button0 = element("button");
			t12 = text(t12_value);
			t13 = space();
			wmgPlayerJSTest_9 = element("wmgPlayerJSTest_");
			button1 = element("button");
			t14 = text(t14_value);
			t15 = space();
			wmgPlayerJSTest_10 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "id", "mgPlayerJSTest_input-login-email-label");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_text-align-left mgPlayerJSTest_login-field-label");
			attr(input0, "id", "mgPlayerJSTest_input-login-email");
			attr(input0, "class", "mgPlayerJSTest_input-type-text mgPlayerJSTest_font-size-16 mgPlayerJSTest_inline-block-vm");
			attr(input0, "maxlength", "50");
			attr(input0, "spellcheck", "true");
			attr(input0, "type", "email");
			attr(input0, "placeholder", input0_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderEmail);
			attr(input0, "aria-describedby", "mgPlayerJSTest_input-login-email-err");
			attr(input0, "aria-labelledby", "mgPlayerJSTest_input-login-email-label");
			attr(input0, "autocomplete", "email");
			attr(input0, "aria-label", "Email ID");
			input0.required = true;
			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_input-login-email-err");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_error-input-wrapper emailid-error-wrapper");
			toggle_class(wmgPlayerJSTest_1, "active", /*showEmailError*/ ctx[3]);
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_input-email-wrapper mgPlayerJSTest_margin-tb-10");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_text-align-left mgPlayerJSTest_login-field-label");
			attr(input1, "id", "mgPlayerJSTest_input-login-pass");
			attr(input1, "autocomplete", "off");
			attr(input1, "class", "mgPlayerJSTest_input-type-text mgPlayerJSTest_font-size-16 mgPlayerJSTest_ege-inline-block-vm");
			attr(input1, "minlength", "6");
			attr(input1, "maxlength", "20");
			attr(input1, "spellcheck", "true");
			attr(input1, "type", "password");
			attr(input1, "placeholder", input1_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderPassword);
			attr(input1, "name", "password");
			input1.required = true;
			attr(input1, "aria-describedby", "mgPlayerJSTest_input-login-pass-err");
			attr(input1, "aria-label", "Password");
			attr(wmgPlayerJSTest_4, "id", "mgPlayerJSTest_input-login-pass-err");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_error-input-wrapper password-error-wrapper");
			toggle_class(wmgPlayerJSTest_4, "active", /*showPassError*/ ctx[4]);
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_input-password-wrapper mgPlayerJSTest_margin-tb-10");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_signin-form-input");
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_clear");
			attr(button0, "id", "mgPlayerJSTest_btn-login-title");
			attr(button0, "class", "mgPlayerJSTest_btn-default mgPlayerJSTest_font-size-15");
			attr(button0, "aria-label", "Login");
			attr(button0, "type", "button");
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_btn-login-wrapper mgPlayerJSTest_text-align-center");
			attr(button1, "id", "mgPlayerJSTest_label-login-forgot-pass");
			attr(button1, "type", "button");
			attr(button1, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_options-label mgPlayerJSTest_text-align-center mgPlayerJSTest_cursor-pointer mgPlayerJSTest_inline-block-vm mgPlayerJSTest_font-weight-550");
			attr(wmgPlayerJSTest_9, "class", "mgPlayerJSTest_float-right mgPlayerJSTest_options-wrapper mgPlayerJSTest_single-option-wrapper");
			attr(wmgPlayerJSTest_10, "class", "mgPlayerJSTest_clear");
			attr(wmgPlayerJSTest_11, "class", "mgPlayerJSTest_signin-form-container");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_11, anchor);
			append(wmgPlayerJSTest_11, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_2, t1);
			append(wmgPlayerJSTest_2, input0);
			set_input_value(input0, /*email*/ ctx[1]);
			/*input0_binding*/ ctx[30](input0);
			append(wmgPlayerJSTest_2, t2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t3);
			append(wmgPlayerJSTest_6, t4);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, t5);
			append(wmgPlayerJSTest_5, t6);
			append(wmgPlayerJSTest_5, input1);
			set_input_value(input1, /*pwd*/ ctx[2]);
			/*input1_binding*/ ctx[32](input1);
			append(wmgPlayerJSTest_5, t7);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, t8);
			append(wmgPlayerJSTest_6, t9);
			if (if_block) if_block.m(wmgPlayerJSTest_6, null);
			append(wmgPlayerJSTest_11, t10);
			append(wmgPlayerJSTest_11, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_11, t11);
			append(wmgPlayerJSTest_11, wmgPlayerJSTest_8);
			append(wmgPlayerJSTest_8, button0);
			append(button0, t12);
			append(wmgPlayerJSTest_11, t13);
			append(wmgPlayerJSTest_11, wmgPlayerJSTest_9);
			append(wmgPlayerJSTest_9, button1);
			append(button1, t14);
			append(wmgPlayerJSTest_11, t15);
			append(wmgPlayerJSTest_11, wmgPlayerJSTest_10);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input0, "input", /*input0_input_handler*/ ctx[29]),
					listen(input1, "input", /*input1_input_handler*/ ctx[31]),
					listen(button0, "click", /*onClickSignin*/ ctx[22]),
					listen(button1, "click", /*goToForgotPwd*/ ctx[23])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*rootScope*/ 1) && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.placeholderEmail + "")) set_data(t0, t0_value);

			if (!current || dirty[0] & /*rootScope*/ 1 && input0_placeholder_value !== (input0_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderEmail)) {
				attr(input0, "placeholder", input0_placeholder_value);
			}

			if (dirty[0] & /*email*/ 2 && input0.value !== /*email*/ ctx[1]) {
				set_input_value(input0, /*email*/ ctx[1]);
			}

			if ((!current || dirty[0] & /*rootScope*/ 1) && t3_value !== (t3_value = /*rootScope*/ ctx[0].labels.emailError + "")) set_data(t3, t3_value);

			if (!current || dirty[0] & /*showEmailError*/ 8) {
				toggle_class(wmgPlayerJSTest_1, "active", /*showEmailError*/ ctx[3]);
			}

			if ((!current || dirty[0] & /*rootScope*/ 1) && t5_value !== (t5_value = /*rootScope*/ ctx[0].labels.placeholderPassword + "")) set_data(t5, t5_value);

			if (!current || dirty[0] & /*rootScope*/ 1 && input1_placeholder_value !== (input1_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderPassword)) {
				attr(input1, "placeholder", input1_placeholder_value);
			}

			if (dirty[0] & /*pwd*/ 4 && input1.value !== /*pwd*/ ctx[2]) {
				set_input_value(input1, /*pwd*/ ctx[2]);
			}

			if ((!current || dirty[0] & /*rootScope*/ 1) && t8_value !== (t8_value = /*rootScope*/ ctx[0].labels.passwordError + "")) set_data(t8, t8_value);

			if (!current || dirty[0] & /*showPassError*/ 16) {
				toggle_class(wmgPlayerJSTest_4, "active", /*showPassError*/ ctx[4]);
			}

			if (!/*rootScope*/ ctx[0].config.hideCaptcha) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*rootScope*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_11$a(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(wmgPlayerJSTest_6, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*rootScope*/ 1) && t12_value !== (t12_value = /*rootScope*/ ctx[0].labels.loginTitle + "")) set_data(t12, t12_value);
			if ((!current || dirty[0] & /*rootScope*/ 1) && t14_value !== (t14_value = /*rootScope*/ ctx[0].labels.forgotPass + "")) set_data(t14, t14_value);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_11);
			}

			/*input0_binding*/ ctx[30](null);
			/*input1_binding*/ ctx[32](null);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (406:7) {#if !rootScope.config.hideCaptcha}
function create_if_block_11$a(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.captchaLbl + "";
	let t0;
	let t1;
	let captcha;
	let updating_captchaValid;
	let updating_showCaptchaError;
	let updating_inputCaptchaRef;
	let current;

	function captcha_captchaValid_binding(value) {
		/*captcha_captchaValid_binding*/ ctx[33](value);
	}

	function captcha_showCaptchaError_binding(value) {
		/*captcha_showCaptchaError_binding*/ ctx[34](value);
	}

	function captcha_inputCaptchaRef_binding(value) {
		/*captcha_inputCaptchaRef_binding*/ ctx[35](value);
	}

	let captcha_props = {};

	if (/*validCaptcha*/ ctx[18] !== void 0) {
		captcha_props.captchaValid = /*validCaptcha*/ ctx[18];
	}

	if (/*showCapError*/ ctx[19] !== void 0) {
		captcha_props.showCaptchaError = /*showCapError*/ ctx[19];
	}

	if (/*captchaRef*/ ctx[20] !== void 0) {
		captcha_props.inputCaptchaRef = /*captchaRef*/ ctx[20];
	}

	captcha = new Captcha({ props: captcha_props });
	binding_callbacks.push(() => bind(captcha, 'captchaValid', captcha_captchaValid_binding));
	binding_callbacks.push(() => bind(captcha, 'showCaptchaError', captcha_showCaptchaError_binding));
	binding_callbacks.push(() => bind(captcha, 'inputCaptchaRef', captcha_inputCaptchaRef_binding));

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			create_component(captcha.$$.fragment);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_text-align-left mgPlayerJSTest_login-field-label");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_margin-tb-10");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_1, t1);
			mount_component(captcha, wmgPlayerJSTest_1, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*rootScope*/ 1) && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.captchaLbl + "")) set_data(t0, t0_value);
			const captcha_changes = {};

			if (!updating_captchaValid && dirty[0] & /*validCaptcha*/ 262144) {
				updating_captchaValid = true;
				captcha_changes.captchaValid = /*validCaptcha*/ ctx[18];
				add_flush_callback(() => updating_captchaValid = false);
			}

			if (!updating_showCaptchaError && dirty[0] & /*showCapError*/ 524288) {
				updating_showCaptchaError = true;
				captcha_changes.showCaptchaError = /*showCapError*/ ctx[19];
				add_flush_callback(() => updating_showCaptchaError = false);
			}

			if (!updating_inputCaptchaRef && dirty[0] & /*captchaRef*/ 1048576) {
				updating_inputCaptchaRef = true;
				captcha_changes.inputCaptchaRef = /*captchaRef*/ ctx[20];
				add_flush_callback(() => updating_inputCaptchaRef = false);
			}

			captcha.$set(captcha_changes);
		},
		i(local) {
			if (current) return;
			transition_in(captcha.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(captcha.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			destroy_component(captcha);
		}
	};
}

// (448:4) {#if rootScope.appConfig.login.SSO === 1}
function create_if_block_9$b(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let button;
	let t_value = /*rootScope*/ ctx[0].labels.logInWithSSO + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			button = element("button");
			t = text(t_value);
			attr(button, "type", "button");
			attr(button, "id", "mgPlayerJSTest_label-login-with-sso");
			attr(button, "class", "mgPlayerJSTest_btn-default mgPlayerJSTest_btn-large mgPlayerJSTest_font-size-16 mgPlayerJSTest_text-align-center mgPlayerJSTest_margin-t-50");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_margin-tb-20");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_signin-form-container");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, button);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*ssoLogin*/ ctx[26]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.logInWithSSO + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			mounted = false;
			dispose();
		}
	};
}

// (466:0) {#if showOtpForm && !showOrgList}
function create_if_block_3$g(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let form;
	let h2;
	let t0_value = /*rootScope*/ ctx[0].labels.loginOtpScreenTitle + "";
	let t0;
	let t1;
	let t2;
	let wmgPlayerJSTest_0;
	let if_block = /*rootScope*/ ctx[0].appConfig.login.guideme === 1 && create_if_block_4$f(ctx);

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			form = element("form");
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			attr(h2, "class", "mgPlayerJSTest_font-size-24 mgPlayerJSTest_text-align-center mgPlayerJSTest_margin-25");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_ege-clear");
			attr(form, "name", "form.verifyOtp");
			attr(form, "autocomplete", "off");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_signin-page-wrapper");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_ege-panel-main-container mgPlayerJSTest_signin-page-container mgPlayerJSTest_overflow mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, form);
			append(form, h2);
			append(h2, t0);
			append(form, t1);
			if (if_block) if_block.m(form, null);
			append(form, t2);
			append(form, wmgPlayerJSTest_0);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.loginOtpScreenTitle + "")) set_data(t0, t0_value);

			if (/*rootScope*/ ctx[0].appConfig.login.guideme === 1) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4$f(ctx);
					if_block.c();
					if_block.m(form, t2);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			if (if_block) if_block.d();
		}
	};
}

// (474:4) {#if rootScope.appConfig.login.guideme === 1}
function create_if_block_4$f(ctx) {
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.placeholderOtp + "";
	let t0;
	let t1;
	let input;
	let input_placeholder_value;
	let t2;
	let wmgPlayerJSTest_1;
	let t3_value = /*rootScope*/ ctx[0].labels.otpError + "";
	let t3;
	let wmgPlayerJSTest_1_class_value;
	let t4;
	let wmgPlayerJSTest_4;
	let button;
	let t5_value = /*rootScope*/ ctx[0].labels.btnOtpVerify + "";
	let t5;
	let button_class_value;
	let button_aria_disabled_value;
	let button_aria_label_value;
	let t6;
	let wmgPlayerJSTest_5;
	let t7;
	let t8;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*isDisabled*/ ctx[9]) return create_if_block_7$c;
		return create_else_block$c;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*otpSent*/ ctx[10] && create_if_block_6$d(ctx);
	let if_block2 = /*showLimitWarning*/ ctx[12] && create_if_block_5$e(ctx);

	return {
		c() {
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			input = element("input");
			t2 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t3 = text(t3_value);
			t4 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			button = element("button");
			t5 = text(t5_value);
			t6 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			if_block0.c();
			t7 = space();
			if (if_block1) if_block1.c();
			t8 = space();
			if (if_block2) if_block2.c();
			attr(wmgPlayerJSTest_0, "id", "mgPlayerJSTest_input-otp-label");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_text-align-left mgPlayerJSTest_login-field-label");
			attr(input, "id", "mgPlayerJSTest_input-otp");
			attr(input, "class", "mgPlayerJSTest_input-type-text mgPlayerJSTest_font-size-13 mgPlayerJSTest_inline-block-vm");
			attr(input, "maxlength", "6");
			attr(input, "spellcheck", "true");
			attr(input, "type", "text");
			attr(input, "placeholder", input_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderOtp);
			input.required = true;
			attr(input, "name", "otp");
			attr(input, "pattern", "^[0-9]*$");
			attr(input, "aria-describedby", "mgPlayerJSTest_input-otp-err");
			attr(input, "aria-labelledby", "mgPlayerJSTest_input-otp-label");
			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_input-otp-err");
			attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_error-input-wrapper emailid-error-wrapper " + (/*error*/ ctx[11].otpRequired ? 'active' : ''));
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_input-email-wrapper mgPlayerJSTest_margin-tb-10");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_signin-form-input");
			attr(button, "id", "mgPlayerJSTest_btn-verify-otp");
			attr(button, "class", button_class_value = "mgPlayerJSTest_btn-default mgPlayerJSTest_btn-large mgPlayerJSTest_font-size-16 " + (/*error*/ ctx[11].otpRequired ? 'mgPlayerJSTest_disabled' : ''));
			attr(button, "type", "button");
			attr(button, "aria-disabled", button_aria_disabled_value = /*error*/ ctx[11].otpRequired);
			attr(button, "aria-label", button_aria_label_value = /*rootScope*/ ctx[0].labels.btnOtpVerify);
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_margin-tb-25 mgPlayerJSTest_text-align-center");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_options-wrapper");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_signin-form-container");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_6, anchor);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_2, t1);
			append(wmgPlayerJSTest_2, input);
			set_input_value(input, /*otp*/ ctx[8]);
			append(wmgPlayerJSTest_2, t2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t3);
			append(wmgPlayerJSTest_6, t4);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, button);
			append(button, t5);
			append(wmgPlayerJSTest_6, t6);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			if_block0.m(wmgPlayerJSTest_5, null);
			append(wmgPlayerJSTest_6, t7);
			if (if_block1) if_block1.m(wmgPlayerJSTest_6, null);
			append(wmgPlayerJSTest_6, t8);
			if (if_block2) if_block2.m(wmgPlayerJSTest_6, null);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[36]),
					listen(input, "focus", /*focus_handler*/ ctx[37]),
					listen(button, "click", /*submitOtpForm*/ ctx[21])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.placeholderOtp + "")) set_data(t0, t0_value);

			if (dirty[0] & /*rootScope*/ 1 && input_placeholder_value !== (input_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderOtp)) {
				attr(input, "placeholder", input_placeholder_value);
			}

			if (dirty[0] & /*otp*/ 256 && input.value !== /*otp*/ ctx[8]) {
				set_input_value(input, /*otp*/ ctx[8]);
			}

			if (dirty[0] & /*rootScope*/ 1 && t3_value !== (t3_value = /*rootScope*/ ctx[0].labels.otpError + "")) set_data(t3, t3_value);

			if (dirty[0] & /*error*/ 2048 && wmgPlayerJSTest_1_class_value !== (wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_error-input-wrapper emailid-error-wrapper " + (/*error*/ ctx[11].otpRequired ? 'active' : ''))) {
				attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && t5_value !== (t5_value = /*rootScope*/ ctx[0].labels.btnOtpVerify + "")) set_data(t5, t5_value);

			if (dirty[0] & /*error*/ 2048 && button_class_value !== (button_class_value = "mgPlayerJSTest_btn-default mgPlayerJSTest_btn-large mgPlayerJSTest_font-size-16 " + (/*error*/ ctx[11].otpRequired ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(button, "class", button_class_value);
			}

			if (dirty[0] & /*error*/ 2048 && button_aria_disabled_value !== (button_aria_disabled_value = /*error*/ ctx[11].otpRequired)) {
				attr(button, "aria-disabled", button_aria_disabled_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && button_aria_label_value !== (button_aria_label_value = /*rootScope*/ ctx[0].labels.btnOtpVerify)) {
				attr(button, "aria-label", button_aria_label_value);
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_5, null);
				}
			}

			if (/*otpSent*/ ctx[10]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_6$d(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_6, t8);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*showLimitWarning*/ ctx[12]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_5$e(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_6, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_6);
			}

			if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (525:7) {:else}
function create_else_block$c(ctx) {
	let button0;
	let t0_value = /*rootScope*/ ctx[0].labels.resendOTP + "";
	let t0;
	let button0_aria_label_value;
	let t1;
	let button1;
	let t2_value = /*rootScope*/ ctx[0].labels.backToLogin + "";
	let t2;
	let button1_aria_label_value;
	let mounted;
	let dispose;

	return {
		c() {
			button0 = element("button");
			t0 = text(t0_value);
			t1 = space();
			button1 = element("button");
			t2 = text(t2_value);
			attr(button0, "id", "mgPlayerJSTest_label-resend-otp");
			attr(button0, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_options-label mgPlayerJSTest_text-align-center mgPlayerJSTest_font-size-15 mgPlayerJSTest_cursor-pointer");
			attr(button0, "type", "button");
			attr(button0, "aria-label", button0_aria_label_value = /*rootScope*/ ctx[0].labels.resendOTP);
			attr(button1, "id", "mgPlayerJSTest_label-back-to-login");
			attr(button1, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_options-label mgPlayerJSTest_text-align-center mgPlayerJSTest_back-to-login mgPlayerJSTest_text-align-center mgPlayerJSTest_cursor-pointer mgPlayerJSTest_font-size-15 mgPlayerJSTest_inline-block-vm");
			attr(button1, "aria-label", button1_aria_label_value = /*rootScope*/ ctx[0].labels.backToLogin);
			attr(button1, "type", "button");
		},
		m(target, anchor) {
			insert(target, button0, anchor);
			append(button0, t0);
			insert(target, t1, anchor);
			insert(target, button1, anchor);
			append(button1, t2);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*resendOTP*/ ctx[25]),
					listen(button1, "click", /*backFromOTP*/ ctx[24])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.resendOTP + "")) set_data(t0, t0_value);

			if (dirty[0] & /*rootScope*/ 1 && button0_aria_label_value !== (button0_aria_label_value = /*rootScope*/ ctx[0].labels.resendOTP)) {
				attr(button0, "aria-label", button0_aria_label_value);
			}

			if (dirty[0] & /*rootScope*/ 1 && t2_value !== (t2_value = /*rootScope*/ ctx[0].labels.backToLogin + "")) set_data(t2, t2_value);

			if (dirty[0] & /*rootScope*/ 1 && button1_aria_label_value !== (button1_aria_label_value = /*rootScope*/ ctx[0].labels.backToLogin)) {
				attr(button1, "aria-label", button1_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button0);
				detach(t1);
				detach(button1);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (521:7) {#if isDisabled}
function create_if_block_7$c(ctx) {
	let wmgPlayerJSTest_;
	let t0_value = /*rootScope*/ ctx[0].labels.otpTimer + "";
	let t0;
	let t1;
	let t2_value = /*rootScope*/ ctx[0].labels.seconds + "";
	let t2;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = text(/*otpTimer*/ ctx[7]);
			t2 = text(t2_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_text-align-center mgPlayerJSTest_font-size-13 mgPlayerJSTest_margin-tb-5 mgPlayerJSTest_theme-color");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t0);
			append(wmgPlayerJSTest_, t1);
			append(wmgPlayerJSTest_, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.otpTimer + "")) set_data(t0, t0_value);
			if (dirty[0] & /*otpTimer*/ 128) set_data(t1, /*otpTimer*/ ctx[7]);
			if (dirty[0] & /*rootScope*/ 1 && t2_value !== (t2_value = /*rootScope*/ ctx[0].labels.seconds + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (546:6) {#if otpSent}
function create_if_block_6$d(ctx) {
	let wmgPlayerJSTest_;
	let t_value = /*rootScope*/ ctx[0].labels.otpSent + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_text-align-center mgPlayerJSTest_font-size-13 mgPlayerJSTest_margin-tb-5 mgPlayerJSTest_theme-color");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.otpSent + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (551:6) {#if showLimitWarning}
function create_if_block_5$e(ctx) {
	let wmgPlayerJSTest_;
	let t_value = /*rootScope*/ ctx[0].labels.limitWarning + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_text-align-center mgPlayerJSTest_font-size-13 mgPlayerJSTest_margin-tb-5 mgPlayerJSTest_error-text-color");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.limitWarning + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (563:0) {#if showOrgList}
function create_if_block$l(ctx) {
	let wmgPlayerJSTest_;
	let t;
	let if_block0 = /*rootScope*/ ctx[0].labels.selectOrganization !== undefined && create_if_block_2$i(ctx);
	let if_block1 = /*showOrgList*/ ctx[13] && create_if_block_1$j(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_multiple-org-list-container mgPlayerJSTest_margin-tb-15");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			if (if_block1) if_block1.m(wmgPlayerJSTest_, null);
		},
		p(ctx, dirty) {
			if (/*rootScope*/ ctx[0].labels.selectOrganization !== undefined) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$i(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*showOrgList*/ ctx[13]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$j(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (565:2) {#if rootScope.labels.selectOrganization !== undefined}
function create_if_block_2$i(ctx) {
	let h2;
	let t_value = /*rootScope*/ ctx[0].labels.selectOrganization + "";
	let t;

	return {
		c() {
			h2 = element("h2");
			t = text(t_value);
			attr(h2, "class", "mgPlayerJSTest_font-size-24 mgPlayerJSTest_text-align-center mgPlayerJSTest_margin-25");
		},
		m(target, anchor) {
			insert(target, h2, anchor);
			append(h2, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.selectOrganization + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(h2);
			}
		}
	};
}

// (570:2) {#if showOrgList}
function create_if_block_1$j(ctx) {
	let wmgPlayerJSTest_;
	let each_value = ensure_array_like(/*orgsList*/ ctx[14]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_multiple-org-list-wrapper mgPlayerJSTest_margin-tb-15 mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y mgPlayerJSTest_scrollbar-thin");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(wmgPlayerJSTest_, null);
				}
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*orgsList, signIn*/ 134234112) {
				each_value = ensure_array_like(/*orgsList*/ ctx[14]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$a(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$a(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(wmgPlayerJSTest_, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (572:4) {#each orgsList as org}
function create_each_block$a(ctx) {
	let wmgPlayerJSTest_;
	let button;
	let t0_value = /*org*/ ctx[53].name + "";
	let t0;
	let button_aria_label_value;
	let t1;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[38](/*org*/ ctx[53]);
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = text(t0_value);
			t1 = space();
			attr(button, "class", "mgPlayerJSTest_btn-default");
			attr(button, "aria-label", button_aria_label_value = /*org*/ ctx[53].name);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_margin-tb-25");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, button);
			append(button, t0);
			append(wmgPlayerJSTest_, t1);

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*orgsList*/ 16384 && t0_value !== (t0_value = /*org*/ ctx[53].name + "")) set_data(t0, t0_value);

			if (dirty[0] & /*orgsList*/ 16384 && button_aria_label_value !== (button_aria_label_value = /*org*/ ctx[53].name)) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			dispose();
		}
	};
}

function create_fragment$q(ctx) {
	let header;
	let t0;
	let t1;
	let t2;
	let t3;
	let footer;
	let current;
	header = new Header({});
	let if_block0 = /*showLoginForm*/ ctx[5] && !/*showOrgList*/ ctx[13] && create_if_block_8$c(ctx);
	let if_block1 = /*showOtpForm*/ ctx[6] && !/*showOrgList*/ ctx[13] && create_if_block_3$g(ctx);
	let if_block2 = /*showOrgList*/ ctx[13] && create_if_block$l(ctx);
	footer = new Footer({});

	return {
		c() {
			create_component(header.$$.fragment);
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			create_component(footer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(header, target, anchor);
			insert(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t2, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t3, anchor);
			mount_component(footer, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*showLoginForm*/ ctx[5] && !/*showOrgList*/ ctx[13]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*showLoginForm, showOrgList*/ 8224) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_8$c(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*showOtpForm*/ ctx[6] && !/*showOrgList*/ ctx[13]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$g(ctx);
					if_block1.c();
					if_block1.m(t2.parentNode, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*showOrgList*/ ctx[13]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$l(ctx);
					if_block2.c();
					if_block2.m(t3.parentNode, t3);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(if_block0);
			transition_in(footer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(header.$$.fragment, local);
			transition_out(if_block0);
			transition_out(footer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(t2);
				detach(t3);
			}

			destroy_component(header, detaching);
			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d(detaching);
			if (if_block2) if_block2.d(detaching);
			destroy_component(footer, detaching);
		}
	};
}

function getSignInUser() {
	
}

function isValidOtp(otp) {
	return otp !== '' && otp.length === 6 && (/^[0-9]*$/).test(otp);
}

function instance$p($$self, $$props, $$invalidate) {
	let email = '';
	let pwd = '';
	let showEmailError = false;
	let showPassError = false;
	let showLoginForm = true;
	let showOtpForm = false;
	let otpTimer = 30;
	let otpCounter = 0;
	let otp;
	let isDisabled = false;
	let otpSent = false;
	let error = { otpRequired: false };
	let showLimitWarning = false;
	let dualAuthToken = [];
	let currentUserToken;
	let timeout;
	let otpInterval;
	let showOrgList = false;
	let orgsList;
	rootScope.currentView = 'login-view';
	let inputEmailRef;
	let inputPassRef;

	function getUserToken(userEmail) {
		if (dualAuthToken) {
			for (let i = 0; i < dualAuthToken.length; i++) {
				if (dualAuthToken[i].email === userEmail) {
					let currentTime = new Date().getTime();

					if (currentTime < dualAuthToken[i].expiry) {
						return dualAuthToken[i].token;
					}
				}
			}
		}
	}

	get_store_value(Gm.appList);

	onMount(() => {
	});

	let showCredError = false;

	function onFail() {
		$$invalidate(17, showCredError = true);
		Gm.loading.set(false);
	}

	async function onSuccess(user) {
		Gm.loading.set(false);

		if (typeof user === 'string') {
			addTokenToStorage(user, email);

			//popup for otp code is removed from here for now
			modal.open(rootScope.labels.signInVerifyYourAccount, 'success', function () {
				$$invalidate(5, showLoginForm = false);
				$$invalidate(6, showOtpForm = true);

				setTimeout(
					function () {
						mg$('#mgPlayerJSTest_input-otp').focus();
					},
					500
				);
			});

			mg$('#mgPlayerJSTest_btn-ok-common-popup').focus();
			return true;
		}

		if (user && user.orgs) {
			$$invalidate(13, showOrgList = true);
			$$invalidate(14, orgsList = user.orgs);
			return;
		}

		mg$('#mgPlayerJSTest_btn-verify-otp').addClass('mgPlayerJSTest_disabled');
		rootScope.onUserSignin(user, false);
	}

	let validCaptcha = false;
	let showCapError = false;
	let captchaRef;

	function validateEmail() {
		const pattern = /^[^\s@]+@[^\s@]+\.[^\s@]{2,}$/;
		return email.trim() !== '' && pattern.test(email);
	}

	function submitOtpForm() {
		Gm.loading.set(true);
		let isValid = isValidOtp(otp);

		//validate form
		if (!isValid) {
			Gm.loading.set(false);
			$$invalidate(11, error.otpRequired = true, error);
		} else {
			let data = {
				email, // return;
				code: otp,
				token: currentUserToken
			};

			$$invalidate(10, otpSent = false);
			api.verifyUser(data, onSuccess, onFail);
		}
	}

	function onClickSignin() {
		Gm.loading.set(true);
		$$invalidate(3, showEmailError = false);
		$$invalidate(4, showPassError = false);

		if (!validCaptcha && !GmCXt.conf.hideCaptcha) {
			$$invalidate(19, showCapError = true);
			captchaRef?.focus();
			Gm.loading.set(false);
		}

		if (!validateEmail()) {
			$$invalidate(3, showEmailError = true);
			inputEmailRef?.focus();
			Gm.loading.set(false);
			return;
		}

		let isValidPassword = pwd.length >= 6 && pwd.length <= 20;

		if (!isValidPassword) {
			$$invalidate(4, showPassError = true);
			inputPassRef?.focus();
			Gm.loading.set(false);
		}

		if ((validCaptcha || GmCXt.conf.hideCaptcha) && validateEmail() && isValidPassword) {
			let data = {
				email_id: email,
				password: pwd,
				keep_login: 1
			};

			currentUserToken = getUserToken(email);

			if (currentUserToken) {
				data.token = currentUserToken;
			}

			api.userSignIn(data, onSuccess, onFail);
		}
	}

	function goToForgotPwd() {
		Gm.activeView.set('forgotpwd');
	}

	let setHeight = function () {
		mg$('.mgPlayerJSTest_signin-page-container').css({
			height: window.innerHeight - mg$('#mgPlayerJSTest_ege-header').innerHeight() - mg$('#mgPlayerJSTest_footer-panel-container').innerHeight() - 50
		});

		if (mg$('.mgPlayerJSTest_signin-page-container').innerHeight() < 60) {
			mg$('.mgPlayerJSTest_header-banner-wrapper').hide();
		} else {
			mg$('.mgPlayerJSTest_header-banner-wrapper').removeAttr('style');
		}
	};

	function addTokenToStorage(token, userEmail) {
		let newTokenStatus = true;

		for (let i = 0; i < dualAuthToken.length; i++) {
			if (dualAuthToken[i].email === userEmail) {
				currentUserToken = token;
				dualAuthToken[i].token = token;
				dualAuthToken[i].expiry = new Date().getTime() + rootScope.thirtyDaysInMSeconds;
				newTokenStatus = false;
				break;
			}
		}

		if (newTokenStatus) {
			let tokenData = {};
			tokenData.email = email;
			tokenData.token = token;
			tokenData.expiry = new Date().getTime() + rootScope.thirtyDaysInMSeconds;
			dualAuthToken.push(tokenData);
			currentUserToken = token;
		}

		GmCXt.saveToStorage('dual_auth_token', rootScope.thirtyDaysInSeconds);
	}

	function backFromOTP() {
		$$invalidate(6, showOtpForm = false);
		$$invalidate(5, showLoginForm = true);
		$$invalidate(8, otp = '');
		otpCounter = 0;
		$$invalidate(12, showLimitWarning = false);
		setHeight();
	}

	function resendOTP() {
		$$invalidate(7, otpTimer = 30);
		$$invalidate(9, isDisabled = true);
		otpCounter += 1;

		if (otpCounter > 3) {
			$$invalidate(9, isDisabled = false);
			$$invalidate(12, showLimitWarning = true);

			setTimeout(
				function () {
					otpCounter = 0;
					$$invalidate(12, showLimitWarning = false);
				},
				300000
			);

			return;
		}

		function successCb(token) {
			addTokenToStorage(token, email);
		}

		$$invalidate(10, otpSent = true);
		let data = { email };
		data.token = currentUserToken;
		api.resendOTP(data, successCb);

		// Countdown function for OTP timer
		function decrementOtpTimer() {
			$$invalidate(7, otpTimer--, otpTimer);

			if (otpTimer <= 0) {
				clearInterval(otpInterval);
			}
		}

		// Start OTP interval
		otpInterval = setInterval(decrementOtpTimer, 1000);

		// Timeout to reset states after 30 seconds
		timeout = setTimeout(
			() => {
				$$invalidate(9, isDisabled = false);
				$$invalidate(10, otpSent = false);
				clearInterval(otpInterval);
			},
			30000
		);
	}

	function ssoLogin() {
		$$invalidate(0, rootScope.ssoHitCount = 0, rootScope);

		if (GmCXt.isMyGuide()) {
			rootScope.getSsoId().then(function (response) {
				if (response && response.id) {
					rootScope.openSsoTab();
				}
			}).catch(function () {
				
			});
		} else {
			rootScope.openSsoTab();
		}
	}

	function signIn(orgId) {
		mgError.try(
			function () {
				let data = {
					email_id: email,
					password: pwd,
					keep_login: 1
				};

				if (orgId) {
					data.org_id = orgId;
				}

				currentUserToken = getUserToken(email);

				if (currentUserToken) {
					data.token = currentUserToken;
				}

				api.userSignIn(data, onSuccess, onFail);
			},
			700
		);
	}

	/* set the list hight on window resize */
	const win = mg$(window);

	win.off('resize');
	win.on('resize', setHeight);

	// Clean up on component destruction
	onDestroy(() => {
		clearTimeout(timeout);
		clearInterval(otpInterval);
	});

	setTimeout(
		function () {
			setHeight();
		},
		500
	);

	function input0_input_handler() {
		email = this.value;
		$$invalidate(1, email);
	}

	function input0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEmailRef = $$value;
			$$invalidate(15, inputEmailRef);
		});
	}

	function input1_input_handler() {
		pwd = this.value;
		$$invalidate(2, pwd);
	}

	function input1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputPassRef = $$value;
			$$invalidate(16, inputPassRef);
		});
	}

	function captcha_captchaValid_binding(value) {
		validCaptcha = value;
		$$invalidate(18, validCaptcha);
	}

	function captcha_showCaptchaError_binding(value) {
		showCapError = value;
		$$invalidate(19, showCapError);
	}

	function captcha_inputCaptchaRef_binding(value) {
		captchaRef = value;
		$$invalidate(20, captchaRef);
	}

	function input_input_handler() {
		otp = this.value;
		$$invalidate(8, otp);
	}

	const focus_handler = () => {
		$$invalidate(11, error.otpRequired = false, error);
	};

	const click_handler = org => signIn(org.organization_id);

	return [
		rootScope,
		email,
		pwd,
		showEmailError,
		showPassError,
		showLoginForm,
		showOtpForm,
		otpTimer,
		otp,
		isDisabled,
		otpSent,
		error,
		showLimitWarning,
		showOrgList,
		orgsList,
		inputEmailRef,
		inputPassRef,
		showCredError,
		validCaptcha,
		showCapError,
		captchaRef,
		submitOtpForm,
		onClickSignin,
		goToForgotPwd,
		backFromOTP,
		resendOTP,
		ssoLogin,
		signIn,
		getSignInUser,
		input0_input_handler,
		input0_binding,
		input1_input_handler,
		input1_binding,
		captcha_captchaValid_binding,
		captcha_showCaptchaError_binding,
		captcha_inputCaptchaRef_binding,
		input_input_handler,
		focus_handler,
		click_handler
	];
}

class SignIn extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$p, create_fragment$q, safe_not_equal, { getSignInUser: 28 }, null, [-1, -1]);
	}

	get getSignInUser() {
		return getSignInUser;
	}
}

/* src/components/Empty.svelte generated by Svelte v4.2.20 */

class Empty extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, null, safe_not_equal, {});
	}
}

/* src/components/Search.svelte generated by Svelte v4.2.20 */

function create_fragment$p(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw0_value = /*rootScope*/ ctx[1].svgs.search + "";
	let t0;
	let input;
	let input_class_value;
	let t1;
	let button;
	let raw1_value = /*rootScope*/ ctx[1].svgs.search_close + "";
	let button_class_value;
	let wmgPlayerJSTest_1_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			input = element("input");
			t1 = space();
			button = element("button");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_search-icon mgPlayerJSTest_inline-block-vm");
			attr(input, "id", "mgPlayerJSTest_search-text-input");

			attr(input, "class", input_class_value = "mgPlayerJSTest_search-input mgPlayerJSTest_inline-block-vm mgPlayerJSTest_height-100 ng-pristine ng-untouched ng-valid ng-empty ng-valid-maxlength " + (/*rootScope*/ ctx[1].isMicroPlayer
			? 'mgPlayerJSTest_width-100 mgPlayerJSTest_no-trans'
			: ''));

			attr(input, "maxlength", "100");
			attr(input, "placeholder", /*searchPlaceholderText*/ ctx[4]);
			attr(input, "autocomplete", "off");
			attr(input, "aria-label", /*searchPlaceholderText*/ ctx[4]);
			toggle_class(input, "mgPlayerJSTest_search-input-wd-task", GmCXt.FT.isPlayer && /*isTaskListVisible*/ ctx[3]);
			toggle_class(input, "mgPlayerJSTest_search-input-player", GmCXt.FT.isPlayer && !/*isTaskListVisible*/ ctx[3]);
			toggle_class(input, "mgPlayerJSTest_search-input-active", GmCXt.FT.isPlayer && (/*rootScope*/ ctx[1].currentPageOnly || /*activeSearch*/ ctx[2]));
			toggle_class(input, "mgPlayerJSTest_search-input-creator-active", GmCXt.FT.creatorApp && /*searchTerm*/ ctx[0].length);
			attr(button, "id", "mgPlayerJSTest_icon-search-close-current-page");
			attr(button, "class", button_class_value = "mgPlayerJSTest_search-close-icon mgPlayerJSTest_cursor-pointer mgPlayerJSTest_inline-block-vm mgPlayerJSTest_lbl-btn " + (/*searchTerm*/ ctx[0].length > 0 ? 'mgPlayerJSTest_active' : '') + "");

			attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_search-input-wrapper mgPlayerJSTest_position-relative " + (/*rootScope*/ ctx[1].isMicroPlayer
			? 'mgPlayerJSTest_width-100'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw0_value;
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, input);
			set_input_value(input, /*searchTerm*/ ctx[0]);
			append(wmgPlayerJSTest_1, t1);
			append(wmgPlayerJSTest_1, button);
			button.innerHTML = raw1_value;

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[7]),
					listen(input, "input", /*debouncedSearchGuide*/ ctx[6]),
					listen(button, "click", /*clearSearch*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 2 && raw0_value !== (raw0_value = /*rootScope*/ ctx[1].svgs.search + "")) wmgPlayerJSTest_0.innerHTML = raw0_value;
			if (dirty[0] & /*rootScope*/ 2 && input_class_value !== (input_class_value = "mgPlayerJSTest_search-input mgPlayerJSTest_inline-block-vm mgPlayerJSTest_height-100 ng-pristine ng-untouched ng-valid ng-empty ng-valid-maxlength " + (/*rootScope*/ ctx[1].isMicroPlayer
			? 'mgPlayerJSTest_width-100 mgPlayerJSTest_no-trans'
			: ''))) {
				attr(input, "class", input_class_value);
			}

			if (dirty[0] & /*searchPlaceholderText*/ 16) {
				attr(input, "placeholder", /*searchPlaceholderText*/ ctx[4]);
			}

			if (dirty[0] & /*searchPlaceholderText*/ 16) {
				attr(input, "aria-label", /*searchPlaceholderText*/ ctx[4]);
			}

			if (dirty[0] & /*searchTerm*/ 1 && input.value !== /*searchTerm*/ ctx[0]) {
				set_input_value(input, /*searchTerm*/ ctx[0]);
			}

			if (dirty[0] & /*rootScope, isTaskListVisible*/ 10) {
				toggle_class(input, "mgPlayerJSTest_search-input-wd-task", GmCXt.FT.isPlayer && /*isTaskListVisible*/ ctx[3]);
			}

			if (dirty[0] & /*rootScope, isTaskListVisible*/ 10) {
				toggle_class(input, "mgPlayerJSTest_search-input-player", GmCXt.FT.isPlayer && !/*isTaskListVisible*/ ctx[3]);
			}

			if (dirty[0] & /*rootScope, rootScope, activeSearch*/ 6) {
				toggle_class(input, "mgPlayerJSTest_search-input-active", GmCXt.FT.isPlayer && (/*rootScope*/ ctx[1].currentPageOnly || /*activeSearch*/ ctx[2]));
			}

			if (dirty[0] & /*rootScope, searchTerm*/ 3) {
				toggle_class(input, "mgPlayerJSTest_search-input-creator-active", GmCXt.FT.creatorApp && /*searchTerm*/ ctx[0].length);
			}

			if (dirty[0] & /*rootScope*/ 2 && raw1_value !== (raw1_value = /*rootScope*/ ctx[1].svgs.search_close + "")) button.innerHTML = raw1_value;
			if (dirty[0] & /*searchTerm*/ 1 && button_class_value !== (button_class_value = "mgPlayerJSTest_search-close-icon mgPlayerJSTest_cursor-pointer mgPlayerJSTest_inline-block-vm mgPlayerJSTest_lbl-btn " + (/*searchTerm*/ ctx[0].length > 0 ? 'mgPlayerJSTest_active' : '') + "")) {
				attr(button, "class", button_class_value);
			}

			if (dirty[0] & /*rootScope*/ 2 && wmgPlayerJSTest_1_class_value !== (wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_search-input-wrapper mgPlayerJSTest_position-relative " + (/*rootScope*/ ctx[1].isMicroPlayer
			? 'mgPlayerJSTest_width-100'
			: ''))) {
				attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

let limit$3 = 50;
let offset = 0;

function instance$o($$self, $$props, $$invalidate) {
	let searchTermLower;
	let searchTerm;
	let currentPage;
	let currentPageTours;
	let breadCrumb;
	let activeSearch;
	let isTaskListVisible = false;
	let sortByProperty;
	let searchTours = [];
	let currentSearchTime;
	let toursFetchedInLastApiCall = [];
	let tours = [];
	let lastSearchTime = 0;
	let searchPlaceholderText = '';

	// let filters;
	const currentPageToursSubscriber = Gm.CurrentPageTours.subscribe(value => {
		currentPageTours = value;
	});

	const labelSubscriber = Gm.labels.subscribe(value => {
		if (!GmCXt.isEmpty(value)) {
			$$invalidate(1, rootScope.labels = value, rootScope);
		}
	});

	const filtersSubscriber = Gm.filters.subscribe(value => {
		searchGuide();
	});

	Gm.searchTerm.subscribe(value => {
		if (value !== searchTerm) {
			$$invalidate(0, searchTerm = value);
		}
	});

	mg$(document).on('keyup', '#mgPlayerJSTest_search-text-input', function (e) {
		let excludeKey = [27, 20, 16, 17, 18, 91, 93, 37, 38, 39, 40, 45, 46];

		if (excludeKey.indexOf(e.keyCode) !== -1) {
			return;
		}
	});

	const breadcrumbDataSubscriber = Gm.breadCrumb.subscribe(value => {
		breadCrumb = value;
		getSearchText();
	});

	const currentPageSubscriber = Gm.CurrentPage.subscribe(value => {
		currentPage = value;

		if (currentPage !== 'allguidesSearchPage' && currentPage !== 'currentPageSearchPage') {
			Gm.searchTerm.set('');
		}

		getSearchText();
	});

	const clearSearch = () => {
		$$invalidate(0, searchTerm = '');
		Gm.searchTerm.set('');
		clearFilters();

		if (currentPage === 'allguidesSearchPage') {
			rootScope.setCurrentPage('allguides');
		} else if (currentPage === 'currentPageSearchPage') {
			rootScope.setCurrentPage('currentpage');
		}
	};

	// Clear filters
	function clearFilters() {
		$$invalidate(1, rootScope.currentUserFilter = '', rootScope);
		$$invalidate(1, rootScope.filterByPublishedGuides = '', rootScope);
		$$invalidate(1, rootScope.currentAssigneeFilter = '', rootScope);
		$$invalidate(1, rootScope.sortByProperty = '', rootScope);
	}

	const searchAllGuides = function (track) {
		if (searchTerm.length === 0) {
			rootScope.setCurrentPage('allguides');
		}

		if (searchTerm && searchTerm.length > 1) {
			// Add your additional processing code here
			Gm.loading.set(true);

			Gm.searchTours.set([]);

			if (get_store_value(Gm.CurrentPage) !== 'allguidesSearchPage') {
				rootScope.setCurrentPage('allguidesSearchPage');
			}

			let searchCatId = '';

			if (breadCrumb.length > 0 && breadCrumb[breadCrumb.length - 1].has_tour) {
				searchCatId = breadCrumb[breadCrumb.length - 1].category_id;
			}

			mg$('#mgPlayerJSTest_search-text-input').focus();
			let sortBy = 'tour_id';
			let param;
			if (rootScope.sortByProperty) sortByProperty = rootScope.sortByProperty;
			if (sortByProperty === rootScope.labels.name) sortBy = 'tour_title';

			//   if (GmCXt.isPlayer()) {
			param = {
				limit: limit$3,
				offset,
				search_text: searchTermLower,
				sort_by: sortBy
			};

			//   } else {
			//     param = {
			//       limit: limit,
			//       offset: offset,
			//       search_text: searchTermLower
			//     };
			//   }
			if (rootScope.myGuidesFilter) param.my_guides = rootScope.user.user_id;

			if (rootScope.currentUserFilter && rootScope.currentUserFilter.user_id !== 0) {
				param.creator_id = rootScope.currentUserFilter.user_id;
			}

			if (rootScope.filterByPublishedGuides === rootScope.labels.published) {
				param.is_published = '1';
			} else if (rootScope.filterByPublishedGuides === rootScope.labels.unpublished) {
				param.is_published = '0';
			}

			if (rootScope.currentAssigneeFilter && rootScope.currentAssigneeFilter.user_id !== 0) param.locked_user_id = rootScope.currentAssigneeFilter.user_id;

			if (GmCXt.FT.publishedGuides) {
				param.is_published = '1';
			}

			if (searchCatId) {
				param.category_id = searchCatId;
			}

			if (GmCXt.inPlayer || GmCXt.onPrem()) {
				api.searchTours(param, function (l) {
					searchCb(l, searchTerm);
				});
			} else {
				api.getTourList(param, function (l) {
					searchCb(l, searchTerm);
				});
			}
		}
	};

	function checkValueExist(t) {
		return t && t.toLowerCase().indexOf(searchTermLower.toLowerCase()) > -1;
	}

	function trackCurrentPageSearch(results) {
		currentSearchTime = new Date().getTime();

		if (lastSearchTime && currentSearchTime - lastSearchTime >= 5000) {
			rootScope.trackCurrentPageSearchEvent(false);
		}

		lastSearchTime = currentSearchTime;

		$$invalidate(
			1,
			rootScope.trackCurrentPageSearch = {
				keyword: searchTermLower,
				results_returned: results.length,
				track: true,
				startTime: new Date().getTime()
			},
			rootScope
		);
	}

	function searchGuide() {
		if (searchTerm && searchTerm.length > 1) {
			Gm.searchTerm.set(searchTermLower);
		}

		if (currentPage === 'allguides' || currentPage === 'allguidesSearchPage' || currentPage === 'myguides') {
			searchAllGuides();
		} else if (currentPage === 'currentpage' || currentPage === 'currentPageSearchPage') {
			searchCurrentPage();
		}
	}

	function searchCurrentPage() {
		if (searchTerm.length === 0) {
			rootScope.setCurrentPage('currentpage');
		}

		let currentPageSearchTours = [];

		if (currentPageTours.length > 0 && searchTerm.length > 1) {
			if (get_store_value(Gm.CurrentPage) !== 'currentPageSearchPage') {
				rootScope.setCurrentPage('currentPageSearchPage');
			}

			currentPageTours.filter(function (t) {
				if (checkValueExist(t.tour_title) || t.tour_id === searchTermLower || checkValueExist(t.keywords) || checkValueExist(t.tour_description)) {
					currentPageSearchTours.push(t);
				}
			});

			trackCurrentPageSearch(currentPageSearchTours);
			Gm.searchTours.set(currentPageSearchTours);
			searchCb(currentPageSearchTours, searchTermLower);
		}
	}

	function searchCb(_tours, keyword) {
		searchTours = [];
		currentSearchTime = new Date().getTime();
		toursFetchedInLastApiCall = _tours.length;

		if (toursFetchedInLastApiCall) {
			tours = mg$.merge(tours, _tours);
			tours = GmCXt.removeDuplicateGuides(tours);

			if (rootScope.notDefaultLang()) {
				tours = rootScope.getTranslatedTours(tours);
			}

			if (GmCXt.FT.isPlayer) {
				tours = tours.filter(function (_t) {
					if (GmCXt.isGuide(_t) || GmCXt.isOnboarding(_t)) {
						return _t;
					}
				});

				if (tours.length === 0) ;
			}

			//Set height to search-list element to properly apply slider
			//$scope.setHeight();
			//check time diffrence between the last and current search
			if (lastSearchTime && rootScope.trackSearch && !rootScope.trackSearch.filters && currentSearchTime - lastSearchTime >= 5000) {
				rootScope.trackSearchEvent(false);
			}
		}

		$$invalidate(
			1,
			rootScope.trackSearch = {
				keyword,
				results_returned: toursFetchedInLastApiCall,
				track: true,
				startTime: new Date().getTime()
			},
			rootScope
		);

		if (!tours.length && !toursFetchedInLastApiCall) {
			rootScope.trackSearchEvent(false);
		}

		if (!rootScope.trackSearch.filters) lastSearchTime = currentSearchTime;

		if (rootScope.guideSegmentation && GmCXt.FT.isPlayer) {
			Gm.loading.set(true);
			GmCXt.checkGuidesBasedOnSegment(_tours, segmentCb, 'searchSeg');
		} else {
			Gm.loading.set(false);
			Gm.searchTours.set(_tours);
		}
	}

	function segmentCb(t) {
		if (!GmCXt.isEmpty(t)) {
			searchTours.push(t);
		}

		searchTours = GmCXt.removeDuplicateGuides(searchTours);
		Gm.loading.set(false);
		Gm.searchTours.set(searchTours);
	}

	const debouncedSearchGuide = rootScope.debounce(searchGuide, 1000);

	const isTaskListVisibleStore = Gm.isTaskListVisible.subscribe(value => {
		$$invalidate(3, isTaskListVisible = value);
	});

	function getSearchText() {
		if (currentPage === 'currentpage') {
			$$invalidate(4, searchPlaceholderText = rootScope.labels.currentPageSearchPlaceholder);
		} else if (currentPage === 'allguides' && !breadCrumb.length || currentPage === 'myguides') {
			$$invalidate(4, searchPlaceholderText = rootScope.labels.inputPlaceHolderSearch);
		} else {
			$$invalidate(4, searchPlaceholderText = rootScope.labels.searchInFolder);
		}
	}

	onDestroy(() => {
		isTaskListVisibleStore();
		currentPageToursSubscriber();
		labelSubscriber();
		filtersSubscriber();
		breadcrumbDataSubscriber();
		currentPageSubscriber();
	});

	function input_input_handler() {
		searchTerm = this.value;
		$$invalidate(0, searchTerm);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*searchTerm*/ 1) {
			// Search functions
			searchTermLower = searchTerm.toLowerCase();
		}

		if ($$self.$$.dirty[0] & /*searchTerm*/ 1) {
			{
				if (searchTerm.trim().length > 0) {
					// If searchTerm's length is greater than 0, focus the input element
					$$invalidate(2, activeSearch = true);
				} else {
					clearSearch();
					$$invalidate(2, activeSearch = false);
				}
			}
		}
	};

	return [
		searchTerm,
		rootScope,
		activeSearch,
		isTaskListVisible,
		searchPlaceholderText,
		clearSearch,
		debouncedSearchGuide,
		input_input_handler
	];
}

class Search extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$o, create_fragment$p, safe_not_equal, {}, null, [-1, -1]);
	}
}

/* src/components/Filter.svelte generated by Svelte v4.2.20 */

function get_each_context$9(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[55] = list[i];
	return child_ctx;
}

function get_each_context_1$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[55] = list[i];
	return child_ctx;
}

// (564:1) {:else}
function create_else_block_1$3(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.selectFromCategories + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_1;
	let t2_value = /*rootScope*/ ctx[0].automationGuideSelectCount + "";
	let t2;
	let t3;
	let t4_value = /*rootScope*/ ctx[0].labels.selectedGuides + "";
	let t4;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t2 = text(t2_value);
			t3 = space();
			t4 = text(t4_value);
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_auto-header-bar-container");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_2, t1);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t2);
			append(wmgPlayerJSTest_1, t3);
			append(wmgPlayerJSTest_1, t4);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.selectFromCategories + "")) set_data(t0, t0_value);
			if (dirty[0] & /*rootScope*/ 1 && t2_value !== (t2_value = /*rootScope*/ ctx[0].automationGuideSelectCount + "")) set_data(t2, t2_value);
			if (dirty[0] & /*rootScope*/ 1 && t4_value !== (t4_value = /*rootScope*/ ctx[0].labels.selectedGuides + "")) set_data(t4, t4_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}
		}
	};
}

// (262:1) {#if !rootScope.automationSelectionMode}
function create_if_block$k(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t0;
	let search;
	let t1;
	let wmgPlayerJSTest_0_class_value;
	let t2;
	let t3;
	let current;
	let if_block0 = GmCXt.FT.isPlayer && /*isTaskListVisible*/ ctx[8] && create_if_block_13$7(ctx);
	search = new Search({});
	let if_block1 = GmCXt.FT.isPlayer && create_if_block_11$9(ctx);
	let if_block2 = !/*rootScope*/ ctx[0].isMicroPlayer && create_if_block_9$a(ctx);
	let if_block3 = /*currentPage*/ ctx[1] === 'allguidesSearchPage' && create_if_block_1$i(ctx);

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			create_component(search.$$.fragment);
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			if (if_block3) if_block3.c();

			attr(wmgPlayerJSTest_0, "class", wmgPlayerJSTest_0_class_value = "mgPlayerJSTest_search-bar-container mgPlayerJSTest_display-flex " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_bg-white mgPlayerJSTest_mplayer-search-view'
			: '') + " " + (!/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_search-bar-collapse'
			: ''));

			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_list-page-header-wrapper mgPlayerJSTest_no-padding mgPlayerJSTest_position-relative");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			if (if_block0) if_block0.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t0);
			mount_component(search, wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t1);
			if (if_block1) if_block1.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_1, t2);
			if (if_block2) if_block2.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t3);
			if (if_block3) if_block3.m(wmgPlayerJSTest_1, null);
			current = true;
		},
		p(ctx, dirty) {
			if (GmCXt.FT.isPlayer && /*isTaskListVisible*/ ctx[8]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_13$7(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_0, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (GmCXt.FT.isPlayer) if_block1.p(ctx, dirty);

			if (!current || dirty[0] & /*rootScope*/ 1 && wmgPlayerJSTest_0_class_value !== (wmgPlayerJSTest_0_class_value = "mgPlayerJSTest_search-bar-container mgPlayerJSTest_display-flex " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_bg-white mgPlayerJSTest_mplayer-search-view'
			: '') + " " + (!/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_search-bar-collapse'
			: ''))) {
				attr(wmgPlayerJSTest_0, "class", wmgPlayerJSTest_0_class_value);
			}

			if (!/*rootScope*/ ctx[0].isMicroPlayer) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_9$a(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_1, t3);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*currentPage*/ ctx[1] === 'allguidesSearchPage') {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_1$i(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_1, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(search.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(search.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			if (if_block0) if_block0.d();
			destroy_component(search);
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
		}
	};
}

// (269:4) {#if GmCXt.FT.isPlayer && isTaskListVisible}
function create_if_block_13$7(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].taskListCount + "";
	let t0;
	let t1;
	let button;
	let raw_value = /*rootScope*/ ctx[0].svgs.iconTaskList + "";
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			button = element("button");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_task-list-count mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center");
			attr(button, "class", "mgPlayerJSTest_task-list-icon mgPlayerJSTest_lbl-btn mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_position-relative");
			attr(button, "aria-label", "Task List");
			attr(button, "tabindex", "0");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_task-list-icon-container mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_position-relative");
			toggle_class(wmgPlayerJSTest_1, "mgPlayerJSTest_task-list-icon-mplayer", /*rootScope*/ ctx[0]?.isMicroPlayer);
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_1, t1);
			append(wmgPlayerJSTest_1, button);
			button.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[24]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].taskListCount + "")) set_data(t0, t0_value);
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.iconTaskList + "")) button.innerHTML = raw_value;
			if (dirty[0] & /*rootScope*/ 1) {
				toggle_class(wmgPlayerJSTest_1, "mgPlayerJSTest_task-list-icon-mplayer", /*rootScope*/ ctx[0]?.isMicroPlayer);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			mounted = false;
			dispose();
		}
	};
}

// (288:4) {#if GmCXt.FT.isPlayer}
function create_if_block_11$9(ctx) {
	let wmgPlayerJSTest_3;
	let button0;
	let raw_value = /*rootScope*/ ctx[0].svgs.filter_mplayer + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let t1;
	let button1;
	let t2_value = (/*labels*/ ctx[11]?.recent || /*rootScope*/ ctx[0].labels.recent) + "";
	let t2;
	let button1_aria_label_value;
	let t3;
	let button2;
	let t4_value = (/*labels*/ ctx[11]?.older || /*rootScope*/ ctx[0].labels.older) + "";
	let t4;
	let button2_aria_label_value;
	let t5;
	let wmgPlayerJSTest_1;
	let button3;
	let t6_value = (/*labels*/ ctx[11]?.clear || /*rootScope*/ ctx[0].labels.clear) + "";
	let t6;
	let button3_aria_label_value;
	let mounted;
	let dispose;
	let if_block = (!/*rootScope*/ ctx[0].enableTranslation || /*rootScope*/ ctx[0].defaultLang.language === /*rootScope*/ ctx[0].language) && create_if_block_12$7(ctx);

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			button0 = element("button");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			if (if_block) if_block.c();
			t1 = space();
			button1 = element("button");
			t2 = text(t2_value);
			t3 = space();
			button2 = element("button");
			t4 = text(t4_value);
			t5 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			button3 = element("button");
			t6 = text(t6_value);
			attr(button0, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_filter-sort-icon mgPlayerJSTest_position-relative mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer");
			attr(button0, "aria-label", "Sort By");
			attr(button0, "aria-expanded", "false");
			attr(button1, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_filter-dropdown-item mgPlayerJSTest_padding-tb-10 mgPlayerJSTest_padding-lr-25 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer");
			attr(button1, "aria-label", button1_aria_label_value = /*labels*/ ctx[11]?.recent || /*rootScope*/ ctx[0].labels.recent);
			toggle_class(button1, "mgPlayerJSTest_active-sort-filter", /*activeSortFilter*/ ctx[6] === 'recent');
			attr(button2, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_filter-dropdown-item mgPlayerJSTest_padding-tb-10 mgPlayerJSTest_padding-lr-25 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer");
			attr(button2, "aria-label", button2_aria_label_value = /*labels*/ ctx[11]?.older || /*rootScope*/ ctx[0].labels.older);
			toggle_class(button2, "mgPlayerJSTest_active-sort-filter", /*activeSortFilter*/ ctx[6] === 'older');
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_padding-tb-5");
			attr(button3, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_filter-common-btn mgPlayerJSTest_margin-lr-5 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_text-color-white mgPlayerJSTest_theme-background mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer mgPlayerJSTest_no-border mgPlayerJSTest_no-border-all mgPlayerJSTest_disabled");
			attr(button3, "aria-label", button3_aria_label_value = /*labels*/ ctx[11]?.clear || /*rootScope*/ ctx[0].labels.clear);
			attr(button3, "aria-disabled", "true");
			toggle_class(button3, "mgPlayerJSTest_disabled", !/*activeSortFilter*/ ctx[6]);
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_filter-btn-wrapper mgPlayerJSTest_width-100 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_filter-sorting-dropdown-wrapper mgPlayerJSTest_z-index mgPlayerJSTest_z-index-max");
			attr(wmgPlayerJSTest_2, "role", "region");
			attr(wmgPlayerJSTest_2, "aria-label", "Sort");
			toggle_class(wmgPlayerJSTest_2, "mgPlayerJSTest_display-block", /*searchFilterDropDownVisible*/ ctx[7]);
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_filter-sorting-wrapper mgPlayerJSTest_position-relative");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, button0);
			button0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			if (if_block) if_block.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t1);
			append(wmgPlayerJSTest_0, button1);
			append(button1, t2);
			append(wmgPlayerJSTest_0, t3);
			append(wmgPlayerJSTest_0, button2);
			append(button2, t4);
			append(wmgPlayerJSTest_2, t5);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, button3);
			append(button3, t6);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*searchFilterDropdown*/ ctx[12]),
					listen(button1, "click", /*click_handler_3*/ ctx[27]),
					listen(button2, "click", /*click_handler_4*/ ctx[28]),
					listen(button3, "click", /*click_handler_5*/ ctx[29])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.filter_mplayer + "")) button0.innerHTML = raw_value;
			if (!/*rootScope*/ ctx[0].enableTranslation || /*rootScope*/ ctx[0].defaultLang.language === /*rootScope*/ ctx[0].language) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_12$7(ctx);
					if_block.c();
					if_block.m(wmgPlayerJSTest_0, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*labels, rootScope*/ 2049 && t2_value !== (t2_value = (/*labels*/ ctx[11]?.recent || /*rootScope*/ ctx[0].labels.recent) + "")) set_data(t2, t2_value);

			if (dirty[0] & /*labels, rootScope*/ 2049 && button1_aria_label_value !== (button1_aria_label_value = /*labels*/ ctx[11]?.recent || /*rootScope*/ ctx[0].labels.recent)) {
				attr(button1, "aria-label", button1_aria_label_value);
			}

			if (dirty[0] & /*activeSortFilter*/ 64) {
				toggle_class(button1, "mgPlayerJSTest_active-sort-filter", /*activeSortFilter*/ ctx[6] === 'recent');
			}

			if (dirty[0] & /*labels, rootScope*/ 2049 && t4_value !== (t4_value = (/*labels*/ ctx[11]?.older || /*rootScope*/ ctx[0].labels.older) + "")) set_data(t4, t4_value);

			if (dirty[0] & /*labels, rootScope*/ 2049 && button2_aria_label_value !== (button2_aria_label_value = /*labels*/ ctx[11]?.older || /*rootScope*/ ctx[0].labels.older)) {
				attr(button2, "aria-label", button2_aria_label_value);
			}

			if (dirty[0] & /*activeSortFilter*/ 64) {
				toggle_class(button2, "mgPlayerJSTest_active-sort-filter", /*activeSortFilter*/ ctx[6] === 'older');
			}

			if (dirty[0] & /*labels, rootScope*/ 2049 && t6_value !== (t6_value = (/*labels*/ ctx[11]?.clear || /*rootScope*/ ctx[0].labels.clear) + "")) set_data(t6, t6_value);

			if (dirty[0] & /*labels, rootScope*/ 2049 && button3_aria_label_value !== (button3_aria_label_value = /*labels*/ ctx[11]?.clear || /*rootScope*/ ctx[0].labels.clear)) {
				attr(button3, "aria-label", button3_aria_label_value);
			}

			if (dirty[0] & /*activeSortFilter*/ 64) {
				toggle_class(button3, "mgPlayerJSTest_disabled", !/*activeSortFilter*/ ctx[6]);
			}

			if (dirty[0] & /*searchFilterDropDownVisible*/ 128) {
				toggle_class(wmgPlayerJSTest_2, "mgPlayerJSTest_display-block", /*searchFilterDropDownVisible*/ ctx[7]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}

			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (305:8) {#if !rootScope.enableTranslation || rootScope.defaultLang.language === rootScope.language}
function create_if_block_12$7(ctx) {
	let button0;
	let t0_value = /*rootScope*/ ctx[0].labels.atoz + "";
	let t0;
	let button0_aria_label_value;
	let t1;
	let button1;
	let t2_value = /*rootScope*/ ctx[0].labels.ztoa + "";
	let t2;
	let button1_aria_label_value;
	let mounted;
	let dispose;

	return {
		c() {
			button0 = element("button");
			t0 = text(t0_value);
			t1 = space();
			button1 = element("button");
			t2 = text(t2_value);
			attr(button0, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_filter-dropdown-item mgPlayerJSTest_padding-tb-10 mgPlayerJSTest_padding-lr-25 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer");
			attr(button0, "aria-label", button0_aria_label_value = /*rootScope*/ ctx[0].labels.atoz);
			toggle_class(button0, "mgPlayerJSTest_active-sort-filter", /*activeSortFilter*/ ctx[6] === 'atoz');
			attr(button1, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_filter-dropdown-item mgPlayerJSTest_padding-tb-10 mgPlayerJSTest_padding-lr-25 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer");
			attr(button1, "aria-label", button1_aria_label_value = /*rootScope*/ ctx[0].labels.ztoa);
			toggle_class(button1, "mgPlayerJSTest_active-sort-filter", /*activeSortFilter*/ ctx[6] === 'ztoa');
		},
		m(target, anchor) {
			insert(target, button0, anchor);
			append(button0, t0);
			insert(target, t1, anchor);
			insert(target, button1, anchor);
			append(button1, t2);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*click_handler_1*/ ctx[25]),
					listen(button1, "click", /*click_handler_2*/ ctx[26])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.atoz + "")) set_data(t0, t0_value);

			if (dirty[0] & /*rootScope*/ 1 && button0_aria_label_value !== (button0_aria_label_value = /*rootScope*/ ctx[0].labels.atoz)) {
				attr(button0, "aria-label", button0_aria_label_value);
			}

			if (dirty[0] & /*activeSortFilter*/ 64) {
				toggle_class(button0, "mgPlayerJSTest_active-sort-filter", /*activeSortFilter*/ ctx[6] === 'atoz');
			}

			if (dirty[0] & /*rootScope*/ 1 && t2_value !== (t2_value = /*rootScope*/ ctx[0].labels.ztoa + "")) set_data(t2, t2_value);

			if (dirty[0] & /*rootScope*/ 1 && button1_aria_label_value !== (button1_aria_label_value = /*rootScope*/ ctx[0].labels.ztoa)) {
				attr(button1, "aria-label", button1_aria_label_value);
			}

			if (dirty[0] & /*activeSortFilter*/ 64) {
				toggle_class(button1, "mgPlayerJSTest_active-sort-filter", /*activeSortFilter*/ ctx[6] === 'ztoa');
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button0);
				detach(t1);
				detach(button1);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (362:3) {#if !rootScope.isMicroPlayer}
function create_if_block_9$a(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let button;
	let t0_value = (/*labels*/ ctx[11]?.currentPage || /*rootScope*/ ctx[0].labels.currentPage) + "";
	let t0;
	let button_class_value;
	let t1;
	let mounted;
	let dispose;

	function select_block_type_1(ctx, dirty) {
		if (GmCXt.FT.isPlayer) return create_if_block_10$9;
		return create_else_block$b;
	}

	let current_block_type = select_block_type_1();
	let if_block = current_block_type(ctx);

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = text(t0_value);
			t1 = space();
			if_block.c();
			attr(button, "id", "mgPlayerJSTest_filter-tab-current-page");

			attr(button, "class", button_class_value = "mgPlayerJSTest_lbl-btn mgPlayerJSTest_filter-tab mgPlayerJSTest_inline-block-vm mgPlayerJSTest_text-align-center mgPlayerJSTest_cursor-pointer mgPlayerJSTest_margin-lr-5 mgPlayerJSTest_text-overflow-ellipsis " + (/*currentPage*/ ctx[1] === 'currentpage'
			? 'mgPlayerJSTest_filter-active-tab'
			: ''));

			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_library-filter-wrapper mgPlayerJSTest_inline-block-vm mgPlayerJSTest_margin-lr-10");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_inline-block-vm all-guides-filters-tab mgPlayerJSTest_width-100 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, button);
			append(button, t0);
			append(wmgPlayerJSTest_0, t1);
			if_block.m(wmgPlayerJSTest_0, null);

			if (!mounted) {
				dispose = listen(button, "click", /*toggleCurrentPage*/ ctx[14]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*labels, rootScope*/ 2049 && t0_value !== (t0_value = (/*labels*/ ctx[11]?.currentPage || /*rootScope*/ ctx[0].labels.currentPage) + "")) set_data(t0, t0_value);

			if (dirty[0] & /*currentPage*/ 2 && button_class_value !== (button_class_value = "mgPlayerJSTest_lbl-btn mgPlayerJSTest_filter-tab mgPlayerJSTest_inline-block-vm mgPlayerJSTest_text-align-center mgPlayerJSTest_cursor-pointer mgPlayerJSTest_margin-lr-5 mgPlayerJSTest_text-overflow-ellipsis " + (/*currentPage*/ ctx[1] === 'currentpage'
			? 'mgPlayerJSTest_filter-active-tab'
			: ''))) {
				attr(button, "class", button_class_value);
			}

			if_block.p(ctx, dirty);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (386:6) {:else}
function create_else_block$b(ctx) {
	let button;
	let t_value = (/*labels*/ ctx[11]?.myGuides || /*rootScope*/ ctx[0].labels.myGuides) + "";
	let t;
	let button_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t = text(t_value);
			attr(button, "id", "mgPlayerJSTest_filter-tab-go-to-lib");

			attr(button, "class", button_class_value = "mgPlayerJSTest_lbl-btn mgPlayerJSTest_filter-tab mgPlayerJSTest_inline-block-vm mgPlayerJSTest_text-align-center mgPlayerJSTest_cursor-pointer mgPlayerJSTest_margin-lr-5 mgPlayerJSTest_text-overflow-ellipsis " + (/*currentPage*/ ctx[1] === 'myguides'
			? 'mgPlayerJSTest_filter-active-tab'
			: ''));
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*toggleMyGuides*/ ctx[15]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*labels, rootScope*/ 2049 && t_value !== (t_value = (/*labels*/ ctx[11]?.myGuides || /*rootScope*/ ctx[0].labels.myGuides) + "")) set_data(t, t_value);

			if (dirty[0] & /*currentPage*/ 2 && button_class_value !== (button_class_value = "mgPlayerJSTest_lbl-btn mgPlayerJSTest_filter-tab mgPlayerJSTest_inline-block-vm mgPlayerJSTest_text-align-center mgPlayerJSTest_cursor-pointer mgPlayerJSTest_margin-lr-5 mgPlayerJSTest_text-overflow-ellipsis " + (/*currentPage*/ ctx[1] === 'myguides'
			? 'mgPlayerJSTest_filter-active-tab'
			: ''))) {
				attr(button, "class", button_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (375:6) {#if GmCXt.FT.isPlayer}
function create_if_block_10$9(ctx) {
	let button;
	let t_value = (/*labels*/ ctx[11]?.allGuides || /*rootScope*/ ctx[0].labels.allGuides) + "";
	let t;
	let button_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t = text(t_value);
			attr(button, "id", "mgPlayerJSTest_filter-tab-go-to-lib");

			attr(button, "class", button_class_value = "mgPlayerJSTest_lbl-btn mgPlayerJSTest_filter-tab mgPlayerJSTest_inline-block-vm mgPlayerJSTest_text-align-center mgPlayerJSTest_cursor-pointer mgPlayerJSTest_margin-lr-5 mgPlayerJSTest_text-overflow-ellipsis " + (/*currentPage*/ ctx[1] === 'allguides'
			? 'mgPlayerJSTest_filter-active-tab'
			: ''));
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*toggleCurrentPage*/ ctx[14]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*labels, rootScope*/ 2049 && t_value !== (t_value = (/*labels*/ ctx[11]?.allGuides || /*rootScope*/ ctx[0].labels.allGuides) + "")) set_data(t, t_value);

			if (dirty[0] & /*currentPage*/ 2 && button_class_value !== (button_class_value = "mgPlayerJSTest_lbl-btn mgPlayerJSTest_filter-tab mgPlayerJSTest_inline-block-vm mgPlayerJSTest_text-align-center mgPlayerJSTest_cursor-pointer mgPlayerJSTest_margin-lr-5 mgPlayerJSTest_text-overflow-ellipsis " + (/*currentPage*/ ctx[1] === 'allguides'
			? 'mgPlayerJSTest_filter-active-tab'
			: ''))) {
				attr(button, "class", button_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (401:3) {#if currentPage === 'allguidesSearchPage'}
function create_if_block_1$i(ctx) {
	let wmgPlayerJSTest_0;
	let t0;
	let t1;
	let wmgPlayerJSTest_1;
	let t2_value = /*rootScope*/ ctx[0].labels.searchResult + "";
	let t2;
	let if_block = !/*rootScope*/ ctx[0].isMicroPlayer && GmCXt.FT.creatorApp && create_if_block_2$h(ctx);

	return {
		c() {
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t2 = text(t2_value);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_ege-clear");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_search-result-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_font-size-15 mgPlayerJSTest_padding-lr-20");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_0, anchor);
			insert(target, t0, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, t1, anchor);
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, t2);
		},
		p(ctx, dirty) {
			if (!/*rootScope*/ ctx[0].isMicroPlayer && GmCXt.FT.creatorApp) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$h(ctx);
					if_block.c();
					if_block.m(t1.parentNode, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*rootScope*/ 1 && t2_value !== (t2_value = /*rootScope*/ ctx[0].labels.searchResult + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_0);
				detach(t0);
				detach(t1);
				detach(wmgPlayerJSTest_1);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (404:4) {#if !rootScope.isMicroPlayer && GmCXt.FT.creatorApp}
function create_if_block_2$h(ctx) {
	let wmgPlayerJSTest_;
	let t0;
	let t1;
	let t2;
	let if_block0 = /*currentPage*/ ctx[1] === 'allguidesSearchPage' && create_if_block_7$b(ctx);
	let if_block1 = /*currentPage*/ ctx[1] === 'allguidesSearchPage' && create_if_block_6$c(ctx);
	let if_block2 = /*currentPage*/ ctx[1] === 'allguidesSearchPage' && create_if_block_4$e(ctx);
	let if_block3 = /*currentPage*/ ctx[1] === 'allguidesSearchPage' && create_if_block_3$f(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_inline-block-vm all-guides-filters-tab mgPlayerJSTest_width-100 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t0);
			if (if_block1) if_block1.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t1);
			if (if_block2) if_block2.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t2);
			if (if_block3) if_block3.m(wmgPlayerJSTest_, null);
		},
		p(ctx, dirty) {
			if (/*currentPage*/ ctx[1] === 'allguidesSearchPage') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_7$b(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*currentPage*/ ctx[1] === 'allguidesSearchPage') {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_6$c(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*currentPage*/ ctx[1] === 'allguidesSearchPage') {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_4$e(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*currentPage*/ ctx[1] === 'allguidesSearchPage') {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_3$f(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
		}
	};
}

// (408:6) {#if currentPage === 'allguidesSearchPage'}
function create_if_block_7$b(ctx) {
	let wmgPlayerJSTest_5;
	let t0_value = `${/*rootScope*/ ctx[0].labels.creator}:` + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*currentUser*/ ctx[3]?.first_name + "";
	let t2;
	let t3;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[0].svgs.down_arrow_icon + "";
	let t4;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_1;
	let t5_value = /*rootScope*/ ctx[0].labels.currentUser + "";
	let t5;
	let t6;
	let wmgPlayerJSTest_2;
	let t7_value = /*rootScope*/ ctx[0].labels.allUser + "";
	let t7;
	let t8;
	let wmgPlayerJSTest_3;
	let t9;
	let mounted;
	let dispose;
	let if_block = /*userList*/ ctx[10].length > 0 && create_if_block_8$b(ctx);

	return {
		c() {
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t4 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t5 = text(t5_value);
			t6 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t7 = text(t7_value);
			t8 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t9 = space();
			if (if_block) if_block.c();
			attr(span, "class", "mgPlayerJSTest_all-guides-search-filters-label");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_all-guides-search-filters-icon mgPlayerJSTest_ege-inline-block-vt");
			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_filter-search-by-current-user");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_all-guides-search-filters-dropdown-item");
			attr(wmgPlayerJSTest_2, "id", "mgPlayerJSTest_filter-search-by-all-user");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_all-guides-search-filters-dropdown-item");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_horizontal-line margin-none");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_all-guides-search-filters-dropdown-user");
			attr(wmgPlayerJSTest_5, "id", "mgPlayerJSTest_filter-search-by");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_all-guides-search-filters");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_5, anchor);
			append(wmgPlayerJSTest_5, t0);
			append(wmgPlayerJSTest_5, t1);
			append(wmgPlayerJSTest_5, span);
			append(span, t2);
			append(wmgPlayerJSTest_5, t3);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_5, t4);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t5);
			append(wmgPlayerJSTest_4, t6);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, t7);
			append(wmgPlayerJSTest_4, t8);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_4, t9);
			if (if_block) if_block.m(wmgPlayerJSTest_4, null);

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_1, "click", /*click_handler_6*/ ctx[30]),
					listen(wmgPlayerJSTest_2, "click", /*click_handler_7*/ ctx[31]),
					listen(wmgPlayerJSTest_5, "click", /*click_handler_9*/ ctx[33])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = `${/*rootScope*/ ctx[0].labels.creator}:` + "")) set_data(t0, t0_value);
			if (dirty[0] & /*currentUser*/ 8 && t2_value !== (t2_value = /*currentUser*/ ctx[3]?.first_name + "")) set_data(t2, t2_value);
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.down_arrow_icon + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if (dirty[0] & /*rootScope*/ 1 && t5_value !== (t5_value = /*rootScope*/ ctx[0].labels.currentUser + "")) set_data(t5, t5_value);
			if (dirty[0] & /*rootScope*/ 1 && t7_value !== (t7_value = /*rootScope*/ ctx[0].labels.allUser + "")) set_data(t7, t7_value);

			if (/*userList*/ ctx[10].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_8$b(ctx);
					if_block.c();
					if_block.m(wmgPlayerJSTest_4, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_5);
			}

			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (437:9) {#if userList.length > 0}
function create_if_block_8$b(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let each_value_1 = ensure_array_like(/*userList*/ ctx[10].sort(func));
	const get_key = ctx => /*user*/ ctx[55].user_id;

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1$4(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$4(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*userList, currentUser, filterByUser*/ 132104) {
				each_value_1 = ensure_array_like(/*userList*/ ctx[10].sort(func));
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block_1$4, each_1_anchor, get_each_context_1$4);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}
		}
	};
}

// (438:10) {#each userList.sort((a, b) => a.first_name.localeCompare(b.first_name)) as user (user.user_id)}
function create_each_block_1$4(key_1, ctx) {
	let wmgPlayerJSTest_;
	let t0_value = /*user*/ ctx[55].first_name + ' ' + /*user*/ ctx[55].last_name + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_id_value;
	let mounted;
	let dispose;

	function click_handler_8() {
		return /*click_handler_8*/ ctx[32](/*user*/ ctx[55]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			attr(wmgPlayerJSTest_, "id", wmgPlayerJSTest_id_value = `mgPlayerJSTest_filter-search-by-user-${/*user*/ ctx[55].user_id}`);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_all-guides-search-filters-dropdown-item");
			toggle_class(wmgPlayerJSTest_, "mgPlayerJSTest_selected-filter-dropdown-item", /*currentUser*/ ctx[3].user_id === /*user*/ ctx[55].user_id);
			this.first = wmgPlayerJSTest_;
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t0);
			append(wmgPlayerJSTest_, t1);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_, "click", click_handler_8);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*userList*/ 1024 && t0_value !== (t0_value = /*user*/ ctx[55].first_name + ' ' + /*user*/ ctx[55].last_name + "")) set_data(t0, t0_value);

			if (dirty[0] & /*userList*/ 1024 && wmgPlayerJSTest_id_value !== (wmgPlayerJSTest_id_value = `mgPlayerJSTest_filter-search-by-user-${/*user*/ ctx[55].user_id}`)) {
				attr(wmgPlayerJSTest_, "id", wmgPlayerJSTest_id_value);
			}

			if (dirty[0] & /*currentUser, userList*/ 1032) {
				toggle_class(wmgPlayerJSTest_, "mgPlayerJSTest_selected-filter-dropdown-item", /*currentUser*/ ctx[3].user_id === /*user*/ ctx[55].user_id);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			dispose();
		}
	};
}

// (453:6) {#if currentPage === 'allguidesSearchPage'}
function create_if_block_6$c(ctx) {
	let wmgPlayerJSTest_5;
	let t0_value = `${/*rootScope*/ ctx[0].labels.status}:` + "";
	let t0;
	let t1;
	let span;
	let t2;
	let t3;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[0].svgs.down_arrow_icon + "";
	let t4;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_1;
	let t5_value = /*rootScope*/ ctx[0].labels.all + "";
	let t5;
	let t6;
	let wmgPlayerJSTest_2;
	let t7_value = /*rootScope*/ ctx[0].labels.published + "";
	let t7;
	let t8;
	let wmgPlayerJSTest_3;
	let t9_value = /*rootScope*/ ctx[0].labels.unpublished + "";
	let t9;
	let wmgPlayerJSTest_4_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(/*filterByPublishedGuides*/ ctx[5]);
			t3 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t4 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t5 = text(t5_value);
			t6 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t7 = text(t7_value);
			t8 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t9 = text(t9_value);
			attr(span, "class", "mgPlayerJSTest_all-guides-search-filters-label");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_all-guides-search-filters-icon mgPlayerJSTest_ege-inline-block-vt");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_all-guides-search-filters-dropdown-item");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_all-guides-search-filters-dropdown-item");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_all-guides-search-filters-dropdown-item");
			attr(wmgPlayerJSTest_4, "class", wmgPlayerJSTest_4_class_value = "mgPlayerJSTest_all-guides-search-filters-dropdown-published mgPlayerJSTest_all-guides-search-filters-dropdown-" + /*rootScope*/ ctx[0].labels.published);
			attr(wmgPlayerJSTest_5, "id", "mgPlayerJSTest_filter-search-by-status");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_all-guides-search-filters");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_5, anchor);
			append(wmgPlayerJSTest_5, t0);
			append(wmgPlayerJSTest_5, t1);
			append(wmgPlayerJSTest_5, span);
			append(span, t2);
			append(wmgPlayerJSTest_5, t3);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_5, t4);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t5);
			append(wmgPlayerJSTest_4, t6);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, t7);
			append(wmgPlayerJSTest_4, t8);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, t9);

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_1, "click", /*allstatus*/ ctx[21]),
					listen(wmgPlayerJSTest_2, "click", /*publishedGuidesAdvance*/ ctx[22]),
					listen(wmgPlayerJSTest_3, "click", /*unpublishedGuides*/ ctx[23]),
					listen(wmgPlayerJSTest_5, "click", /*click_handler_10*/ ctx[34])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = `${/*rootScope*/ ctx[0].labels.status}:` + "")) set_data(t0, t0_value);
			if (dirty[0] & /*filterByPublishedGuides*/ 32) set_data(t2, /*filterByPublishedGuides*/ ctx[5]);
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.down_arrow_icon + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if (dirty[0] & /*rootScope*/ 1 && t5_value !== (t5_value = /*rootScope*/ ctx[0].labels.all + "")) set_data(t5, t5_value);
			if (dirty[0] & /*rootScope*/ 1 && t7_value !== (t7_value = /*rootScope*/ ctx[0].labels.published + "")) set_data(t7, t7_value);
			if (dirty[0] & /*rootScope*/ 1 && t9_value !== (t9_value = /*rootScope*/ ctx[0].labels.unpublished + "")) set_data(t9, t9_value);

			if (dirty[0] & /*rootScope*/ 1 && wmgPlayerJSTest_4_class_value !== (wmgPlayerJSTest_4_class_value = "mgPlayerJSTest_all-guides-search-filters-dropdown-published mgPlayerJSTest_all-guides-search-filters-dropdown-" + /*rootScope*/ ctx[0].labels.published)) {
				attr(wmgPlayerJSTest_4, "class", wmgPlayerJSTest_4_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_5);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (481:6) {#if currentPage === 'allguidesSearchPage'}
function create_if_block_4$e(ctx) {
	let wmgPlayerJSTest_5;
	let t0_value = `${/*rootScope*/ ctx[0].labels.assignee}:` + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*currentAssignee*/ ctx[4]?.first_name + "";
	let t2;
	let t3;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[0].svgs.down_arrow_icon + "";
	let t4;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_1;
	let t5_value = /*rootScope*/ ctx[0].labels.currentUser + "";
	let t5;
	let t6;
	let wmgPlayerJSTest_2;
	let t7_value = /*rootScope*/ ctx[0].labels.allUser + "";
	let t7;
	let t8;
	let wmgPlayerJSTest_3;
	let t9;
	let mounted;
	let dispose;
	let if_block = /*userList*/ ctx[10].length > 0 && create_if_block_5$d(ctx);

	return {
		c() {
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t4 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t5 = text(t5_value);
			t6 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t7 = text(t7_value);
			t8 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t9 = space();
			if (if_block) if_block.c();
			attr(span, "class", "mgPlayerJSTest_all-guides-search-filters-label");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_all-guides-search-filters-icon mgPlayerJSTest_ege-inline-block-vt");
			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_filter-search-locked-by-current-user");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_all-guides-search-filters-dropdown-item");
			attr(wmgPlayerJSTest_2, "id", "mgPlayerJSTest_filter-search-locked-by-all-user");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_all-guides-search-filters-dropdown-item");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_horizontal-line margin-none");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_all-guides-search-filters-dropdown-assignee");
			attr(wmgPlayerJSTest_5, "id", "mgPlayerJSTest_filter-search-by-assignee");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_all-guides-search-filters");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_5, anchor);
			append(wmgPlayerJSTest_5, t0);
			append(wmgPlayerJSTest_5, t1);
			append(wmgPlayerJSTest_5, span);
			append(span, t2);
			append(wmgPlayerJSTest_5, t3);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_5, t4);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t5);
			append(wmgPlayerJSTest_4, t6);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, t7);
			append(wmgPlayerJSTest_4, t8);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_4, t9);
			if (if_block) if_block.m(wmgPlayerJSTest_4, null);

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_1, "click", /*click_handler_11*/ ctx[35]),
					listen(wmgPlayerJSTest_2, "click", /*click_handler_12*/ ctx[36]),
					listen(wmgPlayerJSTest_5, "click", /*click_handler_14*/ ctx[38])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = `${/*rootScope*/ ctx[0].labels.assignee}:` + "")) set_data(t0, t0_value);
			if (dirty[0] & /*currentAssignee*/ 16 && t2_value !== (t2_value = /*currentAssignee*/ ctx[4]?.first_name + "")) set_data(t2, t2_value);
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.down_arrow_icon + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if (dirty[0] & /*rootScope*/ 1 && t5_value !== (t5_value = /*rootScope*/ ctx[0].labels.currentUser + "")) set_data(t5, t5_value);
			if (dirty[0] & /*rootScope*/ 1 && t7_value !== (t7_value = /*rootScope*/ ctx[0].labels.allUser + "")) set_data(t7, t7_value);

			if (/*userList*/ ctx[10].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_5$d(ctx);
					if_block.c();
					if_block.m(wmgPlayerJSTest_4, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_5);
			}

			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (508:9) {#if userList.length > 0}
function create_if_block_5$d(ctx) {
	let each_1_anchor;
	let each_value = ensure_array_like(/*userList*/ ctx[10].sort(func_1));
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*userList, currentUser, filterByAssignee*/ 263176) {
				each_value = ensure_array_like(/*userList*/ ctx[10].sort(func_1));
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$9(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$9(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (509:10) {#each userList.sort((a, b) => a.first_name.localeCompare(b.first_name)) as user}
function create_each_block$9(ctx) {
	let wmgPlayerJSTest_;
	let t0_value = /*user*/ ctx[55].first_name + ' ' + /*user*/ ctx[55].last_name + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_id_value;
	let wmgPlayerJSTest_class_value;
	let mounted;
	let dispose;

	function click_handler_13() {
		return /*click_handler_13*/ ctx[37](/*user*/ ctx[55]);
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			attr(wmgPlayerJSTest_, "id", wmgPlayerJSTest_id_value = 'mgPlayerJSTest_filter-search-locked-by-user-' + /*user*/ ctx[55].user_id);

			attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value = "mgPlayerJSTest_all-guides-search-filters-dropdown-item " + (/*currentUser*/ ctx[3].user_id === /*user*/ ctx[55].user_id
			? 'mgPlayerJSTest_selected-filter-dropdown-item'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t0);
			append(wmgPlayerJSTest_, t1);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_, "click", click_handler_13);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*userList*/ 1024 && t0_value !== (t0_value = /*user*/ ctx[55].first_name + ' ' + /*user*/ ctx[55].last_name + "")) set_data(t0, t0_value);

			if (dirty[0] & /*userList*/ 1024 && wmgPlayerJSTest_id_value !== (wmgPlayerJSTest_id_value = 'mgPlayerJSTest_filter-search-locked-by-user-' + /*user*/ ctx[55].user_id)) {
				attr(wmgPlayerJSTest_, "id", wmgPlayerJSTest_id_value);
			}

			if (dirty[0] & /*currentUser, userList*/ 1032 && wmgPlayerJSTest_class_value !== (wmgPlayerJSTest_class_value = "mgPlayerJSTest_all-guides-search-filters-dropdown-item " + (/*currentUser*/ ctx[3].user_id === /*user*/ ctx[55].user_id
			? 'mgPlayerJSTest_selected-filter-dropdown-item'
			: ''))) {
				attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			dispose();
		}
	};
}

// (525:6) {#if currentPage === 'allguidesSearchPage'}
function create_if_block_3$f(ctx) {
	let wmgPlayerJSTest_4;
	let t0_value = `${/*rootScope*/ ctx[0].labels.sortBy}:` + "";
	let t0;
	let t1;
	let span;
	let t2;
	let t3;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[0].svgs.down_arrow_icon + "";
	let t4;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_1;
	let t5_value = /*rootScope*/ ctx[0].labels.latest + "";
	let t5;
	let t6;
	let wmgPlayerJSTest_2;
	let t7_value = /*rootScope*/ ctx[0].labels.name + "";
	let t7;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(/*sortByProperty*/ ctx[9]);
			t3 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t4 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t5 = text(t5_value);
			t6 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t7 = text(t7_value);
			attr(span, "class", "mgPlayerJSTest_all-guides-search-filters-label");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_all-guides-search-filters-icon mgPlayerJSTest_ege-inline-block-vt");
			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_filter-search-by-sort-latest");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_all-guides-search-filters-dropdown-item");
			attr(wmgPlayerJSTest_2, "id", "mgPlayerJSTest_filter-search-by-sort-name");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_all-guides-search-filters-dropdown-item");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_all-guides-search-filters-dropdown-sort");
			attr(wmgPlayerJSTest_4, "id", "mgPlayerJSTest_filter-search-by-sort");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_all-guides-search-filters");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_4, anchor);
			append(wmgPlayerJSTest_4, t0);
			append(wmgPlayerJSTest_4, t1);
			append(wmgPlayerJSTest_4, span);
			append(span, t2);
			append(wmgPlayerJSTest_4, t3);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_4, t4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t5);
			append(wmgPlayerJSTest_3, t6);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, t7);

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_1, "click", /*sortByLatest*/ ctx[19]),
					listen(wmgPlayerJSTest_2, "click", /*sortByName*/ ctx[20]),
					listen(wmgPlayerJSTest_4, "click", /*click_handler_15*/ ctx[39])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = `${/*rootScope*/ ctx[0].labels.sortBy}:` + "")) set_data(t0, t0_value);
			if (dirty[0] & /*sortByProperty*/ 512) set_data(t2, /*sortByProperty*/ ctx[9]);
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.down_arrow_icon + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if (dirty[0] & /*rootScope*/ 1 && t5_value !== (t5_value = /*rootScope*/ ctx[0].labels.latest + "")) set_data(t5, t5_value);
			if (dirty[0] & /*rootScope*/ 1 && t7_value !== (t7_value = /*rootScope*/ ctx[0].labels.name + "")) set_data(t7, t7_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_4);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$o(ctx) {
	let wmgPlayerJSTest_;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$k, create_else_block_1$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (!/*rootScope*/ ctx[0].automationSelectionMode) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if_block.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_list-page-header");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if_blocks[current_block_type_index].m(wmgPlayerJSTest_, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(wmgPlayerJSTest_, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if_blocks[current_block_type_index].d();
		}
	};
}

const func = (a, b) => a.first_name.localeCompare(b.first_name);
const func_1 = (a, b) => a.first_name.localeCompare(b.first_name);

function instance$n($$self, $$props, $$invalidate) {
	let currentPage,
		allUser,
		currentUser,
		currentAssignee,
		filterByPublishedGuides,
		myGuides;

	let activeSortFilter = '';
	let searchFilterDropDownVisible = false;
	let isTaskListVisible = false;
	let sortByProperty = rootScope.labels.latest;
	let userList = [];

	const currentPageSubscriber = Gm.CurrentPage.subscribe(value => {
		$$invalidate(1, currentPage = value);
	});

	let labels = get_store_value(Gm.labels);

	Gm.activeSortFilterStore.subscribe(value => {
		$$invalidate(6, activeSortFilter = value);
	});

	Gm.isTaskListVisible.subscribe(value => {
		$$invalidate(8, isTaskListVisible = value);
	});

	Gm.taskListCount.subscribe(value => {
	});

	const routeActionSubscriber = Gm.routeAction.subscribe(value => {
		if (value && value.action === 'updateAutomationCount') {
			$$invalidate(0, rootScope.automationGuideSelectCount = value.data, rootScope);

			// Clear the action so it doesn't trigger again
			Gm.routeAction.set(null);
		}
	});

	allUser = {
		user_id: 0,
		first_name: rootScope.labels.all
	};

	if (!rootScope.currentUserFilter) {
		currentUser = allUser;
	}

	if (!rootScope.currentAssigneeFilter) {
		currentAssignee = allUser;
	}

	if (!rootScope.filterByPublishedGuides) {
		filterByPublishedGuides = rootScope.labels.all;
	}

	// Function to toggle dropdown visibility
	const searchFilterDropdown = function () {
		if (searchFilterDropDownVisible) {
			hideSearchFilterDropdown();
		} else {
			$$invalidate(7, searchFilterDropDownVisible = !searchFilterDropDownVisible);
			$$invalidate(7, searchFilterDropDownVisible = true);
			rootScope.addPanelOverlay();
			rootScope.showPanelOverlay();
			mg$('.mgPlayerJSTest_theme-mplayer-header').append("<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-panel-overlay'></wmgPlayerJSTest_>");
			mg$('.mgPlayerJSTest_filter-sort-icon').addClass('mgPlayerJSTest_z-index mgPlayerJSTest_z-index-max');
			mg$('.mgPlayerJSTest_filter-sort-icon').addClass('mgPlayerJSTest_filter-active-state');
		}
	};

	// Function to close dropdown
	const hideSearchFilterDropdown = function () {
		$$invalidate(7, searchFilterDropDownVisible = false);
		Gm.activeSortFilterStore.set(activeSortFilter);
		rootScope.hidePanelOverlay();
		mg$('.mgPlayerJSTest_filter-sort-icon').removeClass('mgPlayerJSTest_z-index mgPlayerJSTest_z-index-max');
		mg$('.mgPlayerJSTest_filter-sort-icon').removeClass('mgPlayerJSTest_filter-active-state');
	};

	// Function to handle selection of an option
	const selectSearchFilterOption = function (selectedOrder) {
		$$invalidate(7, searchFilterDropDownVisible = false);
		$$invalidate(6, activeSortFilter = selectedOrder);
		Gm.activeSortFilterStore.set(activeSortFilter);
		GmCXt.saveToStorage('activeSortFilter', activeSortFilter);
		$$invalidate(0, rootScope.descOrder = activeSortFilter.descOrder, rootScope);
		$$invalidate(0, rootScope.activeSortFilter = activeSortFilter.activeSfilter, rootScope);
		hideSearchFilterDropdown();
	};

	const toggleCurrentPage = function () {
		if (currentPage === 'allguides' || currentPage === 'myguides') {
			Gm.loading.set(true);
			rootScope.setCurrentPage('currentpage');
			Gm.breadCrumb.set([]);
		} else {
			Gm.loading.set(true);
			rootScope.setCurrentPage('allguides');
			Gm.breadCrumb.set([]);
		}
	};

	const toggleMyGuides = function () {
		if (currentPage === 'allguides' || currentPage === 'currentpage') {
			Gm.loading.set(true);
			rootScope.setCurrentPage('myguides');
			myGuides = true;
			Gm.breadCrumb.set([]);
		} else {
			Gm.loading.set(true);
			rootScope.setCurrentPage('allguides');
			myGuides = false;
			Gm.breadCrumb.set([]);
		}

		$$invalidate(0, rootScope.myGuidesFilter = !myGuides ? false : true, rootScope);
	};

	// Show filters dropdown
	function showGuidesFiltersDropdown(filter) {
		rootScope.hideFiltersDropdown();

		// Logic to show dropdown
		let dropdownEl = mg$('.mgPlayerJSTest_all-guides-search-filters-dropdown-' + filter);

		if (dropdownEl && !dropdownEl.is(':visible')) {
			dropdownEl.slideDown(200);
		}
	}

	function getUserList() {
		function cb(userListFromApi) {
			if (userListFromApi.length > 0) {
				$$invalidate(10, userList = userListFromApi);

				if (!rootScope.currentUserFilter) {
					$$invalidate(3, currentUser = allUser);
				}

				if (!rootScope.currentAssigneeFilter) {
					$$invalidate(4, currentAssignee = allUser);
				}
			}
		}

		rootScope.getUserList(cb);
	}

	// Apply advanced filters
	function applyFilterAdvanced() {
		// Logic to apply advanced filters
		if (rootScope.currentUserFilter || rootScope.filterByPublishedGuides || rootScope.currentAssigneeFilter || rootScope.sortByProperty) {
			let filters = {
				currentUserFilter: rootScope.currentUserFilter,
				filterByPublishedGuides: rootScope.filterByPublishedGuides,
				currentAssigneeFilter: rootScope.currentAssigneeFilter,
				sortByProperty: rootScope.sortByProperty
			};

			Gm.filters.set(filters);
		}
	}

	// Other filtering functions
	function filterByUser(user) {
		$$invalidate(3, currentUser = user);
		$$invalidate(0, rootScope.currentUserFilter = user, rootScope);
		applyFilterAdvanced();
	}

	function filterByAssignee(user) {
		$$invalidate(4, currentAssignee = user);
		$$invalidate(0, rootScope.currentAssigneeFilter = user, rootScope);
		applyFilterAdvanced();
	}

	function sortByLatest() {
		$$invalidate(9, sortByProperty = rootScope.labels.latest);
		$$invalidate(0, rootScope.sortByProperty = rootScope.labels.latest, rootScope);
		applyFilterAdvanced();
	}

	function sortByName() {
		$$invalidate(9, sortByProperty = rootScope.labels.name);
		$$invalidate(0, rootScope.sortByProperty = rootScope.labels.name, rootScope);
		applyFilterAdvanced();
	}

	function allstatus() {
		$$invalidate(0, rootScope.filterByPublishedGuides = rootScope.labels.all, rootScope);
		$$invalidate(5, filterByPublishedGuides = rootScope.labels.all);
		applyFilterAdvanced();
	}

	function publishedGuidesAdvance() {
		$$invalidate(5, filterByPublishedGuides = rootScope.labels.published);
		$$invalidate(0, rootScope.filterByPublishedGuides = rootScope.labels.published, rootScope);
		applyFilterAdvanced();
	}

	function unpublishedGuides() {
		$$invalidate(0, rootScope.filterByPublishedGuides = rootScope.labels.unpublished, rootScope);
		$$invalidate(5, filterByPublishedGuides = rootScope.labels.unpublished);
		applyFilterAdvanced();
	}

	// new filter
	if (!rootScope.isUserRole() && GmCXt.FT.quickFilters) {
		if (rootScope.myGuidesFilter) currentUser = { ...rootScope.user }; else if (rootScope.currentUserFilter) currentUser = rootScope.currentUserFilter; else currentUser = allUser;
		if (rootScope.filterByPublishedGuides) filterByPublishedGuides = rootScope.filterByPublishedGuides; else filterByPublishedGuides = rootScope.labels.all;
		if (rootScope.currentAssigneeFilter) currentAssignee = rootScope.currentAssigneeFilter; else currentAssignee = allUser;
	}

	const labelSubscriber = Gm.labels.subscribe(value => {
		$$invalidate(11, labels = value);
	});

	onMount(() => {
		// if (currentView == 'search-page') {
		if (GmCXt.FT.creatorApp && !rootScope.isUserRole()) {
			getUserList();
		}
	});

	onDestroy(() => {
		currentPageSubscriber();
		labelSubscriber();
		hideSearchFilterDropdown();
		routeActionSubscriber();
	});

	const click_handler = () => rootScope.openTaskList();
	const click_handler_1 = () => selectSearchFilterOption('atoz');
	const click_handler_2 = () => selectSearchFilterOption('ztoa');
	const click_handler_3 = () => selectSearchFilterOption('recent');
	const click_handler_4 = () => selectSearchFilterOption('older');
	const click_handler_5 = () => selectSearchFilterOption('');
	const click_handler_6 = () => filterByUser(rootScope.user);
	const click_handler_7 = () => filterByUser(allUser);
	const click_handler_8 = user => filterByUser(user);
	const click_handler_9 = event => showGuidesFiltersDropdown('user');
	const click_handler_10 = event => showGuidesFiltersDropdown(rootScope.labels.published);
	const click_handler_11 = () => filterByAssignee(rootScope.user);
	const click_handler_12 = () => filterByAssignee(allUser);
	const click_handler_13 = user => filterByAssignee(user);
	const click_handler_14 = event => showGuidesFiltersDropdown('assignee');
	const click_handler_15 = event => showGuidesFiltersDropdown('sort');

	return [
		rootScope,
		currentPage,
		allUser,
		currentUser,
		currentAssignee,
		filterByPublishedGuides,
		activeSortFilter,
		searchFilterDropDownVisible,
		isTaskListVisible,
		sortByProperty,
		userList,
		labels,
		searchFilterDropdown,
		selectSearchFilterOption,
		toggleCurrentPage,
		toggleMyGuides,
		showGuidesFiltersDropdown,
		filterByUser,
		filterByAssignee,
		sortByLatest,
		sortByName,
		allstatus,
		publishedGuidesAdvance,
		unpublishedGuides,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		click_handler_6,
		click_handler_7,
		click_handler_8,
		click_handler_9,
		click_handler_10,
		click_handler_11,
		click_handler_12,
		click_handler_13,
		click_handler_14,
		click_handler_15
	];
}

class Filter extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$n, create_fragment$o, safe_not_equal, {}, null, [-1, -1]);
	}
}

/* src/components/TestMeWidget.svelte generated by Svelte v4.2.20 */

function add_css$3(target) {
	append_styles(target, "svelte-6eoq61", "dialog.svelte-6eoq61::backdrop{background:rgba(0, 0, 0, 0.3)}dialog[open].svelte-6eoq61{animation:svelte-6eoq61-zoom 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)}@keyframes svelte-6eoq61-zoom{from{transform:scale(0.95)}to{transform:scale(1)}}dialog[open].svelte-6eoq61::backdrop{animation:svelte-6eoq61-fade 0.2s ease-out}@keyframes svelte-6eoq61-fade{from{opacity:0}to{opacity:1}}button.svelte-6eoq61{display:block}");
}

// (62:0) {#if showTestMe}
function create_if_block$j(ctx) {
	let dialog_1;
	let wmgPlayerJSTest_17;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_0;
	let t0;
	let t1;
	let button0;
	let wmgPlayerJSTest_1;
	let raw0_value = rootScope.svgs.iconSearchClose + "";
	let t2;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;
	let t4;
	let wmgPlayerJSTest_16;
	let wmgPlayerJSTest_7;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_5;
	let t5;
	let t6_value = /*tour*/ ctx[1].tour_title + "";
	let t6;
	let t7;
	let wmgPlayerJSTest_14;
	let wmgPlayerJSTest_10;
	let wmgPlayerJSTest_8;
	let t8_value = rootScope.labels.firstStep + "";
	let t8;
	let t9;
	let html_tag;
	let raw1_value = /*newSteps*/ ctx[4][0].step_title + "";
	let t10;
	let wmgPlayerJSTest_9;
	let img0;
	let img0_src_value;
	let t11;
	let wmgPlayerJSTest_13;
	let wmgPlayerJSTest_11;
	let t12_value = rootScope.labels.lastStep + "";
	let t12;
	let t13;
	let html_tag_1;
	let raw2_value = /*newSteps*/ ctx[4][/*stepCount*/ ctx[6] - 1].step_title + "";
	let t14;
	let wmgPlayerJSTest_12;
	let img1;
	let img1_src_value;
	let t15;
	let wmgPlayerJSTest_15;
	let button1;
	let t17;
	let button2;
	let mounted;
	let dispose;

	return {
		c() {
			dialog_1 = element("dialog");
			wmgPlayerJSTest_17 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(/*testMe*/ ctx[3]);
			t1 = space();
			button0 = element("button");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2.textContent = `${rootScope.labels.close}`;
			t4 = space();
			wmgPlayerJSTest_16 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5.innerHTML = `<svg width="24px" height="30px" viewBox="0 0 24 30" version="1.1"><defs></defs><g id="Page-1" stroke="none" stroke-width="1" fill-rule="evenodd"><g id="clipboard" fill-rule="nonzero"><path d="M21.0913898,3.4972619 L18.2461695,3.4972619 L18.2461695,2.99767857 C18.2461695,2.44809524 17.7340339,1.99845238 17.1080678,1.99845238 L15.4009492,1.99845238 L15.4009492,1.49880952 C15.4009492,0.699404762 14.6612203,0 13.6938305,0 L10.2795254,0 C9.31213559,0 8.57240678,0.649464286 8.57240678,1.49880952 L8.57240678,1.99839286 L6.86528814,1.99839286 C6.23932203,1.99839286 5.72718644,2.44803571 5.72718644,2.99761905 L5.72718644,3.49720238 L2.8819661,3.49720238 C1.28861017,3.49720238 0.0367457627,4.59636905 0.0367457627,5.9952381 L0.0367457627,27.4784524 C0.0367457627,28.877381 1.28867797,29.9764881 2.8819661,29.9764881 L21.0914576,29.9764881 C22.6848136,29.9764881 23.936678,28.8773214 23.936678,27.4784524 L23.936678,5.99529762 C23.936678,4.64636905 22.6847458,3.4972619 21.0913898,3.4972619 Z M6.86522034,3.99690476 L6.86522034,2.99767857 L9.14142373,2.99767857 C9.48284746,2.99767857 9.71044068,2.79785714 9.71044068,2.49809524 L9.71044068,1.49880952 C9.71044068,1.19904762 9.9380339,0.99922619 10.2794576,0.99922619 L13.6937627,0.99922619 C14.0351864,0.99922619 14.2627797,1.19904762 14.2627797,1.49880952 L14.2627797,2.49803571 C14.2627797,2.79779762 14.4903729,2.99761905 14.8317966,2.99761905 L17.108,2.99761905 L17.108,6.49488095 L6.86522034,6.49488095 L6.86522034,3.99690476 Z M18.2461695,25.480119 L5.72711864,25.480119 C5.38569492,25.480119 5.15810169,25.2802976 5.15810169,24.9805357 C5.15810169,24.6807738 5.38569492,24.4809524 5.72711864,24.4809524 L18.2461695,24.4809524 C18.5875932,24.4809524 18.8151864,24.6807738 18.8151864,24.9805357 C18.8151864,25.2802976 18.5875932,25.480119 18.2461695,25.480119 Z M18.2461695,20.983631 L5.72711864,20.983631 C5.38569492,20.983631 5.15810169,20.7838095 5.15810169,20.4840476 C5.15810169,20.1842857 5.38569492,19.9844643 5.72711864,19.9844643 L18.2461695,19.9844643 C18.5875932,19.9844643 18.8151864,20.1842857 18.8151864,20.4840476 C18.8152542,20.78375 18.5875932,20.983631 18.2461695,20.983631 Z M18.2461695,16.4871429 L5.72711864,16.4871429 C5.38569492,16.4871429 5.15810169,16.2873214 5.15810169,15.9875595 C5.15810169,15.6877976 5.38569492,15.4879762 5.72711864,15.4879762 L18.2461695,15.4879762 C18.5875932,15.4879762 18.8151864,15.6877976 18.8151864,15.9875595 C18.8151864,16.2873214 18.5875932,16.4871429 18.2461695,16.4871429 Z M18.2461695,11.9906548 L5.72711864,11.9906548 C5.38569492,11.9906548 5.15810169,11.7908333 5.15810169,11.4910714 C5.15810169,11.1913095 5.38569492,10.9914881 5.72711864,10.9914881 L18.2461695,10.9914881 C18.5875932,10.9914881 18.8151864,11.1913095 18.8151864,11.4910714 C18.8151864,11.7908333 18.5875932,11.9906548 18.2461695,11.9906548 Z" class="shape"></path></g></g></svg>`;
			t5 = space();
			t6 = text(t6_value);
			t7 = space();
			wmgPlayerJSTest_14 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_10 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			t8 = text(t8_value);
			t9 = text(": ");
			html_tag = new HtmlTag(false);
			t10 = space();
			wmgPlayerJSTest_9 = element("wmgPlayerJSTest_");
			img0 = element("img");
			t11 = space();
			wmgPlayerJSTest_13 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_11 = element("wmgPlayerJSTest_");
			t12 = text(t12_value);
			t13 = text(": ");
			html_tag_1 = new HtmlTag(false);
			t14 = space();
			wmgPlayerJSTest_12 = element("wmgPlayerJSTest_");
			img1 = element("img");
			t15 = space();
			wmgPlayerJSTest_15 = element("wmgPlayerJSTest_");
			button1 = element("button");
			button1.textContent = `${rootScope.labels.startTest}`;
			t17 = space();
			button2 = element("button");
			button2.textContent = `${rootScope.labels.close}`;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_popup-test-me-title");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_ege-inline-block-vt");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left");
			attr(button0, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_popup-test-me-close svelte-6eoq61");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_popup-test-me-header");
			attr(wmgPlayerJSTest_5, "class", "tour-play-icon-test-me mgPlayerJSTest_ege-inline-block-vm");
			attr(wmgPlayerJSTest_6, "class", "tour-title-wrapper mgPlayerJSTest_ege-inline-block-vt");
			set_style(wmgPlayerJSTest_6, "padding", "20px");
			attr(wmgPlayerJSTest_7, "class", "tour-details-container");
			html_tag.a = null;
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_preview-step-first-title");
			attr(img0, "class", "step-image mgPlayerJSTest_custom-image");
			if (!src_url_equal(img0.src, img0_src_value = /*newSteps*/ ctx[4][0].screen_url + GmCXt.getCdnSign())) attr(img0, "src", img0_src_value);
			attr(img0, "alt", "test");
			attr(wmgPlayerJSTest_9, "class", "image-preview-step-first");
			attr(wmgPlayerJSTest_10, "class", "mgPlayerJSTest_preview-step-first-wrapper");
			html_tag_1.a = null;
			attr(wmgPlayerJSTest_11, "class", "mgPlayerJSTest_preview-step-last-title");
			attr(img1, "class", "step-image mgPlayerJSTest_custom-image");
			if (!src_url_equal(img1.src, img1_src_value = /*newSteps*/ ctx[4][/*stepCount*/ ctx[6] - 1].screen_url + GmCXt.getCdnSign())) attr(img1, "src", img1_src_value);
			attr(img1, "alt", "test");
			attr(wmgPlayerJSTest_12, "class", "image-preview-step-last");
			attr(wmgPlayerJSTest_13, "class", "mgPlayerJSTest_preview-step-last-wrapper");
			attr(wmgPlayerJSTest_14, "class", "step-preview-container");
			attr(button1, "class", "mgPlayerJSTest_btn-default mgPlayerJSTest_inline-block-vt svelte-6eoq61");
			attr(button2, "class", "mgPlayerJSTest_btn-default mgPlayerJSTest_btn-neutral mgPlayerJSTest_inline-block-vt svelte-6eoq61");
			attr(wmgPlayerJSTest_15, "class", "test-me-btn-action mgPlayerJSTest_display-flex mgPlayerJSTest_justify-content-center mgPlayerJSTest_padding-tb-15");
			attr(wmgPlayerJSTest_16, "class", "mgPlayerJSTest_popup-test-me-container");
			attr(wmgPlayerJSTest_17, "class", "mgPlayerJSTest_popup-test-me-preview");
			toggle_class(wmgPlayerJSTest_17, "mgPlayerJSTest_accessibility-theme", GmCXt.accessibility);
			attr(dialog_1, "id", "svelte-notification-modal");
			attr(dialog_1, "class", "svelte-6eoq61");
		},
		m(target, anchor) {
			insert(target, dialog_1, anchor);
			append(dialog_1, wmgPlayerJSTest_17);
			append(wmgPlayerJSTest_17, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_4, t1);
			append(wmgPlayerJSTest_4, button0);
			append(button0, wmgPlayerJSTest_1);
			wmgPlayerJSTest_1.innerHTML = raw0_value;
			append(button0, t2);
			append(button0, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_17, t4);
			append(wmgPlayerJSTest_17, wmgPlayerJSTest_16);
			append(wmgPlayerJSTest_16, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_6, t5);
			append(wmgPlayerJSTest_6, t6);
			append(wmgPlayerJSTest_16, t7);
			append(wmgPlayerJSTest_16, wmgPlayerJSTest_14);
			append(wmgPlayerJSTest_14, wmgPlayerJSTest_10);
			append(wmgPlayerJSTest_10, wmgPlayerJSTest_8);
			append(wmgPlayerJSTest_8, t8);
			append(wmgPlayerJSTest_8, t9);
			html_tag.m(raw1_value, wmgPlayerJSTest_8);
			append(wmgPlayerJSTest_10, t10);
			append(wmgPlayerJSTest_10, wmgPlayerJSTest_9);
			append(wmgPlayerJSTest_9, img0);
			append(wmgPlayerJSTest_14, t11);
			append(wmgPlayerJSTest_14, wmgPlayerJSTest_13);
			append(wmgPlayerJSTest_13, wmgPlayerJSTest_11);
			append(wmgPlayerJSTest_11, t12);
			append(wmgPlayerJSTest_11, t13);
			html_tag_1.m(raw2_value, wmgPlayerJSTest_11);
			append(wmgPlayerJSTest_13, t14);
			append(wmgPlayerJSTest_13, wmgPlayerJSTest_12);
			append(wmgPlayerJSTest_12, img1);
			append(wmgPlayerJSTest_16, t15);
			append(wmgPlayerJSTest_16, wmgPlayerJSTest_15);
			append(wmgPlayerJSTest_15, button1);
			append(wmgPlayerJSTest_15, t17);
			append(wmgPlayerJSTest_15, button2);
			/*dialog_1_binding*/ ctx[11](dialog_1);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*click_handler*/ ctx[9]),
					listen(button1, "click", /*click_handler_1*/ ctx[10]),
					listen(button2, "click", /*closeTestMe*/ ctx[8]),
					listen(dialog_1, "close", /*close_handler*/ ctx[12])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*testMe*/ 8) set_data(t0, /*testMe*/ ctx[3]);
			if (dirty & /*tour*/ 2 && t6_value !== (t6_value = /*tour*/ ctx[1].tour_title + "")) set_data(t6, t6_value);
			if (dirty & /*newSteps*/ 16 && raw1_value !== (raw1_value = /*newSteps*/ ctx[4][0].step_title + "")) html_tag.p(raw1_value);

			if (dirty & /*newSteps*/ 16 && !src_url_equal(img0.src, img0_src_value = /*newSteps*/ ctx[4][0].screen_url + GmCXt.getCdnSign())) {
				attr(img0, "src", img0_src_value);
			}

			if (dirty & /*newSteps*/ 16 && raw2_value !== (raw2_value = /*newSteps*/ ctx[4][/*stepCount*/ ctx[6] - 1].step_title + "")) html_tag_1.p(raw2_value);

			if (dirty & /*newSteps*/ 16 && !src_url_equal(img1.src, img1_src_value = /*newSteps*/ ctx[4][/*stepCount*/ ctx[6] - 1].screen_url + GmCXt.getCdnSign())) {
				attr(img1, "src", img1_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(dialog_1);
			}

			/*dialog_1_binding*/ ctx[11](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$n(ctx) {
	let if_block_anchor;
	let if_block = /*showTestMe*/ ctx[0] && create_if_block$j(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*showTestMe*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$j(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function resetMplayerPos() {
	if (GmCXt.isMicroPlayer()) {
		mg$('.mgPlayerJSTest_ege-panel').removeAttr('style');
		GmCXt.resetMplayerPos();
	}
}

function instance$m($$self, $$props, $$invalidate) {
	let { showTestMe } = $$props;
	let { tour } = $$props;
	let dialog; // HTMLDialogElement
	let testMe;

	let newSteps = tour.steps.filter(function (el) {
		return el.step_type === 'inline';
	});

	const stepCount = newSteps.length;
	newSteps[0].step_title = mg$('<span />').html(newSteps[0].step_title).text();
	newSteps[stepCount - 1].step_title = mg$('<span />').html(newSteps[stepCount - 1].step_title).text();
	let data = {};
	data.tour = tour;
	var appSetting = GmCXt.getAppSetting();

	if (appSetting && appSetting.userLabels && appSetting.userLabels.testMe) {
		testMe = appSetting.userLabels.testMe;
	} else {
		testMe = 'TestMe';
	}

	GmCXt.increaseSidePanelWidth();

	function startTest(data) {
		rootScope.closeAppPopup();
		$$invalidate(0, showTestMe = false);
		resetMplayerPos();
		let m = { data };
		GmCXt.handleStartTest(m);
	}

	function closeTestMe() {
		$$invalidate(0, showTestMe = false);
		dialog.close();
	}

	const click_handler = () => dialog.close();
	const click_handler_1 = () => startTest(data);

	function dialog_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			dialog = $$value;
			$$invalidate(2, dialog);
		});
	}

	const close_handler = () => $$invalidate(0, showTestMe = false);

	$$self.$$set = $$props => {
		if ('showTestMe' in $$props) $$invalidate(0, showTestMe = $$props.showTestMe);
		if ('tour' in $$props) $$invalidate(1, tour = $$props.tour);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*dialog, showTestMe*/ 5) {
			if (dialog && showTestMe) dialog.showModal();
		}
	};

	return [
		showTestMe,
		tour,
		dialog,
		testMe,
		newSteps,
		data,
		stepCount,
		startTest,
		closeTestMe,
		click_handler,
		click_handler_1,
		dialog_1_binding,
		close_handler
	];
}

class TestMeWidget extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$m, create_fragment$n, safe_not_equal, { showTestMe: 0, tour: 1 }, add_css$3);
	}
}

/* src/components/DownloadMedia.svelte generated by Svelte v4.2.20 */

function create_if_block$i(ctx) {
	let button;
	let wmgPlayerJSTest_;
	let raw_value = /*rootScope*/ ctx[1].svgs.guideViewDownload + "";
	let t;
	let mounted;
	let dispose;
	let if_block = /*tour*/ ctx[0].media_files && create_if_block_1$h(ctx);

	return {
		c() {
			button = element("button");
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = space();
			if (if_block) if_block.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_download-icon mgPlayerJSTest_inline-block-vm");
			attr(button, "id", "mgPlayerJSTest_icon-tour-download");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_header-detail-view-tour-download-wrapper mgPlayerJSTest_header-icon-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center");
			attr(button, "aria-label", "tour download dropdown");
			toggle_class(button, "mgPlayerJSTest_disabled", !/*tour*/ ctx[0].is_published);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, wmgPlayerJSTest_);
			wmgPlayerJSTest_.innerHTML = raw_value;
			append(button, t);
			if (if_block) if_block.m(button, null);

			if (!mounted) {
				dispose = listen(button, "click", stop_propagation(/*showDownloadTourActionDropdown*/ ctx[4]));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 2 && raw_value !== (raw_value = /*rootScope*/ ctx[1].svgs.guideViewDownload + "")) wmgPlayerJSTest_.innerHTML = raw_value;
			if (/*tour*/ ctx[0].media_files) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$h(ctx);
					if_block.c();
					if_block.m(button, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*tour*/ 1) {
				toggle_class(button, "mgPlayerJSTest_disabled", !/*tour*/ ctx[0].is_published);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (173:3) {#if tour.media_files}
function create_if_block_1$h(ctx) {
	let wmgPlayerJSTest_;

	function select_block_type(ctx, dirty) {
		if (/*tour*/ ctx[0].media_files.length) return create_if_block_2$g;
		return create_else_block$a;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if_block.c();
			attr(wmgPlayerJSTest_, "id", "detail-view-download-options");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_detail-download-action-options-dropdown");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if_block.m(wmgPlayerJSTest_, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(wmgPlayerJSTest_, null);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if_block.d();
		}
	};
}

// (299:5) {:else}
function create_else_block$a(ctx) {
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let img;
	let img_src_value;
	let t0;
	let wmgPlayerJSTest_1;
	let t1_value = /*rootScope*/ ctx[1].labels.pleaseWait + "";
	let t1;
	let t2;
	let wmgPlayerJSTest_2;
	let t3_value = /*rootScope*/ ctx[1].labels.mediaDownloadMsg + "";
	let t3;
	let t4;
	let a;
	let t5_value = /*rootScope*/ ctx[1].labels.close + "";
	let t5;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			img = element("img");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			t2 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t3 = text(t3_value);
			t4 = space();
			a = element("a");
			t5 = text(t5_value);
			attr(img, "class", "mgPlayerJSTest_max-width-height-100");
			if (!src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) attr(img, "src", img_src_value);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_media-progress-loader-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_font-size-18 mgPlayerJSTest_margin-tb-20");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_text-align-center");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_flex-direction-column mgPlayerJSTest_margin-tb-15");
			attr(a, "class", "mgPlayerJSTest_lbl-link mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_btn-default mgPlayerJSTest_btn-neutral");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_media-progress-container mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between mgPlayerJSTest_flex-direction-column mgPlayerJSTest_width-100 mgPlayerJSTest_height-100 mgPlayerJSTest_position-absolute mgPlayerJSTest_bg-white mgPlayerJSTest_z-index mgPlayerJSTest_z-index-2 mgPlayerJSTest_padding-15");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_4, anchor);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, img);
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t1);
			append(wmgPlayerJSTest_3, t2);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, t3);
			append(wmgPlayerJSTest_4, t4);
			append(wmgPlayerJSTest_4, a);
			append(a, t5);

			if (!mounted) {
				dispose = listen(a, "click", stop_propagation(/*closeMediaDownloadDropdown*/ ctx[5]));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 2 && !src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*rootScope*/ 2 && t1_value !== (t1_value = /*rootScope*/ ctx[1].labels.pleaseWait + "")) set_data(t1, t1_value);
			if (dirty & /*rootScope*/ 2 && t3_value !== (t3_value = /*rootScope*/ ctx[1].labels.mediaDownloadMsg + "")) set_data(t3, t3_value);
			if (dirty & /*rootScope*/ 2 && t5_value !== (t5_value = /*rootScope*/ ctx[1].labels.close + "")) set_data(t5, t5_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_4);
			}

			mounted = false;
			dispose();
		}
	};
}

// (175:5) {#if tour.media_files.length}
function create_if_block_2$g(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let show_if_3 = /*tour*/ ctx[0].media_files[0].gify && /*tour*/ ctx[0].tour_settings.downloadGuideFiles.gif_file && /*showMediafile*/ ctx[2](/*tour*/ ctx[0]) && !GmCXt.isOnboarding(/*tour*/ ctx[0]);
	let t4;
	let t5;
	let show_if_2 = /*tour*/ ctx[0].media_files[0].doc && /*tour*/ ctx[0].tour_settings.downloadGuideFiles.word_file && /*showMediafile*/ ctx[2](/*tour*/ ctx[0]);
	let t6;
	let t7;
	let show_if_1 = /*tour*/ ctx[0].media_files[0].blog && /*tour*/ ctx[0].tour_settings.downloadGuideFiles.blog_file && /*showMediafile*/ ctx[2](/*tour*/ ctx[0]) && !GmCXt.isOnboarding(/*tour*/ ctx[0]);
	let t8;
	let t9;
	let show_if = /*tour*/ ctx[0].media_files[0].text && /*tour*/ ctx[0].tour_settings.downloadGuideFiles.text_file && /*showMediafile*/ ctx[2](/*tour*/ ctx[0]) && !GmCXt.isOnboarding(/*tour*/ ctx[0]);
	let if_block10_anchor;
	let if_block0 = /*tour*/ ctx[0].media_files[0].pdf && /*tour*/ ctx[0].tour_settings.downloadGuideFiles.pdf_file && create_if_block_18$4(ctx);
	let if_block1 = /*tour*/ ctx[0].tour_settings.downloadGuideFiles.pdf_file && create_if_block_17$4();
	let if_block2 = /*tour*/ ctx[0].media_files[0].ppt && /*tour*/ ctx[0].tour_settings.downloadGuideFiles.pptx_file && create_if_block_15$6(ctx);
	let if_block3 = /*tour*/ ctx[0].tour_settings.downloadGuideFiles.pptx_file && create_if_block_14$6();
	let if_block4 = show_if_3 && create_if_block_12$6(ctx);
	let if_block5 = /*tour*/ ctx[0].tour_settings.downloadGuideFiles.gif_file && create_if_block_11$8();
	let if_block6 = show_if_2 && create_if_block_9$9(ctx);
	let if_block7 = /*tour*/ ctx[0].tour_settings.downloadGuideFiles.word_file && create_if_block_8$a();
	let if_block8 = show_if_1 && create_if_block_6$b(ctx);
	let if_block9 = /*tour*/ ctx[0].tour_settings.downloadGuideFiles.blog_fil && create_if_block_5$c();
	let if_block10 = show_if && create_if_block_3$e(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			if (if_block4) if_block4.c();
			t4 = space();
			if (if_block5) if_block5.c();
			t5 = space();
			if (if_block6) if_block6.c();
			t6 = space();
			if (if_block7) if_block7.c();
			t7 = space();
			if (if_block8) if_block8.c();
			t8 = space();
			if (if_block9) if_block9.c();
			t9 = space();
			if (if_block10) if_block10.c();
			if_block10_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t2, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert(target, t3, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert(target, t4, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert(target, t5, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert(target, t6, anchor);
			if (if_block7) if_block7.m(target, anchor);
			insert(target, t7, anchor);
			if (if_block8) if_block8.m(target, anchor);
			insert(target, t8, anchor);
			if (if_block9) if_block9.m(target, anchor);
			insert(target, t9, anchor);
			if (if_block10) if_block10.m(target, anchor);
			insert(target, if_block10_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*tour*/ ctx[0].media_files[0].pdf && /*tour*/ ctx[0].tour_settings.downloadGuideFiles.pdf_file) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_18$4(ctx);
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*tour*/ ctx[0].tour_settings.downloadGuideFiles.pdf_file) {
				if (if_block1) ; else {
					if_block1 = create_if_block_17$4();
					if_block1.c();
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*tour*/ ctx[0].media_files[0].ppt && /*tour*/ ctx[0].tour_settings.downloadGuideFiles.pptx_file) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_15$6(ctx);
					if_block2.c();
					if_block2.m(t2.parentNode, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*tour*/ ctx[0].tour_settings.downloadGuideFiles.pptx_file) {
				if (if_block3) ; else {
					if_block3 = create_if_block_14$6();
					if_block3.c();
					if_block3.m(t3.parentNode, t3);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (dirty & /*tour*/ 1) show_if_3 = /*tour*/ ctx[0].media_files[0].gify && /*tour*/ ctx[0].tour_settings.downloadGuideFiles.gif_file && /*showMediafile*/ ctx[2](/*tour*/ ctx[0]) && !GmCXt.isOnboarding(/*tour*/ ctx[0]);

			if (show_if_3) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_12$6(ctx);
					if_block4.c();
					if_block4.m(t4.parentNode, t4);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (/*tour*/ ctx[0].tour_settings.downloadGuideFiles.gif_file) {
				if (if_block5) ; else {
					if_block5 = create_if_block_11$8();
					if_block5.c();
					if_block5.m(t5.parentNode, t5);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (dirty & /*tour*/ 1) show_if_2 = /*tour*/ ctx[0].media_files[0].doc && /*tour*/ ctx[0].tour_settings.downloadGuideFiles.word_file && /*showMediafile*/ ctx[2](/*tour*/ ctx[0]);

			if (show_if_2) {
				if (if_block6) {
					if_block6.p(ctx, dirty);
				} else {
					if_block6 = create_if_block_9$9(ctx);
					if_block6.c();
					if_block6.m(t6.parentNode, t6);
				}
			} else if (if_block6) {
				if_block6.d(1);
				if_block6 = null;
			}

			if (/*tour*/ ctx[0].tour_settings.downloadGuideFiles.word_file) {
				if (if_block7) ; else {
					if_block7 = create_if_block_8$a();
					if_block7.c();
					if_block7.m(t7.parentNode, t7);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}

			if (dirty & /*tour*/ 1) show_if_1 = /*tour*/ ctx[0].media_files[0].blog && /*tour*/ ctx[0].tour_settings.downloadGuideFiles.blog_file && /*showMediafile*/ ctx[2](/*tour*/ ctx[0]) && !GmCXt.isOnboarding(/*tour*/ ctx[0]);

			if (show_if_1) {
				if (if_block8) {
					if_block8.p(ctx, dirty);
				} else {
					if_block8 = create_if_block_6$b(ctx);
					if_block8.c();
					if_block8.m(t8.parentNode, t8);
				}
			} else if (if_block8) {
				if_block8.d(1);
				if_block8 = null;
			}

			if (/*tour*/ ctx[0].tour_settings.downloadGuideFiles.blog_fil) {
				if (if_block9) ; else {
					if_block9 = create_if_block_5$c();
					if_block9.c();
					if_block9.m(t9.parentNode, t9);
				}
			} else if (if_block9) {
				if_block9.d(1);
				if_block9 = null;
			}

			if (dirty & /*tour*/ 1) show_if = /*tour*/ ctx[0].media_files[0].text && /*tour*/ ctx[0].tour_settings.downloadGuideFiles.text_file && /*showMediafile*/ ctx[2](/*tour*/ ctx[0]) && !GmCXt.isOnboarding(/*tour*/ ctx[0]);

			if (show_if) {
				if (if_block10) {
					if_block10.p(ctx, dirty);
				} else {
					if_block10 = create_if_block_3$e(ctx);
					if_block10.c();
					if_block10.m(if_block10_anchor.parentNode, if_block10_anchor);
				}
			} else if (if_block10) {
				if_block10.d(1);
				if_block10 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(t2);
				detach(t3);
				detach(t4);
				detach(t5);
				detach(t6);
				detach(t7);
				detach(t8);
				detach(t9);
				detach(if_block10_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d(detaching);
			if (if_block2) if_block2.d(detaching);
			if (if_block3) if_block3.d(detaching);
			if (if_block4) if_block4.d(detaching);
			if (if_block5) if_block5.d(detaching);
			if (if_block6) if_block6.d(detaching);
			if (if_block7) if_block7.d(detaching);
			if (if_block8) if_block8.d(detaching);
			if (if_block9) if_block9.d(detaching);
			if (if_block10) if_block10.d(detaching);
		}
	};
}

// (176:6) {#if tour.media_files[0].pdf && tour.tour_settings.downloadGuideFiles.pdf_file}
function create_if_block_18$4(ctx) {
	let wmgPlayerJSTest_;
	let input;
	let input_value_value;
	let t;
	let mounted;
	let dispose;
	let if_block = (!/*tour*/ ctx[0].media_files[0].pdf || /*tour*/ ctx[0].media_files[0].pdf == '0') && create_if_block_19$4(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			input = element("input");
			t = space();
			if (if_block) if_block.c();
			attr(input, "type", "button");
			attr(input, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_detail-download-action-options-dropdown-item download-link mgPlayerJSTest_inline-block-vm mgPlayerJSTest_width-100");
			input.value = input_value_value = "" + (/*rootScope*/ ctx[1].labels.pdf + " (.pdf)");
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_tour-download-pdf");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, input);
			append(wmgPlayerJSTest_, t);
			if (if_block) if_block.m(wmgPlayerJSTest_, null);

			if (!mounted) {
				dispose = listen(input, "click", stop_propagation(function () {
					if (is_function(/*downloadFile*/ ctx[3]('tour_pdf_download', /*tour*/ ctx[0].media_files[0].pdf, /*tour*/ ctx[0]))) /*downloadFile*/ ctx[3]('tour_pdf_download', /*tour*/ ctx[0].media_files[0].pdf, /*tour*/ ctx[0]).apply(this, arguments);
				}));

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*rootScope*/ 2 && input_value_value !== (input_value_value = "" + (/*rootScope*/ ctx[1].labels.pdf + " (.pdf)"))) {
				input.value = input_value_value;
			}

			if (!/*tour*/ ctx[0].media_files[0].pdf || /*tour*/ ctx[0].media_files[0].pdf == '0') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_19$4(ctx);
					if_block.c();
					if_block.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (187:8) {#if !tour.media_files[0].pdf || tour.media_files[0].pdf == '0'}
function create_if_block_19$4(ctx) {
	let wmgPlayerJSTest_;
	let img;
	let img_src_value;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			img = element("img");
			attr(img, "class", "mgPlayerJSTest_max-width-height-100");
			if (!src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) attr(img, "src", img_src_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_media-progress-loader mgPlayerJSTest_margin-r-20");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, img);
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 2 && !src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (194:6) {#if tour.tour_settings.downloadGuideFiles.pdf_file}
function create_if_block_17$4(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_horizontal-line");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (197:6) {#if tour.media_files[0].ppt && tour.tour_settings.downloadGuideFiles.pptx_file}
function create_if_block_15$6(ctx) {
	let wmgPlayerJSTest_;
	let input;
	let input_value_value;
	let t;
	let mounted;
	let dispose;
	let if_block = (!/*tour*/ ctx[0].media_files[0].ppt || /*tour*/ ctx[0].media_files[0].ppt == '0') && create_if_block_16$5(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			input = element("input");
			t = space();
			if (if_block) if_block.c();
			attr(input, "type", "button");
			attr(input, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_detail-download-action-options-dropdown-item download-link mgPlayerJSTest_inline-block-vm mgPlayerJSTest_width-100");
			input.value = input_value_value = "" + (/*rootScope*/ ctx[1].labels.downloadPptx + " (.pptx)");
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_tour-download-pptx");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, input);
			append(wmgPlayerJSTest_, t);
			if (if_block) if_block.m(wmgPlayerJSTest_, null);

			if (!mounted) {
				dispose = listen(input, "click", stop_propagation(function () {
					if (is_function(/*downloadFile*/ ctx[3]('tour_ppt_download', /*tour*/ ctx[0].media_files[0].ppt, /*tour*/ ctx[0]))) /*downloadFile*/ ctx[3]('tour_ppt_download', /*tour*/ ctx[0].media_files[0].ppt, /*tour*/ ctx[0]).apply(this, arguments);
				}));

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*rootScope*/ 2 && input_value_value !== (input_value_value = "" + (/*rootScope*/ ctx[1].labels.downloadPptx + " (.pptx)"))) {
				input.value = input_value_value;
			}

			if (!/*tour*/ ctx[0].media_files[0].ppt || /*tour*/ ctx[0].media_files[0].ppt == '0') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_16$5(ctx);
					if_block.c();
					if_block.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (208:8) {#if !tour.media_files[0].ppt || tour.media_files[0].ppt == '0'}
function create_if_block_16$5(ctx) {
	let wmgPlayerJSTest_;
	let img;
	let img_src_value;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			img = element("img");
			attr(img, "class", "mgPlayerJSTest_max-width-height-100");
			if (!src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) attr(img, "src", img_src_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_media-progress-loader mgPlayerJSTest_margin-r-20");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, img);
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 2 && !src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (215:6) {#if tour.tour_settings.downloadGuideFiles.pptx_file}
function create_if_block_14$6(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_horizontal-line");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (218:6) {#if tour.media_files[0].gify && tour.tour_settings.downloadGuideFiles.gif_file && showMediafile(tour) && !GmCXt.isOnboarding(tour)}
function create_if_block_12$6(ctx) {
	let wmgPlayerJSTest_;
	let input;
	let input_value_value;
	let t;
	let mounted;
	let dispose;
	let if_block = (!/*tour*/ ctx[0].media_files[0].gify || /*tour*/ ctx[0].media_files[0].gify == '0') && create_if_block_13$6(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			input = element("input");
			t = space();
			if (if_block) if_block.c();
			attr(input, "type", "button");
			attr(input, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_detail-download-action-options-dropdown-item download-link mgPlayerJSTest_inline-block-vm mgPlayerJSTest_width-100");
			input.value = input_value_value = "" + (/*rootScope*/ ctx[1].labels.giphy + " (.gif)");
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_tour-download-gif");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, input);
			append(wmgPlayerJSTest_, t);
			if (if_block) if_block.m(wmgPlayerJSTest_, null);

			if (!mounted) {
				dispose = listen(input, "click", stop_propagation(function () {
					if (is_function(/*downloadFile*/ ctx[3]('tour_gif_download', /*tour*/ ctx[0].media_files[0].gify, /*tour*/ ctx[0]))) /*downloadFile*/ ctx[3]('tour_gif_download', /*tour*/ ctx[0].media_files[0].gify, /*tour*/ ctx[0]).apply(this, arguments);
				}));

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*rootScope*/ 2 && input_value_value !== (input_value_value = "" + (/*rootScope*/ ctx[1].labels.giphy + " (.gif)"))) {
				input.value = input_value_value;
			}

			if (!/*tour*/ ctx[0].media_files[0].gify || /*tour*/ ctx[0].media_files[0].gify == '0') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_13$6(ctx);
					if_block.c();
					if_block.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (229:8) {#if !tour.media_files[0].gify || tour.media_files[0].gify == '0'}
function create_if_block_13$6(ctx) {
	let wmgPlayerJSTest_;
	let img;
	let img_src_value;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			img = element("img");
			attr(img, "class", "mgPlayerJSTest_max-width-height-100");
			if (!src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) attr(img, "src", img_src_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_media-progress-loader mgPlayerJSTest_margin-r-20");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, img);
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 2 && !src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (236:6) {#if tour.tour_settings.downloadGuideFiles.gif_file}
function create_if_block_11$8(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_horizontal-line");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (239:6) {#if tour.media_files[0].doc && tour.tour_settings.downloadGuideFiles.word_file && showMediafile(tour)}
function create_if_block_9$9(ctx) {
	let wmgPlayerJSTest_;
	let input;
	let input_value_value;
	let t;
	let mounted;
	let dispose;
	let if_block = (!/*tour*/ ctx[0].media_files[0].doc || /*tour*/ ctx[0].media_files[0].doc == '0') && create_if_block_10$8(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			input = element("input");
			t = space();
			if (if_block) if_block.c();
			attr(input, "type", "button");
			attr(input, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_detail-download-action-options-dropdown-item download-link mgPlayerJSTest_inline-block-vm mgPlayerJSTest_width-100");
			input.value = input_value_value = "" + (/*rootScope*/ ctx[1].labels.downloadWord + " (.docx)");
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_tour-download-docx");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, input);
			append(wmgPlayerJSTest_, t);
			if (if_block) if_block.m(wmgPlayerJSTest_, null);

			if (!mounted) {
				dispose = listen(input, "click", stop_propagation(function () {
					if (is_function(/*downloadFile*/ ctx[3]('tour_word_download', /*tour*/ ctx[0].media_files[0].doc, /*tour*/ ctx[0]))) /*downloadFile*/ ctx[3]('tour_word_download', /*tour*/ ctx[0].media_files[0].doc, /*tour*/ ctx[0]).apply(this, arguments);
				}));

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*rootScope*/ 2 && input_value_value !== (input_value_value = "" + (/*rootScope*/ ctx[1].labels.downloadWord + " (.docx)"))) {
				input.value = input_value_value;
			}

			if (!/*tour*/ ctx[0].media_files[0].doc || /*tour*/ ctx[0].media_files[0].doc == '0') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_10$8(ctx);
					if_block.c();
					if_block.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (250:8) {#if !tour.media_files[0].doc || tour.media_files[0].doc == '0'}
function create_if_block_10$8(ctx) {
	let wmgPlayerJSTest_;
	let img;
	let img_src_value;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			img = element("img");
			attr(img, "class", "mgPlayerJSTest_max-width-height-100");
			if (!src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) attr(img, "src", img_src_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_media-progress-loader mgPlayerJSTest_margin-r-20");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, img);
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 2 && !src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (257:6) {#if tour.tour_settings.downloadGuideFiles.word_file}
function create_if_block_8$a(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_horizontal-line");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (260:6) {#if tour.media_files[0].blog && tour.tour_settings.downloadGuideFiles.blog_file && showMediafile(tour) && !GmCXt.isOnboarding(tour)}
function create_if_block_6$b(ctx) {
	let wmgPlayerJSTest_;
	let input;
	let input_value_value;
	let t;
	let mounted;
	let dispose;
	let if_block = (!/*tour*/ ctx[0].media_files[0].blog || /*tour*/ ctx[0].media_files[0].blog == '0') && create_if_block_7$a(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			input = element("input");
			t = space();
			if (if_block) if_block.c();
			attr(input, "type", "button");
			attr(input, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_detail-download-action-options-dropdown-item download-link mgPlayerJSTest_inline-block-vm mgPlayerJSTest_width-100");
			input.value = input_value_value = "" + (/*rootScope*/ ctx[1].labels.downloadBlog + " (.html)");
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_tour-download-html");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, input);
			append(wmgPlayerJSTest_, t);
			if (if_block) if_block.m(wmgPlayerJSTest_, null);

			if (!mounted) {
				dispose = listen(input, "click", stop_propagation(function () {
					if (is_function(/*downloadFile*/ ctx[3]('tour_blog_download', /*tour*/ ctx[0].media_files[0].blog, /*tour*/ ctx[0]))) /*downloadFile*/ ctx[3]('tour_blog_download', /*tour*/ ctx[0].media_files[0].blog, /*tour*/ ctx[0]).apply(this, arguments);
				}));

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*rootScope*/ 2 && input_value_value !== (input_value_value = "" + (/*rootScope*/ ctx[1].labels.downloadBlog + " (.html)"))) {
				input.value = input_value_value;
			}

			if (!/*tour*/ ctx[0].media_files[0].blog || /*tour*/ ctx[0].media_files[0].blog == '0') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_7$a(ctx);
					if_block.c();
					if_block.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (271:8) {#if !tour.media_files[0].blog || tour.media_files[0].blog == '0'}
function create_if_block_7$a(ctx) {
	let wmgPlayerJSTest_;
	let img;
	let img_src_value;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			img = element("img");
			attr(img, "class", "mgPlayerJSTest_max-width-height-100");
			if (!src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) attr(img, "src", img_src_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_media-progress-loader mgPlayerJSTest_margin-r-20");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, img);
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 2 && !src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (278:6) {#if tour.tour_settings.downloadGuideFiles.blog_fil}
function create_if_block_5$c(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_horizontal-line");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (281:6) {#if tour.media_files[0].text && tour.tour_settings.downloadGuideFiles.text_file && showMediafile(tour) && !GmCXt.isOnboarding(tour)}
function create_if_block_3$e(ctx) {
	let wmgPlayerJSTest_;
	let input;
	let input_value_value;
	let t;
	let mounted;
	let dispose;
	let if_block = (!/*tour*/ ctx[0].media_files[0].text || /*tour*/ ctx[0].media_files[0].text == '0') && create_if_block_4$d(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			input = element("input");
			t = space();
			if (if_block) if_block.c();
			attr(input, "type", "button");
			attr(input, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_detail-download-action-options-dropdown-item download-link mgPlayerJSTest_inline-block-vm mgPlayerJSTest_width-100");
			input.value = input_value_value = "" + (/*rootScope*/ ctx[1].labels.downloadTxt + " (.txt)");
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_tour-download-txt");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, input);
			append(wmgPlayerJSTest_, t);
			if (if_block) if_block.m(wmgPlayerJSTest_, null);

			if (!mounted) {
				dispose = listen(input, "click", stop_propagation(function () {
					if (is_function(/*downloadFile*/ ctx[3]('', /*tour*/ ctx[0].media_files[0].text, /*tour*/ ctx[0]))) /*downloadFile*/ ctx[3]('', /*tour*/ ctx[0].media_files[0].text, /*tour*/ ctx[0]).apply(this, arguments);
				}));

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*rootScope*/ 2 && input_value_value !== (input_value_value = "" + (/*rootScope*/ ctx[1].labels.downloadTxt + " (.txt)"))) {
				input.value = input_value_value;
			}

			if (!/*tour*/ ctx[0].media_files[0].text || /*tour*/ ctx[0].media_files[0].text == '0') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4$d(ctx);
					if_block.c();
					if_block.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (292:8) {#if !tour.media_files[0].text || tour.media_files[0].text == '0'}
function create_if_block_4$d(ctx) {
	let wmgPlayerJSTest_;
	let img;
	let img_src_value;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			img = element("img");
			attr(img, "class", "mgPlayerJSTest_max-width-height-100");
			if (!src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) attr(img, "src", img_src_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_media-progress-loader mgPlayerJSTest_margin-r-20");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, img);
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 2 && !src_url_equal(img.src, img_src_value = "" + (/*rootScope*/ ctx[1].staticContentPath + "loader_hourglass.gif"))) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

function create_fragment$m(ctx) {
	let wmgPlayerJSTest_;
	let show_if = /*showDownload*/ ctx[6](/*tour*/ ctx[0]);
	let if_block = show_if && create_if_block$i(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block) if_block.c();
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block) if_block.m(wmgPlayerJSTest_, null);
		},
		p(ctx, [dirty]) {
			if (dirty & /*tour*/ 1) show_if = /*showDownload*/ ctx[6](/*tour*/ ctx[0]);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$i(ctx);
					if_block.c();
					if_block.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block) if_block.d();
		}
	};
}

function instance$l($$self, $$props, $$invalidate) {
	let { tour } = $$props;

	const showMediafile = function (t) {
		if (!t) return false;
		let showMediafile = true;

		if (GmCXt.branchStepExist(t)) {
			showMediafile = false;
		}

		return showMediafile;
	};

	const hideDownload = function (tour) {
		return GmCXt.FT.isPlayer && rootScope.appConfig.customer === 'humana' || GmCXt.isFalseObj(tour.tour_settings.downloadGuideFiles);
	};

	const downloadFile = function (type, url, tour) {
		const cb = function (assetUrl) {
			if (assetUrl) url = assetUrl;
			downloadFileEvent(type, url);
		};

		let tempUrl = GmCXt.getUrlWithLang(url);
		url = url + GmCXt.getCdnSign();

		if (tour && !tour.tour_settings.translationEnable) {
			GmCXt.checkAssetUrl(url, url, cb);
		} else {
			GmCXt.checkAssetUrl(tempUrl, url, cb);
		}
	};

	const trackEvent = function (type) {
		switch (type) {
			case 'tour_video_download':
				GmCXt.trackerV1.trackGuideDownload(tour, 'video');
				break;
			case 'tour_pdf_download':
				GmCXt.trackerV1.trackGuideDownload(tour, 'pdf');
				break;
			case 'tour_ppt_download':
				GmCXt.trackerV1.trackGuideDownload(tour, 'ppt');
				break;
			case 'tour_gif_download':
				GmCXt.trackerV1.trackGuideDownload(tour, 'gif');
				break;
			case 'tour_word_download':
				GmCXt.trackerV1.trackGuideDownload(tour, 'docx');
				break;
			case 'tour_blog_download':
				GmCXt.trackerV1.trackGuideDownload(tour, 'html');
				break;
			default:
				GmCXt.trackerV1.trackGuideDownload(tour, 'txt');
				break;
		}
	};

	const downloadFileEvent = function (type, url) {
		let element = document.createElement('a');
		element.setAttribute('href', url);
		element.setAttribute('target', '_blank');
		element.style.display = 'none';
		document.body.appendChild(element);
		let event;

		//This is true only for IE,firefox
		if (document && document.createEvent && window) {
			// To create a mouse event , first we need to create an event and then initialize it.
			event = document.createEvent('MouseEvent');

			event.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
		} else {
			event = new MouseEvent('click',
			{
					view: window,
					bubbles: true,
					cancelable: true
				});
		}

		element.addEventListener(
			'click',
			function (e) {
				e.stopPropagation();
				document.body.removeChild(element);
				trackEvent(type);
			},
			false
		);

		element.dispatchEvent(event);
	};

	const showDownloadTourActionDropdown = function (event) {
		$$invalidate(1, rootScope.isMediaFileDropdown = false, rootScope);
		mg$('.mgPlayerJSTest_detail-view-action-options-dropdownn').slideUp(200);
		mg$('.mgPlayerJSTest_step-action-menu-options-dropdown').slideUp(200);
		rootScope.hideTourActionDropdown();
		closeMediaDownloadDropdown();
		$$invalidate(1, rootScope.isMediaFileDropdown = mg$(event.target).children('.mgPlayerJSTest_detail-download-action-options-dropdown').is(':visible'), rootScope);

		if (rootScope.isMediaFileDropdown) {
			mg$(event.target).children('.mgPlayerJSTest_detail-download-action-options-dropdown').slideUp(200);
			$$invalidate(1, rootScope.isMediaFileDropdown = false, rootScope);
		} else {
			mg$(event.target).children('.mgPlayerJSTest_detail-download-action-options-dropdown').slideDown(200);
			$$invalidate(1, rootScope.isMediaFileDropdown = true, rootScope);
			mg$(event.target).addClass('mgPlayerJSTest_dropdown-active');
			mg$(event.target).parents('.mgPlayerJSTest_tour-item').addClass('mgPlayerJSTest_z-index mgPlayerJSTest_z-index-10');
		}

		document.addEventListener('click', closeDropdownOnOutsideClick);
	};

	const closeMediaDownloadDropdown = function () {
		mg$('.mgPlayerJSTest_detail-download-action-options-dropdown').slideUp(200);
		mg$('.mgPlayerJSTest_tour-item').removeClass('mgPlayerJSTest_z-index mgPlayerJSTest_z-index-10');
		mg$('.mgPlayerJSTest_header-detail-view-tour-download-wrapper').removeClass('mgPlayerJSTest_dropdown-active');
	};

	const closeDropdownOnOutsideClick = function (event) {
		if (!mg$(event.target).closest('.mgPlayerJSTest_detail-download-action-options-dropdown').length) {
			mg$('.mgPlayerJSTest_detail-download-action-options-dropdown').slideUp(200);
			$$invalidate(1, rootScope.isMediaFileDropdown = false, rootScope);
			document.removeEventListener('click', closeDropdownOnOutsideClick);
		}
	};

	const showDownload = function (tour) {
		return (GmCXt.isGuide(tour) || rootScope.isTooltip(tour) && rootScope.createTooltipMediaFile || rootScope.isCADGuide(tour) || GmCXt.isOnboarding(tour) && tour.tour_settings.tutorial_tour_type === 'tutorial') && !hideDownload(tour) && rootScope.mediafileCreation && !(GmCXt.accessibility && GmCXt.FT.isPlayer);
	};

	onMount(() => {
		document.addEventListener('click', closeDropdownOnOutsideClick);
	});

	onDestroy(() => {
		document.removeEventListener('click', closeDropdownOnOutsideClick);
	});

	$$self.$$set = $$props => {
		if ('tour' in $$props) $$invalidate(0, tour = $$props.tour);
	};

	return [
		tour,
		rootScope,
		showMediafile,
		downloadFile,
		showDownloadTourActionDropdown,
		closeMediaDownloadDropdown,
		showDownload
	];
}

class DownloadMedia extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$l, create_fragment$m, safe_not_equal, { tour: 0 });
	}
}

/* src/components/TourView.svelte generated by Svelte v4.2.20 */

function create_if_block_30$1(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let t0;
	let wmgPlayerJSTest_1;
	let t1_value = rootScope.labels.draftGuide + "";
	let t1;
	let wmgPlayerJSTest_1_class_value;
	let wmgPlayerJSTest_2_id_value;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tour-draft-highlight");
			attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_tour-draft " + (/*tour*/ ctx[0].pin ? 'mgPlayerJSTest_tour-draft-pin' : ''));
			attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value = "tour-draft-" + /*tour*/ ctx[0].tour_id);
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_tour-draft-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t1);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*tour*/ 1 && wmgPlayerJSTest_1_class_value !== (wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_tour-draft " + (/*tour*/ ctx[0].pin ? 'mgPlayerJSTest_tour-draft-pin' : ''))) {
				attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value);
			}

			if (dirty[0] & /*tour*/ 1 && wmgPlayerJSTest_2_id_value !== (wmgPlayerJSTest_2_id_value = "tour-draft-" + /*tour*/ ctx[0].tour_id)) {
				attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}
		}
	};
}

// (309:2) {#if !isToolTip}
function create_if_block_14$5(ctx) {
	let wmgPlayerJSTest_1;
	let t0;
	let wmgPlayerJSTest_0;
	let t1;
	let t2;
	let wmgPlayerJSTest_0_id_value;
	let wmgPlayerJSTest_0_class_value;
	let wmgPlayerJSTest_1_class_value;
	let mounted;
	let dispose;
	let if_block0 = !/*isHelpArticle*/ ctx[6] && !/*defPlayAct*/ ctx[7] && create_if_block_26$1(ctx);
	let if_block1 = (/*isGuide*/ ctx[12] || /*isCADGuide*/ ctx[13] || /*isBotGuide*/ ctx[5] || /*isHelpArticle*/ ctx[6] || /*isTrackingGuide*/ ctx[14]) && create_if_block_19$3(ctx);
	let if_block2 = /*isOnboarding*/ ctx[11] && create_if_block_16$4(ctx);
	let if_block3 = /*showGuideBeacon*/ ctx[17] !== -1 && create_if_block_15$5();

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			attr(wmgPlayerJSTest_0, "id", wmgPlayerJSTest_0_id_value = "mgPlayerJSTest_icon-tour-play-" + /*tour*/ ctx[0].tour_id);

			attr(wmgPlayerJSTest_0, "class", wmgPlayerJSTest_0_class_value = "mgPlayerJSTest_ege-inline-block-vm tour-play-icon mgPlayerJSTest_playTourBtn active " + (/*tour*/ ctx[0].is_published
			? 'published-tour-icon'
			: '') + " " + (get_store_value(Gm.CurrentPage) != 'currentpage' && get_store_value(Gm.CurrentPage) != 'allguidesSearchPage' && get_store_value(Gm.activeView) !== 'findNReplace' && !/*category*/ ctx[24]?.is_published && /*tour*/ ctx[0]?.is_published
			? 'mgPlayerJSTest_published-category-tour-icon'
			: ''));

			attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_tour-play-action-wrapper mgPlayerJSTest_ege-inline-block-vm mgPlayerJSTest_position-relative " + (/*tour*/ ctx[0].is_published
			? 'activePublishedTourPlay'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			if (if_block1) if_block1.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t1);
			if (if_block2) if_block2.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t2);
			if (if_block3) if_block3.m(wmgPlayerJSTest_0, null);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_0, "click", /*click_handler_1*/ ctx[36]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!/*isHelpArticle*/ ctx[6] && !/*defPlayAct*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_26$1(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_1, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*isGuide*/ ctx[12] || /*isCADGuide*/ ctx[13] || /*isBotGuide*/ ctx[5] || /*isHelpArticle*/ ctx[6] || /*isTrackingGuide*/ ctx[14]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_19$3(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_0, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*isOnboarding*/ ctx[11]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_16$4(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_0, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*showGuideBeacon*/ ctx[17] !== -1) {
				if (if_block3) ; else {
					if_block3 = create_if_block_15$5();
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_0, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (dirty[0] & /*tour*/ 1 && wmgPlayerJSTest_0_id_value !== (wmgPlayerJSTest_0_id_value = "mgPlayerJSTest_icon-tour-play-" + /*tour*/ ctx[0].tour_id)) {
				attr(wmgPlayerJSTest_0, "id", wmgPlayerJSTest_0_id_value);
			}

			if (dirty[0] & /*tour*/ 1 && wmgPlayerJSTest_0_class_value !== (wmgPlayerJSTest_0_class_value = "mgPlayerJSTest_ege-inline-block-vm tour-play-icon mgPlayerJSTest_playTourBtn active " + (/*tour*/ ctx[0].is_published
			? 'published-tour-icon'
			: '') + " " + (get_store_value(Gm.CurrentPage) != 'currentpage' && get_store_value(Gm.CurrentPage) != 'allguidesSearchPage' && get_store_value(Gm.activeView) !== 'findNReplace' && !/*category*/ ctx[24]?.is_published && /*tour*/ ctx[0]?.is_published
			? 'mgPlayerJSTest_published-category-tour-icon'
			: ''))) {
				attr(wmgPlayerJSTest_0, "class", wmgPlayerJSTest_0_class_value);
			}

			if (dirty[0] & /*tour*/ 1 && wmgPlayerJSTest_1_class_value !== (wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_tour-play-action-wrapper mgPlayerJSTest_ege-inline-block-vm mgPlayerJSTest_position-relative " + (/*tour*/ ctx[0].is_published
			? 'activePublishedTourPlay'
			: ''))) {
				attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			mounted = false;
			dispose();
		}
	};
}

// (316:4) {#if !isHelpArticle && !defPlayAct}
function create_if_block_26$1(ctx) {
	let wmgPlayerJSTest_;
	let wmgPlayerJSTest_id_value;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if ((/*defaultPlayAction*/ ctx[8] === rootScope.playGuideMe || /*tour*/ ctx[0].tour_settings.defaultPlayAction === 'Default' && /*defPlayActAppSet*/ ctx[3] === rootScope.playGuideMe) && !/*isDesktopApp*/ ctx[10] && !/*isOnboarding*/ ctx[11]) return create_if_block_27$1;
		if (/*defaultPlayAction*/ ctx[8] === rootScope.playSlideshow || /*tour*/ ctx[0].tour_settings.defaultPlayAction === 'Default' && /*defPlayActAppSet*/ ctx[3] === rootScope.playSlideshow || /*isDesktopApp*/ ctx[10] || /*isOnboarding*/ ctx[11]) return create_if_block_28$1;
		if ((/*defaultPlayAction*/ ctx[8] === rootScope.playAuto || /*tour*/ ctx[0].tour_settings.defaultPlayAction === 'Default' && /*defPlayActAppSet*/ ctx[3] === rootScope.playAuto) && !/*isDesktopApp*/ ctx[10] && !/*isOnboarding*/ ctx[11]) return create_if_block_29$1;
		return create_else_block$9;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if_block.c();
			attr(wmgPlayerJSTest_, "id", wmgPlayerJSTest_id_value = "mgPlayerJSTest_title-tooltip-wrapper-" + /*tour*/ ctx[0].tour_id);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-right");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if_block.m(wmgPlayerJSTest_, null);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_, "click", /*click_handler*/ ctx[33]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(wmgPlayerJSTest_, null);
				}
			}

			if (dirty[0] & /*tour*/ 1 && wmgPlayerJSTest_id_value !== (wmgPlayerJSTest_id_value = "mgPlayerJSTest_title-tooltip-wrapper-" + /*tour*/ ctx[0].tour_id)) {
				attr(wmgPlayerJSTest_, "id", wmgPlayerJSTest_id_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (336:6) {:else}
function create_else_block$9(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_.textContent = `${rootScope.labels.guideMe}`;
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_tooltip-title mgPlayerJSTest_text-align-center");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (332:192) 
function create_if_block_29$1(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_.textContent = `${rootScope.labels.doItForMe}`;
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_tooltip-title mgPlayerJSTest_text-align-center");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (328:198) 
function create_if_block_28$1(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_.textContent = `${rootScope.labels.showMe}`;
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_tooltip-title mgPlayerJSTest_text-align-center");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (324:6) {#if (defaultPlayAction === rootScope.playGuideMe || (tour.tour_settings.defaultPlayAction === 'Default' && defPlayActAppSet === rootScope.playGuideMe)) && !isDesktopApp && !isOnboarding}
function create_if_block_27$1(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_.textContent = `${rootScope.labels.guideMe}`;
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_tooltip-title mgPlayerJSTest_text-align-center");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (360:5) {#if isGuide || isCADGuide || isBotGuide || isHelpArticle || isTrackingGuide}
function create_if_block_19$3(ctx) {
	let button;
	let show_if_4 = !/*isHelpArticle*/ ctx[6] && !/*isBotGuide*/ ctx[5] && /*tour*/ ctx[0].image_url.indexOf('default_icon') >= 0 && !/*isTrackingGuide*/ ctx[14];
	let t0;
	let show_if_3 = /*isMobileGuide*/ ctx[15] && /*tour*/ ctx[0].image_url.indexOf('default_icon') >= 0;
	let t1;
	let show_if_2 = /*isHelpArticle*/ ctx[6] && /*tour*/ ctx[0].image_url.indexOf('default_icon') >= 0;
	let t2;
	let show_if_1 = /*isTrackingGuide*/ ctx[14] && /*tour*/ ctx[0].image_url.indexOf('default_icon') >= 0;
	let t3;
	let t4;
	let show_if = !GmCXt.isEmpty(/*tour*/ ctx[0].image_url) && /*tour*/ ctx[0].image_url.indexOf('default_icon') === -1;
	let if_block0 = show_if_4 && create_if_block_25$2(ctx);
	let if_block1 = show_if_3 && create_if_block_24$2(ctx);
	let if_block2 = show_if_2 && create_if_block_23$2();
	let if_block3 = show_if_1 && create_if_block_22$2();
	let if_block4 = /*isBotGuide*/ ctx[5] && create_if_block_21$2();
	let if_block5 = show_if && create_if_block_20$3(ctx);

	return {
		c() {
			button = element("button");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			if (if_block4) if_block4.c();
			t4 = space();
			if (if_block5) if_block5.c();
			attr(button, "class", "mgPlayerJSTest_guide-icon-wrapper mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm mgPlayerJSTest_lbl-btn");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			if (if_block0) if_block0.m(button, null);
			append(button, t0);
			if (if_block1) if_block1.m(button, null);
			append(button, t1);
			if (if_block2) if_block2.m(button, null);
			append(button, t2);
			if (if_block3) if_block3.m(button, null);
			append(button, t3);
			if (if_block4) if_block4.m(button, null);
			append(button, t4);
			if (if_block5) if_block5.m(button, null);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*isHelpArticle, isBotGuide, tour, isTrackingGuide*/ 16481) show_if_4 = !/*isHelpArticle*/ ctx[6] && !/*isBotGuide*/ ctx[5] && /*tour*/ ctx[0].image_url.indexOf('default_icon') >= 0 && !/*isTrackingGuide*/ ctx[14];

			if (show_if_4) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_25$2(ctx);
					if_block0.c();
					if_block0.m(button, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*isMobileGuide, tour*/ 32769) show_if_3 = /*isMobileGuide*/ ctx[15] && /*tour*/ ctx[0].image_url.indexOf('default_icon') >= 0;

			if (show_if_3) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_24$2(ctx);
					if_block1.c();
					if_block1.m(button, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*isHelpArticle, tour*/ 65) show_if_2 = /*isHelpArticle*/ ctx[6] && /*tour*/ ctx[0].image_url.indexOf('default_icon') >= 0;

			if (show_if_2) {
				if (if_block2) ; else {
					if_block2 = create_if_block_23$2();
					if_block2.c();
					if_block2.m(button, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty[0] & /*isTrackingGuide, tour*/ 16385) show_if_1 = /*isTrackingGuide*/ ctx[14] && /*tour*/ ctx[0].image_url.indexOf('default_icon') >= 0;

			if (show_if_1) {
				if (if_block3) ; else {
					if_block3 = create_if_block_22$2();
					if_block3.c();
					if_block3.m(button, t3);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*isBotGuide*/ ctx[5]) {
				if (if_block4) ; else {
					if_block4 = create_if_block_21$2();
					if_block4.c();
					if_block4.m(button, t4);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (dirty[0] & /*tour*/ 1) show_if = !GmCXt.isEmpty(/*tour*/ ctx[0].image_url) && /*tour*/ ctx[0].image_url.indexOf('default_icon') === -1;

			if (show_if) {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block_20$3(ctx);
					if_block5.c();
					if_block5.m(button, null);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
		}
	};
}

// (362:7) {#if !isHelpArticle && !isBotGuide && tour.image_url.indexOf('default_icon') >= 0 && !isTrackingGuide}
function create_if_block_25$2(ctx) {
	let wmgPlayerJSTest_;
	let svg;
	let raw_value = /*createSvgElmnt*/ ctx[31]() + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			svg = svg_element("svg");
			attr(svg, "width", "40");
			attr(svg, "height", "40");
			attr(svg, "viewBox", "0 0 40 40");
			attr(svg, "fill", "none");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, svg);
			svg.innerHTML = raw_value;
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (369:7) {#if isMobileGuide && tour.image_url.indexOf('default_icon') >= 0}
function create_if_block_24$2(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = /*isMobileGuide*/ ctx[15];
		},
		p(ctx, dirty) {
			if (dirty[0] & /*isMobileGuide*/ 32768) wmgPlayerJSTest_.innerHTML = /*isMobileGuide*/ ctx[15];		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (372:7) {#if isHelpArticle && tour.image_url.indexOf('default_icon') >= 0}
function create_if_block_23$2(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.mobileGuide + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (375:7) {#if isTrackingGuide && tour.image_url.indexOf('default_icon') >= 0}
function create_if_block_22$2(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.insight + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (378:7) {#if isBotGuide}
function create_if_block_21$2(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.guide_bot_icon + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (383:7) {#if !GmCXt.isEmpty(tour.image_url) && tour.image_url.indexOf('default_icon') === -1}
function create_if_block_20$3(ctx) {
	let wmgPlayerJSTest_;
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			img = element("img");
			attr(img, "class", "mgPlayerJSTest_guide-upld-img mgPlayerJSTest_custom-image mgPlayerJSTest_width-height-100 mgPlayerJSTest_position-center mgPlayerJSTest_border-radius-50");
			if (!src_url_equal(img.src, img_src_value = /*tour*/ ctx[0].image_url + /*cdn*/ ctx[23])) attr(img, "src", img_src_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_guide-upld-img-wrapper mgPlayerJSTest_guide-pub-img-border mgPlayerJSTest_position-relative mgPlayerJSTest_border-radius-50");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, img);

			if (!mounted) {
				dispose = listen(img, "error", /*error_handler*/ ctx[34]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*tour, cdn*/ 8388609 && !src_url_equal(img.src, img_src_value = /*tour*/ ctx[0].image_url + /*cdn*/ ctx[23])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			dispose();
		}
	};
}

// (399:5) {#if isOnboarding}
function create_if_block_16$4(ctx) {
	let wmgPlayerJSTest_;
	let show_if_1 = /*tour*/ ctx[0].image_url.indexOf('default_icon') >= 0;
	let t;
	let show_if = !GmCXt.isEmpty(/*tour*/ ctx[0].image_url) && /*tour*/ ctx[0].image_url.indexOf('default_icon') == -1;
	let if_block0 = show_if_1 && create_if_block_18$3();
	let if_block1 = show_if && create_if_block_17$3(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_guide-icon-wrapper mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			if (if_block1) if_block1.m(wmgPlayerJSTest_, null);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*tour*/ 1) show_if_1 = /*tour*/ ctx[0].image_url.indexOf('default_icon') >= 0;

			if (show_if_1) {
				if (if_block0) ; else {
					if_block0 = create_if_block_18$3();
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*tour*/ 1) show_if = !GmCXt.isEmpty(/*tour*/ ctx[0].image_url) && /*tour*/ ctx[0].image_url.indexOf('default_icon') == -1;

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_17$3(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (401:7) {#if tour.image_url.indexOf('default_icon') >= 0}
function create_if_block_18$3(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.guide_onboarding + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (406:7) {#if !GmCXt.isEmpty(tour.image_url) && tour.image_url.indexOf('default_icon') == -1}
function create_if_block_17$3(ctx) {
	let wmgPlayerJSTest_;
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			img = element("img");
			attr(img, "class", "mgPlayerJSTest_guide-upld-img mgPlayerJSTest_custom-image mgPlayerJSTest_width-height-100 mgPlayerJSTest_position-center mgPlayerJSTest_border-radius-50");
			if (!src_url_equal(img.src, img_src_value = /*tour*/ ctx[0].image_url + /*cdn*/ ctx[23])) attr(img, "src", img_src_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_guide-upld-img-wrapper mgPlayerJSTest_guide-pub-img-border mgPlayerJSTest_position-relative mgPlayerJSTest_border-radius-50");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, img);

			if (!mounted) {
				dispose = listen(img, "error", /*error_handler_1*/ ctx[35]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*tour, cdn*/ 8388609 && !src_url_equal(img.src, img_src_value = /*tour*/ ctx[0].image_url + /*cdn*/ ctx[23])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			dispose();
		}
	};
}

// (421:5) {#if showGuideBeacon !== -1}
function create_if_block_15$5(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.guide_beacon + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_guide-beacon");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (430:2) {#if isToolTip}
function create_if_block_13$5(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.tooltipIcon + "";
	let wmgPlayerJSTest_0_class_value;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");

			attr(wmgPlayerJSTest_0, "class", wmgPlayerJSTest_0_class_value = "mgPlayerJSTest_inline-block-vt tour-play-icon active " + (/*tour*/ ctx[0].is_published ? 'published-tour' : '') + " " + (get_store_value(Gm.CurrentPage) != 'currentpage' && get_store_value(Gm.CurrentPage) != 'allguidesSearchPage' && get_store_value(Gm.activeView) !== 'findNReplace' && !/*category*/ ctx[24]?.is_published && /*tour*/ ctx[0]?.is_published
			? 'mgPlayerJSTest_published-category-tour-icon'
			: ''));

			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_guide-icon-wrapper mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*tour*/ 1 && wmgPlayerJSTest_0_class_value !== (wmgPlayerJSTest_0_class_value = "mgPlayerJSTest_inline-block-vt tour-play-icon active " + (/*tour*/ ctx[0].is_published ? 'published-tour' : '') + " " + (get_store_value(Gm.CurrentPage) != 'currentpage' && get_store_value(Gm.CurrentPage) != 'allguidesSearchPage' && get_store_value(Gm.activeView) !== 'findNReplace' && !/*category*/ ctx[24]?.is_published && /*tour*/ ctx[0]?.is_published
			? 'mgPlayerJSTest_published-category-tour-icon'
			: ''))) {
				attr(wmgPlayerJSTest_0, "class", wmgPlayerJSTest_0_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}
		}
	};
}

// (479:4) {#if tour.tour_title.length > 0 || tour.tour_description.length > 0}
function create_if_block_12$5(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let t0_value = /*tour*/ ctx[0].tour_title + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_1;
	let t2_value = /*tour*/ ctx[0].tour_description + "";
	let t2;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t2 = text(t2_value);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-right mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_2, t1);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*tour*/ 1 && t0_value !== (t0_value = /*tour*/ ctx[0].tour_title + "")) set_data(t0, t0_value);
			if (dirty[0] & /*tour*/ 1 && t2_value !== (t2_value = /*tour*/ ctx[0].tour_description + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}
		}
	};
}

// (486:3) {#if get(GmCXt.CurrentPage) === 'allguidesSearchPage'}
function create_if_block_11$7(ctx) {
	let wmgPlayerJSTest_1;
	let button;
	let t0;
	let wmgPlayerJSTest_0;
	let t1_value = /*tour*/ ctx[0].category_title + "";
	let t1;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			attr(button, "class", "mgPlayerJSTest_guide-category-title-icon mgPlayerJSTest_inline-block-vm mgPlayerJSTest_lbl-btn");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_guide-category-title mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_guide-description-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, button);
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t1);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*tour*/ 1 && t1_value !== (t1_value = /*tour*/ ctx[0].category_title + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}
		}
	};
}

// (499:2) {#if GmCXt.FT.isPlayer}
function create_if_block_5$b(ctx) {
	let wmgPlayerJSTest_;
	let show_if = /*showReplay*/ ctx[26]() || /*showResume*/ ctx[27]();
	let t0;
	let t1;
	let t2;
	let t3;
	let if_block0 = show_if && create_if_block_10$7(ctx);
	let if_block1 = /*showGuideMe*/ ctx[18] && create_if_block_9$8(ctx);
	let if_block2 = /*showShowMe*/ ctx[19] && create_if_block_8$9(ctx);
	let if_block3 = /*showTestMe*/ ctx[20] && create_if_block_7$9(ctx);
	let if_block4 = /*showDoItForMe*/ ctx[21] && create_if_block_6$a(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			if (if_block4) if_block4.c();

			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_guide-play-action-wrapper mgPlayerJSTest_inline-block-vm mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-flex-end mgPlayerJSTest_float-right mgPlayerJSTest_border-radius mgPlayerJSTest_border-radius-4px mgPlayerJSTest_border-rounded " + (rootScope.isMicroPlayer
			? 'mgPlayerJSTest_no-margin mgPlayerJSTest_border-rounded-left'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t0);
			if (if_block1) if_block1.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t1);
			if (if_block2) if_block2.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t2);
			if (if_block3) if_block3.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t3);
			if (if_block4) if_block4.m(wmgPlayerJSTest_, null);
		},
		p(ctx, dirty) {
			if (show_if) if_block0.p(ctx, dirty);

			if (/*showGuideMe*/ ctx[18]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_9$8(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*showShowMe*/ ctx[19]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_8$9(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*showTestMe*/ ctx[20]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_7$9(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_, t3);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*showDoItForMe*/ ctx[21]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_6$a(ctx);
					if_block4.c();
					if_block4.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
		}
	};
}

// (505:4) {#if showReplay() || showResume()}
function create_if_block_10$7(ctx) {
	let button;
	let wmgPlayerJSTest_0;

	let raw0_value = (/*showReplay*/ ctx[26]()
	? rootScope.svgs.replay_guide
	: rootScope.svgs.resume_guide) + "";
	let t;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;

	let raw1_value = (/*showReplay*/ ctx[26]()
	? rootScope.labels.replay
	: rootScope.labels.yesResume) + "";

	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");

			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_action-icon mgPlayerJSTest_position-center " + (/*showReplay*/ ctx[26]()
			? 'mgPlayerJSTest_action-icon-replay'
			: 'mgPlayerJSTest_action-icon-resume'));

			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left mgPlayerJSTest_margin-tb-15");
			attr(button, "id", "mgPlayerJSTest_guide-replay-resume-wrapper");
			attr(button, "class", "mgPlayerJSTest_guide-action-icon-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_border-radius-50 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer mgPlayerJSTest_lbl-btn");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw0_value;
			append(button, t);
			append(button, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			wmgPlayerJSTest_1.innerHTML = raw1_value;

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(/*showReplay*/ ctx[26]()
					? rootScope.play(/*tour*/ ctx[0], false)
					: rootScope.play(/*tour*/ ctx[0], true))) (/*showReplay*/ ctx[26]()
					? rootScope.play(/*tour*/ ctx[0], false)
					: rootScope.play(/*tour*/ ctx[0], true)).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (525:4) {#if showGuideMe}
function create_if_block_9$8(ctx) {
	let button;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.guidePlayIcon + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.guideMe}`;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_action-icon mgPlayerJSTest_position-center");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left mgPlayerJSTest_margin-tb-15");
			attr(button, "id", "mgPlayerJSTest_icon-guide-action-guideme");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_guide-action-icon-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_border-radius-50 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(button, t0);
			append(button, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(rootScope.guideAction(rootScope.playGuideMe, null, /*tour*/ ctx[0], rootScope.currentView))) rootScope.guideAction(rootScope.playGuideMe, null, /*tour*/ ctx[0], rootScope.currentView).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (541:4) {#if showShowMe}
function create_if_block_8$9(ctx) {
	let button;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.play_showme + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.showMe}`;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_action-icon mgPlayerJSTest_position-center");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left mgPlayerJSTest_margin-tb-15");
			attr(button, "id", "mgPlayerJSTest_icon-guide-action-showme");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_guide-action-icon-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_border-radius-50 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer mgPlayerJSTest_lbl-btn");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(button, t0);
			append(button, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(rootScope.guideAction(rootScope.playSlideshow, null, /*tour*/ ctx[0], rootScope.currentView))) rootScope.guideAction(rootScope.playSlideshow, null, /*tour*/ ctx[0], rootScope.currentView).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (556:4) {#if showTestMe}
function create_if_block_7$9(ctx) {
	let button;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.play_testme + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.testMe}`;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_action-icon mgPlayerJSTest_position-center");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left mgPlayerJSTest_margin-tb-15");
			attr(button, "id", "mgPlayerJSTest_icon-guide-action-testMe");
			attr(button, "class", "mgPlayerJSTest_guide-action-icon-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_border-radius-50 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer mgPlayerJSTest_lbl-btn");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(button, t0);
			append(button, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(/*showTestMeWidget*/ ctx[29](/*tour*/ ctx[0]))) /*showTestMeWidget*/ ctx[29](/*tour*/ ctx[0]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (570:4) {#if showDoItForMe}
function create_if_block_6$a(ctx) {
	let button;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.doItForMeIcon + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.doItForMe}`;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_action-icon mgPlayerJSTest_position-center");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left mgPlayerJSTest_margin-tb-15");
			attr(button, "id", "mgPlayerJSTest_icon-guide-action-doitforme");
			attr(button, "class", "mgPlayerJSTest_guide-action-icon-wrapper mgPlayerJSTest_float-left mgPlayerJSTest_position-relative mgPlayerJSTest_border-radius-50 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer mgPlayerJSTest_lbl-btn");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(button, t0);
			append(button, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(rootScope.guideAction(rootScope.playAuto, null, /*tour*/ ctx[0], rootScope.currentView))) rootScope.guideAction(rootScope.playAuto, null, /*tour*/ ctx[0], rootScope.currentView).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (589:2) {#if tour.media_files[0] && rootScope.isMicroPlayer}
function create_if_block_4$c(ctx) {
	let wmgPlayerJSTest_;
	let downloadmedia;
	let current;
	downloadmedia = new DownloadMedia({ props: { tour: /*tour*/ ctx[0] } });

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(downloadmedia.$$.fragment);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_guide-row-download-wrapper mgPlayerJSTest_float-right mgPlayerJSTest_border-radius mgPlayerJSTest_border-radius-4px mgPlayerJSTest_border-rounded mgPlayerJSTest_border-rounded-right");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(downloadmedia, wmgPlayerJSTest_, null);
			current = true;
		},
		p(ctx, dirty) {
			const downloadmedia_changes = {};
			if (dirty[0] & /*tour*/ 1) downloadmedia_changes.tour = /*tour*/ ctx[0];
			downloadmedia.$set(downloadmedia_changes);
		},
		i(local) {
			if (current) return;
			transition_in(downloadmedia.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(downloadmedia.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(downloadmedia);
		}
	};
}

// (600:0) {#if breadcrumb.length > 0 && rootScope.isOwnerOrAppAdmin() && GmCXt.FT.creatorApp && !rootScope.automationSelectionMode && !rootScope.hideMirrorAppCtrl() && !rootScope.isDesktopApp()}
function create_if_block_3$d(ctx) {
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.pin + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.btnPin}`;
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_info-hover-text");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_info-hover");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_pin-guide-icon-wrapper mgPlayerJSTest_icon-unpin-guide mgPlayerJSTest_border-radius-50");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_3, "click", /*click_handler_2*/ ctx[37]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}

			mounted = false;
			dispose();
		}
	};
}

// (613:0) {#if breadcrumb.length > 0 && rootScope.isOwnerOrAppAdmin() && GmCXt.FT.creatorApp && !rootScope.automationSelectionMode && !rootScope.hideMirrorAppCtrl() && tour.pin}
function create_if_block_2$f(ctx) {
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.pin_filled + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.btnUnpin}`;
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_info-hover-text");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_info-hover");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_pin-guide-icon-wrapper mgPlayerJSTest_icon-pin-guide mgPlayerJSTest_border-radius-50");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_3, "click", /*click_handler_3*/ ctx[38]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}

			mounted = false;
			dispose();
		}
	};
}

// (625:0) {#if !GmCXt.FT.isPlayer && !rootScope.isDesktopApp() && get(Gm.activeView) !== 'findNReplace'}
function create_if_block$h(ctx) {
	let wmgPlayerJSTest_;
	let show_if = get_store_value(Gm.CurrentPage) !== 'stepview' && GmCXt.FT.creatorApp && !rootScope.automationSelectionMode && (rootScope.hasTourAccess(/*tour*/ ctx[0]) || !/*tour*/ ctx[0].is_published || rootScope.isOwnerOrAppAdmin()) && !rootScope.isUserRole() && !rootScope.exportEnabled && !rootScope.hideMirrorAppCtrl();
	let t;
	let tourusericon;
	let current;
	let if_block = show_if && create_if_block_1$g(ctx);
	tourusericon = new Empty({ props: { tour: /*tour*/ ctx[0] } });

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block) if_block.c();
			t = space();
			create_component(tourusericon.$$.fragment);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_guide-user-action-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block) if_block.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			mount_component(tourusericon, wmgPlayerJSTest_, null);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*tour*/ 1) show_if = get_store_value(Gm.CurrentPage) !== 'stepview' && GmCXt.FT.creatorApp && !rootScope.automationSelectionMode && (rootScope.hasTourAccess(/*tour*/ ctx[0]) || !/*tour*/ ctx[0].is_published || rootScope.isOwnerOrAppAdmin()) && !rootScope.isUserRole() && !rootScope.exportEnabled && !rootScope.hideMirrorAppCtrl();

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*tour*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$g(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(wmgPlayerJSTest_, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const tourusericon_changes = {};
			if (dirty[0] & /*tour*/ 1) tourusericon_changes.tour = /*tour*/ ctx[0];
			tourusericon.$set(tourusericon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(tourusericon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(tourusericon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block) if_block.d();
			destroy_component(tourusericon);
		}
	};
}

// (627:2) {#if get(Gm.CurrentPage) !== 'stepview' && GmCXt.FT.creatorApp && !rootScope.automationSelectionMode && (rootScope.hasTourAccess(tour) || !tour.is_published || rootScope.isOwnerOrAppAdmin()) && !rootScope.isUserRole() && !rootScope.exportEnabled && !rootScope.hideMirrorAppCtrl()}
function create_if_block_1$g(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let guidedropdown;
	let wmgPlayerJSTest_1_id_value;
	let current;
	guidedropdown = new Empty({ props: { tour: /*tour*/ ctx[0] } });

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			create_component(guidedropdown.$$.fragment);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_add-step-wrapper tour-action-dropdown-wrapper");
			toggle_class(wmgPlayerJSTest_0, "published-tour", /*tour*/ ctx[0].is_published);

			attr(wmgPlayerJSTest_1, "id", wmgPlayerJSTest_1_id_value = `tour-pencil-icon-${/*tour*/ ctx[0].tour_id} ${!/*tour*/ ctx[0].is_published
			? 'tour-pencil-icon-unpublish'
			: ''}`);

			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_inline-block-vm tour-pencil-icon");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			mount_component(guidedropdown, wmgPlayerJSTest_0, null);
			current = true;
		},
		p(ctx, dirty) {
			const guidedropdown_changes = {};
			if (dirty[0] & /*tour*/ 1) guidedropdown_changes.tour = /*tour*/ ctx[0];
			guidedropdown.$set(guidedropdown_changes);

			if (!current || dirty[0] & /*tour*/ 1) {
				toggle_class(wmgPlayerJSTest_0, "published-tour", /*tour*/ ctx[0].is_published);
			}

			if (!current || dirty[0] & /*tour*/ 1 && wmgPlayerJSTest_1_id_value !== (wmgPlayerJSTest_1_id_value = `tour-pencil-icon-${/*tour*/ ctx[0].tour_id} ${!/*tour*/ ctx[0].is_published
			? 'tour-pencil-icon-unpublish'
			: ''}`)) {
				attr(wmgPlayerJSTest_1, "id", wmgPlayerJSTest_1_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(guidedropdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(guidedropdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			destroy_component(guidedropdown);
		}
	};
}

function create_fragment$l(ctx) {
	let wmgPlayerJSTest_7;
	let wmgPlayerJSTest_4;
	let show_if_4 = /*showDraftGuide*/ ctx[9] && !rootScope.hideMirrorAppCtrl();
	let t0;
	let t1;
	let t2;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;
	let button;
	let raw_value = /*textHighlighter*/ ctx[32](/*tour*/ ctx[0].tour_title, /*searchKeyword*/ ctx[1], /*replaceKeyword*/ ctx[2]) + "";
	let t3;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t4_value = /*tour*/ ctx[0].tour_description + "";
	let t4;
	let wmgPlayerJSTest_1_id_value;
	let t5;
	let wmgPlayerJSTest_2_id_value;
	let t6;
	let show_if_3 = get_store_value(GmCXt.CurrentPage) === 'allguidesSearchPage';
	let wmgPlayerJSTest_3_class_value;
	let t7;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_5;
	let t8;
	let t9;
	let wmgPlayerJSTest_6_id_value;
	let t10;
	let show_if_2 = /*breadcrumb*/ ctx[22].length > 0 && rootScope.isOwnerOrAppAdmin() && GmCXt.FT.creatorApp && !rootScope.automationSelectionMode && !rootScope.hideMirrorAppCtrl() && !rootScope.isDesktopApp();
	let t11;
	let show_if_1 = /*breadcrumb*/ ctx[22].length > 0 && rootScope.isOwnerOrAppAdmin() && GmCXt.FT.creatorApp && !rootScope.automationSelectionMode && !rootScope.hideMirrorAppCtrl() && /*tour*/ ctx[0].pin;
	let t12;
	let show_if = !GmCXt.FT.isPlayer && !rootScope.isDesktopApp() && get_store_value(Gm.activeView) !== 'findNReplace';
	let t13;
	let wmgPlayerJSTest_8;
	let current;
	let mounted;
	let dispose;
	let if_block0 = show_if_4 && create_if_block_30$1(ctx);
	let if_block1 = !/*isToolTip*/ ctx[4] && create_if_block_14$5(ctx);
	let if_block2 = /*isToolTip*/ ctx[4] && create_if_block_13$5(ctx);
	let if_block3 = (/*tour*/ ctx[0].tour_title.length > 0 || /*tour*/ ctx[0].tour_description.length > 0) && create_if_block_12$5(ctx);
	let if_block4 = show_if_3 && create_if_block_11$7(ctx);
	let if_block5 = GmCXt.FT.isPlayer && create_if_block_5$b(ctx);
	let if_block6 = /*tour*/ ctx[0].media_files[0] && rootScope.isMicroPlayer && create_if_block_4$c(ctx);
	let if_block7 = show_if_2 && create_if_block_3$d(ctx);
	let if_block8 = show_if_1 && create_if_block_2$f(ctx);
	let if_block9 = show_if && create_if_block$h(ctx);

	return {
		c() {
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			button = element("button");
			t3 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t4 = text(t4_value);
			t5 = space();
			if (if_block3) if_block3.c();
			t6 = space();
			if (if_block4) if_block4.c();
			t7 = space();
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			t8 = space();
			if (if_block5) if_block5.c();
			t9 = space();
			if (if_block6) if_block6.c();
			t10 = space();
			if (if_block7) if_block7.c();
			t11 = space();
			if (if_block8) if_block8.c();
			t12 = space();
			if (if_block9) if_block9.c();
			t13 = space();
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_guide-title mgPlayerJSTest_wrap-text mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tour-desc mgPlayerJSTest_wrap-text");
			attr(wmgPlayerJSTest_1, "id", wmgPlayerJSTest_1_id_value = "mgPlayerJSTest_tour-desc-" + /*tour*/ ctx[0].tour_id);
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_guide-desc-wrapper mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_1, "tabindex", "0");
			attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_tour-title-" + /*tour*/ ctx[0].tour_id);
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_guide-title-wrapper mgPlayerJSTest_ege-inline-block-vm");

			attr(wmgPlayerJSTest_3, "class", wmgPlayerJSTest_3_class_value = "mgPlayerJSTest_guide-details-wrapper mgPlayerJSTest_ege-inline-block-vm " + (rootScope.exportEnabled
			? 'mgPlayerJSTest_disable-tour-play-action'
			: '') + " " + (rootScope.automationSelectionMode ? 'mgPlayerJSTest_width-80' : '') + " " + (GmCXt.FT.creatorApp && !/*showDraftGuide*/ ctx[9]
			? 'mgPlayerJSTest_guide-details-creator'
			: '') + " " + (GmCXt.FT.creatorApp && /*showDraftGuide*/ ctx[9]
			? 'mgPlayerJSTest_guide-details-draft-guide'
			: '') + " " + (GmCXt.FT.creatorApp && /*showDraftGuide*/ ctx[9] && /*tour*/ ctx[0].pin
			? 'mgPlayerJSTest_guide-details-draft-pin'
			: ''));

			attr(wmgPlayerJSTest_6, "id", wmgPlayerJSTest_6_id_value = "mgPlayerJSTest_guide-row-action-wrapper_" + /*tour*/ ctx[0].tour_id);
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_guide-row-action-wrapper");
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_ege-inline-block-vm mgPlayerJSTest_tour-title-description-wrapper");
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_ege-clear");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_7, anchor);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_4);
			if (if_block0) if_block0.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t0);
			if (if_block1) if_block1.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t1);
			if (if_block2) if_block2.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t2);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t3);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t4);
			append(wmgPlayerJSTest_2, t5);
			if (if_block3) if_block3.m(wmgPlayerJSTest_2, null);
			append(wmgPlayerJSTest_3, t6);
			if (if_block4) if_block4.m(wmgPlayerJSTest_3, null);
			append(wmgPlayerJSTest_7, t7);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_6, t8);
			if (if_block5) if_block5.m(wmgPlayerJSTest_6, null);
			append(wmgPlayerJSTest_6, t9);
			if (if_block6) if_block6.m(wmgPlayerJSTest_6, null);
			insert(target, t10, anchor);
			if (if_block7) if_block7.m(target, anchor);
			insert(target, t11, anchor);
			if (if_block8) if_block8.m(target, anchor);
			insert(target, t12, anchor);
			if (if_block9) if_block9.m(target, anchor);
			insert(target, t13, anchor);
			insert(target, wmgPlayerJSTest_8, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_2, "click", stop_propagation(function () {
					if (is_function(rootScope.currentView == 'manage-keywords'
					? ''
					: /*openTour*/ ctx[30](/*tour*/ ctx[0]))) (rootScope.currentView == 'manage-keywords'
					? ''
					: /*openTour*/ ctx[30](/*tour*/ ctx[0])).apply(this, arguments);
				}));

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*showDraftGuide*/ 512) show_if_4 = /*showDraftGuide*/ ctx[9] && !rootScope.hideMirrorAppCtrl();

			if (show_if_4) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_30$1(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_4, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!/*isToolTip*/ ctx[4]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_14$5(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_4, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*isToolTip*/ ctx[4]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_13$5(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_4, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if ((!current || dirty[0] & /*tour, searchKeyword, replaceKeyword*/ 7) && raw_value !== (raw_value = /*textHighlighter*/ ctx[32](/*tour*/ ctx[0].tour_title, /*searchKeyword*/ ctx[1], /*replaceKeyword*/ ctx[2]) + "")) button.innerHTML = raw_value;			if ((!current || dirty[0] & /*tour*/ 1) && t4_value !== (t4_value = /*tour*/ ctx[0].tour_description + "")) set_data(t4, t4_value);

			if (!current || dirty[0] & /*tour*/ 1 && wmgPlayerJSTest_1_id_value !== (wmgPlayerJSTest_1_id_value = "mgPlayerJSTest_tour-desc-" + /*tour*/ ctx[0].tour_id)) {
				attr(wmgPlayerJSTest_1, "id", wmgPlayerJSTest_1_id_value);
			}

			if (/*tour*/ ctx[0].tour_title.length > 0 || /*tour*/ ctx[0].tour_description.length > 0) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_12$5(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_2, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (!current || dirty[0] & /*tour*/ 1 && wmgPlayerJSTest_2_id_value !== (wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_tour-title-" + /*tour*/ ctx[0].tour_id)) {
				attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value);
			}

			if (show_if_3) if_block4.p(ctx, dirty);

			if (!current || dirty[0] & /*showDraftGuide, tour*/ 513 && wmgPlayerJSTest_3_class_value !== (wmgPlayerJSTest_3_class_value = "mgPlayerJSTest_guide-details-wrapper mgPlayerJSTest_ege-inline-block-vm " + (rootScope.exportEnabled
			? 'mgPlayerJSTest_disable-tour-play-action'
			: '') + " " + (rootScope.automationSelectionMode ? 'mgPlayerJSTest_width-80' : '') + " " + (GmCXt.FT.creatorApp && !/*showDraftGuide*/ ctx[9]
			? 'mgPlayerJSTest_guide-details-creator'
			: '') + " " + (GmCXt.FT.creatorApp && /*showDraftGuide*/ ctx[9]
			? 'mgPlayerJSTest_guide-details-draft-guide'
			: '') + " " + (GmCXt.FT.creatorApp && /*showDraftGuide*/ ctx[9] && /*tour*/ ctx[0].pin
			? 'mgPlayerJSTest_guide-details-draft-pin'
			: ''))) {
				attr(wmgPlayerJSTest_3, "class", wmgPlayerJSTest_3_class_value);
			}

			if (GmCXt.FT.isPlayer) if_block5.p(ctx, dirty);

			if (/*tour*/ ctx[0].media_files[0] && rootScope.isMicroPlayer) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[0] & /*tour*/ 1) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_4$c(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(wmgPlayerJSTest_6, null);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*tour*/ 1 && wmgPlayerJSTest_6_id_value !== (wmgPlayerJSTest_6_id_value = "mgPlayerJSTest_guide-row-action-wrapper_" + /*tour*/ ctx[0].tour_id)) {
				attr(wmgPlayerJSTest_6, "id", wmgPlayerJSTest_6_id_value);
			}

			if (dirty[0] & /*breadcrumb*/ 4194304) show_if_2 = /*breadcrumb*/ ctx[22].length > 0 && rootScope.isOwnerOrAppAdmin() && GmCXt.FT.creatorApp && !rootScope.automationSelectionMode && !rootScope.hideMirrorAppCtrl() && !rootScope.isDesktopApp();

			if (show_if_2) {
				if (if_block7) {
					if_block7.p(ctx, dirty);
				} else {
					if_block7 = create_if_block_3$d(ctx);
					if_block7.c();
					if_block7.m(t11.parentNode, t11);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}

			if (dirty[0] & /*breadcrumb, tour*/ 4194305) show_if_1 = /*breadcrumb*/ ctx[22].length > 0 && rootScope.isOwnerOrAppAdmin() && GmCXt.FT.creatorApp && !rootScope.automationSelectionMode && !rootScope.hideMirrorAppCtrl() && /*tour*/ ctx[0].pin;

			if (show_if_1) {
				if (if_block8) {
					if_block8.p(ctx, dirty);
				} else {
					if_block8 = create_if_block_2$f(ctx);
					if_block8.c();
					if_block8.m(t12.parentNode, t12);
				}
			} else if (if_block8) {
				if_block8.d(1);
				if_block8 = null;
			}

			if (show_if) if_block9.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block6);
			transition_in(if_block9);
			current = true;
		},
		o(local) {
			transition_out(if_block6);
			transition_out(if_block9);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_7);
				detach(t10);
				detach(t11);
				detach(t12);
				detach(t13);
				detach(wmgPlayerJSTest_8);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (if_block7) if_block7.d(detaching);
			if (if_block8) if_block8.d(detaching);
			if (if_block9) if_block9.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function getCircle(t, n, a, r, o) {
	n = parseInt(n);
	a = parseInt(a);
	r = parseInt(r);

	let radius = 19,
		i = 3,
		u = radius * Math.PI * 2;

	if (u - 10 * n < 1) {
		i = u / n / 1.2;
	}

	let s = (u - i * n) / n;

	let c = (function (e, t, n, a) {
		return e + t * (n + a);
	})(u / 4 - i / 2, r, i, s);

	let d = 1 !== n
	? (function (e, t, n, a) {
			return new Array(e).fill(void 0).map(function (r, o) {
				return ('').concat(t, ' ').concat(o === e - 1 ? n - e * (a + t) + a : a);
			}).join(' ');
		})(a, s, u, i)
	: void 0;

	return `<circle class="${t}" cx="20" cy="20" r="19" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4" stroke-dashoffset="${c}" stroke-dasharray="${d}"></circle>`;
}

function instance$k($$self, $$props, $$invalidate) {
	let { tour } = $$props;
	let { searchKeyword } = $$props;
	let { replaceKeyword } = $$props;
	let isToolTip = rootScope.isTooltip(tour);
	let isBotGuide = GmCXt.isBotGuide(tour);
	let isHelpArticle = rootScope.isHelpArticle(tour);
	let defPlayActAppSet = GmCXt.getAppSetting('defaultPlayAction');
	let defPlayAct = GmCXt.isFalse(defPlayActAppSet);
	let defaultPlayAction = rootScope.getDefaultPlayAction(tour);
	let showDraftGuide = GmCXt.FT.creatorApp && !rootScope.isUserRole() && !rootScope.exportEnabled && tour.parent_tour_id;
	let isDesktopApp = rootScope.isDesktopApp();
	let isOnboarding = GmCXt.isOnboarding(tour);
	let isGuide = GmCXt.isGuide(tour);
	let isCADGuide = rootScope.isCADGuide(tour);
	let isTrackingGuide = rootScope.isTrackingGuide(tour);
	let isMobileGuide = rootScope.isMobileGuide(tour);
	let guideDefaultImg = GmCXt.getDefaultGuideIcon();
	let showGuideBeacon = tour.tour_type.indexOf('beacon_tour');
	let showGuideMe = rootScope.showPlayOption(rootScope.playGuideMe, tour);
	let showShowMe = rootScope.showPlayOption(rootScope.playSlideshow, tour);
	let showTestMe = rootScope.showPlayOption(rootScope.playTestMe, tour) && !GmCXt.branchStepExist(tour);
	let showDoItForMe = rootScope.showPlayOption(rootScope.playAuto, tour) && !GmCXt.isOnboarding(tour);
	const dispatch = createEventDispatcher();
	let playedStepCount;
	let breadcrumb = [];
	let cdn = GmCXt.getCdnSign();
	let category = rootScope.getCategory(tour.category_id);

	const breadcrumbDataSubscriber = Gm.breadCrumb.subscribe(value => {
		$$invalidate(22, breadcrumb = value);
	});

	onDestroy(() => {
		breadcrumbDataSubscriber();
	});

	function handlePinAction(tour, pin, event) {
		if (pin === 'pin') {
			rootScope.pinTourToTop(tour, pin, (tour, action) => {
				// Dispatch an event with the updated list
				dispatch('updatePinnedTours', { tour, action });
			});
		} else {
			rootScope.pinTourToTop(tour, pin, (tour, action) => {
				// Dispatch an event with the updated list
				dispatch('updatePinnedTours', { tour, action });
			});
		}
	}

	function getNextStep(t) {
		if (!GmCXt.tourActivity) return false;
		let lastStepId = GmCXt.tourActivity['t:' + t.tour_id];

		let ps = t.tour_settings.play_structure
		? t.tour_settings.play_structure
		: GmCXt.getGuidePlayStructure(t);

		let nextStepId = GmCXt.getTail(lastStepId, ps, null, t);
		return rootScope.getStepFromTour(nextStepId, t);
	}

	const showReplay = () => {
		if (!GmCXt.isEmpty(tour) && rootScope.isPlayedTour(tour.tour_id) && getNextStep(tour) === false) {
			return true;
		}
	};

	const showResume = () => {
		if (!GmCXt.isEmpty(tour) && getNextStep(tour) !== false && rootScope.getDefaultPlayAction(tour) === rootScope.playGuideMe) {
			return true;
		}
	};

	function playDefaultModeOnClick(isPlayer) {
		if (rootScope.isOnlySurveyGuide(tour) || GmCXt.isBotGuide(tour)) {
			return '';
		}

		if (defPlayAct) {
			return '';
		} else {
			rootScope.play(tour, false);
		}
	}

	const showTestMeWidget = tour => {
		let newSteps = tour.steps.filter(function (el) {
			return el.step_type === 'inline';
		});

		if (newSteps.length) {
			new TestMeWidget({
					target: document.body,
					props: { showTestMe: true, tour }
				});
		} else {
			rootScope.showPopup(rootScope.labels.noInappStepInGuide);
		}
	};

	const openTour = originalTour => {
		let tour = JSON.parse(JSON.stringify(originalTour));

		if (tour.tour_type !== 'bot') {
			if (rootScope.automationSelectionMode) {
				return;
			}

			if (tour.tour_type === 'help_article') {
				window.open(tour.tour_settings.articleUrl, '_blank');
			} else {
				if (rootScope.isMicroPlayer) {
					rootScope.play(tour);
				} else {
					rootScope.trackSearchActivity(true);
					rootScope.clearSearchInput();
					rootScope.getBreadcrumsCategories(tour);

					if (GmCXt.FT.creatorApp) {
						//Api call should get trigerred while opening the tour in creator
						tour.steps = [];
					}

					Gm.currentTour.set(tour);
					rootScope.setCurrentPage('stepview');
				}
			}
		}
	};

	function createSvgElmnt() {
		let cir = '';

		if (GmCXt.FT.isPlayer) {
			if (!GmCXt.branchStepExist(tour)) {
				let tourStepCount = parseInt(tour.step_count);

				playedStepCount = rootScope.playedSteps
				? rootScope.getPlayedStepCount(tour)
				: 0;

				if (tourStepCount && !playedStepCount) {
					cir = getCircle('mgPlayerJSTest_dashes-green', tourStepCount, tourStepCount, tourStepCount);

					if (tourStepCount === 1) {
						cir = `<circle class="mgPlayerJSTest_dashes-green" cx="20" cy="20" r="19" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4"></circle>`;
					}
				}

				if (tourStepCount && playedStepCount) {
					if (playedStepCount === tourStepCount) {
						cir = getCircle('mgPlayerJSTest_dashes-gray', playedStepCount, playedStepCount, playedStepCount);

						if (playedStepCount === 1) {
							cir = `<circle class="mgPlayerJSTest_dashes-gray" cx="20" cy="20" r="19" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4"></circle>`;
						}
					}

					if (playedStepCount !== tourStepCount) {
						cir += getCircle('mgPlayerJSTest_dashes-green', tourStepCount, tourStepCount - playedStepCount, tourStepCount - playedStepCount);
						cir += getCircle('mgPlayerJSTest_dashes-gray', tourStepCount, playedStepCount, tourStepCount);
					}
				}
			} else {
				cir += `<circle cx="20" cy="20" r="19" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4"></circle>`;
			}

			if (defaultPlayAction === rootScope.playSlideshow || tour.tour_settings.defaultPlayAction === 'Default' && defPlayActAppSet === rootScope.playSlideshow || isDesktopApp) {
				return cir += `<path d="M25.1375 15.9427H23.1482C22.5161 15.359 21.3251 15 19.9999 15C18.6747 15 17.4837 15.359 16.8516 15.9427H14.8623C12.1812 15.9427 10 18.1985 10 20.9713C10 23.7441 12.1812 26 14.8623 26C17.5434 26 19.7246 23.7441 19.7246 20.9713C19.7246 20.9346 19.7242 20.8979 19.7235 20.8611H20.2764C20.2756 20.8979 20.2753 20.9346 20.2753 20.9713C20.2753 23.7441 22.4566 26 25.1377 26C27.8188 26 30 23.7441 30 20.9713C29.9999 18.1985 27.8186 15.9427 25.1375 15.9427ZM14.8623 23.9552C13.2715 23.9552 11.9772 22.6166 11.9772 20.9713C11.9772 19.3261 13.2715 17.9875 14.8623 17.9875C16.4532 17.9875 17.7475 19.3261 17.7475 20.9713C17.7475 22.6166 16.4532 23.9552 14.8623 23.9552ZM21.3065 17.89H18.6926C18.3824 17.89 18.1303 17.6286 18.1303 17.3077C18.1303 16.9869 18.3824 16.7254 18.6926 16.7254H21.3065C21.6173 16.7254 21.8695 16.9869 21.8695 17.3077C21.8695 17.6285 21.6173 17.89 21.3065 17.89ZM25.1375 23.9552C23.5466 23.9552 22.2523 22.6166 22.2523 20.9713C22.2523 19.3261 23.5466 17.9875 25.1375 17.9875C26.7282 17.9875 28.0226 19.3261 28.0226 20.9713C28.0226 22.6166 26.7283 23.9552 25.1375 23.9552Z" fill="#ACADC1" stroke-width="0" />`;
			}

			if (defaultPlayAction === rootScope.playAuto || tour.tour_settings.defaultPlayAction === 'Default' && defPlayActAppSet === rootScope.playAuto && !isDesktopApp) {
				return cir += '<path d="M15.8441 24.4972C14.4834 24.4972 13.3803 25.652 13.3803 27.0765V29H14.6452V27.6678C14.6452 26.5993 15.4726 25.7332 16.4931 25.7332H23.5081C24.5287 25.7332 25.356 26.5993 25.356 27.6678V29H26.6211V27.0765C26.6211 25.652 25.518 24.4972 24.1573 24.4972H15.8441Z" fill="#ACADC1" stroke-width="0" />' + '<path d="M12 18.8136C12 18.1065 12.5475 17.5333 13.2229 17.5333H13.6867V20.0938H13.2229C12.5475 20.0938 12 19.5206 12 18.8136Z" fill="#ACADC1" stroke-width="0" />' + '<path d="M28 18.8136C28 18.1065 27.4525 17.5333 26.7771 17.5333H26.3133V20.0938H26.7771C27.4525 20.0938 28 19.5206 28 18.8136Z" fill="#ACADC1" stroke-width="0" />' + '<path d="M19.7887 18.8136C19.7887 19.5206 19.2412 20.0938 18.5659 20.0938C17.8905 20.0938 17.343 19.5206 17.343 18.8136C17.343 18.1065 17.8905 17.5333 18.5659 17.5333C19.2412 17.5333 19.7887 18.1065 19.7887 18.8136Z" fill="#ACADC1" stroke-width="0" />' + '<path d="M22.7414 18.8136C22.7414 19.5206 22.1939 20.0938 21.5186 20.0938C20.8432 20.0938 20.2957 19.5206 20.2957 18.8136C20.2957 18.1065 20.8432 17.5333 21.5186 17.5333C22.1939 17.5333 22.7414 18.1065 22.7414 18.8136Z" fill="#ACADC1" stroke-width="0" />' + '<path d="M19.494 13.1606C19.494 13.0894 19.5492 13.0317 19.6172 13.0317H20.7202C20.7882 13.0317 20.8434 13.0894 20.8434 13.1606V15.6804H19.494V13.1606Z" fill="#ACADC1" stroke-width="0" />' + '<path d="M18.4948 14.6198H17.279C15.9182 14.6198 14.8151 15.7746 14.8151 17.1992V20.5163C14.8151 21.9409 15.9182 23.0957 17.279 23.0957H22.7247C24.0855 23.0957 25.1886 21.9409 25.1886 20.5163V17.1992C25.1886 15.7746 24.0855 14.6198 22.7247 14.6198H21.8448V15.592H22.2026C23.2232 15.592 24.0505 16.4581 24.0505 17.5265V20.191C24.0505 21.2594 23.2232 22.1255 22.2026 22.1255H17.802C16.7815 22.1255 15.9541 21.2594 15.9541 20.191V17.5265C15.9541 16.4581 16.7815 15.592 17.802 15.592H18.4948V14.6198Z" fill="#ACADC1" stroke-width="0" />' + '<path d="M20.8434 11.7063C20.8434 12.0964 20.5413 12.4127 20.1687 12.4127C19.7961 12.4127 19.494 12.0964 19.494 11.7063C19.494 11.3162 19.7961 11 20.1687 11C20.5413 11 20.8434 11.3162 20.8434 11.7063Z" fill="#ACADC1" stroke-width="0" />';
			}
		} else {
			cir += '<circle cx="20" cy="20" r="19" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4"></circle>';
		}

		cir += '<path d="M12 27.555C12 27.555 20.838 24.372 22.606 22.606C24.374 20.838 27.555 12 27.555 12C27.555 12 18.717 15.183 16.95 16.95C15.183 18.717 12 27.555 12 27.555ZM18.364 18.364L21.192 21.192C21.899 21.899 14.829 24.727 14.829 24.727C14.829 24.727 17.657 17.657 18.364 18.364Z" fill="#ACADC1" stroke="#ACADC1" stroke-width="0" />';
		return cir;
	}

	const textHighlighter = function (text, searchKeyword, replaceKeyword) {
		if (!searchKeyword) return text;
		searchKeyword = searchKeyword.trim();
		const [textSearch, textReplace] = searchKeyword.split(',');
		const regex = new RegExp(textSearch, 'gi');
		return text.replace(regex, match => `<span class="mgPlayerJSTest_text-highlighted">${replaceKeyword || match}</span>`);
	};

	onMount(() => {
		if (GmCXt.isPlayer()) {
			rootScope.bindPlayerTheme();
		}
	});

	const click_handler = () => playDefaultModeOnClick();

	const error_handler = e => {
		e.target.src = guideDefaultImg;
	};

	const error_handler_1 = e => {
		e.target.src = guideDefaultImg;
	};

	const click_handler_1 = () => playDefaultModeOnClick(GmCXt.FT.isPlayer);
	const click_handler_2 = event => handlePinAction(tour, 'pin');
	const click_handler_3 = event => handlePinAction(tour, 'unpin');

	$$self.$$set = $$props => {
		if ('tour' in $$props) $$invalidate(0, tour = $$props.tour);
		if ('searchKeyword' in $$props) $$invalidate(1, searchKeyword = $$props.searchKeyword);
		if ('replaceKeyword' in $$props) $$invalidate(2, replaceKeyword = $$props.replaceKeyword);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*tour, defPlayActAppSet*/ 9) {
			{
				$$invalidate(4, isToolTip = rootScope.isTooltip(tour));
				$$invalidate(5, isBotGuide = GmCXt.isBotGuide(tour));
				$$invalidate(6, isHelpArticle = rootScope.isHelpArticle(tour));
				$$invalidate(3, defPlayActAppSet = GmCXt.getAppSetting('defaultPlayAction'));
				$$invalidate(7, defPlayAct = GmCXt.isFalse(defPlayActAppSet));
				$$invalidate(8, defaultPlayAction = rootScope.getDefaultPlayAction(tour));
				$$invalidate(9, showDraftGuide = GmCXt.FT.creatorApp && !rootScope.isUserRole() && !rootScope.exportEnabled && tour.parent_tour_id);
				$$invalidate(10, isDesktopApp = rootScope.isDesktopApp());
				$$invalidate(11, isOnboarding = GmCXt.isOnboarding(tour));
				$$invalidate(12, isGuide = GmCXt.isGuide(tour));
				$$invalidate(13, isCADGuide = rootScope.isCADGuide(tour));
				$$invalidate(14, isTrackingGuide = rootScope.isTrackingGuide(tour));
				$$invalidate(15, isMobileGuide = rootScope.isMobileGuide(tour));
				$$invalidate(16, guideDefaultImg = GmCXt.getDefaultGuideIcon());
				$$invalidate(17, showGuideBeacon = tour.tour_type.indexOf('beacon_tour'));
				$$invalidate(23, cdn = GmCXt.getCdnSign());
				$$invalidate(18, showGuideMe = rootScope.showPlayOption(rootScope.playGuideMe, tour));
				$$invalidate(19, showShowMe = rootScope.showPlayOption(rootScope.playSlideshow, tour));
				$$invalidate(20, showTestMe = rootScope.showPlayOption(rootScope.playTestMe, tour) && !GmCXt.branchStepExist(tour));
				$$invalidate(21, showDoItForMe = rootScope.showPlayOption(rootScope.playAuto, tour) && !GmCXt.isOnboarding(tour));
			}
		}
	};

	return [
		tour,
		searchKeyword,
		replaceKeyword,
		defPlayActAppSet,
		isToolTip,
		isBotGuide,
		isHelpArticle,
		defPlayAct,
		defaultPlayAction,
		showDraftGuide,
		isDesktopApp,
		isOnboarding,
		isGuide,
		isCADGuide,
		isTrackingGuide,
		isMobileGuide,
		guideDefaultImg,
		showGuideBeacon,
		showGuideMe,
		showShowMe,
		showTestMe,
		showDoItForMe,
		breadcrumb,
		cdn,
		category,
		handlePinAction,
		showReplay,
		showResume,
		playDefaultModeOnClick,
		showTestMeWidget,
		openTour,
		createSvgElmnt,
		textHighlighter,
		click_handler,
		error_handler,
		error_handler_1,
		click_handler_1,
		click_handler_2,
		click_handler_3
	];
}

class TourView extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$k,
			create_fragment$l,
			safe_not_equal,
			{
				tour: 0,
				searchKeyword: 1,
				replaceKeyword: 2
			},
			null,
			[-1, -1]
		);
	}
}

/* src/components/CurrentPage.svelte generated by Svelte v4.2.20 */

function get_each_context$8(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[32] = list[i];
	return child_ctx;
}

// (359:1) {:else}
function create_else_block$8(ctx) {
	let each_1_anchor;
	let current;
	let each_value = ensure_array_like(/*rootScope*/ ctx[0].sortDataByActiveFilter(/*scope_tours*/ ctx[1], 'tour_title', /*activeSortFilter*/ ctx[3]));
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope, scope_tours, activeSortFilter*/ 11) {
				each_value = ensure_array_like(/*rootScope*/ ctx[0].sortDataByActiveFilter(/*scope_tours*/ ctx[1], 'tour_title', /*activeSortFilter*/ ctx[3]));
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$8(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$8(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (333:1) {#if showNoTour && scope_tours.length < 1 && apiResponseReceived}
function create_if_block$g(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[0].svgs.no_guides_image + "";
	let t0;
	let t1;
	let if_block0 = !/*rootScope*/ ctx[0].search && create_if_block_2$e(ctx);
	let if_block1 = /*rootScope*/ ctx[0].search && create_if_block_1$f(ctx);

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_no-guide-image-cartoon");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_no-guide-image-wrapper mgPlayerJSTest_no-margin");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_no-tour-message-wrapper mgPlayerJSTest_position-center");
			toggle_class(wmgPlayerJSTest_2, "mgPlayerJSTest_margin-t-50", !/*rootScope*/ ctx[0].isMicroPlayer);
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			if (if_block0) if_block0.m(wmgPlayerJSTest_2, null);
			append(wmgPlayerJSTest_2, t1);
			if (if_block1) if_block1.m(wmgPlayerJSTest_2, null);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.no_guides_image + "")) wmgPlayerJSTest_0.innerHTML = raw_value;
			if (!/*rootScope*/ ctx[0].search) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$e(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_2, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*rootScope*/ ctx[0].search) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$f(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_2, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*rootScope*/ 1) {
				toggle_class(wmgPlayerJSTest_2, "mgPlayerJSTest_margin-t-50", !/*rootScope*/ ctx[0].isMicroPlayer);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (360:2) {#each rootScope.sortDataByActiveFilter(scope_tours, 'tour_title', activeSortFilter) as tour}
function create_each_block$8(ctx) {
	let wmgPlayerJSTest_;
	let tourview;
	let t;
	let wmgPlayerJSTest_class_value;
	let current;
	tourview = new TourView({ props: { tour: /*tour*/ ctx[32] } });

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(tourview.$$.fragment);
			t = space();

			attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value = "mgPlayerJSTest_tour-item mgPlayerJSTest_guide-list-view " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_guide-list-view-mplayer'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(tourview, wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			current = true;
		},
		p(ctx, dirty) {
			const tourview_changes = {};
			if (dirty[0] & /*rootScope, scope_tours, activeSortFilter*/ 11) tourview_changes.tour = /*tour*/ ctx[32];
			tourview.$set(tourview_changes);

			if (!current || dirty[0] & /*rootScope*/ 1 && wmgPlayerJSTest_class_value !== (wmgPlayerJSTest_class_value = "mgPlayerJSTest_tour-item mgPlayerJSTest_guide-list-view " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_guide-list-view-mplayer'
			: ''))) {
				attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(tourview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tourview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(tourview);
		}
	};
}

// (340:3) {#if !rootScope.search}
function create_if_block_2$e(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t_value = /*rootScope*/ ctx[0].labels.noGuidesOnThisPage + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_no-guide-msg");
			attr(wmgPlayerJSTest_0, "tabindex", "0");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_no-guide-text-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.noGuidesOnThisPage + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}
		}
	};
}

// (348:3) {#if rootScope.search}
function create_if_block_1$f(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.noGuideAvailableFor + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_1;
	let t2_value = /*rootScope*/ ctx[0].labels.tryModifyingYourSearch + "";
	let t2;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t2 = text(t2_value);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_no-guide-msg");
			attr(wmgPlayerJSTest_0, "tabindex", "0");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_instruction-add-category");
			attr(wmgPlayerJSTest_1, "tabindex", "0");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_no-guide-text-wrapper mgPlayerJSTest_no-guide-text-search-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_2, t1);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.noGuideAvailableFor + "")) set_data(t0, t0_value);
			if (dirty[0] & /*rootScope*/ 1 && t2_value !== (t2_value = /*rootScope*/ ctx[0].labels.tryModifyingYourSearch + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}
		}
	};
}

function create_fragment$k(ctx) {
	let wmgPlayerJSTest_;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$g, create_else_block$8];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*showNoTour*/ ctx[2] && /*scope_tours*/ ctx[1].length < 1 && /*apiResponseReceived*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if_block.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_category-list");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if_blocks[current_block_type_index].m(wmgPlayerJSTest_, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(wmgPlayerJSTest_, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if_blocks[current_block_type_index].d();
		}
	};
}
let limit$2 = 50;

function setHeight$1() {
	let egeHeaderHeight = mg$('#mgPlayerJSTest_ege-header').innerHeight() || 0;
	let footerHeight = mg$('#mgPlayerJSTest_footer-panel-container').innerHeight() || 0;
	let searchboxHeight = mg$('.mgPlayerJSTest_list-page-header').innerHeight() || 0;
	let height = window.innerHeight - footerHeight - egeHeaderHeight - searchboxHeight + 5;
	mg$('.mgPlayerJSTest_category-list').css({ height });
}

function instance$j($$self, $$props, $$invalidate) {
	let currentTours = [];
	let timestamp;
	let scope_tours = [];
	let filteredTours = [];
	let numberOfToursReturned;
	let pageEvent = '';
	let tourIndex;
	let forceRefresh = false;
	let showNoTour = false;
	let msgForGuideCountSent = false;
	let apiResponseReceived = writable(false);
	let activeSortFilter;

	const currentPageToursSubscriber = Gm.CurrentPageTours.subscribe(value => {
		$$invalidate(1, scope_tours = value);
	});

	const selectedLangSubscriber = Gm.selectedLang.subscribe(value => {
		if (!GmCXt.getLXPLang() && GmCXt.activeAppId) {
			refreshView();
		}
	});

	onDestroy(() => {
		currentPageToursSubscriber();
		selectedLangSubscriber();
	});

	Gm.showNoTour.subscribe(value => {
		$$invalidate(2, showNoTour = value);
	});

	Gm.activeSortFilterStore.subscribe(value => {
		$$invalidate(3, activeSortFilter = value);
	});

	function filterCurrentPage() {
		let arr = [];

		scope_tours.filter(function (t) {
			if (checkValueExist(t.tour_title) || t.tour_id === rootScope.search || checkValueExist(t.keywords) || checkValueExist(t.tour_description)) {
				arr.push(t);
			}
		});

		Gm.CurrentPageTours.set(scope_tours);

		//trackCurrentPageSearch(arr);
		if (arr.length) {
			scope.setHeight();
		}
	}

	function waitForRulesMatch() {
		const delay = GmCXt.t.currentPageSpinner + 1000;

		setTimeout(
			() => {
				if (scope_tours.length === 0) {
					GmCXt.log(30, 'NO GUIDE rules matched');
				} // showTours([]);
			},
			delay
		);
	}

	function showTours(tours) {
		tours = GmCXt.removeDuplicateGuides(tours);
		apiResponseReceived.set(true);

		if (tours.length) {
			Gm.showNoTour.set(false);
			tours = rootScope.getTranslatedTours(tours);
			$$invalidate(1, scope_tours = tours);
			setHeight$1();
			Gm.CurrentPageTours.set(scope_tours);

			if (!msgForGuideCountSent) {
				rootScope.showCurrentPageGuidesIndicator(true);
				msgForGuideCountSent = true;
			}

			rootScope.getBotGuideCount(scope_tours);
		} else {
			if (!showNoTour) {
				Gm.showNoTour.set(true);
				showNoTourOnCurrentPage();
			}
		}

		if (rootScope.search && rootScope.search.length > 0) {
			filterCurrentPage();
		}
	}

	function segmentCb(t) {
		if (!GmCXt.isEmpty(t)) {
			scope_tours.push(t);
			Gm.CurrentPageTours.set(scope_tours);
			rootScope.cTours.push(t.tour_id);
		}

		showTours(scope_tours);
	}

	function onRuleMatchStatus(result) {
		let valTour = result.tour;

		if (timestamp !== valTour.timestamp) {
			GmCXt.log(30, 'REJECT, having old timestamp');
			return;
		}

		//if (hideSpinTimer) clearTimeout(hideSpinTimer);
		if (result.valid) {
			filteredTours.push(valTour);
		}

		//if (timeout) clearTimeout(timeout);
		if (rootScope.guideSegmentation && GmCXt.isPlayer()) {
			if (result.valid) {
				GmCXt.checkGuidesBasedOnSegment([valTour], segmentCb, 'currPageSeg');
			} else {
				segmentCb();
			}
		} else {
			setTimeout(
				function () {
					showTours(filteredTours);
				},
				0
			);
		}
	}

	function processRuleInChunk() {
		try {
			let c = currentTours.length;
			waitForRulesMatch();

			for (let i = 0; i < c; i++) {
				let tour = currentTours[tourIndex];
				tourIndex++;

				if (currentTours.length >= tourIndex) {
					rootScope.queueRuleForCP(tour, tourIndex, onRuleMatchStatus, pageEvent, 'currentPage');
				}
			}
		} catch(error) {
			if (error.code === 802) {
				// Handle error with code 802
				console.error('Error with code 802 occurred:', error);
			} else {
				// Handle other errors
				console.error('An unexpected error occurred:', error);
			}
		}
	}

	function showNoTourOnCurrentPage() {
		GmCXt.log(30, 'NO GUIDES on this page');
		rootScope.hideCurrentPageGuidesIndicator();
		$$invalidate(1, scope_tours = []);
		Gm.CurrentPageTours.set(scope_tours);
		rootScope.getBotGuideCount(scope_tours);
	}

	function gotCurrentPageGuides(tours) {
		GmCXt.log(30, 'FETCHED tours', tours);
		timestamp = Date.now();
		$$invalidate(1, scope_tours = []);
		Gm.CurrentPageTours.set(scope_tours);
		filteredTours = [];
		numberOfToursReturned = tours.length;
		if (GmCXt.isPlayer() && !GmCXt.isEmpty(tours)) tours = GmCXt.filterScheduleTours(tours);

		if (GmCXt.inPlayer && !GmCXt.isWestpac()) {
			tours = GmCXt.sortToursByModifcationDate(tours);
		}

		if (!tours.length) {
			Gm.loading.set(false);
			apiResponseReceived.set(true);
			Gm.showNoTour.set(true);
			showNoTourOnCurrentPage();
		} else {
			Gm.loading.set(false);
			Gm.showNoTour.set(false);

			for (let i = 0; i < tours.length; i++) {
				tours[i].tour_sequence = i;
				tours[i].timestamp = timestamp;
			}

			currentTours = [...tours];
			tourIndex = 0;
			processRuleInChunk();
		}
	}

	function getCurrentPage() {
		let param = { url: rootScope.pageUrl };
		if (GmCXt.getLXPLang()) param.language = GmCXt.getLXPLang();

		if (GmCXt.isDomainInActiveApp()) {
			let res = rootScope.readLocalCT(param.url, GmCXt.pageTitle);

			if (res && res.length && !forceRefresh) {
				GmCXt.log(30, 'FETCHED tours from CACHE');
				gotCurrentPageGuides(rootScope.filterCurrentPageTourTypes(res));
				return;
			}

			api.getContextualTour(param, function (r) {
				forceRefresh = false;
				let _tours = rootScope.processContextualGuide(r, param.url);
				gotCurrentPageGuides(rootScope.filterCurrentPageTourTypes(_tours));
			});
		} else {
			GmCXt.log(30, 'INVALID domain, NOT present in Org');
			gotCurrentPageGuides([]);
		}
	}

	function showBoxPlayerGuides() {
		GmCXt.log(30, 'SHOWING Box Player guides');
		let t = 0;
		if (!rootScope.publishedTours) t = 1000;

		setTimeout(
			function () {
				let guides = rootScope.filterCurrentPageTourTypes(rootScope.publishedTours);
				if (GmCXt.isPlayer() && !GmCXt.isEmpty(guides)) guides = GmCXt.filterScheduleTours(guides);
				guides = rootScope.validateAllRulesExceptSelectEl(guides).tours;
				gotCurrentPageGuides(guides);
			},
			t
		);
	}

	function refreshView(event) {
		if (event === 'page_click') {
			pageEvent = 'page_click';
		} else {
			pageEvent = '';
			$$invalidate(0, rootScope.cTours = [], rootScope);
		}

		currentTours = [];
		Gm.showNoTour.set(false);
		msgForGuideCountSent = false;
		let u = GmCXt.user;

		if (!u && !GmCXt.isEmpty(u) && rootScope.noLogin()) {
			showBoxPlayerGuides();
		} else {
			event = event || null;
			GmCXt.log(30, 'REFRESH current page. Event: ' + event);
			rootScope.updatePageUrl(GmCXt.getCurrentURL());
			getCurrentPage();
			setHeight$1();
		}
	}

	mg$(window).off('resize').on('resize', setHeight$1);

	mg$('.mgPlayerJSTest_category-list').off('scroll').on('scroll', function () {
		if (!isPreviousEventComplete) return true;

		if (mg$(this).scrollTop() + mg$(this).innerHeight() >= mg$(this)[0].scrollHeight - 20 && mg$(this)[0].scrollHeight + 20 > mg$(this).innerHeight()) {
			isPreviousEventComplete = false;

			if (numberOfToursReturned === limit$2) {
				refreshView();
			}
		}
	});

	refreshView();
	return [rootScope, scope_tours, showNoTour, activeSortFilter, apiResponseReceived];
}

class CurrentPage extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$j, create_fragment$k, safe_not_equal, {}, null, [-1, -1]);
	}
}

/* src/components/FolderView.svelte generated by Svelte v4.2.20 */

function create_if_block_25$1(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.drag_dots + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_drag-guide-icon-wrapper mgPlayerJSTest_icon-update-margin mgPlayerJSTest_ege-inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (83:4) {#if category?.is_published && !category?.has_child}
function create_if_block_22$1(ctx) {
	let show_if_1 = !/*category*/ ctx[0]?.image_url || /*category*/ ctx[0]?.image_url.indexOf('default') >= 0;
	let t;
	let show_if = /*category*/ ctx[0]?.image_url && /*category*/ ctx[0]?.image_url.indexOf('default') == -1;
	let if_block1_anchor;
	let if_block0 = show_if_1 && create_if_block_24$1(ctx);
	let if_block1 = show_if && create_if_block_23$1(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*category*/ 1) show_if_1 = !/*category*/ ctx[0]?.image_url || /*category*/ ctx[0]?.image_url.indexOf('default') >= 0;

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_24$1(ctx);
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*category*/ 1) show_if = /*category*/ ctx[0]?.image_url && /*category*/ ctx[0]?.image_url.indexOf('default') == -1;

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_23$1(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(if_block1_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d(detaching);
		}
	};
}

// (84:5) {#if !category?.image_url || category?.image_url.indexOf('default') >= 0}
function create_if_block_24$1(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.folder + "";
	let wmgPlayerJSTest_class_value;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");

			attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value = "mgPlayerJSTest_category-icon " + (!/*parentCategory*/ ctx[4]?.is_published && /*subCategory*/ ctx[2]
			? 'mgPlayerJSTest_published-category-subfolder-icon'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*parentCategory, subCategory*/ 20 && wmgPlayerJSTest_class_value !== (wmgPlayerJSTest_class_value = "mgPlayerJSTest_category-icon " + (!/*parentCategory*/ ctx[4]?.is_published && /*subCategory*/ ctx[2]
			? 'mgPlayerJSTest_published-category-subfolder-icon'
			: ''))) {
				attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (94:5) {#if category?.image_url && category?.image_url.indexOf('default') == -1}
function create_if_block_23$1(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	return {
		c() {
			img = element("img");
			attr(img, "class", "category-image mgPlayerJSTest_custom-image mgPlayerJSTest_category-uploaded-img-view mgPlayerJSTest_published-category");
			if (!src_url_equal(img.src, img_src_value = GmCXt.restoreAssetSrc(/*category*/ ctx[0]?.image_url))) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);

			if (!mounted) {
				dispose = listen(img, "error", /*error_handler*/ ctx[9]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*category*/ 1 && !src_url_equal(img.src, img_src_value = GmCXt.restoreAssetSrc(/*category*/ ctx[0]?.image_url))) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}

			mounted = false;
			dispose();
		}
	};
}

// (105:4) {#if category?.is_published && category?.has_child}
function create_if_block_19$2(ctx) {
	let show_if_1 = !/*category*/ ctx[0]?.image_url || /*category*/ ctx[0]?.image_url.indexOf('default') >= 0;
	let t;
	let show_if = /*category*/ ctx[0]?.image_url && /*category*/ ctx[0]?.image_url.indexOf('default') == -1;
	let if_block1_anchor;
	let if_block0 = show_if_1 && create_if_block_21$1(ctx);
	let if_block1 = show_if && create_if_block_20$2(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*category*/ 1) show_if_1 = !/*category*/ ctx[0]?.image_url || /*category*/ ctx[0]?.image_url.indexOf('default') >= 0;

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_21$1(ctx);
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*category*/ 1) show_if = /*category*/ ctx[0]?.image_url && /*category*/ ctx[0]?.image_url.indexOf('default') == -1;

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_20$2(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(if_block1_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d(detaching);
		}
	};
}

// (106:5) {#if !category?.image_url || category?.image_url.indexOf('default') >= 0}
function create_if_block_21$1(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.subfolder + "";
	let wmgPlayerJSTest_class_value;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");

			attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value = "mgPlayerJSTest_category-icon " + (!/*parentCategory*/ ctx[4]?.is_published && /*subCategory*/ ctx[2]
			? 'mgPlayerJSTest_published-category-subfolder-icon'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*parentCategory, subCategory*/ 20 && wmgPlayerJSTest_class_value !== (wmgPlayerJSTest_class_value = "mgPlayerJSTest_category-icon " + (!/*parentCategory*/ ctx[4]?.is_published && /*subCategory*/ ctx[2]
			? 'mgPlayerJSTest_published-category-subfolder-icon'
			: ''))) {
				attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (116:5) {#if category?.image_url && category?.image_url.indexOf('default') == -1}
function create_if_block_20$2(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	return {
		c() {
			img = element("img");
			attr(img, "class", "category-image mgPlayerJSTest_custom-image mgPlayerJSTest_category-uploaded-img-view mgPlayerJSTest_published-category");
			if (!src_url_equal(img.src, img_src_value = GmCXt.restoreAssetSrc(/*category*/ ctx[0]?.image_url))) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);

			if (!mounted) {
				dispose = listen(img, "error", /*error_handler_1*/ ctx[10]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*category*/ 1 && !src_url_equal(img.src, img_src_value = GmCXt.restoreAssetSrc(/*category*/ ctx[0]?.image_url))) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}

			mounted = false;
			dispose();
		}
	};
}

// (127:4) {#if !category?.is_published && !category?.has_child && category?.image_url}
function create_if_block_16$3(ctx) {
	let show_if_1 = !/*category*/ ctx[0]?.image_url || /*category*/ ctx[0]?.image_url.indexOf('default') >= 0;
	let t;
	let show_if = /*category*/ ctx[0]?.image_url && /*category*/ ctx[0]?.image_url.indexOf('default') == -1;
	let if_block1_anchor;
	let if_block0 = show_if_1 && create_if_block_18$2();
	let if_block1 = show_if && create_if_block_17$2(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*category*/ 1) show_if_1 = !/*category*/ ctx[0]?.image_url || /*category*/ ctx[0]?.image_url.indexOf('default') >= 0;

			if (show_if_1) {
				if (if_block0) ; else {
					if_block0 = create_if_block_18$2();
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*category*/ 1) show_if = /*category*/ ctx[0]?.image_url && /*category*/ ctx[0]?.image_url.indexOf('default') == -1;

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_17$2(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(if_block1_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d(detaching);
		}
	};
}

// (128:5) {#if !category?.image_url || category?.image_url.indexOf('default') >= 0}
function create_if_block_18$2(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.folder + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (134:5) {#if category?.image_url && category?.image_url.indexOf('default') == -1}
function create_if_block_17$2(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "category-image mgPlayerJSTest_custom-image mgPlayerJSTest_category-uploaded-img-view");
			if (!src_url_equal(img.src, img_src_value = GmCXt.restoreAssetSrc(/*category*/ ctx[0]?.image_url))) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*category*/ 1 && !src_url_equal(img.src, img_src_value = GmCXt.restoreAssetSrc(/*category*/ ctx[0]?.image_url))) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}
		}
	};
}

// (142:4) {#if !category?.is_published && category?.has_child && category?.image_url}
function create_if_block_13$4(ctx) {
	let show_if_1 = !/*category*/ ctx[0]?.image_url || /*category*/ ctx[0]?.image_url.indexOf('default') >= 0;
	let t;
	let show_if = /*category*/ ctx[0]?.image_url && /*category*/ ctx[0]?.image_url.indexOf('default') == -1;
	let if_block1_anchor;
	let if_block0 = show_if_1 && create_if_block_15$4();
	let if_block1 = show_if && create_if_block_14$4(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*category*/ 1) show_if_1 = !/*category*/ ctx[0]?.image_url || /*category*/ ctx[0]?.image_url.indexOf('default') >= 0;

			if (show_if_1) {
				if (if_block0) ; else {
					if_block0 = create_if_block_15$4();
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*category*/ 1) show_if = /*category*/ ctx[0]?.image_url && /*category*/ ctx[0]?.image_url.indexOf('default') == -1;

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_14$4(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(if_block1_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d(detaching);
		}
	};
}

// (143:5) {#if !category?.image_url || category?.image_url.indexOf('default') >= 0}
function create_if_block_15$4(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.subfolder + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (149:5) {#if category?.image_url && category?.image_url.indexOf('default') == -1}
function create_if_block_14$4(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "category-image mgPlayerJSTest_custom-image mgPlayerJSTest_category-uploaded-img-view");
			if (!src_url_equal(img.src, img_src_value = GmCXt.restoreAssetSrc(/*category*/ ctx[0]?.image_url))) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*category*/ 1 && !src_url_equal(img.src, img_src_value = GmCXt.restoreAssetSrc(/*category*/ ctx[0]?.image_url))) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}
		}
	};
}

// (157:4) {#if !category?.image_url && !category?.is_published}
function create_if_block_12$4(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.folder + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (189:2) {#if !category?.has_child && GmCXt.FT.creatorApp}
function create_if_block_4$b(ctx) {
	let wmgPlayerJSTest_4;
	let t0;
	let wmgPlayerJSTest_1;
	let t1;
	let t2;
	let wmgPlayerJSTest_0;
	let t3_value = rootScope.labels.unpublishedGuides + "";
	let t3;
	let t4;
	let t5_value = /*category*/ ctx[0]?.total_unpublish_tour + "";
	let t5;
	let t6;
	let wmgPlayerJSTest_3;
	let t7;
	let t8;
	let wmgPlayerJSTest_2;
	let t9_value = rootScope.labels.publishedGuides + "";
	let t9;
	let t10;
	let t11_value = /*category*/ ctx[0]?.total_publish_tour + "";
	let t11;
	let if_block0 = rootScope.automationSelectionMode && create_if_block_9$7(ctx);
	let if_block1 = /*category*/ ctx[0]?.total_unpublish_tour <= rootScope.countLimit && create_if_block_8$8(ctx);
	let if_block2 = /*category*/ ctx[0]?.total_unpublish_tour > rootScope.countLimit && create_if_block_7$8();
	let if_block3 = /*category*/ ctx[0]?.total_publish_tour <= rootScope.countLimit && create_if_block_6$9(ctx);
	let if_block4 = /*category*/ ctx[0]?.total_publish_tour > rootScope.countLimit && create_if_block_5$a();

	return {
		c() {
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t3 = text(t3_value);
			t4 = space();
			t5 = text(t5_value);
			t6 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			if (if_block3) if_block3.c();
			t7 = space();
			if (if_block4) if_block4.c();
			t8 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t9 = text(t9_value);
			t10 = space();
			t11 = text(t11_value);
			attr(wmgPlayerJSTest_0, "class", "tour-count-tooltip");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_inline-block-vm unpublish-tour-count");
			attr(wmgPlayerJSTest_2, "class", "tour-count-tooltip");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_inline-block-vm publish-tour-count");
			attr(wmgPlayerJSTest_4, "class", "tour-count-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_4, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t0);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_1);
			if (if_block1) if_block1.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t1);
			if (if_block2) if_block2.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t2);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t3);
			append(wmgPlayerJSTest_0, t4);
			append(wmgPlayerJSTest_0, t5);
			append(wmgPlayerJSTest_4, t6);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			if (if_block3) if_block3.m(wmgPlayerJSTest_3, null);
			append(wmgPlayerJSTest_3, t7);
			if (if_block4) if_block4.m(wmgPlayerJSTest_3, null);
			append(wmgPlayerJSTest_3, t8);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, t9);
			append(wmgPlayerJSTest_2, t10);
			append(wmgPlayerJSTest_2, t11);
		},
		p(ctx, dirty) {
			if (rootScope.automationSelectionMode) if_block0.p(ctx, dirty);

			if (/*category*/ ctx[0]?.total_unpublish_tour <= rootScope.countLimit) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_8$8(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_1, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*category*/ ctx[0]?.total_unpublish_tour > rootScope.countLimit) {
				if (if_block2) ; else {
					if_block2 = create_if_block_7$8();
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_1, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*category*/ 1 && t5_value !== (t5_value = /*category*/ ctx[0]?.total_unpublish_tour + "")) set_data(t5, t5_value);

			if (/*category*/ ctx[0]?.total_publish_tour <= rootScope.countLimit) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_6$9(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_3, t7);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*category*/ ctx[0]?.total_publish_tour > rootScope.countLimit) {
				if (if_block4) ; else {
					if_block4 = create_if_block_5$a();
					if_block4.c();
					if_block4.m(wmgPlayerJSTest_3, t8);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (dirty & /*category*/ 1 && t11_value !== (t11_value = /*category*/ ctx[0]?.total_publish_tour + "")) set_data(t11, t11_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_4);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
		}
	};
}

// (191:4) {#if rootScope.automationSelectionMode}
function create_if_block_9$7(ctx) {
	let wmgPlayerJSTest_1;
	let t0;
	let t1;
	let wmgPlayerJSTest_0;
	let t2_value = rootScope.labels.selectGuideForAuto + "";
	let t2;
	let t3;
	let t4_value = /*category*/ ctx[0]?.automationTours + "";
	let t4;
	let if_block0 = /*category*/ ctx[0]?.total_publish_tour <= rootScope.countLimit && rootScope.automationSelectionMode && create_if_block_11$6(ctx);
	let if_block1 = /*category*/ ctx[0]?.total_publish_tour > rootScope.countLimit && rootScope.automationSelectionMode && create_if_block_10$6();

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t2 = text(t2_value);
			t3 = space();
			t4 = text(t4_value);
			attr(wmgPlayerJSTest_0, "class", "tour-count-tooltip");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_inline-block-vm automation-tour-count");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t0);
			if (if_block1) if_block1.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t2);
			append(wmgPlayerJSTest_0, t3);
			append(wmgPlayerJSTest_0, t4);
		},
		p(ctx, dirty) {
			if (/*category*/ ctx[0]?.total_publish_tour <= rootScope.countLimit && rootScope.automationSelectionMode) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_11$6(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_1, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*category*/ ctx[0]?.total_publish_tour > rootScope.countLimit && rootScope.automationSelectionMode) {
				if (if_block1) ; else {
					if_block1 = create_if_block_10$6();
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_1, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*category*/ 1 && t4_value !== (t4_value = /*category*/ ctx[0]?.automationTours + "")) set_data(t4, t4_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (193:6) {#if category?.total_publish_tour <= rootScope.countLimit && rootScope.automationSelectionMode}
function create_if_block_11$6(ctx) {
	let wmgPlayerJSTest_;
	let t_value = /*category*/ ctx[0]?.automationTours + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_automation-count-label");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t);
		},
		p(ctx, dirty) {
			if (dirty & /*category*/ 1 && t_value !== (t_value = /*category*/ ctx[0]?.automationTours + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (199:6) {#if category?.total_publish_tour > rootScope.countLimit && rootScope.automationSelectionMode}
function create_if_block_10$6(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_.textContent = `${rootScope.labels.countLimit}`;
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_automation-count-label");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (209:5) {#if category?.total_unpublish_tour <= rootScope.countLimit}
function create_if_block_8$8(ctx) {
	let wmgPlayerJSTest_;
	let t_value = /*category*/ ctx[0]?.total_unpublish_tour + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_unpublish-count-label");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t);
		},
		p(ctx, dirty) {
			if (dirty & /*category*/ 1 && t_value !== (t_value = /*category*/ ctx[0]?.total_unpublish_tour + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (215:5) {#if category?.total_unpublish_tour > rootScope.countLimit}
function create_if_block_7$8(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_.textContent = `${rootScope.labels.countLimit}`;
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_unpublish-count-label");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (224:5) {#if category?.total_publish_tour <= rootScope.countLimit}
function create_if_block_6$9(ctx) {
	let wmgPlayerJSTest_;
	let t_value = /*category*/ ctx[0]?.total_publish_tour + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_publish-count-label");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t);
		},
		p(ctx, dirty) {
			if (dirty & /*category*/ 1 && t_value !== (t_value = /*category*/ ctx[0]?.total_publish_tour + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (230:5) {#if category?.total_publish_tour > rootScope.countLimit}
function create_if_block_5$a(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_.textContent = `${rootScope.labels.countLimit}`;
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_publish-count-label");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (240:2) {#if category?.has_child && GmCXt.FT.creatorApp}
function create_if_block_1$e(ctx) {
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.guide_category_title + "";
	let wmgPlayerJSTest_0_class_value;
	let t0;
	let wmgPlayerJSTest_2;
	let t1;
	let t2;
	let wmgPlayerJSTest_1;
	let t3;
	let t4_value = /*category*/ ctx[0]?.total_sub_category + "";
	let t4;
	let if_block0 = /*category*/ ctx[0]?.total_sub_category <= rootScope.countLimit && create_if_block_3$c(ctx);
	let if_block1 = /*category*/ ctx[0]?.total_sub_category > rootScope.countLimit && create_if_block_2$d();

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t3 = text("Sub Folders: ");
			t4 = text(t4_value);

			attr(wmgPlayerJSTest_0, "class", wmgPlayerJSTest_0_class_value = "sub-cat-count-icon mgPlayerJSTest_inline-block-vm " + ((/*category*/ ctx[0]?.is_published)
			? 'mgPlayerJSTest_published-category'
			: ''));

			attr(wmgPlayerJSTest_1, "class", "tour-count-tooltip");
			attr(wmgPlayerJSTest_2, "class", "sub-cat-count mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_3, "class", "sub-cat-count-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			if (if_block0) if_block0.m(wmgPlayerJSTest_2, null);
			append(wmgPlayerJSTest_2, t1);
			if (if_block1) if_block1.m(wmgPlayerJSTest_2, null);
			append(wmgPlayerJSTest_2, t2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t3);
			append(wmgPlayerJSTest_1, t4);
		},
		p(ctx, dirty) {
			if (dirty & /*category*/ 1 && wmgPlayerJSTest_0_class_value !== (wmgPlayerJSTest_0_class_value = "sub-cat-count-icon mgPlayerJSTest_inline-block-vm " + ((/*category*/ ctx[0]?.is_published)
			? 'mgPlayerJSTest_published-category'
			: ''))) {
				attr(wmgPlayerJSTest_0, "class", wmgPlayerJSTest_0_class_value);
			}

			if (/*category*/ ctx[0]?.total_sub_category <= rootScope.countLimit) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$c(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_2, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*category*/ ctx[0]?.total_sub_category > rootScope.countLimit) {
				if (if_block1) ; else {
					if_block1 = create_if_block_2$d();
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_2, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*category*/ 1 && t4_value !== (t4_value = /*category*/ ctx[0]?.total_sub_category + "")) set_data(t4, t4_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (247:5) {#if category?.total_sub_category <= rootScope.countLimit}
function create_if_block_3$c(ctx) {
	let wmgPlayerJSTest_;
	let t_value = /*category*/ ctx[0]?.total_sub_category + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_sub-cat-count-label");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t);
		},
		p(ctx, dirty) {
			if (dirty & /*category*/ 1 && t_value !== (t_value = /*category*/ ctx[0]?.total_sub_category + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (253:5) {#if category?.total_sub_category > rootScope.countLimit}
function create_if_block_2$d(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_.textContent = `${rootScope.labels.countLimit}`;
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_sub-cat-count-label");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (263:1) {#if isHovered || parent}
function create_if_block$f(ctx) {
	let fourdotdropdown;
	let current;
	fourdotdropdown = new Empty({ props: { category: /*category*/ ctx[0] } });

	return {
		c() {
			create_component(fourdotdropdown.$$.fragment);
		},
		m(target, anchor) {
			mount_component(fourdotdropdown, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const fourdotdropdown_changes = {};
			if (dirty & /*category*/ 1) fourdotdropdown_changes.category = /*category*/ ctx[0];
			fourdotdropdown.$set(fourdotdropdown_changes);
		},
		i(local) {
			if (current) return;
			transition_in(fourdotdropdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fourdotdropdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(fourdotdropdown, detaching);
		}
	};
}

function create_fragment$j(ctx) {
	let wmgPlayerJSTest_10;
	let show_if = !/*parent*/ ctx[1] && rootScope.isOwnerOrAppAdmin() && GmCXt.FT.creatorApp && !rootScope.isPublicApp && !rootScope.automationSelectionMode && !rootScope.isDesktopApp() && !rootScope.hideMirrorAppCtrl();
	let t0;
	let dnd_nodrag;
	let wmgPlayerJSTest_9;
	let wmgPlayerJSTest_0;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let wmgPlayerJSTest_8;
	let wmgPlayerJSTest_3;
	let button;

	let t6_value = ((/*category*/ ctx[0]?.category_title)
	? /*category*/ ctx[0]?.category_title
	: '') + "";

	let t6;
	let t7;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;

	let t8_value = ((/*category*/ ctx[0]?.category_title)
	? /*category*/ ctx[0]?.category_title
	: '') + "";

	let t8;
	let t9;
	let wmgPlayerJSTest_7;
	let wmgPlayerJSTest_4;

	let t10_value = ((/*category*/ ctx[0]?.category_description)
	? /*category*/ ctx[0]?.category_description
	: '') + "";

	let t10;
	let t11;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_5;

	let t12_value = ((/*category*/ ctx[0]?.category_description)
	? /*category*/ ctx[0]?.category_description
	: '') + "";

	let t12;
	let t13;
	let t14;
	let t15;
	let wmgPlayerJSTest_10_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = show_if && create_if_block_25$1();
	let if_block1 = /*category*/ ctx[0]?.is_published && !/*category*/ ctx[0]?.has_child && create_if_block_22$1(ctx);
	let if_block2 = /*category*/ ctx[0]?.is_published && /*category*/ ctx[0]?.has_child && create_if_block_19$2(ctx);
	let if_block3 = !/*category*/ ctx[0]?.is_published && !/*category*/ ctx[0]?.has_child && /*category*/ ctx[0]?.image_url && create_if_block_16$3(ctx);
	let if_block4 = !/*category*/ ctx[0]?.is_published && /*category*/ ctx[0]?.has_child && /*category*/ ctx[0]?.image_url && create_if_block_13$4(ctx);
	let if_block5 = !/*category*/ ctx[0]?.image_url && !/*category*/ ctx[0]?.is_published && create_if_block_12$4();
	let if_block6 = !/*category*/ ctx[0]?.has_child && GmCXt.FT.creatorApp && create_if_block_4$b(ctx);
	let if_block7 = /*category*/ ctx[0]?.has_child && GmCXt.FT.creatorApp && create_if_block_1$e(ctx);
	let if_block8 = (/*isHovered*/ ctx[3] || /*parent*/ ctx[1]) && create_if_block$f(ctx);

	return {
		c() {
			wmgPlayerJSTest_10 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			dnd_nodrag = element("dnd-nodrag");
			wmgPlayerJSTest_9 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			if (if_block4) if_block4.c();
			t4 = space();
			if (if_block5) if_block5.c();
			t5 = space();
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			button = element("button");
			t6 = text(t6_value);
			t7 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t8 = text(t8_value);
			t9 = space();
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			t10 = text(t10_value);
			t11 = space();
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			t12 = text(t12_value);
			t13 = space();
			if (if_block6) if_block6.c();
			t14 = space();
			if (if_block7) if_block7.c();
			t15 = space();
			if (if_block8) if_block8.c();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_category-image-wrapper mgPlayerJSTest_ege-inline-block-vm");
			attr(button, "class", "mgPlayerJSTest_category-title-wrapper mgPlayerJSTest_lbl-btn mgPlayerJSTest_wrap-text");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-right mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_category-title-container mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_category-description-wrapper mgPlayerJSTest_wrap-text");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-right mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y");
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_category-desc-container mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_category-title-description-wrapper mgPlayerJSTest_ege-inline-block-vm mgPlayerJSTest_position-relative");
			attr(wmgPlayerJSTest_9, "class", "mgPlayerJSTest_category-list-item-wrapper");

			attr(wmgPlayerJSTest_10, "class", wmgPlayerJSTest_10_class_value = "mgPlayerJSTest_category-list-item " + (/*parent*/ ctx[1] ? 'active' : '') + " " + (/*subCategory*/ ctx[2] ? 'sub-category-list-item' : '') + " " + (rootScope.isMicroPlayer && /*parent*/ ctx[1]
			? 'mgPlayerJSTest_no-margin'
			: '') + " " + (GmCXt.FT.isPlayer && !(/*category*/ ctx[0]?.has_child || /*category*/ ctx[0]?.has_tour)
			? 'mgPlayerJSTest_display-none'
			: '') + " " + (rootScope.automationSelectionMode
			? 'mgPlayerJSTest_auto-selection-cat-list'
			: '') + " " + (rootScope.automationSelectionMode && !/*category*/ ctx[0]?.is_published
			? 'mgPlayerJSTest_disabled'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_10, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_10, null);
			append(wmgPlayerJSTest_10, t0);
			append(wmgPlayerJSTest_10, dnd_nodrag);
			append(dnd_nodrag, wmgPlayerJSTest_9);
			append(wmgPlayerJSTest_9, wmgPlayerJSTest_0);
			if (if_block1) if_block1.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t1);
			if (if_block2) if_block2.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t2);
			if (if_block3) if_block3.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t3);
			if (if_block4) if_block4.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t4);
			if (if_block5) if_block5.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_9, t5);
			append(wmgPlayerJSTest_9, wmgPlayerJSTest_8);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, button);
			append(button, t6);
			append(wmgPlayerJSTest_3, t7);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t8);
			append(wmgPlayerJSTest_8, t9);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, t10);
			append(wmgPlayerJSTest_7, t11);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_5, t12);
			append(dnd_nodrag, t13);
			if (if_block6) if_block6.m(dnd_nodrag, null);
			append(dnd_nodrag, t14);
			if (if_block7) if_block7.m(dnd_nodrag, null);
			append(wmgPlayerJSTest_10, t15);
			if (if_block8) if_block8.m(wmgPlayerJSTest_10, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_10, "click", prevent_default(/*click_handler*/ ctx[11])),
					listen(wmgPlayerJSTest_10, "mouseenter", /*handleMouseEnter*/ ctx[6]),
					listen(wmgPlayerJSTest_10, "mouseleave", /*handleMouseLeave*/ ctx[7])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*parent*/ 2) show_if = !/*parent*/ ctx[1] && rootScope.isOwnerOrAppAdmin() && GmCXt.FT.creatorApp && !rootScope.isPublicApp && !rootScope.automationSelectionMode && !rootScope.isDesktopApp() && !rootScope.hideMirrorAppCtrl();

			if (show_if) {
				if (if_block0) ; else {
					if_block0 = create_if_block_25$1();
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_10, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*category*/ ctx[0]?.is_published && !/*category*/ ctx[0]?.has_child) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_22$1(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_0, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*category*/ ctx[0]?.is_published && /*category*/ ctx[0]?.has_child) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_19$2(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_0, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (!/*category*/ ctx[0]?.is_published && !/*category*/ ctx[0]?.has_child && /*category*/ ctx[0]?.image_url) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_16$3(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_0, t3);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (!/*category*/ ctx[0]?.is_published && /*category*/ ctx[0]?.has_child && /*category*/ ctx[0]?.image_url) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_13$4(ctx);
					if_block4.c();
					if_block4.m(wmgPlayerJSTest_0, t4);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (!/*category*/ ctx[0]?.image_url && !/*category*/ ctx[0]?.is_published) {
				if (if_block5) ; else {
					if_block5 = create_if_block_12$4();
					if_block5.c();
					if_block5.m(wmgPlayerJSTest_0, null);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if ((!current || dirty & /*category*/ 1) && t6_value !== (t6_value = ((/*category*/ ctx[0]?.category_title)
			? /*category*/ ctx[0]?.category_title
			: '') + "")) set_data(t6, t6_value);

			if ((!current || dirty & /*category*/ 1) && t8_value !== (t8_value = ((/*category*/ ctx[0]?.category_title)
			? /*category*/ ctx[0]?.category_title
			: '') + "")) set_data(t8, t8_value);

			if ((!current || dirty & /*category*/ 1) && t10_value !== (t10_value = ((/*category*/ ctx[0]?.category_description)
			? /*category*/ ctx[0]?.category_description
			: '') + "")) set_data(t10, t10_value);

			if ((!current || dirty & /*category*/ 1) && t12_value !== (t12_value = ((/*category*/ ctx[0]?.category_description)
			? /*category*/ ctx[0]?.category_description
			: '') + "")) set_data(t12, t12_value);

			if (!/*category*/ ctx[0]?.has_child && GmCXt.FT.creatorApp) {
				if (if_block6) {
					if_block6.p(ctx, dirty);
				} else {
					if_block6 = create_if_block_4$b(ctx);
					if_block6.c();
					if_block6.m(dnd_nodrag, t14);
				}
			} else if (if_block6) {
				if_block6.d(1);
				if_block6 = null;
			}

			if (/*category*/ ctx[0]?.has_child && GmCXt.FT.creatorApp) {
				if (if_block7) {
					if_block7.p(ctx, dirty);
				} else {
					if_block7 = create_if_block_1$e(ctx);
					if_block7.c();
					if_block7.m(dnd_nodrag, null);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}

			if (/*isHovered*/ ctx[3] || /*parent*/ ctx[1]) {
				if (if_block8) {
					if_block8.p(ctx, dirty);

					if (dirty & /*isHovered, parent*/ 10) {
						transition_in(if_block8, 1);
					}
				} else {
					if_block8 = create_if_block$f(ctx);
					if_block8.c();
					transition_in(if_block8, 1);
					if_block8.m(wmgPlayerJSTest_10, null);
				}
			} else if (if_block8) {
				group_outros();

				transition_out(if_block8, 1, 1, () => {
					if_block8 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*parent, subCategory, category*/ 7 && wmgPlayerJSTest_10_class_value !== (wmgPlayerJSTest_10_class_value = "mgPlayerJSTest_category-list-item " + (/*parent*/ ctx[1] ? 'active' : '') + " " + (/*subCategory*/ ctx[2] ? 'sub-category-list-item' : '') + " " + (rootScope.isMicroPlayer && /*parent*/ ctx[1]
			? 'mgPlayerJSTest_no-margin'
			: '') + " " + (GmCXt.FT.isPlayer && !(/*category*/ ctx[0]?.has_child || /*category*/ ctx[0]?.has_tour)
			? 'mgPlayerJSTest_display-none'
			: '') + " " + (rootScope.automationSelectionMode
			? 'mgPlayerJSTest_auto-selection-cat-list'
			: '') + " " + (rootScope.automationSelectionMode && !/*category*/ ctx[0]?.is_published
			? 'mgPlayerJSTest_disabled'
			: ''))) {
				attr(wmgPlayerJSTest_10, "class", wmgPlayerJSTest_10_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block8);
			current = true;
		},
		o(local) {
			transition_out(if_block8);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_10);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (if_block7) if_block7.d();
			if (if_block8) if_block8.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function handleImageError(event) {
	event.target.src = GmCXt.conf.staticContentPath + 'folder_green.png'; // Set src to fallback image path
}

function instance$i($$self, $$props, $$invalidate) {
	let { category } = $$props;
	let { parent } = $$props;
	let { subCategory } = $$props;
	createEventDispatcher();
	let customObject;
	GmCXt.getCdnSign();
	let isHovered = false;
	let parentCategory = false;

	if (subCategory) {
		parentCategory = rootScope.getCategory(category.parent_id);
	}

	let { onFolderClick = () => {
		
	} } = $$props;

	const openCategory = async (event, category) => {
		if (category && category?.has_tour) {
			customObject = { parent: category, hasTour: true };
		} else {
			customObject = {
				parent: category,
				hasTour: category.has_tour,
				hasChild: category.has_child
			};
		}

		let e = { detail: customObject };
		onFolderClick(e);
	};

	function handleMouseEnter() {
		$$invalidate(3, isHovered = true);
	}

	function handleMouseLeave() {
		$$invalidate(3, isHovered = false);
	}

	onMount(() => {
		if (GmCXt.isPlayer()) {
			rootScope.bindPlayerTheme();
		}
	});

	const error_handler = e => {
		e.target.src = handleImageError;
	};

	const error_handler_1 = e => {
		e.target.src = GmCXt.conf.staticContentPath + 'subfolder_green.png';
	};

	const click_handler = e => !parent && openCategory(e, category);

	$$self.$$set = $$props => {
		if ('category' in $$props) $$invalidate(0, category = $$props.category);
		if ('parent' in $$props) $$invalidate(1, parent = $$props.parent);
		if ('subCategory' in $$props) $$invalidate(2, subCategory = $$props.subCategory);
		if ('onFolderClick' in $$props) $$invalidate(8, onFolderClick = $$props.onFolderClick);
	};

	return [
		category,
		parent,
		subCategory,
		isHovered,
		parentCategory,
		openCategory,
		handleMouseEnter,
		handleMouseLeave,
		onFolderClick,
		error_handler,
		error_handler_1,
		click_handler
	];
}

class FolderView extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$i, create_fragment$j, safe_not_equal, {
			category: 0,
			parent: 1,
			subCategory: 2,
			onFolderClick: 8
		});
	}
}

/* src/components/BreadCrumb.svelte generated by Svelte v4.2.20 */

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	child_ctx[10] = i;
	return child_ctx;
}

// (89:4) {#if index > 0}
function create_if_block_2$c(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = /*rootScope*/ ctx[0].svgs.iconBreadcrumArrow + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_breadcrum-arrow-icon");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.iconBreadcrumArrow + "")) wmgPlayerJSTest_.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (107:47) 
function create_if_block_1$d(ctx) {
	let t_value = /*breadCrumbItem*/ ctx[8] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*breadcrumb*/ 2 && t_value !== (t_value = /*breadCrumbItem*/ ctx[8] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (105:5) {#if breadCrumbItem?.category_title}
function create_if_block$e(ctx) {
	let t_value = /*breadCrumbItem*/ ctx[8]?.category_title + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*breadcrumb*/ 2 && t_value !== (t_value = /*breadCrumbItem*/ ctx[8]?.category_title + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (87:2) {#each breadcrumb as breadCrumbItem, index}
function create_each_block$7(ctx) {
	let li;
	let t0;
	let button;
	let button_class_value;
	let button_aria_label_value;
	let t1;
	let mounted;
	let dispose;
	let if_block0 = /*index*/ ctx[10] > 0 && create_if_block_2$c(ctx);

	function select_block_type(ctx, dirty) {
		if (/*breadCrumbItem*/ ctx[8]?.category_title) return create_if_block$e;
		if (/*breadCrumbItem*/ ctx[8] === 'All Guides') return create_if_block_1$d;
	}

	let current_block_type = select_block_type(ctx);
	let if_block1 = current_block_type && current_block_type(ctx);

	function click_handler() {
		return /*click_handler*/ ctx[3](/*breadCrumbItem*/ ctx[8]);
	}

	return {
		c() {
			li = element("li");
			if (if_block0) if_block0.c();
			t0 = space();
			button = element("button");
			if (if_block1) if_block1.c();
			t1 = space();

			attr(button, "class", button_class_value = "mgPlayerJSTest_lbl-btn mgPlayerJSTest_inline-block-vm mgPlayerJSTest_breadcrum-title " + (/*index*/ ctx[10] === /*breadcrumb*/ ctx[1].length - 1
			? 'active-breadcrum'
			: ''));

			attr(button, "aria-label", button_aria_label_value = (/*breadCrumbItem*/ ctx[8]?.category_title)
			? /*breadCrumbItem*/ ctx[8].category_title
			: /*breadCrumbItem*/ ctx[8] === 'All Guides'
				? /*breadCrumbItem*/ ctx[8]
				: '');

			attr(li, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_breadcrum-item");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			if (if_block0) if_block0.m(li, null);
			append(li, t0);
			append(li, button);
			if (if_block1) if_block1.m(button, null);
			append(li, t1);

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (/*index*/ ctx[10] > 0) if_block0.p(ctx, dirty);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if (if_block1) if_block1.d(1);
				if_block1 = current_block_type && current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(button, null);
				}
			}

			if (dirty & /*breadcrumb*/ 2 && button_class_value !== (button_class_value = "mgPlayerJSTest_lbl-btn mgPlayerJSTest_inline-block-vm mgPlayerJSTest_breadcrum-title " + (/*index*/ ctx[10] === /*breadcrumb*/ ctx[1].length - 1
			? 'active-breadcrum'
			: ''))) {
				attr(button, "class", button_class_value);
			}

			if (dirty & /*breadcrumb*/ 2 && button_aria_label_value !== (button_aria_label_value = (/*breadCrumbItem*/ ctx[8]?.category_title)
			? /*breadCrumbItem*/ ctx[8].category_title
			: /*breadCrumbItem*/ ctx[8] === 'All Guides'
				? /*breadCrumbItem*/ ctx[8]
				: '')) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(li);
			}

			if (if_block0) if_block0.d();

			if (if_block1) {
				if_block1.d();
			}

			mounted = false;
			dispose();
		}
	};
}

function create_fragment$i(ctx) {
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;
	let button;
	let raw_value = /*rootScope*/ ctx[0].svgs.btnBackBreadcrumb + "";
	let t0;
	let wmgPlayerJSTest_1;
	let t2;
	let ol;
	let ol_class_value;
	let mounted;
	let dispose;
	let each_value = ensure_array_like(/*breadcrumb*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	}

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.innerHTML = `<wmgPlayerJSTest_ class="mgPlayerJSTest_tooltip-title">Back</wmgPlayerJSTest_>`;
			t2 = space();
			ol = element("ol");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_back-btn mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm");
			attr(button, "aria-label", "back");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-right");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_back-btn-wrapper mgPlayerJSTest_inline-block-vm mgPlayerJSTest_show-text-tooltip mgPlayerJSTest_position-relative mgPlayerJSTest_cursor-pointer");

			attr(ol, "class", ol_class_value = "mgPlayerJSTest_breadcrums-container mgPlayerJSTest_inline-block-vm mgPlayerJSTest_no-margin " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_breadcrums-container-mPlayer'
			: ''));

			attr(wmgPlayerJSTest_3, "id", "mgPlayerJSTest_breadcrums-main-container");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_padding-lr-20");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_3, t2);
			append(wmgPlayerJSTest_3, ol);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ol, null);
				}
			}

			if (!mounted) {
				dispose = listen(button, "click", /*onBack*/ ctx[2]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.btnBackBreadcrumb + "")) button.innerHTML = raw_value;
			if (dirty & /*breadcrumb, rootScope*/ 3) {
				each_value = ensure_array_like(/*breadcrumb*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$7(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$7(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ol, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*rootScope*/ 1 && ol_class_value !== (ol_class_value = "mgPlayerJSTest_breadcrums-container mgPlayerJSTest_inline-block-vm mgPlayerJSTest_no-margin " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_breadcrums-container-mPlayer'
			: ''))) {
				attr(ol, "class", ol_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}

			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	let customObject;
	const dispatch = createEventDispatcher();
	let breadcrumb = get_store_value(Gm.breadCrumb);

	const breadcrumbDataSubscriber = Gm.breadCrumb.subscribe(value => {
		$$invalidate(1, breadcrumb = value);
	});

	rootScope.onClickBreadCrumbHandler = async category => {
		if (!category) {
			customObject = { parent: undefined, hasChild: false };
			dispatch('breadcrumbChanged', customObject);
		} else if (category === 'All Guides') {
			customObject = { parent: 'All Guides' };
			dispatch('breadcrumbChanged', customObject);
		} else {
			customObject = {
				parent: category,
				hasTour: category.has_tour,
				hasChild: category.has_child
			};

			dispatch('breadcrumbChanged', customObject);
		}
	};

	onDestroy(() => {
		breadcrumbDataSubscriber();
		routeActionSubscriber();
	});

	const onBack = () => {
		let category;

		if (breadcrumb.length > 1) {
			category = breadcrumb[breadcrumb.length - 2];
		}

		rootScope.onClickBreadCrumbHandler(category);
	};

	const routeActionSubscriber = Gm.routeAction.subscribe(async value => {
		if (value && value.action === 'goToAllGuides' && value.app) {
			await rootScope.onClickBreadCrumbHandler('All Guides');
			await rootScope.onClickBreadCrumbHandler('All Guides');

			// Clear the action so it doesn't trigger again
			Gm.routeAction.set(null);
		}
	});

	onMount(() => {
		if (GmCXt.isPlayer()) {
			rootScope.bindPlayerTheme();
		}
	});

	const click_handler = breadCrumbItem => rootScope.onClickBreadCrumbHandler(breadCrumbItem);
	return [rootScope, breadcrumb, onBack, click_handler];
}

class BreadCrumb extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$h, create_fragment$i, safe_not_equal, {});
	}
}

/* src/components/NoGuide.svelte generated by Svelte v4.2.20 */

function create_else_block$7(ctx) {
	let t_value = rootScope.labels.noCategoryCreatedYet + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (15:3) {#if get(Gm.breadCrumb).length}
function create_if_block$d(ctx) {
	let t_value = rootScope.labels.noGuideCreatedYet + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

function create_fragment$h(ctx) {
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.no_guides_image + "";
	let t;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;

	function select_block_type(ctx, dirty) {
		if (get_store_value(Gm.breadCrumb).length) return create_if_block$d;
		return create_else_block$7;
	}

	let current_block_type = select_block_type();
	let if_block = current_block_type(ctx);

	return {
		c() {
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			if_block.c();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_no-guide-image-cartoon");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_no-guide-image-wrapper mgPlayerJSTest_no-margin");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_no-guide-msg");
			attr(wmgPlayerJSTest_2, "tabindex", "0");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_no-guide-text-wrapper");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_no-tour-message-wrapper mgPlayerJSTest_position-center");
			toggle_class(wmgPlayerJSTest_4, "mgPlayerJSTest_margin-t-50", !rootScope.isMicroPlayer);
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_4, anchor);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_4, t);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			if_block.m(wmgPlayerJSTest_2, null);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_4);
			}

			if_block.d();
		}
	};
}

class NoGuide extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$h, safe_not_equal, {});
	}
}

/* src/components/AllGuide.svelte generated by Svelte v4.2.20 */

function get_each_context_2$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[88] = list[i];
	child_ctx[89] = list;
	child_ctx[86] = i;
	return child_ctx;
}

function get_each_context_3$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[88] = list[i];
	child_ctx[90] = list;
	child_ctx[91] = i;
	return child_ctx;
}

function get_each_context_1$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	child_ctx[86] = i;
	return child_ctx;
}

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	child_ctx[86] = i;
	return child_ctx;
}

// (953:0) {#if breadcrumb.length > 0}
function create_if_block_16$2(ctx) {
	let wmgPlayerJSTest_;
	let breadcrumb_1;
	let current;
	breadcrumb_1 = new BreadCrumb({});
	breadcrumb_1.$on("breadcrumbChanged", /*backwardtraversal*/ ctx[17]);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(breadcrumb_1.$$.fragment);
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(breadcrumb_1, wmgPlayerJSTest_, null);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(breadcrumb_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(breadcrumb_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(breadcrumb_1);
		}
	};
}

// (992:33) 
function create_if_block_4$a(ctx) {
	let folderview;
	let t;
	let show_if;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	folderview = new FolderView({
			props: {
				category: /*parent*/ ctx[7],
				parent: true,
				onFolderClick: /*onCategoryClick*/ ctx[22]
			}
		});

	folderview.$on("forwardTraversal", /*forwardTraversal*/ ctx[16]);
	const if_block_creators = [create_if_block_5$9, create_if_block_7$7, create_if_block_15$3];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (dirty[0] & /*sortedPinnedTours, toursData*/ 264) show_if = null;
		if (/*childCategories*/ ctx[2] && /*childCategories*/ ctx[2].length > 0) return 0;
		if (show_if == null) show_if = !!(!GmCXt.isEmpty(/*sortedPinnedTours*/ ctx[8]) || !GmCXt.isEmpty(/*toursData*/ ctx[3]));
		if (show_if) return 1;
		if (!/*isTourListApiOn*/ ctx[10]) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_2(ctx, [-1, -1, -1]))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			create_component(folderview.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(folderview, target, anchor);
			insert(target, t, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const folderview_changes = {};
			if (dirty[0] & /*parent*/ 128) folderview_changes.category = /*parent*/ ctx[7];
			folderview.$set(folderview_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(folderview.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(folderview.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(if_block_anchor);
			}

			destroy_component(folderview, detaching);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}
		}
	};
}

// (957:1) {#if breadcrumb.length < 1}
function create_if_block_2$b(ctx) {
	let each_1_anchor;
	let current;
	let each_value = ensure_array_like(/*allCategories*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*mouseYCoordinate, draggingItem, allCategories, draggingItemIndex, draggingItemId, distanceTopGrabbedVsPointer, hoveredItemIndex, dragCategory, onCategoryClick, forwardTraversal, rootScope*/ 5339249) {
				each_value = ensure_array_like(/*allCategories*/ ctx[0]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (1118:29) 
function create_if_block_15$3(ctx) {
	let noguide;
	let current;
	noguide = new NoGuide({});

	return {
		c() {
			create_component(noguide.$$.fragment);
		},
		m(target, anchor) {
			mount_component(noguide, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(noguide.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(noguide.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(noguide, detaching);
		}
	};
}

// (1042:73) 
function create_if_block_7$7(ctx) {
	let show_if_1 = !GmCXt.isEmpty(/*sortedPinnedTours*/ ctx[8]) && !/*rootScope*/ ctx[6].exportEnabled && GmCXt.FT.creatorApp;
	let t;
	let show_if = !GmCXt.isEmpty(/*toursData*/ ctx[3]);
	let if_block1_anchor;
	let current;
	let if_block0 = show_if_1 && create_if_block_12$3(ctx);
	let if_block1 = show_if && create_if_block_8$7(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*sortedPinnedTours, rootScope*/ 320) show_if_1 = !GmCXt.isEmpty(/*sortedPinnedTours*/ ctx[8]) && !/*rootScope*/ ctx[6].exportEnabled && GmCXt.FT.creatorApp;

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*sortedPinnedTours, rootScope*/ 320) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_12$3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*toursData*/ 8) show_if = !GmCXt.isEmpty(/*toursData*/ ctx[3]);

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*toursData*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_8$7(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(if_block1_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d(detaching);
		}
	};
}

// (1000:2) {#if childCategories && childCategories.length > 0}
function create_if_block_5$9(ctx) {
	let each_1_anchor;
	let current;
	let each_value_1 = ensure_array_like(/*childCategories*/ ctx[2]);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*mouseYCoordinate, draggingItem, childCategories, draggingItemIndex, draggingItemId, distanceTopGrabbedVsPointer, hoveredItemIndex, dragCategory, onCategoryClick, forwardTraversal, rootScope*/ 5339252) {
				each_value_1 = ensure_array_like(/*childCategories*/ ctx[2]);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1$3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (1043:3) {#if !GmCXt.isEmpty(sortedPinnedTours) && !rootScope.exportEnabled && GmCXt.FT.creatorApp}
function create_if_block_12$3(ctx) {
	let each_1_anchor;
	let current;
	let each_value_3 = ensure_array_like(/*sortedPinnedTours*/ ctx[8]);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3$2(get_each_context_3$2(ctx, each_value_3, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope, sortedPinnedTours, handleUpdatePinnedTours, showTourItem*/ 786752) {
				each_value_3 = ensure_array_like(/*sortedPinnedTours*/ ctx[8]);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3$2(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_3$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (1045:5) {#if showTourItem(tour) && !rootScope.guideHideForPlayer(tour.tour_settings) && tour.pin}
function create_if_block_13$3(ctx) {
	let wmgPlayerJSTest_;
	let t0;
	let tourview;
	let t1;
	let wmgPlayerJSTest_class_value;
	let current;
	let if_block = GmCXt.FT.creatorApp && /*rootScope*/ ctx[6].automationSelectionMode && create_if_block_14$3(ctx);
	tourview = new TourView({ props: { tour: /*tour*/ ctx[88] } });
	tourview.$on("updatePinnedTours", /*handleUpdatePinnedTours*/ ctx[19]);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block) if_block.c();
			t0 = space();
			create_component(tourview.$$.fragment);
			t1 = space();

			attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value = "mgPlayerJSTest_tour-item mgPlayerJSTest_guide-list-view " + (/*rootScope*/ ctx[6].isMicroPlayer
			? 'mgPlayerJSTest_guide-list-view-mplayer'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block) if_block.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t0);
			mount_component(tourview, wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (GmCXt.FT.creatorApp && /*rootScope*/ ctx[6].automationSelectionMode) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_14$3(ctx);
					if_block.c();
					if_block.m(wmgPlayerJSTest_, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			const tourview_changes = {};
			if (dirty[0] & /*sortedPinnedTours*/ 256) tourview_changes.tour = /*tour*/ ctx[88];
			tourview.$set(tourview_changes);

			if (!current || dirty[0] & /*rootScope*/ 64 && wmgPlayerJSTest_class_value !== (wmgPlayerJSTest_class_value = "mgPlayerJSTest_tour-item mgPlayerJSTest_guide-list-view " + (/*rootScope*/ ctx[6].isMicroPlayer
			? 'mgPlayerJSTest_guide-list-view-mplayer'
			: ''))) {
				attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(tourview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tourview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block) if_block.d();
			destroy_component(tourview);
		}
	};
}

// (1049:7) {#if GmCXt.FT.creatorApp && rootScope.automationSelectionMode}
function create_if_block_14$3(ctx) {
	let wmgPlayerJSTest_;
	let input;
	let mounted;
	let dispose;

	function input_change_handler() {
		/*input_change_handler*/ ctx[32].call(input, /*each_value_3*/ ctx[90], /*tour_index*/ ctx[91]);
	}

	function change_handler() {
		return /*change_handler*/ ctx[33](/*tour*/ ctx[88]);
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			input = element("input");
			attr(input, "class", "mgPlayerJSTest_input-checkbox-custom");
			attr(input, "type", "checkbox");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_icon-update-margin mgPlayerJSTest_ege-inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, input);
			input.checked = /*tour*/ ctx[88].automate;

			if (!mounted) {
				dispose = [
					listen(input, "change", input_change_handler),
					listen(input, "change", change_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*sortedPinnedTours*/ 256) {
				input.checked = /*tour*/ ctx[88].automate;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (1044:4) {#each sortedPinnedTours as tour}
function create_each_block_3$2(ctx) {
	let show_if = /*showTourItem*/ ctx[18](/*tour*/ ctx[88]) && !/*rootScope*/ ctx[6].guideHideForPlayer(/*tour*/ ctx[88].tour_settings) && /*tour*/ ctx[88].pin;
	let if_block_anchor;
	let current;
	let if_block = show_if && create_if_block_13$3(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*sortedPinnedTours, rootScope*/ 320) show_if = /*showTourItem*/ ctx[18](/*tour*/ ctx[88]) && !/*rootScope*/ ctx[6].guideHideForPlayer(/*tour*/ ctx[88].tour_settings) && /*tour*/ ctx[88].pin;

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*sortedPinnedTours, rootScope*/ 320) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_13$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (1064:3) {#if !GmCXt.isEmpty(toursData)}
function create_if_block_8$7(ctx) {
	let each_1_anchor;
	let current;
	let each_value_2 = ensure_array_like(/*toursData*/ ctx[3]);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope, toursData, mouseYCoordinate, draggingItem, draggingItemIndex, draggingItemId, distanceTopGrabbedVsPointer, hoveredItemIndex, dragTours, handleUpdatePinnedTours, showTourItem*/ 2914424) {
				each_value_2 = ensure_array_like(/*toursData*/ ctx[3]);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_2$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (1066:5) {#if showTourItem(tour) && !rootScope.guideHideForPlayer(tour.tour_settings)}
function create_if_block_9$6(ctx) {
	let wmgPlayerJSTest_;
	let show_if;
	let current_block_type_index;
	let if_block;
	let t;
	let wmgPlayerJSTest_class_value;
	let current;
	const if_block_creators = [create_if_block_10$5, create_else_block_2$2];
	const if_blocks = [];

	function select_block_type_4(ctx, dirty) {
		if (dirty[0] & /*rootScope*/ 64) show_if = null;
		if (show_if == null) show_if = !!(!(!/*rootScope*/ ctx[6].isOwnerOrAppAdmin() || !GmCXt.FT.creatorApp || /*rootScope*/ ctx[6].isDesktopApp() || /*rootScope*/ ctx[6].hideMirrorAppCtrl() || /*rootScope*/ ctx[6].exportEnabled) && !/*rootScope*/ ctx[6].automationSelectionMode);
		if (show_if) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_4(ctx, [-1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if_block.c();
			t = space();

			attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value = "mgPlayerJSTest_tour-item mgPlayerJSTest_guide-list-view " + (/*rootScope*/ ctx[6].isMicroPlayer
			? 'mgPlayerJSTest_guide-list-view-mplayer'
			: '') + " " + (!/*tour*/ ctx[88].is_locked || /*tour*/ ctx[88].user_id == /*rootScope*/ ctx[6].user.user_id || /*rootScope*/ ctx[6].isOwnerOrAppAdmin()
			? 'unlocked-guide'
			: '') + " " + (/*rootScope*/ ctx[6].automationSelectionMode && !/*tour*/ ctx[88].is_published
			? 'mgPlayerJSTest_disabled'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if_blocks[current_block_type_index].m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_4(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(wmgPlayerJSTest_, t);
			}

			if (!current || dirty[0] & /*rootScope, toursData*/ 72 && wmgPlayerJSTest_class_value !== (wmgPlayerJSTest_class_value = "mgPlayerJSTest_tour-item mgPlayerJSTest_guide-list-view " + (/*rootScope*/ ctx[6].isMicroPlayer
			? 'mgPlayerJSTest_guide-list-view-mplayer'
			: '') + " " + (!/*tour*/ ctx[88].is_locked || /*tour*/ ctx[88].user_id == /*rootScope*/ ctx[6].user.user_id || /*rootScope*/ ctx[6].isOwnerOrAppAdmin()
			? 'unlocked-guide'
			: '') + " " + (/*rootScope*/ ctx[6].automationSelectionMode && !/*tour*/ ctx[88].is_published
			? 'mgPlayerJSTest_disabled'
			: ''))) {
				attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if_blocks[current_block_type_index].d();
		}
	};
}

// (1101:7) {:else}
function create_else_block_2$2(ctx) {
	let t;
	let tourview;
	let current;
	let if_block = GmCXt.FT.creatorApp && /*rootScope*/ ctx[6].automationSelectionMode && create_if_block_11$5(ctx);
	tourview = new TourView({ props: { tour: /*tour*/ ctx[88] } });
	tourview.$on("updatePinnedTours", /*handleUpdatePinnedTours*/ ctx[19]);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			create_component(tourview.$$.fragment);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			mount_component(tourview, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (GmCXt.FT.creatorApp && /*rootScope*/ ctx[6].automationSelectionMode) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_11$5(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			const tourview_changes = {};
			if (dirty[0] & /*toursData*/ 8) tourview_changes.tour = /*tour*/ ctx[88];
			tourview.$set(tourview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tourview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tourview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}

			if (if_block) if_block.d(detaching);
			destroy_component(tourview, detaching);
		}
	};
}

// (1074:7) {#if !(!rootScope.isOwnerOrAppAdmin() || !GmCXt.FT.creatorApp || rootScope.isDesktopApp() || rootScope.hideMirrorAppCtrl() || rootScope.exportEnabled) && !rootScope.automationSelectionMode}
function create_if_block_10$5(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[6].svgs.drag_dots + "";
	let t;
	let tourview;
	let current;
	let mounted;
	let dispose;
	tourview = new TourView({ props: { tour: /*tour*/ ctx[88] } });
	tourview.$on("updatePinnedTours", /*handleUpdatePinnedTours*/ ctx[19]);

	function dragstart_handler_2(...args) {
		return /*dragstart_handler_2*/ ctx[34](/*tour*/ ctx[88], /*index*/ ctx[86], ...args);
	}

	function dragover_handler_2(...args) {
		return /*dragover_handler_2*/ ctx[36](/*index*/ ctx[86], ...args);
	}

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t = space();
			create_component(tourview.$$.fragment);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_drag-guide-icon-wrapper mgPlayerJSTest_ege-inline-block-vm");
			attr(wmgPlayerJSTest_1, "draggable", "true");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_1, t);
			mount_component(tourview, wmgPlayerJSTest_1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_1, "dragstart", dragstart_handler_2),
					listen(wmgPlayerJSTest_1, "drag", /*drag_handler_2*/ ctx[35]),
					listen(wmgPlayerJSTest_1, "dragover", dragover_handler_2),
					listen(wmgPlayerJSTest_1, "dragend", /*dragend_handler_2*/ ctx[37])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty[0] & /*rootScope*/ 64) && raw_value !== (raw_value = /*rootScope*/ ctx[6].svgs.drag_dots + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			const tourview_changes = {};
			if (dirty[0] & /*toursData*/ 8) tourview_changes.tour = /*tour*/ ctx[88];
			tourview.$set(tourview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tourview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tourview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			destroy_component(tourview);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (1102:8) {#if GmCXt.FT.creatorApp && rootScope.automationSelectionMode}
function create_if_block_11$5(ctx) {
	let wmgPlayerJSTest_;
	let input;
	let mounted;
	let dispose;

	function input_change_handler_1() {
		/*input_change_handler_1*/ ctx[38].call(input, /*each_value_2*/ ctx[89], /*index*/ ctx[86]);
	}

	function change_handler_1() {
		return /*change_handler_1*/ ctx[39](/*tour*/ ctx[88]);
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			input = element("input");
			attr(input, "class", "mgPlayerJSTest_input-checkbox-custom");
			attr(input, "type", "checkbox");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_icon-update-margin mgPlayerJSTest_ege-inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, input);
			input.checked = /*tour*/ ctx[88].automate;

			if (!mounted) {
				dispose = [
					listen(input, "change", input_change_handler_1),
					listen(input, "change", change_handler_1)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*toursData*/ 8) {
				input.checked = /*tour*/ ctx[88].automate;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (1065:4) {#each toursData as tour, index}
function create_each_block_2$2(ctx) {
	let show_if = /*showTourItem*/ ctx[18](/*tour*/ ctx[88]) && !/*rootScope*/ ctx[6].guideHideForPlayer(/*tour*/ ctx[88].tour_settings);
	let if_block_anchor;
	let current;
	let if_block = show_if && create_if_block_9$6(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*toursData, rootScope*/ 72) show_if = /*showTourItem*/ ctx[18](/*tour*/ ctx[88]) && !/*rootScope*/ ctx[6].guideHideForPlayer(/*tour*/ ctx[88].tour_settings);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*toursData, rootScope*/ 72) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_9$6(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (1032:4) {:else}
function create_else_block_1$2(ctx) {
	let folderview;
	let current;

	folderview = new FolderView({
			props: {
				category: /*category*/ ctx[15],
				parent: false,
				subCategory: true,
				onFolderClick: /*onCategoryClick*/ ctx[22]
			}
		});

	folderview.$on("forwardTraversal", /*forwardTraversal*/ ctx[16]);

	return {
		c() {
			create_component(folderview.$$.fragment);
		},
		m(target, anchor) {
			mount_component(folderview, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const folderview_changes = {};
			if (dirty[0] & /*childCategories*/ 4) folderview_changes.category = /*category*/ ctx[15];
			folderview.$set(folderview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(folderview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(folderview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(folderview, detaching);
		}
	};
}

// (1002:4) {#if !(!rootScope.isOwnerOrAppAdmin() || !GmCXt.FT.creatorApp || rootScope.isDesktopApp() || rootScope.hideMirrorAppCtrl())}
function create_if_block_6$8(ctx) {
	let wmgPlayerJSTest_;
	let folderview;
	let t;
	let current;
	let mounted;
	let dispose;

	folderview = new FolderView({
			props: {
				category: /*category*/ ctx[15],
				parent: false,
				subCategory: true,
				onFolderClick: /*onCategoryClick*/ ctx[22]
			}
		});

	folderview.$on("forwardTraversal", /*forwardTraversal*/ ctx[16]);

	function dragstart_handler_1(...args) {
		return /*dragstart_handler_1*/ ctx[28](/*category*/ ctx[15], /*index*/ ctx[86], ...args);
	}

	function dragover_handler_1(...args) {
		return /*dragover_handler_1*/ ctx[30](/*index*/ ctx[86], ...args);
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(folderview.$$.fragment);
			t = space();
			attr(wmgPlayerJSTest_, "draggable", "true");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(folderview, wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			current = true;

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_, "dragstart", dragstart_handler_1),
					listen(wmgPlayerJSTest_, "drag", /*drag_handler_1*/ ctx[29]),
					listen(wmgPlayerJSTest_, "dragover", dragover_handler_1),
					listen(wmgPlayerJSTest_, "dragend", /*dragend_handler_1*/ ctx[31])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const folderview_changes = {};
			if (dirty[0] & /*childCategories*/ 4) folderview_changes.category = /*category*/ ctx[15];
			folderview.$set(folderview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(folderview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(folderview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(folderview);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (1001:3) {#each childCategories as category, index}
function create_each_block_1$3(ctx) {
	let show_if;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_6$8, create_else_block_1$2];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (dirty[0] & /*rootScope*/ 64) show_if = null;
		if (show_if == null) show_if = !!!(!/*rootScope*/ ctx[6].isOwnerOrAppAdmin() || !GmCXt.FT.creatorApp || /*rootScope*/ ctx[6].isDesktopApp() || /*rootScope*/ ctx[6].hideMirrorAppCtrl());
		if (show_if) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_3(ctx, [-1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

// (988:3) {:else}
function create_else_block$6(ctx) {
	let folderview;
	let current;

	folderview = new FolderView({
			props: {
				category: /*category*/ ctx[15],
				parent: false,
				onFolderClick: /*onCategoryClick*/ ctx[22]
			}
		});

	folderview.$on("forwardTraversal", /*forwardTraversal*/ ctx[16]);

	return {
		c() {
			create_component(folderview.$$.fragment);
		},
		m(target, anchor) {
			mount_component(folderview, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const folderview_changes = {};
			if (dirty[0] & /*allCategories*/ 1) folderview_changes.category = /*category*/ ctx[15];
			folderview.$set(folderview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(folderview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(folderview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(folderview, detaching);
		}
	};
}

// (959:3) {#if !(!rootScope.isOwnerOrAppAdmin() || !GmCXt.FT.creatorApp || rootScope.isDesktopApp() || rootScope.hideMirrorAppCtrl())}
function create_if_block_3$b(ctx) {
	let wmgPlayerJSTest_;
	let folderview;
	let t;
	let current;
	let mounted;
	let dispose;

	folderview = new FolderView({
			props: {
				category: /*category*/ ctx[15],
				parent: false,
				onFolderClick: /*onCategoryClick*/ ctx[22]
			}
		});

	folderview.$on("forwardTraversal", /*forwardTraversal*/ ctx[16]);

	function dragstart_handler(...args) {
		return /*dragstart_handler*/ ctx[24](/*category*/ ctx[15], /*index*/ ctx[86], ...args);
	}

	function dragover_handler(...args) {
		return /*dragover_handler*/ ctx[26](/*index*/ ctx[86], ...args);
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(folderview.$$.fragment);
			t = space();
			attr(wmgPlayerJSTest_, "draggable", "true");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(folderview, wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			current = true;

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_, "dragstart", dragstart_handler),
					listen(wmgPlayerJSTest_, "drag", /*drag_handler*/ ctx[25]),
					listen(wmgPlayerJSTest_, "dragover", dragover_handler),
					listen(wmgPlayerJSTest_, "dragend", /*dragend_handler*/ ctx[27])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const folderview_changes = {};
			if (dirty[0] & /*allCategories*/ 1) folderview_changes.category = /*category*/ ctx[15];
			folderview.$set(folderview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(folderview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(folderview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(folderview);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (958:2) {#each allCategories as category, index}
function create_each_block$6(ctx) {
	let show_if;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_3$b, create_else_block$6];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (dirty[0] & /*rootScope*/ 64) show_if = null;
		if (show_if == null) show_if = !!!(!/*rootScope*/ ctx[6].isOwnerOrAppAdmin() || !GmCXt.FT.creatorApp || /*rootScope*/ ctx[6].isDesktopApp() || /*rootScope*/ ctx[6].hideMirrorAppCtrl());
		if (show_if) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, [-1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

// (1123:1) {#if rootScope.automationSelectionMode}
function create_if_block_1$c(ctx) {
	let guideautomation;
	let current;
	guideautomation = new Empty({});

	return {
		c() {
			create_component(guideautomation.$$.fragment);
		},
		m(target, anchor) {
			mount_component(guideautomation, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(guideautomation.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(guideautomation.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(guideautomation, detaching);
		}
	};
}

// (1127:1) {#if allCategories.length == 0}
function create_if_block$c(ctx) {
	let noguide;
	let current;
	noguide = new NoGuide({});

	return {
		c() {
			create_component(noguide.$$.fragment);
		},
		m(target, anchor) {
			mount_component(noguide, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(noguide.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(noguide.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(noguide, detaching);
		}
	};
}

function create_fragment$g(ctx) {
	let t0;
	let wmgPlayerJSTest_;
	let current_block_type_index;
	let if_block1;
	let t1;
	let t2;
	let current;
	let if_block0 = /*breadcrumb*/ ctx[1].length > 0 && create_if_block_16$2(ctx);
	const if_block_creators = [create_if_block_2$b, create_if_block_4$a];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*breadcrumb*/ ctx[1].length < 1) return 0;
		if (/*breadcrumb*/ ctx[1].length > 0) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	let if_block2 = /*rootScope*/ ctx[6].automationSelectionMode && create_if_block_1$c();
	let if_block3 = /*allCategories*/ ctx[0].length == 0 && create_if_block$c();

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_category-list");
			set_style(wmgPlayerJSTest_, "height", "682px");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, wmgPlayerJSTest_, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(wmgPlayerJSTest_, null);
			}

			append(wmgPlayerJSTest_, t1);
			if (if_block2) if_block2.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t2);
			if (if_block3) if_block3.m(wmgPlayerJSTest_, null);
			/*wmgPlayerJSTest_binding*/ ctx[40](wmgPlayerJSTest_);
			current = true;
		},
		p(ctx, dirty) {
			if (/*breadcrumb*/ ctx[1].length > 0) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*breadcrumb*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_16$2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block1) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(wmgPlayerJSTest_, t1);
				} else {
					if_block1 = null;
				}
			}

			if (/*rootScope*/ ctx[6].automationSelectionMode) {
				if (if_block2) {
					if (dirty[0] & /*rootScope*/ 64) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1$c();
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(wmgPlayerJSTest_, t2);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*allCategories*/ ctx[0].length == 0) {
				if (if_block3) {
					if (dirty[0] & /*allCategories*/ 1) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block$c();
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(wmgPlayerJSTest_);
			}

			if (if_block0) if_block0.d(detaching);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			/*wmgPlayerJSTest_binding*/ ctx[40](null);
		}
	};
}

let limit$1 = 50;

function filterDuplicateCategories(categories) {
	let uniqueNames = [];
	let uniqueData = [];

	mg$.each(categories, function (i, el) {
		if (mg$.inArray(el.category_id, uniqueNames) === -1) {
			uniqueNames.push(el.category_id);
			uniqueData.push(el);
		}
	});

	return uniqueData;
}

function instance$g($$self, $$props, $$invalidate) {
	let allCategories = [];
	let categories = [];
	let breadcrumb = [];
	let subCategories = [];
	let parent;
	let childCategories = [];
	let toursData = [];
	let activeSortFilter;
	let selectedLang;
	let noTours = false;
	let categoryId = 0;
	let category;
	let pinnedTours = [];
	let tours = [];
	let sub_categories = [];
	let sortedPinnedTours = [];
	let offset = 0;
	let isPreviousCategoryEventComplete = true;
	let isPreviousTourEventComplete = true;
	let isPreviousSubcategoryEventComplete = true;
	let categoriesFetchedInLastApiCall = 0;
	let subcategoriesFetchedInLastApiCall = 0;
	let toursFetchedInLastApiCall = 0;
	let categoryList;
	let previousView;
	let isTourListApiOn = false;
	let activeTourId = rootScope.activeTourId;
	activeTourId = activeTourId ? activeTourId : 0;

	if (GmCXt.getLXPLang()) {
		selectedLang = GmCXt.getLXPLang();
	} else {
		selectedLang = get_store_value(Gm.selectedLang);
	}

	let setHeight = function () {
		let listPageHeaderHeight = mg$('.mgPlayerJSTest_list-page-header').innerHeight()
		? mg$('.mgPlayerJSTest_list-page-header').innerHeight()
		: 0;

		let egeHeaderHeight = mg$('#mgPlayerJSTest_ege-header').innerHeight()
		? mg$('#mgPlayerJSTest_ege-header').innerHeight()
		: 0;

		let egePanelHeaderSubMenuUrlsHeight = mg$('.mgPlayerJSTest_ege-panel-header-sub-menu-urls').innerHeight()
		? mg$('.mgPlayerJSTest_ege-panel-header-sub-menu-urls').innerHeight()
		: 0;

		let breadCrumsHeight = mg$('#mgPlayerJSTest_breadcrums-main-container').innerHeight()
		? mg$('#mgPlayerJSTest_breadcrums-main-container').innerHeight()
		: 0;

		let footerHeight = mg$('#mgPlayerJSTest_footer-panel-container').innerHeight()
		? mg$('#mgPlayerJSTest_footer-panel-container').innerHeight()
		: 0;

		mg$('.mgPlayerJSTest_category-list').css({
			height: window.innerHeight - footerHeight - egePanelHeaderSubMenuUrlsHeight - listPageHeaderHeight - egeHeaderHeight - breadCrumsHeight
		});
	};

	const createGuideCompleted = function (data) {
		let categoryTours = get_store_value(Gm.categoryTours);
		categoryTours.push(data.tour);
		Gm.categoryTours.set(categoryTours);
	};

	const createCategoryCompleted = function (data) {
		
	}; // console.log("createGuideCompleted", data);
	// let categoryTours = get(Gm.categoryTours);
	// console.log("Gm.categoryTours", categoryTours);
	// categoryTours.push(data.tour);

	// console.log("Gm.categoryTours", categoryTours);
	// Gm.categoryTours.set(categoryTours);
	const selectedLangSubscriber = Gm.selectedLang.subscribe(value => {
		if (value && value === 'default' && rootScope.defaultLang) {
			$$invalidate(6, rootScope.language = rootScope.defaultLang.language, rootScope);
		} else {
			$$invalidate(6, rootScope.language = value, rootScope);
		}

		if (!GmCXt.getLXPLang()) {
			selectedLang = value;
		}

		$$invalidate(0, allCategories = rootScope.prepCatLangJson(get_store_value(Gm.allCategories), selectedLang));
		sub_categories = rootScope.prepCatLangJson(get_store_value(Gm.subCategories), selectedLang);
		$$invalidate(3, toursData = updateTourlang(get_store_value(Gm.categoryTours)));
		$$invalidate(2, childCategories = rootScope.prepCatLangJson(get_store_value(Gm.childCategories), selectedLang));

		if (parent) {
			$$invalidate(7, parent = rootScope.prepSingCatLang(parent, selectedLang));
			breadcrumb.pop();
			breadcrumb.push(parent);
			Gm.breadCrumb.set(breadcrumb);
		}
	});

	function updateTourlang(toursData) {
		if (toursData) {
			toursData = toursData.map(tour => {
				tour = rootScope.getTranslatedTourAndSteps(tour, selectedLang);
				return tour;
			});
		}

		return toursData;
	}

	const categoryToursSubscriber = Gm.categoryTours.subscribe(value => {
		$$invalidate(3, toursData = updateTourlang(value));

		if (GmCXt.FT.creatorApp) {
			processPinnedTours();
		}
	});

	function processPinnedTours() {
		if (toursData && toursData.length > 0) {
			if (!GmCXt.isEmpty(rootScope.pinnedToursList)) {
				let pinnedTourList = rootScope.pinnedToursList.toString();

				$$invalidate(23, pinnedTours = toursData.filter(function (t) {
					t.pin = pinnedTourList.includes(t.tour_id);
					return pinnedTourList.includes(t.tour_id);
				}));

				const pinnedTourIds = pinnedTours.map(tour => tour.tour_id);
				const filteredToursData = toursData.filter(tour => !pinnedTourIds.includes(tour.tour_id));
				$$invalidate(3, toursData = filteredToursData);
				getSortedPinnedTours();
			}
		}
	}

	const childSubscriber = Gm.childCategories.subscribe(value => {
		if (GmCXt.inPlayer && value) {
			$$invalidate(2, childCategories = rootScope.prepCatLangJson(value, selectedLang));
		} else {
			$$invalidate(2, childCategories = value);
		}
	});

	const processTourResponse = function (append, _tours, _pinnedTours) {
		if (_tours && _tours.length > 0) {
			noTours = false;
			if (append) tours = mg$.merge(tours, _tours); else tours = _tours;
			tours = rootScope.filterDefaultGuides(tours);
			tours = GmCXt.removeDuplicateGuides(tours);

			if (GmCXt.FT.creatorApp) {
				tours = rootScope.getTranslatedTours(tours);

				if (!GmCXt.isEmpty(_pinnedTours)) {
					let pinnedTourList = _pinnedTours.toString();

					$$invalidate(23, pinnedTours = tours.filter(function (t) {
						t.pin = pinnedTourList.includes(t.tour_id);
						return pinnedTourList.includes(t.tour_id);
					}));

					tours.filter(function (t) {
						t.pin = pinnedTourList.includes(t.tour_id);
						return !pinnedTourList.includes(t.tour_id);
					});
				} else {
					$$invalidate(23, pinnedTours = []);
				}
			}

			toursFetchedInLastApiCall = _tours.length;
			$$invalidate(6, rootScope.totalTours = tours.length, rootScope);

			if (activeTourId && GmCXt.isDefined(_tours[activeTourId])) {
				_tours[activeTourId].screencastInProgress = true;
			}
		} else if (!append) noTours = true; else if (append) noTours = false;

		isPreviousTourEventComplete = true;
		tours = rootScope.getTranslatedTours(tours);
	};

	const getTourList = function (append) {
		Gm.loading.set(true);

		if (append === 0) {
			offset = 0;
			$$invalidate(10, isTourListApiOn = true);
		}

		let params = { category_id: categoryId, limit: limit$1, offset }; //reloadFlag: reloadFlag

		function cb(_tours, _pinnedTours) {
			if (GmCXt.isPlayer() && !GmCXt.isEmpty(_tours)) _tours = GmCXt.filterScheduleTours(_tours);
			_tours = rootScope.filterAnnouncement(_tours);
			$$invalidate(6, rootScope.pinnedToursList = _pinnedTours, rootScope);
			GmCXt.saveToDapStorage('pinnedToursList', rootScope.pinnedToursList);
			processTourResponse(append, _tours, _pinnedTours);

			// Show the selected tours as selected to the user by,
			// adding the automate flag(used to identify selection) to the tour object
			_tours.forEach(function (t, key) {
				t.automate = false;
				t.tour_order = parseInt(t.tour_order);
			});

			rootScope.categoryDataForAutomation.forEach(function (cat, key) {
				if (cat.category_id === category?.category_id) {
					if (cat.tours.length === parseInt(cat.total_publish_tour)) ;

					tours.forEach(function (tour, key) {
						cat.tours.forEach(function (t, key) {
							if (t.tour_id === tour.tour_id) {
								tour.automate = true;
							}
						});
					});
				}
			});

			Gm.loading.set(false);
			$$invalidate(6, rootScope.isApiCallOn = false, rootScope);

			if (GmCXt.isPlayer()) {
				tours = tours.filter(function (t) {
					return !GmCXt.isFeatureTags(t);
				});
			}

			if (rootScope.guideSegmentation && GmCXt.FT.isPlayer) {
				GmCXt.checkGuidesBasedOnSegment(tours, segmentCb, 'guideListSeg');
			} else {
				Gm.categoryTours.set(tours);
			}

			Gm.childCategories.set(undefined);
			$$invalidate(10, isTourListApiOn = false);

			if (GmCXt.FT.creatorApp) {
				rootScope.checkCurrentViewForUpdate();
			}
		}

		if (GmCXt.FT.publishedGuides) params.published_guides = '1';

		if (rootScope.isUserLoggedIn() || GmCXt.onPrem()) {
			let toursListFromStorage = rootScope.allTourList['cat_' + categoryId];

			if (!rootScope.hasUserEditedTour || GmCXt.isEmpty(toursListFromStorage)) {
				api.getTourList(params, cb);
			} else {
				let toursList = Object.keys(toursListFromStorage).map(function (key) {
					return toursListFromStorage[key];
				});

				cb(toursList, rootScope.pinnedToursList);
			}
		}

		if (!rootScope.hasUserEditedTour) {
			Gm.loading.set(true);
		}
	};

	const processSubCategoriesResponse = function (_categories, append) {
		if (_categories && _categories.length > 0) {
			let categoryList = [];
			subcategoriesFetchedInLastApiCall = _categories.length;

			_categories.forEach(function (subCat, key) {
				categoryList.push(subCat);
				subCat.automationTours = 0;

				rootScope.categoryDataForAutomation.forEach(function (cat, key) {
					if (cat.category_id === subCat.category_id) {
						subCat.automationTours = cat.tours.length;
					}
				});
			});

			if (rootScope.subCategoryStore && GmCXt.isEmpty(rootScope.subCategoryStore['cat_' + categoryId])) {
				rootScope.addMultiCategory(categoryList, categoryId);
			}

			if (append) {
				sub_categories = mg$.merge(sub_categories, categoryList);
			} else {
				sub_categories = _categories;
			}

			sub_categories = GmCXt.removeDuplicateCategories(sub_categories);

			if (GmCXt.inPlayer) {
				sub_categories = rootScope.prepCatLangJson(sub_categories, rootScope.language);
			}

			if (!sub_categories.length) noTours = true;
		} else if (!sub_categories.length) {
			noTours = true;
		}

		Gm.childCategories.set(sub_categories);
		rootScope.checkCurrentViewForUpdate();

		//Set height to category-list element to properly apply slider
		//$timeout(function() {
		//setHeight();
		//}, 500);
		Gm.loading.set(false);

		isPreviousSubcategoryEventComplete = true;
	};

	let getSubCategories = function (append) {
		Gm.loading.set(true);

		if (append === 0) {
			offset = 0;
		}

		let params = { parent_id: categoryId, limit: limit$1, offset };

		function cb(_categories) {
			processSubCategoriesResponse(_categories, append);
			Gm.loading.set(false);
			$$invalidate(6, rootScope.isApiCallOn = false, rootScope);
		}

		if (GmCXt.FT.publishedCat) {
			params.is_publish = '1';
		}

		rootScope.getCategoryListApi(params, cb);
	};

	function forwardTraversal(event) {
		Gm.childCategories.set(undefined);
		Gm.categoryTours.set(undefined);
		Gm.parent.set(event.detail.parent);
		$$invalidate(1, breadcrumb = get_store_value(Gm.breadCrumb));

		if (breadcrumb.length < 1) {
			breadcrumb.push('All Guides');
		}

		const exists = breadcrumb.some(item => typeof item === 'object' && item.category_id === parent.category_id);

		if (!exists) {
			breadcrumb.push(parent);
		}

		Gm.breadCrumb.set(breadcrumb);

		if (event.detail.hasChild) {
			let filterSubCat = [];

			if (GmCXt.isEmpty(parent.sub_categories) && !GmCXt.inPlayer) {
				$$invalidate(6, rootScope.subCategoryStore = [], rootScope);
				categoryId = event.detail.parent.category_id;
				getSubCategories(0);
			} else {
				filterSubCat = parent.sub_categories.filter(subCat => {
					return subCat.has_tour
					? rootScope.filterGuideByEnv(subCat.tours).length > 0
					: true;
				});

				Gm.childCategories.set(filterSubCat);
			}

			Gm.categoryTours.set(undefined);
		} else if (event.detail.hasTour) {
			Gm.categoryTours.set([]);

			if (GmCXt.isEmpty(parent.tours) && !GmCXt.inPlayer) {
				categoryId = event.detail.parent.category_id;
				getTourList(0);
			} else {
				setTimeout(
					() => {
						let envTours = rootScope.filterGuideByEnv(parent.tours);

						if (GmCXt.isPlayer() && !GmCXt.isEmpty(envTours)) {
							envTours = GmCXt.filterScheduleTours(envTours);

							envTours = envTours.filter(function (t) {
								return !GmCXt.isFeatureTags(t);
							});

							envTours = rootScope.filterAnnouncement(envTours);
						}

						GmCXt.checkGuidesBasedOnSegment(envTours, segmentCb, 'guideListSeg');
						Gm.childCategories.set(undefined);
					},
					1
				);
			}
		}

		$$invalidate(15, category = parent);
	}

	function backwardtraversal(event) {
		Gm.loading.set(true);
		Gm.categoryTours.set([]);
		Gm.childCategories.set([]);
		Gm.stepOperationMode.set(GmCXt.STEP_VIEW_OPERATION);
		$$invalidate(8, sortedPinnedTours = []);
		let index = -1;
		let customObject = event.detail;
		let category;
		let categoryData = customObject.parent;
		Gm.loading.set(true);
		category = allCategories.find(obj => obj.category_id === categoryData.category_id);

		if (!category && categoryData.category_id && !GmCXt.isEmpty(subCategories)) {
			category = subCategories.find(obj => obj.category_id === categoryData.category_id);
		} else if (categoryData.category_id && !GmCXt.inPlayer) {
			category = categoryData;
		}

		Gm.parent.set(category);

		if (parent && parent !== 'All Guides') {
			index = breadcrumb.findIndex(item => item.category_id === parent.category_id);
		}

		if (index !== -1) {
			$$invalidate(1, breadcrumb = breadcrumb.slice(0, index + 1));
		} else {
			$$invalidate(1, breadcrumb = []);
			Gm.breadCrumb.set(breadcrumb);

			if (!GmCXt.inPlayer) {
				refreshAllGuidesView();
			} else {
				Gm.loading.set(false);
			}

			return;
		}

		Gm.breadCrumb.set(breadcrumb);

		if (customObject.hasChild) {
			let filterSubCat = [];

			if (GmCXt.isEmpty(parent.sub_categories) && !GmCXt.inPlayer) {
				categoryId = customObject.parent.category_id;
				getSubCategories(0);
			} else {
				filterSubCat = parent.sub_categories.filter(subCat => {
					return subCat.has_tour
					? rootScope.filterGuideByEnv(subCat.tours).length > 0
					: true;
				});

				Gm.childCategories.set(filterSubCat);
				Gm.loading.set(false);
			}

			Gm.categoryTours.set(undefined);
		}

		if (customObject.hasTour) {
			Gm.categoryTours.set([]);

			if (GmCXt.isEmpty(parent.tours) && !GmCXt.inPlayer) {
				categoryId = customObject.parent.category_id;

				// toursFetchedInLastApiCall = 0;
				getTourList(0);
			} else {
				let envTours = rootScope.filterGuideByEnv(parent.tours);

				if (GmCXt.isPlayer() && !GmCXt.isEmpty(envTours)) {
					envTours = GmCXt.filterScheduleTours(envTours);
					envTours = rootScope.filterAnnouncement(envTours);
				}

				GmCXt.checkGuidesBasedOnSegment(envTours, segmentCb, 'guideListSeg');
				Gm.loading.set(false);
			}

			Gm.childCategories.set(undefined);
		}
	}

	function segmentCb(t) {
		if (!GmCXt.isEmpty(t)) {
			let segmentedTours = get_store_value(Gm.categoryTours);
			segmentedTours.push(t);
			segmentedTours = GmCXt.removeDuplicateGuides(segmentedTours);
			Gm.categoryTours.set(segmentedTours);
		}
	}

	function allGuideCb(_categories, append, lang) {
		$$invalidate(6, rootScope.refreshAllGuides = false, rootScope);

		if (GmCXt.isEmpty(_categories) && GmCXt.isEmpty(categories)) {
			noTours = true;
		} else {
			noTours = false;

			if (_categories) {
				categoriesFetchedInLastApiCall = _categories.length;

				_categories.forEach(function (category, key) {
					if (category.category_image === 1) category.category_image = 0;
					category.automationTours = 0;

					rootScope.categoryDataForAutomation.forEach(function (cat) {
						if (cat.category_id === category?.category_id) {
							category.automationTours = cat.tours.length;
						}
					});

					category.category_order = parseInt(category?.category_order);
				});
			}

			if (append) {
				categories = mg$.merge(categories, _categories);
			} else {
				categories = _categories;
			}

			categories = filterDuplicateCategories(categories);
			isPreviousCategoryEventComplete = true;

			if (GmCXt.isEmpty(rootScope.categoryStore)) {
				rootScope.addMultiCategory(categories);
			}

			if (GmCXt.inPlayer) {
				categories = rootScope.prepCatLangJson(categories, lang);
			}
		} //rootScope.focusAccessibilityBtn();

		Gm.allCategories.set(categories);
		$$invalidate(6, rootScope.isApiCallOn = false, rootScope);

		if (!rootScope.isAppJsonCalling) {
			Gm.loading.set(false);
		}

		rootScope.checkCurrentViewForUpdate();
	}

	function refreshAllGuidesView(append) {
		if (rootScope.isApiCallOn) return;

		if (rootScope.resetOffset) {
			offset = 0;
			$$invalidate(6, rootScope.resetOffset = false, rootScope);
		}

		if (append === 0) {
			offset = 0;
			offset = 0;
		}

		let len = limit$1;

		if (rootScope.categoryStore) {
			let clength = Object.keys(rootScope.categoryStore).length;
			len = rootScope.getApiLimit(clength);
		}

		mgError.try(
			function () {
				let params = {
					parent_id: 0,
					limit: rootScope.refreshAllGuides ? len : limit$1,
					offset: append ? offset : 0
				};

				if (GmCXt.getLXPLang()) {
					params.language = GmCXt.getLXPLang();
				} else if (rootScope.language && rootScope.language.indexOf('en-') === -1 && !GmCXt.isFalse(rootScope.language)) {
					params.language = rootScope.language;
				}

				if (GmCXt.FT.publishedCat) {
					params.is_publish = '1';
				}

				Gm.loading.set(true);
				$$invalidate(6, rootScope.isApiCallOn = true, rootScope);

				api.getCategoryList(params, function (c) {
					allGuideCb(c, append, params.language);
				});
			},
			804
		);
	}

	function getSortKey() {
		if (rootScope.automationSelectionMode) {
			return 'is_published';
		}

		return activeSortFilter ? activeSortFilter : 'tour_order';
	}

	function getSortedPinnedTours() {
		const key = getSortKey();
		$$invalidate(8, sortedPinnedTours = [...pinnedTours]);

		$$invalidate(8, sortedPinnedTours = sortedPinnedTours.sort((a, b) => {
			let valueA = a[key];
			let valueB = b[key];
			if (valueA < valueB) return -1;
			if (valueA > valueB) return 1;
			return 0;
		}));

		if (rootScope.descOrder) {
			$$invalidate(8, sortedPinnedTours = sortedPinnedTours.reverse());
		}
	}

	function showTourItem(tour) {
		if (noTours) {
			return false;
		}

		if (tour.tour_type === 'smartTip' && tour.tour_settings.tour_type === 'desktop') {
			return false;
		}

		if (tour.tour_type === 'bot' && GmCXt.isPlayer()) {
			return false;
		}

		return tour.tour_type !== 'smartTip' || GmCXt.FT.creatorApp;
	}

	function handleUpdatePinnedTours(event) {
		if (event.detail.action == 'pin') {
			let updatedPinnedTour = event.detail.tour;
			updatedPinnedTour.pin = true;
			$$invalidate(23, pinnedTours = [...pinnedTours, updatedPinnedTour]);
			$$invalidate(3, toursData = toursData.filter(tour => tour.tour_id !== updatedPinnedTour.tour_id));
		} else if (event.detail.action == 'unpin') {
			let updatedUnpinnedTour = event.detail.tour;
			$$invalidate(23, pinnedTours = pinnedTours.filter(tour => tour.tour_id !== updatedUnpinnedTour.tour_id));
			updatedUnpinnedTour.pin = false;
			$$invalidate(3, toursData = [...toursData, updatedUnpinnedTour]);
			$$invalidate(3, toursData = toursData.sort((a, b) => a.tour_order - b.tour_order));
		}
	}

	function determineCurrentView() {
		if (toursData && toursData.length > 0 && breadcrumb.length > 0) {
			return 'tour';
		} else if (childCategories && childCategories.length > 0 && breadcrumb.length > 0) {
			return 'subcategory';
		} else if (allCategories.length > 0 || breadcrumb.length < 1) {
			return 'category';
		}

		return null;
	}

	const breadcrumbDataSubscriber = Gm.breadCrumb.subscribe(value => {
		$$invalidate(1, breadcrumb = value);
	});

	const activeSortFilterStore = Gm.activeSortFilterStore.subscribe(value => {
		activeSortFilter = value;
		$$invalidate(0, allCategories = rootScope.sortDataByActiveFilter(allCategories, 'category_title', activeSortFilter));
		$$invalidate(2, childCategories = rootScope.sortDataByActiveFilter(childCategories, 'category_title', activeSortFilter));
		$$invalidate(3, toursData = rootScope.sortDataByActiveFilter(toursData, 'tour_title', activeSortFilter));
	});

	const categoryDataSubscriber = Gm.allCategories.subscribe(value => {
		$$invalidate(0, allCategories = rootScope.prepCatLangJson(value, selectedLang));
		setHeight();
	});

	Gm.subCategories.subscribe(value => {
		subCategories = value;
	});

	const parentSubscriber = Gm.parent.subscribe(value => {
		$$invalidate(7, parent = value);
		setHeight();
	});

	const routeActionSubscriber = Gm.routeAction.subscribe(value => {
		if (value && value.action === 'createGuideCompleted' && value.data) {
			createGuideCompleted(value.data);

			// Clear the action so it doesn't trigger again
			Gm.routeAction.set(null);
		} else if (value && value.action === 'createCategoryCompleted' && value.data) {
			createCategoryCompleted(value.data);
			Gm.routeAction.set(null);
		} else if (value && value.action === 'cat_import_compleated' && value.data) {
			categoryId = value.data.catId;
			getSubCategories(0);
			Gm.routeAction.set(null);
		} else if (value && value.action === 'on_app_select' && value.app) {
			Gm.breadCrumb.set([]);
			Gm.allCategories.set([]);
			$$invalidate(6, rootScope.myGuidesFilter = false, rootScope);
			$$invalidate(6, rootScope.currentUserFilter = false, rootScope);
			$$invalidate(6, rootScope.filterByPublishedGuides = '', rootScope);
			refreshAllGuidesView();

			// Clear the action so it doesn't trigger again
			Gm.routeAction.set(null);
		}
	});

	let tourListRefreshSubscriber;

	tourListRefreshSubscriber = Gm.isTourListRefresh.subscribe(value => {
		if (value) {
			let carParent = get_store_value(Gm.parent);
			if (value.data) carParent = value.data;

			if (carParent) {
				categoryId = carParent.category_id;
				getTourList(0);
				Gm.isTourListRefresh.set(false);
			}
		}

		if (tourListRefreshSubscriber) {
			tourListRefreshSubscriber();
		}
	});

	onMount(() => {
		let routeAction = get_store_value(Gm.routeAction);

		if (routeAction && routeAction.action === 'backwardTraversal' && routeAction.data) {
			backwardtraversal(routeAction.data);
			Gm.routeAction.set(null);
		} else if (routeAction && routeAction.action === 'forwardTraversal' && routeAction.data) {
			forwardTraversal(routeAction.data);
			Gm.routeAction.set(null);
		}

		if (GmCXt.inPlayer) Gm.loading.set(false);

		if (!GmCXt.inPlayer) {
			setTimeout(
				() => {
					refreshAllGuidesView();
				},
				100
			);
		}

		setHeight();

		mg$('.mgPlayerJSTest_category-list').off('scroll').on('scroll', function () {
			let currentView = determineCurrentView(); // Replace with your logic to determine the current view

			if (previousView != currentView) {
				offset = 0;
				mg$(this).scrollTop(0);
			}

			previousView = currentView;

			if (currentView === 'tour') {
				if (!isPreviousTourEventComplete) return true;

				if (mg$(this).scrollTop() + mg$(this).innerHeight() >= mg$(this)[0].scrollHeight - 20 && mg$(this)[0].scrollHeight + 20 > mg$(this).innerHeight()) {
					isPreviousTourEventComplete = false;

					if (toursFetchedInLastApiCall === limit$1) {
						// rootScopeshowSpinner = true;
						offset = offset + limit$1;

						getTourList(1);
					}
				}
			} else if (currentView === 'category') {
				if (!isPreviousCategoryEventComplete) return true;

				if (mg$(this).scrollTop() + mg$(this).innerHeight() >= mg$(this)[0].scrollHeight - 20 && mg$(this)[0].scrollHeight + 20 > mg$(this).innerHeight()) {
					isPreviousCategoryEventComplete = false;

					if (categoriesFetchedInLastApiCall === limit$1) {
						// rootScopeshowSpinner = true;
						offset = offset + limit$1;

						refreshAllGuidesView(1);
					}
				}
			} else if (currentView === 'subcategory') {
				if (!isPreviousSubcategoryEventComplete) return true;

				if (mg$(this).scrollTop() + mg$(this).innerHeight() >= mg$(this)[0].scrollHeight - 20 && mg$(this)[0].scrollHeight + 20 > mg$(this).innerHeight()) {
					isPreviousSubcategoryEventComplete = false;

					if (subcategoriesFetchedInLastApiCall === limit$1) {
						offset = offset + limit$1;
						getSubCategories(1);
					}
				}
			}
		});
	});

	mg$(window).off('resize').on('resize', setHeight);

	onDestroy(() => {
		document.removeEventListener('forwardTraversal', forwardTraversal);
		$$invalidate(6, rootScope.isForwardListenerAttached = false, rootScope);
		categoryDataSubscriber();
		breadcrumbDataSubscriber();
		categoryToursSubscriber();
		childSubscriber();
		parentSubscriber();
		routeActionSubscriber();
		activeSortFilterStore();
		tourListRefreshSubscriber();
		selectedLangSubscriber();
	});

	let mouseYCoordinate = null; // pointer y coordinate within client
	let distanceTopGrabbedVsPointer = null;
	let draggingItem = null;
	let draggingItemId = null;
	let draggingItemIndex = null;
	let hoveredItemIndex = null;
	allCategories = rootScope.sortDataByActiveFilter(allCategories, 'category_title', activeSortFilter);
	childCategories = rootScope.sortDataByActiveFilter(childCategories, 'category_title', activeSortFilter);
	toursData = rootScope.sortDataByActiveFilter(toursData, 'tour_title', activeSortFilter);

	let dragCategory = function (categories) {
		mgError.try(
			function () {
				let sortedCategories = [];

				categories.filter(function (el, index) {
					sortedCategories.push({
						category_id: el.category_id,
						category_order: index + 1
					});

					el.category_order = index + 1;
					rootScope.updateCategory(el, 'category_order', parseInt(index + 1));
				});

				sortedCategories = GmCXt.removeDuplicates(sortedCategories);

				let data = {
					organization_id: GmCXt.organization.organization_id,
					json: sortedCategories
				};

				function onFail(data) {
					rootScope.showPopup(data.message);
				}

				api.categoriesDrag(data, onFail);
			},
			803
		);
	};

	let dragTours = function (tours) {
		let sortedTours = [];

		tours.filter(function (el, index) {
			sortedTours.push({
				tour_id: el.tour_id,
				tour_order: index + 1
			});

			el.tour_order = index + 1;
			rootScope.setTour(el, false);
		});

		sortedTours = GmCXt.removeDuplicates(sortedTours);

		let data = {
			category_id: tours[0].category_id,
			json: sortedTours
		};

		function onFail(data) {
			rootScope.showPopup(data.message[0]);
		}

		api.toursDrag(data, onFail);
	};

	function onCategoryClick(e) {
		forwardTraversal(e);
	}

	const dragstart_handler = (category, index, e) => {
		$$invalidate(11, mouseYCoordinate = e.clientY);
		$$invalidate(13, draggingItem = category);
		$$invalidate(4, draggingItemIndex = index);
		$$invalidate(14, draggingItemId = category.category_id);
		$$invalidate(12, distanceTopGrabbedVsPointer = e.target.getBoundingClientRect().y - e.clientY);
	};

	const drag_handler = e => {
		$$invalidate(11, mouseYCoordinate = e.clientY);
	};

	const dragover_handler = (index, e) => {
		$$invalidate(5, hoveredItemIndex = index);
	};

	const dragend_handler = e => {
		dragCategory(allCategories);
		$$invalidate(14, draggingItemId = null); // makes item visible
		$$invalidate(5, hoveredItemIndex = null); // prevents instant swap
	};

	const dragstart_handler_1 = (category, index, e) => {
		$$invalidate(11, mouseYCoordinate = e.clientY);
		$$invalidate(13, draggingItem = category);
		$$invalidate(4, draggingItemIndex = index);
		$$invalidate(14, draggingItemId = category.category_id);
		$$invalidate(12, distanceTopGrabbedVsPointer = e.target.getBoundingClientRect().y - e.clientY);
	};

	const drag_handler_1 = e => {
		$$invalidate(11, mouseYCoordinate = e.clientY);
	};

	const dragover_handler_1 = (index, e) => {
		$$invalidate(5, hoveredItemIndex = index);
	};

	const dragend_handler_1 = e => {
		dragCategory(childCategories);
		$$invalidate(14, draggingItemId = null); // makes item visible
		$$invalidate(5, hoveredItemIndex = null); // prevents instant swap
	};

	function input_change_handler(each_value_3, tour_index) {
		each_value_3[tour_index].automate = this.checked;
		$$invalidate(8, sortedPinnedTours);
	}

	const change_handler = tour => rootScope.onChangeSelectedTourForAutomation(tour);

	const dragstart_handler_2 = (tour, index, e) => {
		$$invalidate(11, mouseYCoordinate = e.clientY);
		$$invalidate(13, draggingItem = tour);
		$$invalidate(4, draggingItemIndex = index);
		$$invalidate(14, draggingItemId = tour.tour_id);
		$$invalidate(12, distanceTopGrabbedVsPointer = e.target.getBoundingClientRect().y - e.clientY);
	};

	const drag_handler_2 = e => {
		$$invalidate(11, mouseYCoordinate = e.clientY);
	};

	const dragover_handler_2 = (index, e) => {
		$$invalidate(5, hoveredItemIndex = index);
	};

	const dragend_handler_2 = e => {
		dragTours(toursData);
		$$invalidate(14, draggingItemId = null); // makes item visible
		$$invalidate(5, hoveredItemIndex = null); // prevents instant swap
	};

	function input_change_handler_1(each_value_2, index) {
		each_value_2[index].automate = this.checked;
		((((($$invalidate(3, toursData), $$invalidate(4, draggingItemIndex)), $$invalidate(5, hoveredItemIndex)), $$invalidate(1, breadcrumb)), $$invalidate(0, allCategories)), $$invalidate(2, childCategories));
	}

	const change_handler_1 = tour => rootScope.onChangeSelectedTourForAutomation(tour);

	function wmgPlayerJSTest_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			categoryList = $$value;
			$$invalidate(9, categoryList);
		});
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*draggingItemIndex, hoveredItemIndex, breadcrumb, allCategories, childCategories, toursData*/ 63) {
			{
				if (draggingItemIndex != null && hoveredItemIndex != null && draggingItemIndex != hoveredItemIndex) {
					if (breadcrumb.length < 1) {
						// swap items
						$$invalidate(0, [allCategories[draggingItemIndex], allCategories[hoveredItemIndex]] = [allCategories[hoveredItemIndex], allCategories[draggingItemIndex]], allCategories);
					} else if (childCategories && childCategories.length > 0) {
						// swap items
						$$invalidate(
							2,
							[
								childCategories[draggingItemIndex],
								childCategories[hoveredItemIndex]
							] = [
								childCategories[hoveredItemIndex],
								childCategories[draggingItemIndex]
							],
							childCategories
						);
					} else if (toursData) {
						// swap items
						$$invalidate(3, [toursData[draggingItemIndex], toursData[hoveredItemIndex]] = [toursData[hoveredItemIndex], toursData[draggingItemIndex]], toursData);
					}

					// balance
					$$invalidate(4, draggingItemIndex = hoveredItemIndex);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*pinnedTours*/ 8388608) {
			{
				if (pinnedTours.length >= 0) {
					getSortedPinnedTours();
				}
			}
		}
	};

	return [
		allCategories,
		breadcrumb,
		childCategories,
		toursData,
		draggingItemIndex,
		hoveredItemIndex,
		rootScope,
		parent,
		sortedPinnedTours,
		categoryList,
		isTourListApiOn,
		mouseYCoordinate,
		distanceTopGrabbedVsPointer,
		draggingItem,
		draggingItemId,
		category,
		forwardTraversal,
		backwardtraversal,
		showTourItem,
		handleUpdatePinnedTours,
		dragCategory,
		dragTours,
		onCategoryClick,
		pinnedTours,
		dragstart_handler,
		drag_handler,
		dragover_handler,
		dragend_handler,
		dragstart_handler_1,
		drag_handler_1,
		dragover_handler_1,
		dragend_handler_1,
		input_change_handler,
		change_handler,
		dragstart_handler_2,
		drag_handler_2,
		dragover_handler_2,
		dragend_handler_2,
		input_change_handler_1,
		change_handler_1,
		wmgPlayerJSTest_binding
	];
}

class AllGuide extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$g, create_fragment$g, safe_not_equal, {}, null, [-1, -1, -1]);
	}
}

/* src/components/StepModes.svelte generated by Svelte v4.2.20 */

function create_if_block_11$4(ctx) {
	let wmgPlayerJSTest_1;
	let button;
	let raw_value = rootScope.svgs.myGuide + "";
	let t0;
	let wmgPlayerJSTest_0;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0.textContent = `${rootScope.labels.preview}`;
			attr(button, "id", "mgPlayerJSTest_btn-tour-action-preview");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_guide-view-header-panel-icons mgPlayerJSTest_header-icon-preview mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center");
			attr(button, "aria-label", "preview smartTip");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_guide-view-header-panel-icons-text");
			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_guide-play-mode-preview-container");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_guide-view-header-panel mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_flex-direction-column");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[9]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			mounted = false;
			dispose();
		}
	};
}

// (217:2) {#if !rootScope.isAnnouncement(tour)}
function create_if_block$b(ctx) {
	let show_if_3 = /*showGuideMe*/ ctx[4]();
	let t0;
	let show_if_2 = /*showShowMe*/ ctx[5]();
	let t1;
	let show_if_1 = /*showDoItForMe*/ ctx[6]();
	let t2;
	let show_if = /*showTestMe*/ ctx[7]();
	let if_block3_anchor;
	let if_block0 = show_if_3 && create_if_block_8$6(ctx);
	let if_block1 = show_if_2 && create_if_block_5$8(ctx);
	let if_block2 = show_if_1 && create_if_block_2$a(ctx);
	let if_block3 = show_if && create_if_block_1$b(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			if_block3_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t2, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert(target, if_block3_anchor, anchor);
		},
		p(ctx, dirty) {
			if (show_if_3) if_block0.p(ctx, dirty);
			if (show_if_2) if_block1.p(ctx, dirty);
			if (show_if_1) if_block2.p(ctx, dirty);
			if (show_if) if_block3.p(ctx, dirty);
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(t2);
				detach(if_block3_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d(detaching);
			if (if_block2) if_block2.d(detaching);
			if (if_block3) if_block3.d(detaching);
		}
	};
}

// (218:3) {#if showGuideMe()}
function create_if_block_8$6(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let button;
	let raw_value = rootScope.svgs.myGuide + "";
	let t0;
	let show_if_1 = /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) !== rootScope.playGuideMe && !GmCXt.FT.isPlayer && !/*tour*/ ctx[0].is_published && !rootScope.hideMirrorAppCtrl();
	let t1;
	let show_if = /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === rootScope.playGuideMe && GmCXt.FT.creatorApp && !/*tour*/ ctx[0].is_published;
	let t2;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_class_value;
	let mounted;
	let dispose;
	let if_block0 = show_if_1 && create_if_block_10$4(ctx);
	let if_block1 = show_if && create_if_block_9$5();

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.guideMe}`;
			attr(button, "id", "mgPlayerJSTest_btn-tour-action-guideme");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_guide-view-header-panel-icons mgPlayerJSTest_header-icon-guideme mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_active-play-mode");
			attr(button, "aria-label", "GuideMe");
			toggle_class(button, "mgPlayerJSTest_active-play-mode", /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === 'guideMe');
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_guide-play-mode-wrapper mgPlayerJSTest_position-relative");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_guide-view-header-panel-icons-text ng-binding");
			attr(wmgPlayerJSTest_2, "id", "mgPlayerJSTest_guide-play-mode-guide-container");
			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_guide-view-header-panel mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_flex-direction-column " + (/*tour*/ ctx[0].is_published ? 'published-tour' : ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_0, t0);
			if (if_block0) if_block0.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t1);
			if (if_block1) if_block1.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_2, t2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_1*/ ctx[10]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*guideDefaultPlayAction, tour*/ 5) {
				toggle_class(button, "mgPlayerJSTest_active-play-mode", /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === 'guideMe');
			}

			if (dirty & /*tour*/ 1) show_if_1 = /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) !== rootScope.playGuideMe && !GmCXt.FT.isPlayer && !/*tour*/ ctx[0].is_published && !rootScope.hideMirrorAppCtrl();

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_10$4(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_0, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*tour*/ 1) show_if = /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === rootScope.playGuideMe && GmCXt.FT.creatorApp && !/*tour*/ ctx[0].is_published;

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_9$5();
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_0, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*tour*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_guide-view-header-panel mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_flex-direction-column " + (/*tour*/ ctx[0].is_published ? 'published-tour' : ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

// (235:6) {#if guideDefaultPlayAction(tour) !== rootScope.playGuideMe && !GmCXt.FT.isPlayer && !tour.is_published && !rootScope.hideMirrorAppCtrl()}
function create_if_block_10$4(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "type", "radio");
			attr(input, "class", "mgPlayerJSTest_input-radio-custom mgPlayerJSTest_opacity mgPlayerJSTest_opacity-2");
			attr(input, "name", "mgPlayerJSTest_guide-play-mode");
		},
		m(target, anchor) {
			insert(target, input, anchor);

			if (!mounted) {
				dispose = listen(input, "click", /*click_handler_2*/ ctx[11]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			mounted = false;
			dispose();
		}
	};
}

// (247:6) {#if guideDefaultPlayAction(tour) === rootScope.playGuideMe && GmCXt.FT.creatorApp && !tour.is_published}
function create_if_block_9$5(ctx) {
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = GmCXt.svgs.doubleTick + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.defaultGuidePlayAction}`;
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-top-right mgPlayerJSTest_margin-tb-5");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_selected-mode-tick mgPlayerJSTest_position-relative");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}
		}
	};
}

// (262:3) {#if showShowMe()}
function create_if_block_5$8(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let button;
	let raw_value = rootScope.svgs.myShow + "";
	let t0;
	let show_if_1 = /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) !== rootScope.playSlideshow && !GmCXt.FT.isPlayer && !/*tour*/ ctx[0].is_published && !rootScope.hideMirrorAppCtrl() && !rootScope.isDesktopApp();
	let t1;
	let show_if = /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === rootScope.playSlideshow && GmCXt.FT.creatorApp && !/*tour*/ ctx[0].is_published;
	let t2;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_class_value;
	let mounted;
	let dispose;
	let if_block0 = show_if_1 && create_if_block_7$6(ctx);
	let if_block1 = show_if && create_if_block_6$7();

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.showMe}`;
			attr(button, "id", "mgPlayerJSTest_btn-tour-action-showme");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_guide-view-header-panel-icons mgPlayerJSTest_header-icon-showme mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center");
			toggle_class(button, "mgPlayerJSTest_active-play-mode", /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === 'slideshow');
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_guide-play-mode-wrapper mgPlayerJSTest_position-relative");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_guide-view-header-panel-icons-text ng-binding");
			attr(wmgPlayerJSTest_2, "id", "mgPlayerJSTest_guide-play-mode-showme-container");
			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_guide-view-header-panel mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_flex-direction-column " + (/*tour*/ ctx[0].is_published ? 'published-tour' : ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_0, t0);
			if (if_block0) if_block0.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t1);
			if (if_block1) if_block1.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_2, t2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_3*/ ctx[12]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*guideDefaultPlayAction, tour*/ 5) {
				toggle_class(button, "mgPlayerJSTest_active-play-mode", /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === 'slideshow');
			}

			if (dirty & /*tour*/ 1) show_if_1 = /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) !== rootScope.playSlideshow && !GmCXt.FT.isPlayer && !/*tour*/ ctx[0].is_published && !rootScope.hideMirrorAppCtrl() && !rootScope.isDesktopApp();

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_7$6(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_0, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*tour*/ 1) show_if = /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === rootScope.playSlideshow && GmCXt.FT.creatorApp && !/*tour*/ ctx[0].is_published;

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_6$7();
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_0, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*tour*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_guide-view-header-panel mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_flex-direction-column " + (/*tour*/ ctx[0].is_published ? 'published-tour' : ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

// (278:6) {#if guideDefaultPlayAction(tour) !== rootScope.playSlideshow && !GmCXt.FT.isPlayer && !tour.is_published && !rootScope.hideMirrorAppCtrl() && !rootScope.isDesktopApp()}
function create_if_block_7$6(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "type", "radio");
			attr(input, "class", "mgPlayerJSTest_input-radio-custom mgPlayerJSTest_opacity mgPlayerJSTest_opacity-2");
			attr(input, "name", "mgPlayerJSTest_guide-play-mode");
		},
		m(target, anchor) {
			insert(target, input, anchor);

			if (!mounted) {
				dispose = listen(input, "click", /*click_handler_4*/ ctx[13]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			mounted = false;
			dispose();
		}
	};
}

// (290:6) {#if guideDefaultPlayAction(tour) === rootScope.playSlideshow && GmCXt.FT.creatorApp && !tour.is_published}
function create_if_block_6$7(ctx) {
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = GmCXt.svgs.doubleTick + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.defaultGuidePlayAction}`;
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-top-right mgPlayerJSTest_margin-tb-5");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_selected-mode-tick mgPlayerJSTest_position-relative");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}
		}
	};
}

// (305:3) {#if showDoItForMe()}
function create_if_block_2$a(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let button;
	let raw_value = rootScope.svgs.myBot + "";
	let t0;
	let show_if_1 = /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) !== rootScope.playAuto && !GmCXt.FT.isPlayer && !/*tour*/ ctx[0].is_published && !rootScope.hideMirrorAppCtrl();
	let t1;
	let show_if = /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === rootScope.playAuto && GmCXt.FT.creatorApp && !/*tour*/ ctx[0].is_published;
	let t2;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_class_value;
	let mounted;
	let dispose;
	let if_block0 = show_if_1 && create_if_block_4$9(ctx);
	let if_block1 = show_if && create_if_block_3$a();

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.doItForMe}`;
			attr(button, "id", "mgPlayerJSTest_btn-tour-action-doitforme");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_guide-view-header-panel-icons mgPlayerJSTest_header-icon-doit mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center");
			toggle_class(button, "mgPlayerJSTest_active-play-mode", /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === 'doitforme');
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_guide-play-mode-wrapper mgPlayerJSTest_position-relative");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_guide-view-header-panel-icons-text ng-binding");
			attr(wmgPlayerJSTest_2, "id", "mgPlayerJSTest_guide-play-mode-doitforme-container");
			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_guide-view-header-panel mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_flex-direction-column " + (/*tour*/ ctx[0].is_published ? 'published-tour' : ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_0, t0);
			if (if_block0) if_block0.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t1);
			if (if_block1) if_block1.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_2, t2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_5*/ ctx[14]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*guideDefaultPlayAction, tour*/ 5) {
				toggle_class(button, "mgPlayerJSTest_active-play-mode", /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === 'doitforme');
			}

			if (dirty & /*tour*/ 1) show_if_1 = /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) !== rootScope.playAuto && !GmCXt.FT.isPlayer && !/*tour*/ ctx[0].is_published && !rootScope.hideMirrorAppCtrl();

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$9(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_0, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*tour*/ 1) show_if = /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === rootScope.playAuto && GmCXt.FT.creatorApp && !/*tour*/ ctx[0].is_published;

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$a();
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_0, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*tour*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_guide-view-header-panel mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_flex-direction-column " + (/*tour*/ ctx[0].is_published ? 'published-tour' : ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

// (321:6) {#if guideDefaultPlayAction(tour) !== rootScope.playAuto && !GmCXt.FT.isPlayer && !tour.is_published && !rootScope.hideMirrorAppCtrl()}
function create_if_block_4$9(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "type", "radio");
			attr(input, "class", "mgPlayerJSTest_input-radio-custom mgPlayerJSTest_opacity mgPlayerJSTest_opacity-2");
			attr(input, "name", "mgPlayerJSTest_guide-play-mode");
		},
		m(target, anchor) {
			insert(target, input, anchor);

			if (!mounted) {
				dispose = listen(input, "click", /*click_handler_6*/ ctx[15]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			mounted = false;
			dispose();
		}
	};
}

// (333:6) {#if guideDefaultPlayAction(tour) === rootScope.playAuto && GmCXt.FT.creatorApp && !tour.is_published}
function create_if_block_3$a(ctx) {
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = GmCXt.svgs.doubleTick + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.defaultGuidePlayAction}`;
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-top-right mgPlayerJSTest_margin-tb-5");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_selected-mode-tick mgPlayerJSTest_position-relative");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}
		}
	};
}

// (348:3) {#if showTestMe()}
function create_if_block_1$b(ctx) {
	let wmgPlayerJSTest_1;
	let button;
	let raw_value = rootScope.svgs.myTest + "";
	let t0;
	let wmgPlayerJSTest_0;
	let wmgPlayerJSTest_1_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0.textContent = `${rootScope.labels.testMe}`;
			attr(button, "id", "mgPlayerJSTest_btn-tour-action-testme");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_guide-view-header-panel-icons mgPlayerJSTest_header-icon-doit mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center");
			attr(button, "aria-label", "TestMe");
			toggle_class(button, "mgPlayerJSTest_active-play-mode", /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === 'testMe');
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_guide-view-header-panel-icons-text ng-binding");
			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_guide-play-mode-testme-container");

			attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_guide-view-header-panel mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_flex-direction-column " + (/*tour*/ ctx[0].is_published
			? 'published-tour'
			: 'disabled'));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_7*/ ctx[16]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*guideDefaultPlayAction, tour*/ 5) {
				toggle_class(button, "mgPlayerJSTest_active-play-mode", /*guideDefaultPlayAction*/ ctx[2](/*tour*/ ctx[0]) === 'testMe');
			}

			if (dirty & /*tour*/ 1 && wmgPlayerJSTest_1_class_value !== (wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_guide-view-header-panel mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_flex-direction-column " + (/*tour*/ ctx[0].is_published
			? 'published-tour'
			: 'disabled'))) {
				attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			mounted = false;
			dispose();
		}
	};
}

function create_fragment$f(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let show_if_1 = rootScope.isTooltip(/*tour*/ ctx[0]) && /*tour*/ ctx[0].step_count > 0;
	let t;
	let show_if = !rootScope.isAnnouncement(/*tour*/ ctx[0]);
	let wmgPlayerJSTest_1_class_value;
	let if_block0 = show_if_1 && create_if_block_11$4(ctx);
	let if_block1 = show_if && create_if_block$b(ctx);

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_guide-view-header-panel-container mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between " + (/*tour*/ ctx[0].isEditMode ? 'mgPlayerJSTest_disabled' : ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			if (if_block0) if_block0.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_0, t);
			if (if_block1) if_block1.m(wmgPlayerJSTest_0, null);
		},
		p(ctx, [dirty]) {
			if (dirty & /*tour*/ 1) show_if_1 = rootScope.isTooltip(/*tour*/ ctx[0]) && /*tour*/ ctx[0].step_count > 0;

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_11$4(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_0, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*tour*/ 1) show_if = !rootScope.isAnnouncement(/*tour*/ ctx[0]);

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$b(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_0, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*tour*/ 1 && wmgPlayerJSTest_1_class_value !== (wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_guide-view-header-panel-container mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between " + (/*tour*/ ctx[0].isEditMode ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	let tour = get_store_value(Gm.currentTour);

	const currentTourSubscriber = Gm.currentTour.subscribe(value => {
		$$invalidate(0, tour = value);
	});

	onDestroy(() => {
		currentTourSubscriber();
	});

	const guideAction = (e, type, step) => {
		e.stopPropagation();

		if (type === 'doitforme' && GmCXt.disableDoItForMe) {
			modal.open(rootScope.labels.doitForMeWarning, 'warning');
			return false;
		}

		rootScope.guideAction(type, step, tour, get_store_value(Gm.CurrentPage), '');
	};

	const guideDefaultPlayAction = t => {
		let action = t.tour_settings.defaultPlayAction;

		if (action === 'Default') {
			action = GmCXt.getAppSetting('defaultPlayAction');
		}

		return action;
	};

	const showTestMeWidget = () => {
		let tour = get_store_value(Gm.currentTour);

		let newSteps = tour.steps.filter(function (el) {
			return el.step_type === 'inline';
		});

		if (newSteps.length) {
			new TestMeWidget({
					target: document.body,
					props: { showTestMe: true, tour }
				});
		} else {
			rootScope.showPopup(rootScope.labels.noInappStepInGuide);
		}
	};

	const showGuideMe = () => {
		let tour = get_store_value(Gm.currentTour);
		if (!tour) return false;
		let option = rootScope.existsOrUndefined(GmCXt.getAppSetting('guideMeSetting'));
		let dAction = true;
		let ts = GmCXt.createDeepCopy(tour.tour_settings);

		if (ts.defaultPlayAction === undefined || ts.defaultPlayAction === 'Default') {
			ts.defaultPlayAction = GmCXt.getAppSetting('defaultPlayAction');
		}

		if (GmCXt.FT.isPlayer) {
			dAction = ts.defaultPlayAction === rootScope.playGuideMe || ts.defaultPlayAction === rootScope.playSlideshow && rootScope.enableGuidemeMode;
		}

		let type = GmCXt.isGuide(tour) && !rootScope.isDesktopGuide(tour) && !rootScope.isMobileGuide(tour);

		if (window.matchMedia('(max-width: 480px)').matches && !GmCXt.isMiniPlayer) {
			type = GmCXt.isGuide(tour) && rootScope.isDesktopGuide(tour) && !rootScope.isMobileGuide(tour);
		}

		if (type && option && dAction) {
			return true;
		}

		return false;
	};

	const showShowMe = () => {
		let tour = get_store_value(Gm.currentTour);

		if (rootScope.isOnlySurveyGuide(tour)) {
			return false;
		}

		let showMeOpt = rootScope.existsOrUndefined(GmCXt.getAppSetting('showMeSetting'));
		let dAction = true;
		let ts = GmCXt.createDeepCopy(tour.tour_settings);

		if (ts.defaultPlayAction === undefined || ts.defaultPlayAction === 'Default') {
			ts.defaultPlayAction = GmCXt.getAppSetting('defaultPlayAction');
		}

		if (GmCXt.FT.isPlayer) {
			dAction = ts.defaultPlayAction === rootScope.playGuideMe || ts.defaultPlayAction === rootScope.playSlideshow;
		}

		let type = GmCXt.isGuide(tour) || rootScope.isCADGuide(tour) || rootScope.isDesktopGuide(tour) || rootScope.isMobileGuide(tour) || GmCXt.isOnboarding(tour);
		return GmCXt.FT.showMe && showMeOpt && dAction && type;
	};

	const showDoItForMe = () => {
		let tour = get_store_value(Gm.currentTour);

		if (rootScope.isOnlySurveyGuide(tour)) {
			return false;
		}

		// $scope.disableDoItForMe = rootScope.checkStepsForDoItForMeMode(tour);
		let dAction = true;

		let ts = GmCXt.createDeepCopy(tour.tour_settings);

		if (ts.defaultPlayAction === undefined || ts.defaultPlayAction === 'Default') {
			ts.defaultPlayAction = GmCXt.getAppSetting('defaultPlayAction');
		}

		if (GmCXt.FT.isPlayer) {
			dAction = ts.defaultPlayAction === rootScope.playAuto;
		}

		return rootScope._doitforme && !rootScope.isCADGuide(tour) && GmCXt.isGuide(tour) && !rootScope.isDesktopGuide(tour) && !rootScope.isMobileGuide(tour) && dAction;
	};

	const showTestMe = () => {
		let tour = get_store_value(Gm.currentTour);

		if (rootScope.isOnlySurveyGuide(tour)) {
			return false;
		}

		let option = rootScope.existsOrUndefined(GmCXt.getAppSetting('testMeSetting'));
		let dAction = true;
		let ts = GmCXt.createDeepCopy(tour.tour_settings);

		if (ts.defaultPlayAction === undefined || ts.defaultPlayAction === 'Default') {
			ts.defaultPlayAction = GmCXt.getAppSetting('defaultPlayAction');
		}

		if (GmCXt.FT.isPlayer) {
			dAction = ts.defaultPlayAction === rootScope.playGuideMe;
		}

		let type = GmCXt.isGuide(tour) && !rootScope.isDesktopGuide(tour) && !rootScope.isMobileGuide(tour) && !GmCXt.containBranchStep(tour);
		return GmCXt.FT.testme && option && dAction && type;
	};

	const previewSmartTip = function () {
		let previewTour = JSON.parse(JSON.stringify(tour));
		previewTour.is_published = true;

		let message = {
			action: 'mgPlayerJSTest_action:preview_smarttip',
			data: [previewTour]
		};

		GmCXt.handlePreviewTooltip(message);
	};

	onMount(() => {
		if (GmCXt.isPlayer()) {
			rootScope.bindPlayerTheme();
		}
	});

	const click_handler = () => previewSmartTip();
	const click_handler_1 = e => guideAction(e, '', '');

	const click_handler_2 = () => {
		$$invalidate(0, tour.tour_settings.defaultPlayAction = 'guideMe', tour);
		rootScope.updateTourData(tour);
	};

	const click_handler_3 = e => guideAction(e, 'slideshow');

	const click_handler_4 = () => {
		$$invalidate(0, tour.tour_settings.defaultPlayAction = 'slideshow', tour);
		rootScope.updateTourData(tour);
	};

	const click_handler_5 = e => guideAction(e, 'doitforme');

	const click_handler_6 = () => {
		$$invalidate(0, tour.tour_settings.defaultPlayAction = 'doitforme', tour);
		rootScope.updateTourData(tour);
	};

	const click_handler_7 = e => showTestMeWidget();

	return [
		tour,
		guideAction,
		guideDefaultPlayAction,
		showTestMeWidget,
		showGuideMe,
		showShowMe,
		showDoItForMe,
		showTestMe,
		previewSmartTip,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		click_handler_6,
		click_handler_7
	];
}

class StepModes extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});
	}
}

/* src/components/AddEditFeatureStep.svelte generated by Svelte v4.2.20 */

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i];
	child_ctx[31] = list;
	child_ctx[1] = i;
	return child_ctx;
}

// (240:0) {#if imageStatus === 'fail'}
function create_if_block_5$7(ctx) {
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = GmCXt.svgs.reset + "";
	let t0;
	let wmgPlayerJSTest_2;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2.innerHTML = `<wmgPlayerJSTest_ class="mgPlayerJSTest_tooltip-title ng-binding">Retry</wmgPlayerJSTest_>`;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-retry-icon mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left mgPlayerJSTest_margin-tb-10");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_step-retry-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_position-relative");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_3, "click", /*click_handler*/ ctx[10]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}

			mounted = false;
			dispose();
		}
	};
}

// (255:1) {#if previewImage}
function create_if_block_4$8(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "id", "mgPlayerJSTest_preview-image");
			if (!src_url_equal(img.src, img_src_value = /*previewImage*/ ctx[6])) attr(img, "src", img_src_value);
			attr(img, "class", "mgPlayerJSTest_preview-image mgPlayerJSTest_custom-image");
			attr(img, "image-load", "");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(img);
			}
		}
	};
}

// (276:5) {#if !editTags}
function create_if_block_3$9(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = GmCXt.svgs.addTag + "";
	let wmgPlayerJSTest_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value = "mgPlayerJSTest_btn-add-tag-elem mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer " + (!/*elemTagReq*/ ctx[3].elTags ? 'mgPlayerJSTest_disabled' : ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_, "click", /*click_handler_1*/ ctx[12]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*elemTagReq*/ 8 && wmgPlayerJSTest_class_value !== (wmgPlayerJSTest_class_value = "mgPlayerJSTest_btn-add-tag-elem mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer " + (!/*elemTagReq*/ ctx[3].elTags ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			dispose();
		}
	};
}

// (316:7) {#if showElemSelectorIcon(elTag)}
function create_if_block_2$9(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = GmCXt.svgs.matchingAlgo + "";
	let mounted;
	let dispose;

	function click_handler_5() {
		return /*click_handler_5*/ ctx[18](/*index*/ ctx[1]);
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_tag-edit-jquery-icon");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_, "click", click_handler_5);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			dispose();
		}
	};
}

// (327:123) 
function create_if_block_1$a(ctx) {
	let wmgPlayerJSTest_;
	let matchingalgo;
	let current;

	matchingalgo = new Empty({
			props: {
				element: /*elTag*/ ctx[30].step_settings.element,
				index: /*index*/ ctx[1],
				showlabel: true
			}
		});

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(matchingalgo.$$.fragment);
			attr(wmgPlayerJSTest_, "id", "match-" + /*index*/ ctx[1]);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_tag-edit-jquery mgPlayerJSTest_display-none");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(matchingalgo, wmgPlayerJSTest_, null);
			current = true;
		},
		p(ctx, dirty) {
			const matchingalgo_changes = {};
			if (dirty[0] & /*elemTagReq*/ 8) matchingalgo_changes.element = /*elTag*/ ctx[30].step_settings.element;
			matchingalgo.$set(matchingalgo_changes);
		},
		i(local) {
			if (current) return;
			transition_in(matchingalgo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(matchingalgo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(matchingalgo);
		}
	};
}

// (323:6) {#if elTag.element && elTag.element.criteria.jquery_selector}
function create_if_block$a(ctx) {
	let wmgPlayerJSTest_;
	let matchingalgo;
	let current;

	matchingalgo = new Empty({
			props: {
				element: /*elTag*/ ctx[30].element,
				index: /*index*/ ctx[1],
				showlabel: true
			}
		});

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(matchingalgo.$$.fragment);
			attr(wmgPlayerJSTest_, "id", "match-" + /*index*/ ctx[1]);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_tag-edit-jquery mgPlayerJSTest_display-none");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(matchingalgo, wmgPlayerJSTest_, null);
			current = true;
		},
		p(ctx, dirty) {
			const matchingalgo_changes = {};
			if (dirty[0] & /*elemTagReq*/ 8) matchingalgo_changes.element = /*elTag*/ ctx[30].element;
			matchingalgo.$set(matchingalgo_changes);
		},
		i(local) {
			if (current) return;
			transition_in(matchingalgo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(matchingalgo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(matchingalgo);
		}
	};
}

// (287:4) {#each elemTagReq.elTags as elTag, index}
function create_each_block$5(ctx) {
	let wmgPlayerJSTest_4;
	let input;
	let t0;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw0_value = GmCXt.svgs.edit + "";
	let t1;
	let wmgPlayerJSTest_1;
	let raw1_value = GmCXt.svgs.close + "";
	let t2;
	let wmgPlayerJSTest_2;
	let raw2_value = rootScope.svgs.iconDelete + "";
	let t3;
	let show_if = showElemSelectorIcon(/*elTag*/ ctx[30]);
	let t4;
	let current_block_type_index;
	let if_block1;
	let t5;
	let current;
	let mounted;
	let dispose;

	function input_input_handler_1() {
		/*input_input_handler_1*/ ctx[13].call(input, /*each_value*/ ctx[31], /*index*/ ctx[1]);
	}

	function input_handler() {
		return /*input_handler*/ ctx[14](/*elTag*/ ctx[30], /*index*/ ctx[1]);
	}

	function click_handler_2() {
		return /*click_handler_2*/ ctx[15](/*index*/ ctx[1]);
	}

	function click_handler_3() {
		return /*click_handler_3*/ ctx[16](/*index*/ ctx[1]);
	}

	function click_handler_4() {
		return /*click_handler_4*/ ctx[17](/*elTag*/ ctx[30]);
	}

	let if_block0 = show_if && create_if_block_2$9(ctx);
	const if_block_creators = [create_if_block$a, create_if_block_1$a];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*elTag*/ ctx[30].element && /*elTag*/ ctx[30].element.criteria.jquery_selector) return 0;
		if (/*elTag*/ ctx[30].step_settings && /*elTag*/ ctx[30].step_settings.element && /*elTag*/ ctx[30].step_settings.element.criteria.jquery_selector) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			input = element("input");
			t0 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t2 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t3 = space();
			if (if_block0) if_block0.c();
			t4 = space();
			if (if_block1) if_block1.c();
			t5 = space();
			attr(input, "type", "text");
			attr(input, "id", "mgPlayerJSTest_panel-text-input-" + /*index*/ ctx[1]);
			attr(input, "class", "mgPlayerJSTest_text-input mgPlayerJSTest_panel-text-input mgPlayerJSTest_text-input-readonly mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex");
			attr(wmgPlayerJSTest_0, "id", "mgPlayerJSTest_tag-elem-action-edit-" + /*index*/ ctx[1]);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tag-elem-group-action-icon mgPlayerJSTest_tag-elem-action-edit mgPlayerJSTest_margin-lr-5 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer");
			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_tag-elem-action-cancel-" + /*index*/ ctx[1]);
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tag-elem-group-action-icon mgPlayerJSTest_tag-elem-action-cancel mgPlayerJSTest_display-none mgPlayerJSTest_margin-lr-5 mgPlayerJSTest_cursor mgPlayerJSTest_cursor-pointer");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_tag-elem-action-delete");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_tag-elem-group-action-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_justify-content-flex-end");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_tag-elem-list-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_4, anchor);
			append(wmgPlayerJSTest_4, input);
			set_input_value(input, /*elTag*/ ctx[30].step_title);
			append(wmgPlayerJSTest_4, t0);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw0_value;
			append(wmgPlayerJSTest_3, t1);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_1);
			wmgPlayerJSTest_1.innerHTML = raw1_value;
			append(wmgPlayerJSTest_3, t2);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			wmgPlayerJSTest_2.innerHTML = raw2_value;
			append(wmgPlayerJSTest_3, t3);
			if (if_block0) if_block0.m(wmgPlayerJSTest_3, null);
			append(wmgPlayerJSTest_4, t4);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(wmgPlayerJSTest_4, null);
			}

			append(wmgPlayerJSTest_4, t5);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "input", input_input_handler_1),
					listen(input, "input", input_handler),
					listen(wmgPlayerJSTest_0, "click", click_handler_2),
					listen(wmgPlayerJSTest_1, "click", click_handler_3),
					listen(wmgPlayerJSTest_2, "click", click_handler_4)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*elemTagReq*/ 8 && input.value !== /*elTag*/ ctx[30].step_title) {
				set_input_value(input, /*elTag*/ ctx[30].step_title);
			}

			if (dirty[0] & /*elemTagReq*/ 8) show_if = showElemSelectorIcon(/*elTag*/ ctx[30]);

			if (show_if) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$9(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_3, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block1) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(wmgPlayerJSTest_4, t5);
				} else {
					if_block1 = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_4);
			}

			if (if_block0) if_block0.d();

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$e(ctx) {
	let wmgPlayerJSTest_0;
	let dnd_nodrag;
	let span;
	let t0_value = /*index*/ ctx[1] + 1 + "";
	let t0;
	let t1;
	let t2;
	let wmgPlayerJSTest_8;
	let t3;
	let wmgPlayerJSTest_7;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let t5;
	let input;
	let t6;
	let t7;
	let wmgPlayerJSTest_5;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*imageStatus*/ ctx[0] === 'fail' && create_if_block_5$7(ctx);
	let if_block1 = /*previewImage*/ ctx[6] && create_if_block_4$8(ctx);
	let if_block2 = !/*editTags*/ ctx[4] && create_if_block_3$9(ctx);
	let each_value = ensure_array_like(/*elemTagReq*/ ctx[3].elTags);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			dnd_nodrag = element("dnd-nodrag");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			if (if_block1) if_block1.c();
			t3 = space();
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${GmCXt.label.tagsGroupTitle}`;
			t5 = space();
			input = element("input");
			t6 = space();
			if (if_block2) if_block2.c();
			t7 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(span, "class", "mgPlayerJSTest_step-index");
			set_custom_element_data(dnd_nodrag, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-flex-start");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_ege-inline-block-vt mgPlayerJSTest_step-title-wrapper mgPlayerJSTest_step-title-edit-view-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_padding-b-0");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tag-elem-group-input-label mgPlayerJSTest_margin-tb-10");
			attr(input, "type", "text");
			attr(input, "class", "mgPlayerJSTest_text-input mgPlayerJSTest_tag-group-name");
			attr(input, "maxlength", "100");
			attr(input, "placeholder", "Enter events group name...");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-flex-start mgPlayerJSTest_flex-direction-column mgPlayerJSTest_width-100");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_tag-elem-group-input-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-flex-end mgPlayerJSTest_width-100 mgPlayerJSTest_padding-lr-10");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_tag-elem-group-details-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_tag-elem-group-wrapper mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_tag-elem-middle-section-wrapper");
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_tag-elem-create-panel-container");
			attr(wmgPlayerJSTest_8, "id", "inline-container");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_0, anchor);
			append(wmgPlayerJSTest_0, dnd_nodrag);
			append(dnd_nodrag, span);
			append(span, t0);
			insert(target, t1, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t2, anchor);
			insert(target, wmgPlayerJSTest_8, anchor);
			if (if_block1) if_block1.m(wmgPlayerJSTest_8, null);
			append(wmgPlayerJSTest_8, t3);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_2, t5);
			append(wmgPlayerJSTest_2, input);
			set_input_value(input, /*groupTitle*/ ctx[2]);
			append(wmgPlayerJSTest_3, t6);
			if (if_block2) if_block2.m(wmgPlayerJSTest_3, null);
			append(wmgPlayerJSTest_6, t7);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(wmgPlayerJSTest_5, null);
				}
			}

			current = true;

			if (!mounted) {
				dispose = listen(input, "input", /*input_input_handler*/ ctx[11]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*index*/ 2) && t0_value !== (t0_value = /*index*/ ctx[1] + 1 + "")) set_data(t0, t0_value);

			if (/*imageStatus*/ ctx[0] === 'fail') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_5$7(ctx);
					if_block0.c();
					if_block0.m(t2.parentNode, t2);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*previewImage*/ ctx[6]) if_block1.p(ctx, dirty);

			if (dirty[0] & /*groupTitle*/ 4 && input.value !== /*groupTitle*/ ctx[2]) {
				set_input_value(input, /*groupTitle*/ ctx[2]);
			}

			if (!/*editTags*/ ctx[4]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_3$9(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_3, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty[0] & /*elemTagReq, removeTag, updateTagTitle*/ 296) {
				each_value = ensure_array_like(/*elemTagReq*/ ctx[3].elTags);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(wmgPlayerJSTest_5, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_0);
				detach(t1);
				detach(t2);
				detach(wmgPlayerJSTest_8);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};
}

function showElemSelectorIcon(elmTag) {
	let showElemSelector = false;

	let elem = elmTag.step_settings
	? elmTag.step_settings.element
	: elmTag.element;

	if (elem && elem.criteria.jquery_selector) {
		if (containsShadowDOM(elem)) {
			return false;
		} else {
			return true;
		}
	}

	return showElemSelector;
}

function containsShadowDOM(element) {
	if (element && element.selector && element.selector.js) {
		return element.selector.js.indexOf('shadowRoot') !== -1;
	}

	return true;
}

function actionTag(index, action) {
	let inputText = mg$('#mgPlayerJSTest_panel-text-input-' + index);
	let btnEdit = mg$('#mgPlayerJSTest_tag-elem-action-edit-' + index);
	let btnCancel = mg$('#mgPlayerJSTest_tag-elem-action-cancel-' + index);
	inputText.removeClass('mgPlayerJSTest_text-input-readonly');
	btnEdit.hide();
	inputText.focus();
	btnCancel.removeClass('mgPlayerJSTest_display-none');

	if (action) {
		inputText.addClass('mgPlayerJSTest_text-input-readonly');
		inputText.blur();
		btnEdit.show();
		btnCancel.addClass('mgPlayerJSTest_display-none');
	}
}

function editJquery(index) {
	let textArea = mg$('#match-' + index);

	if (textArea.hasClass('mgPlayerJSTest_display-none')) {
		textArea.removeClass('mgPlayerJSTest_display-none');
	} else {
		textArea.addClass('mgPlayerJSTest_display-none');
	}
}

function instance$e($$self, $$props, $$invalidate) {
	let { step } = $$props;
	let { index } = $$props;
	let { imageStatus } = $$props;
	mg$('.mgPlayerJSTest_screen-container').show();
	GmCXt.conf.staticContentPath;
	GmCXt.FT;

	function showPreview() {
		mg$('.mgPlayerJSTest_tag-selector').remove();
		let os = GmCXt.getStepSettings();
		let borderWidth = os ? os.selectorStyle.borderWidth : '';
		let borderColor = os ? os.selectorStyle.borderColor : '';
		let el = null;
		let close_tag = '';

		for (let i = 0; i < elmTags.length; i++) {
			let tagTitle = elmTags[i].title;

			if (editTags) {
				el = elmTags[i].step_settings.element.position;
				elmTags[i].id = elmTags[i].step_id;
				tagTitle = elmTags[i].step_title;
				close_tag = '<wmgPlayerJSTest_ class="mgPlayerJSTest_tag-close" id=' + elmTags[i].id + '></wmgPlayerJSTest_>';
			} else {
				el = elmTags[i].element.position;
				$$invalidate(3, elemTagReq.elTags[i].step_title = tagTitle, elemTagReq);
				close_tag = '<wmgPlayerJSTest_ class="mgPlayerJSTest_tag-close" id=' + elmTags[i].id + '></wmgPlayerJSTest_>';
			}

			mg$('<wmgPlayerJSTest_ class="mgPlayerJSTest_tag-selector" id="mgPlayerJSTest_tag-selector-' + elmTags[i].id + '">' + '<input type="text" autocomplete="off" class="mgPlayerJSTest_tag-title mgPlayerJSTest_cursor mgPlayerJSTest_cursor-default" id="mgPlayerJSTest_tag-title-' + elmTags[i].id + '" value="' + tagTitle + '" readonly="true" style="width: ' + el.width + 'px; background:' + borderColor + '; left:-' + borderWidth + 'px;"">' + close_tag + '</wmgPlayerJSTest_>').appendTo('#mgPlayerJSTest_step-creation-preview-image').css({
				position: 'fixed',
				width: el.width,
				height: el.height,
				left: el.left,
				top: el.top,
				'border-color': borderColor,
				'border-width': borderWidth
			});

			if (el.top < 25) {
				mg$('#mgPlayerJSTest_tag-title-' + elmTags[i].id).css({ top: el.height - borderWidth });
				mg$('#' + elmTags[i].id).css({ top: el.height - borderWidth + 10 });
			}

			mg$('.mgPlayerJSTest_tag-close').html(GmCXt.svgs.close_btn);
		}

		mg$('.mgPlayerJSTest_tag-close').on('click', function (e) {
			removeTag(e.currentTarget.id);
		});
	}

	function removeTag(elId) {
		if (editTags) {
			if (!step.data.deleteTags) $$invalidate(9, step.data.deleteTags = [], step);

			if (step.data.elTags.length === 1) {
				GmCXt.toastMsg(GmCXt.label.deleteTagError).show();
				return;
			}

			let deleteTags = mg$.grep(step.data.elTags, function (element) {
				return elId === element.id;
			});

			step.data.deleteTags.push(deleteTags[0]);

			$$invalidate(
				9,
				step.data.elTags = mg$.grep(step.data.elTags, function (element) {
					return elId != element.id;
				}),
				step
			);

			$$invalidate(3, elemTagReq = step.data);
			elmTags = step.data.elTags;
		} else {
			$$invalidate(
				9,
				step.elTags = mg$.grep(step.elTags, function (element) {
					return elId != element.id;
				}),
				step
			);

			$$invalidate(3, elemTagReq = step);
			elmTags = step.elTags;
		}

		mg$('#mgPlayerJSTest_tag-selector-' + elId).remove();
	}

	mg$('#mgPlayerJSTest_toast-msg').hide();
	mg$('.step-create-section-container').addClass('mgPlayerJSTest_tag-create-section').show();
	let elemTagReq = step.data || step;
	GmCXt.brandLogo();

	let elmTags = step.data && step.data.elTags
	? step.data.elTags
	: step.elTags;

	let previewImage = step.previewImage;
	let editTags = false;
	let groupTitle = elmTags[0].groupTitle;

	if (step.data && step.data.elTags) {
		editTags = true;
		groupTitle = elmTags[0].step_settings.groupTitle;
		elmTags[0].step_settings.groupId;
	}

	function selectElement() {
		let tags = step.elTags || step.data.elTags;

		if (tags && tags.length < 10) {
			tags = elemTagReq.elTags;
			mg$('#mgPlayerJSTest_step-creation-preview-image').empty();
			GmCXt.stepReq = step;
			GmCXt.sendMessageToAllWindows('mgPlayerJSTest_action:clear_dom_outline');
			GmCXt.handleSelectTag();
		} else {
			GmCXt.toastMsg(GmCXt.label.messageMaxTagsLimitMessage).show();
		}
	}

	function updateTagTitle(id, index) {
		mg$('#mgPlayerJSTest_tag-title-' + id).val(elemTagReq.elTags[index].step_title);
	}

	const loadPrevImg = function () {
		let img = '';
		if (step.previewImage) img = step.previewImage; else if (step.isEdit) img = step.thumbnail_url + GmCXt.getCdnSign();
		let prevImg = '<wmgPlayerJSTest_ id="mgPlayerJSTest_preview-image" class="mgPlayerJSTest_preview-image">' + '<img src=' + img + ' image-load />' + '</wmgPlayerJSTest_>';
		mg$('#mgPlayerJSTest_step-creation-preview-image').empty();
		mg$('#mgPlayerJSTest_step-creation-preview-image').append(prevImg);
		showPreview();
	};

	onMount(() => {
		loadPrevImg();

		GmCXt.timeout(
			function () {
				if (mg$('.step-item')[index]) mg$('.step-item')[index].scrollIntoView();
			},
			10
		);
	});

	const click_handler = () => retryStepImageUpload();

	function input_input_handler() {
		groupTitle = this.value;
		$$invalidate(2, groupTitle);
	}

	const click_handler_1 = () => selectElement();

	function input_input_handler_1(each_value, index) {
		each_value[index].step_title = this.value;
		$$invalidate(3, elemTagReq);
	}

	const input_handler = (elTag, index) => updateTagTitle(elTag.id, index);
	const click_handler_2 = index => actionTag(index);
	const click_handler_3 = index => actionTag(index, 'cancel');
	const click_handler_4 = elTag => removeTag(elTag.id);
	const click_handler_5 = index => editJquery(index);

	$$self.$$set = $$props => {
		if ('step' in $$props) $$invalidate(9, step = $$props.step);
		if ('index' in $$props) $$invalidate(1, index = $$props.index);
		if ('imageStatus' in $$props) $$invalidate(0, imageStatus = $$props.imageStatus);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*groupTitle*/ 4) {
			$$invalidate(9, step.groupTitle = groupTitle, step);
		}

		if ($$self.$$.dirty[0] & /*groupTitle*/ 4) {
			$$invalidate(9, step.step_title = groupTitle, step);
		}
	};

	return [
		imageStatus,
		index,
		groupTitle,
		elemTagReq,
		editTags,
		removeTag,
		previewImage,
		selectElement,
		updateTagTitle,
		step,
		click_handler,
		input_input_handler,
		click_handler_1,
		input_input_handler_1,
		input_handler,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5
	];
}

class AddEditFeatureStep extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$e, create_fragment$e, safe_not_equal, { step: 9, index: 1, imageStatus: 0 }, null, [-1, -1]);
	}
}

/* src/components/StepView.svelte generated by Svelte v4.2.20 */

function add_css$2(target) {
	append_styles(target, "svelte-hv9a3t", ".mgPlayerJSTest_tg-img.svelte-hv9a3t{width:100%;height:100%}");
}

// (256:0) {#if !GmCXt.isEmpty(step)}
function create_if_block$9(ctx) {
	let wmgPlayerJSTest_;
	let show_if;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$9, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty[0] & /*tour*/ 4) show_if = null;
		if (show_if == null) show_if = !!GmCXt.isOnboarding(/*tour*/ ctx[2]);
		if (show_if) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if_block.c();
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if_blocks[current_block_type_index].m(wmgPlayerJSTest_, null);
			current = true;

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_, "click", /*setActiveStep*/ ctx[12]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(wmgPlayerJSTest_, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};
}

// (422:2) {:else}
function create_else_block_1$1(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let show_if;
	let current_block_type_index;
	let if_block;
	let wmgPlayerJSTest_0_id_value;
	let wmgPlayerJSTest_0_class_value;
	let wmgPlayerJSTest_1_class_value;
	let current;
	const if_block_creators = [create_if_block_12$2, create_if_block_22, create_if_block_40];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (dirty[0] & /*tour, step*/ 5) show_if = null;
		if (show_if == null) show_if = !!(rootScope.isTrackingGuide(/*tour*/ ctx[2]) && (!/*step*/ ctx[0].isEdit && !/*step*/ ctx[0].isCreation || !/*tour*/ ctx[2].isEditMode));
		if (show_if) return 0;
		if (!/*step*/ ctx[0].isEdit && !/*step*/ ctx[0].isCreation || !/*tour*/ ctx[2].isEditMode) return 1;
		if ((/*step*/ ctx[0].isEdit || /*step*/ ctx[0].isCreation) && /*tour*/ ctx[2].isEditMode) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_2(ctx, [-1, -1]))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			if (if_block) if_block.c();
			attr(wmgPlayerJSTest_0, "id", wmgPlayerJSTest_0_id_value = "step-" + /*step*/ ctx[0].step_id);

			attr(wmgPlayerJSTest_0, "class", wmgPlayerJSTest_0_class_value = "mgPlayerJSTest_ege-inline-block-vt mgPlayerJSTest_step-title-description-wrapper " + (/*step*/ ctx[0].isEdit || /*step*/ ctx[0].isCreation
			? 'mgPlayerJSTest_step-add-edit-view'
			: '') + " " + (/*imageStatus*/ ctx[6] === 'fail'
			? 'mgPlayerJSTest_step-failed-view'
			: '') + " " + (rootScope.isTrackingGuide(/*tour*/ ctx[2])
			? 'mgPlayerJSTest_feature-tag-step-wrapper'
			: ''));

			attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_step-item " + (rootScope.showBranchView(/*tour*/ ctx[2])
			? 'mgPlayerJSTest_branch-step-add-wrapper'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(wmgPlayerJSTest_0, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(wmgPlayerJSTest_0, null);
				} else {
					if_block = null;
				}
			}

			if (!current || dirty[0] & /*step*/ 1 && wmgPlayerJSTest_0_id_value !== (wmgPlayerJSTest_0_id_value = "step-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_0, "id", wmgPlayerJSTest_0_id_value);
			}

			if (!current || dirty[0] & /*step, imageStatus, tour*/ 69 && wmgPlayerJSTest_0_class_value !== (wmgPlayerJSTest_0_class_value = "mgPlayerJSTest_ege-inline-block-vt mgPlayerJSTest_step-title-description-wrapper " + (/*step*/ ctx[0].isEdit || /*step*/ ctx[0].isCreation
			? 'mgPlayerJSTest_step-add-edit-view'
			: '') + " " + (/*imageStatus*/ ctx[6] === 'fail'
			? 'mgPlayerJSTest_step-failed-view'
			: '') + " " + (rootScope.isTrackingGuide(/*tour*/ ctx[2])
			? 'mgPlayerJSTest_feature-tag-step-wrapper'
			: ''))) {
				attr(wmgPlayerJSTest_0, "class", wmgPlayerJSTest_0_class_value);
			}

			if (!current || dirty[0] & /*tour*/ 4 && wmgPlayerJSTest_1_class_value !== (wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_step-item " + (rootScope.showBranchView(/*tour*/ ctx[2])
			? 'mgPlayerJSTest_branch-step-add-wrapper'
			: ''))) {
				attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};
}

// (258:2) {#if GmCXt.isOnboarding(tour)}
function create_if_block_1$9(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let t0_value = /*index*/ ctx[1] + 1 + "";
	let t0;
	let t1;
	let dnd_nodrag;
	let wmgPlayerJSTest_1;
	let show_if_4 = GmCXt.FT.creatorApp && rootScope.hasTourAccess(/*tour*/ ctx[2]) && !rootScope.hideMirrorAppCtrl() && !rootScope.isAnnouncement(/*tour*/ ctx[2]) && !rootScope.isUploadTutorial(/*tour*/ ctx[2]) && !(/*tour*/ ctx[2].is_published && /*step*/ ctx[0].step_type == 'video');
	let t2;
	let show_if_3 = /*step*/ ctx[0].step_video > 0 || /*step*/ ctx[0].screen_url.indexOf('default_icon') == -1;
	let t3;
	let show_if_2 = rootScope.isUploadTutorial(/*tour*/ ctx[2]);
	let t4;
	let wmgPlayerJSTest_3;
	let raw_value = getTutorialDesc(/*step*/ ctx[0]) + "";
	let wmgPlayerJSTest_3_class_value;
	let t5;
	let wmgPlayerJSTest_4;
	let show_if_1 = !rootScope.isAnnouncement(/*tour*/ ctx[2]);
	let t6;
	let show_if = !rootScope.hideMirrorAppCtrl() && !rootScope.isAnnouncement(/*tour*/ ctx[2]) && !rootScope.isUploadTutorial(/*tour*/ ctx[2]);
	let current;
	let if_block0 = show_if_4 && create_if_block_8$5(ctx);
	let if_block1 = show_if_3 && create_if_block_6$6(ctx);
	let if_block2 = show_if_2 && create_if_block_5$6();
	let if_block3 = show_if_1 && create_if_block_4$7(ctx);
	let if_block4 = show_if && create_if_block_2$8(ctx);

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			dnd_nodrag = element("dnd-nodrag");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t5 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			if (if_block3) if_block3.c();
			t6 = space();
			if (if_block4) if_block4.c();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_font-size-15 mgPlayerJSTest_font-weight-550");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tg-btn-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
			set_custom_element_data(dnd_nodrag, "class", "mgPlayerJSTest_dnd-nodrag-inline-block mgPlayerJSTest_step-action-menu-wrapper");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_tg-view-header mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between mgPlayerJSTest_padding-20");

			attr(wmgPlayerJSTest_3, "class", wmgPlayerJSTest_3_class_value = "mgPlayerJSTest_tg-content-wrapper " + (/*step*/ ctx[0].step_video == 0 && /*step*/ ctx[0].screen_url.indexOf('default_icon') >= 0
			? 'mgPlayerJSTest_min-tg-content-wrapper'
			: ''));

			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_step-overlay");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_2, t1);
			append(wmgPlayerJSTest_2, dnd_nodrag);
			append(dnd_nodrag, wmgPlayerJSTest_1);
			if (if_block0) if_block0.m(wmgPlayerJSTest_1, null);
			insert(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t3, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t4, anchor);
			insert(target, wmgPlayerJSTest_3, anchor);
			wmgPlayerJSTest_3.innerHTML = raw_value;
			insert(target, t5, anchor);
			insert(target, wmgPlayerJSTest_4, anchor);
			if (if_block3) if_block3.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t6);
			if (if_block4) if_block4.m(wmgPlayerJSTest_4, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*index*/ 2) && t0_value !== (t0_value = /*index*/ ctx[1] + 1 + "")) set_data(t0, t0_value);
			if (dirty[0] & /*tour, step*/ 5) show_if_4 = GmCXt.FT.creatorApp && rootScope.hasTourAccess(/*tour*/ ctx[2]) && !rootScope.hideMirrorAppCtrl() && !rootScope.isAnnouncement(/*tour*/ ctx[2]) && !rootScope.isUploadTutorial(/*tour*/ ctx[2]) && !(/*tour*/ ctx[2].is_published && /*step*/ ctx[0].step_type == 'video');

			if (show_if_4) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_8$5(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_1, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*step*/ 1) show_if_3 = /*step*/ ctx[0].step_video > 0 || /*step*/ ctx[0].screen_url.indexOf('default_icon') == -1;

			if (show_if_3) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_6$6(ctx);
					if_block1.c();
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*tour*/ 4) show_if_2 = rootScope.isUploadTutorial(/*tour*/ ctx[2]);

			if (show_if_2) {
				if (if_block2) ; else {
					if_block2 = create_if_block_5$6();
					if_block2.c();
					if_block2.m(t4.parentNode, t4);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if ((!current || dirty[0] & /*step*/ 1) && raw_value !== (raw_value = getTutorialDesc(/*step*/ ctx[0]) + "")) wmgPlayerJSTest_3.innerHTML = raw_value;
			if (!current || dirty[0] & /*step*/ 1 && wmgPlayerJSTest_3_class_value !== (wmgPlayerJSTest_3_class_value = "mgPlayerJSTest_tg-content-wrapper " + (/*step*/ ctx[0].step_video == 0 && /*step*/ ctx[0].screen_url.indexOf('default_icon') >= 0
			? 'mgPlayerJSTest_min-tg-content-wrapper'
			: ''))) {
				attr(wmgPlayerJSTest_3, "class", wmgPlayerJSTest_3_class_value);
			}

			if (dirty[0] & /*tour*/ 4) show_if_1 = !rootScope.isAnnouncement(/*tour*/ ctx[2]);

			if (show_if_1) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_4$7(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_4, t6);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (dirty[0] & /*tour*/ 4) show_if = !rootScope.hideMirrorAppCtrl() && !rootScope.isAnnouncement(/*tour*/ ctx[2]) && !rootScope.isUploadTutorial(/*tour*/ ctx[2]);

			if (show_if) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[0] & /*tour*/ 4) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_2$8(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(wmgPlayerJSTest_4, null);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block4);
			current = true;
		},
		o(local) {
			transition_out(if_block4);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
				detach(t2);
				detach(t3);
				detach(t4);
				detach(wmgPlayerJSTest_3);
				detach(t5);
				detach(wmgPlayerJSTest_4);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d(detaching);
			if (if_block2) if_block2.d(detaching);
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
		}
	};
}

// (860:67) 
function create_if_block_40(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block_41,
		create_if_block_42,
		create_if_block_43,
		create_if_block_44,
		create_if_block_45
	];

	const if_blocks = [];

	function select_block_type_5(ctx, dirty) {
		if (/*step*/ ctx[0].step_type === GmCXt.STEP_TYPE_INLINE) return 0;
		if (/*step*/ ctx[0].step_type === GmCXt.STEP_TYPE_MESSAGE) return 1;
		if (/*step*/ ctx[0].step_type === GmCXt.STEP_TYPE_IMAGE) return 2;
		if (/*step*/ ctx[0].step_type === GmCXt.STEP_TYPE_SMART_TIP) return 3;
		if (/*step*/ ctx[0].step_type === GmCXt.STEP_TYPE_TAG) return 4;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_5(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_5(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}
		}
	};
}

// (587:70) 
function create_if_block_22(ctx) {
	let wmgPlayerJSTest_1;
	let t0;
	let dnd_nodrag0;
	let span0;
	let t1_value = /*index*/ ctx[1] + 1 + "";
	let t1;
	let t2;
	let show_if_2 = /*tour*/ ctx[2].filteredSteps.length > 1 && !/*tour*/ ctx[2].is_published && rootScope.hasTourAccess(/*tour*/ ctx[2]) && !/*step*/ ctx[0].step_screen_temp && !rootScope.isDesktopApp() && !rootScope.hideMirrorAppCtrl() && !/*tour*/ ctx[2].isEditMode;
	let t3;
	let span1;
	let raw0_value = GmCXt.truncate(GmCXt.htmlToPlaintext(/*step*/ ctx[0].step_title), 140) + "";
	let t4;
	let dnd_nodrag1;
	let wmgPlayerJSTest_0;
	let raw1_value = GmCXt.truncate(GmCXt.htmlToPlaintext(/*step*/ ctx[0].step_description), 150) + "";
	let t5;
	let wmgPlayerJSTest_2;
	let show_if_1;
	let t6;
	let dnd_nodrag2;
	let show_if = /*stepOperationMode*/ ctx[7] === GmCXt.STEP_VIEW_OPERATION && rootScope.isUserLoggedIn() && GmCXt.FT.creatorApp && rootScope.hasTourAccess(/*tour*/ ctx[2]) && !rootScope.hideMirrorAppCtrl() && !(/*tour*/ ctx[2].is_published && /*step*/ ctx[0].step_type === 'video');
	let t7;
	let wmgPlayerJSTest_4;
	let dnd_nodrag3;
	let wmgPlayerJSTest_3;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*step*/ ctx[0].step_settings?.startPoint && create_if_block_39();
	let if_block1 = show_if_2 && create_if_block_38();

	function select_block_type_3(ctx, dirty) {
		if (dirty[0] & /*tour*/ 4) show_if_1 = null;
		if (show_if_1 == null) show_if_1 = !!GmCXt.isOnboarding(/*tour*/ ctx[2]);
		if (show_if_1) return create_if_block_33;
		if (/*step*/ ctx[0].step_type === GmCXt.STEP_TYPE_VIDEO) return create_if_block_37;
		return create_else_block_2$1;
	}

	let current_block_type = select_block_type_3(ctx, [-1, -1]);
	let if_block2 = current_block_type(ctx);
	let if_block3 = show_if && create_if_block_25(ctx);
	let if_block4 = /*stepOperationMode*/ ctx[7] === GmCXt.STEP_VIEW_OPERATION && create_if_block_23(ctx);

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			dnd_nodrag0 = element("dnd-nodrag");
			span0 = element("span");
			t1 = text(t1_value);
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			span1 = element("span");
			t4 = space();
			dnd_nodrag1 = element("dnd-nodrag");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t5 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			if_block2.c();
			t6 = space();
			dnd_nodrag2 = element("dnd-nodrag");
			if (if_block3) if_block3.c();
			t7 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			dnd_nodrag3 = element("dnd-nodrag");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			if (if_block4) if_block4.c();
			attr(span0, "class", "mgPlayerJSTest_step-index");
			attr(span1, "class", "mgPlayerJSTest_align-items-center");
			set_custom_element_data(dnd_nodrag0, "class", "mgPlayerJSTest_ege-inline-block-vt mgPlayerJSTest_width-100");
			attr(wmgPlayerJSTest_0, "class", "step-description-wrapper");
			set_custom_element_data(dnd_nodrag1, "class", "mgPlayerJSTest_dnd-nodrag-block mgPlayerJSTest_ege-inline-block-vt mgPlayerJSTest_width-100");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_ege-inline-block-vt mgPlayerJSTest_step-title-wrapper mgPlayerJSTest_align-items-center");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_step-image-wrapper mgPlayerJSTest_step-image-wrapper-head");
			set_custom_element_data(dnd_nodrag2, "class", "mgPlayerJSTest_dnd-nodrag-inline-block mgPlayerJSTest_step-action-menu-wrapper");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_step-image-wrapper mgPlayerJSTest_width-100");
			set_custom_element_data(dnd_nodrag3, "class", "mgPlayerJSTest_dnd-nodrag-block");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_dnd-nodrag-block");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, dnd_nodrag0);
			append(dnd_nodrag0, span0);
			append(span0, t1);
			append(dnd_nodrag0, t2);
			if (if_block1) if_block1.m(dnd_nodrag0, null);
			append(dnd_nodrag0, t3);
			append(dnd_nodrag0, span1);
			span1.innerHTML = raw0_value;
			append(wmgPlayerJSTest_1, t4);
			append(wmgPlayerJSTest_1, dnd_nodrag1);
			append(dnd_nodrag1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw1_value;
			insert(target, t5, anchor);
			insert(target, wmgPlayerJSTest_2, anchor);
			if_block2.m(wmgPlayerJSTest_2, null);
			insert(target, t6, anchor);
			insert(target, dnd_nodrag2, anchor);
			if (if_block3) if_block3.m(dnd_nodrag2, null);
			insert(target, t7, anchor);
			insert(target, wmgPlayerJSTest_4, anchor);
			append(wmgPlayerJSTest_4, dnd_nodrag3);
			append(dnd_nodrag3, wmgPlayerJSTest_3);
			if (if_block4) if_block4.m(wmgPlayerJSTest_3, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_1, "click", function () {
						if (is_function(!/*tour*/ ctx[2].isEditMode && (!/*step*/ ctx[0].isEdit || !/*step*/ ctx[0].isCreation)
						? /*click_handler_11*/ ctx[29]
						: '')) (!/*tour*/ ctx[2].isEditMode && (!/*step*/ ctx[0].isEdit || !/*step*/ ctx[0].isCreation)
						? /*click_handler_11*/ ctx[29]
						: '').apply(this, arguments);
					}),
					listen(wmgPlayerJSTest_2, "click", function () {
						if (is_function(!/*tour*/ ctx[2].isEditMode && (!/*step*/ ctx[0].isEdit || !/*step*/ ctx[0].isCreation)
						? /*click_handler_12*/ ctx[33]
						: '')) (!/*tour*/ ctx[2].isEditMode && (!/*step*/ ctx[0].isEdit || !/*step*/ ctx[0].isCreation)
						? /*click_handler_12*/ ctx[33]
						: '').apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*step*/ ctx[0].step_settings?.startPoint) {
				if (if_block0) ; else {
					if_block0 = create_if_block_39();
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_1, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if ((!current || dirty[0] & /*index*/ 2) && t1_value !== (t1_value = /*index*/ ctx[1] + 1 + "")) set_data(t1, t1_value);
			if (dirty[0] & /*tour, step*/ 5) show_if_2 = /*tour*/ ctx[2].filteredSteps.length > 1 && !/*tour*/ ctx[2].is_published && rootScope.hasTourAccess(/*tour*/ ctx[2]) && !/*step*/ ctx[0].step_screen_temp && !rootScope.isDesktopApp() && !rootScope.hideMirrorAppCtrl() && !/*tour*/ ctx[2].isEditMode;

			if (show_if_2) {
				if (if_block1) ; else {
					if_block1 = create_if_block_38();
					if_block1.c();
					if_block1.m(dnd_nodrag0, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if ((!current || dirty[0] & /*step*/ 1) && raw0_value !== (raw0_value = GmCXt.truncate(GmCXt.htmlToPlaintext(/*step*/ ctx[0].step_title), 140) + "")) span1.innerHTML = raw0_value;			if ((!current || dirty[0] & /*step*/ 1) && raw1_value !== (raw1_value = GmCXt.truncate(GmCXt.htmlToPlaintext(/*step*/ ctx[0].step_description), 150) + "")) wmgPlayerJSTest_0.innerHTML = raw1_value;
			if (current_block_type === (current_block_type = select_block_type_3(ctx, dirty)) && if_block2) {
				if_block2.p(ctx, dirty);
			} else {
				if_block2.d(1);
				if_block2 = current_block_type(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_2, null);
				}
			}

			if (dirty[0] & /*stepOperationMode, tour, step*/ 133) show_if = /*stepOperationMode*/ ctx[7] === GmCXt.STEP_VIEW_OPERATION && rootScope.isUserLoggedIn() && GmCXt.FT.creatorApp && rootScope.hasTourAccess(/*tour*/ ctx[2]) && !rootScope.hideMirrorAppCtrl() && !(/*tour*/ ctx[2].is_published && /*step*/ ctx[0].step_type === 'video');

			if (show_if) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_25(ctx);
					if_block3.c();
					if_block3.m(dnd_nodrag2, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*stepOperationMode*/ ctx[7] === GmCXt.STEP_VIEW_OPERATION) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[0] & /*stepOperationMode*/ 128) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_23(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(wmgPlayerJSTest_3, null);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block4);
			current = true;
		},
		o(local) {
			transition_out(if_block4);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
				detach(t5);
				detach(wmgPlayerJSTest_2);
				detach(t6);
				detach(dnd_nodrag2);
				detach(t7);
				detach(wmgPlayerJSTest_4);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (432:5) {#if rootScope.isTrackingGuide(tour) && ((!step.isEdit && !step.isCreation) || !tour.isEditMode)}
function create_if_block_12$2(ctx) {
	let wmgPlayerJSTest_5;
	let dnd_nodrag0;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_0;
	let raw0_value = rootScope.svgs.iconAddStepInline + "";
	let t0;
	let wmgPlayerJSTest_1;
	let raw1_value = rootScope.svgs.endTracking + "";
	let t1;
	let wmgPlayerJSTest_2;
	let raw2_value = rootScope.svgs.terminate + "";
	let t2;
	let wmgPlayerJSTest_3;
	let raw3_value = rootScope.svgs.captureEvents + "";
	let t3;
	let dnd_nodrag1;
	let t4;
	let t5;
	let dnd_nodrag2;
	let show_if_1 = /*stepOperationMode*/ ctx[7] === GmCXt.STEP_VIEW_OPERATION && rootScope.isUserLoggedIn() && GmCXt.FT.creatorApp && rootScope.hasTourAccess(/*tour*/ ctx[2]) && !rootScope.hideMirrorAppCtrl() && !(/*tour*/ ctx[2].is_published && /*step*/ ctx[0].step_type == 'video');
	let t6;
	let dnd_nodrag3;
	let show_if = /*showThumbnail*/ ctx[9]();
	let current;
	let if_block0 = !/*step*/ ctx[0].step_type !== 'smartTip' && create_if_block_21(ctx);
	let if_block1 = show_if_1 && create_if_block_18$1(ctx);
	let if_block2 = show_if && create_if_block_13$2(ctx);

	return {
		c() {
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			dnd_nodrag0 = element("dnd-nodrag");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t1 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t3 = space();
			dnd_nodrag1 = element("dnd-nodrag");
			t4 = text(" \n\t\t\t\t\t\t\t\t");
			if (if_block0) if_block0.c();
			t5 = space();
			dnd_nodrag2 = element("dnd-nodrag");
			if (if_block1) if_block1.c();
			t6 = space();
			dnd_nodrag3 = element("dnd-nodrag");
			if (if_block2) if_block2.c();

			set_style(wmgPlayerJSTest_0, "display", /*step*/ ctx[0].step_settings && /*step*/ ctx[0].step_settings.trackerType === 'start'
			? ''
			: 'none');

			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_inline-block-vm");

			set_style(wmgPlayerJSTest_1, "display", /*step*/ ctx[0].step_settings && /*step*/ ctx[0].step_settings.trackerType === 'cancel'
			? ''
			: 'none');

			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_inline-block-vm");

			set_style(wmgPlayerJSTest_2, "display", /*step*/ ctx[0].step_settings && /*step*/ ctx[0].step_settings.trackerType === 'end'
			? ''
			: 'none');

			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_inline-block-vm");
			set_style(wmgPlayerJSTest_3, "display", /*step*/ ctx[0].step_type === 'tag' ? '' : 'none');
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_icon-step-insights mgPlayerJSTest_inline-block-vm");
			set_custom_element_data(dnd_nodrag0, "class", "mgPlayerJSTest_dnd-nodrag-inline-block");
			set_custom_element_data(dnd_nodrag1, "class", "mgPlayerJSTest_dnd-nodrag-inline-block");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_ege-inline-block-vt mgPlayerJSTest_step-title-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center");
			set_custom_element_data(dnd_nodrag2, "class", "mgPlayerJSTest_dnd-nodrag-inline-block mgPlayerJSTest_step-action-menu-wrapper");
			set_custom_element_data(dnd_nodrag3, "class", "mgPlayerJSTest_dnd-nodrag-block");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_5, anchor);
			append(wmgPlayerJSTest_5, dnd_nodrag0);
			append(dnd_nodrag0, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw0_value;
			append(wmgPlayerJSTest_4, t0);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_1);
			wmgPlayerJSTest_1.innerHTML = raw1_value;
			append(wmgPlayerJSTest_4, t1);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_2);
			wmgPlayerJSTest_2.innerHTML = raw2_value;
			append(wmgPlayerJSTest_4, t2);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			wmgPlayerJSTest_3.innerHTML = raw3_value;
			append(wmgPlayerJSTest_5, t3);
			append(wmgPlayerJSTest_5, dnd_nodrag1);
			append(dnd_nodrag1, t4);
			if (if_block0) if_block0.m(dnd_nodrag1, null);
			insert(target, t5, anchor);
			insert(target, dnd_nodrag2, anchor);
			if (if_block1) if_block1.m(dnd_nodrag2, null);
			insert(target, t6, anchor);
			insert(target, dnd_nodrag3, anchor);
			if (if_block2) if_block2.m(dnd_nodrag3, null);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty[0] & /*step*/ 1) {
				set_style(wmgPlayerJSTest_0, "display", /*step*/ ctx[0].step_settings && /*step*/ ctx[0].step_settings.trackerType === 'start'
				? ''
				: 'none');
			}

			if (!current || dirty[0] & /*step*/ 1) {
				set_style(wmgPlayerJSTest_1, "display", /*step*/ ctx[0].step_settings && /*step*/ ctx[0].step_settings.trackerType === 'cancel'
				? ''
				: 'none');
			}

			if (!current || dirty[0] & /*step*/ 1) {
				set_style(wmgPlayerJSTest_2, "display", /*step*/ ctx[0].step_settings && /*step*/ ctx[0].step_settings.trackerType === 'end'
				? ''
				: 'none');
			}

			if (!current || dirty[0] & /*step*/ 1) {
				set_style(wmgPlayerJSTest_3, "display", /*step*/ ctx[0].step_type === 'tag' ? '' : 'none');
			}

			if (!/*step*/ ctx[0].step_type !== 'smartTip') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_21(ctx);
					if_block0.c();
					if_block0.m(dnd_nodrag1, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*stepOperationMode, tour, step*/ 133) show_if_1 = /*stepOperationMode*/ ctx[7] === GmCXt.STEP_VIEW_OPERATION && rootScope.isUserLoggedIn() && GmCXt.FT.creatorApp && rootScope.hasTourAccess(/*tour*/ ctx[2]) && !rootScope.hideMirrorAppCtrl() && !(/*tour*/ ctx[2].is_published && /*step*/ ctx[0].step_type == 'video');

			if (show_if_1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_18$1(ctx);
					if_block1.c();
					if_block1.m(dnd_nodrag2, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (show_if) if_block2.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_5);
				detach(t5);
				detach(dnd_nodrag2);
				detach(t6);
				detach(dnd_nodrag3);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};
}

// (869:54) 
function create_if_block_45(ctx) {
	let addeditfeaturestep;
	let updating_step;
	let current;

	function addeditfeaturestep_step_binding(value) {
		/*addeditfeaturestep_step_binding*/ ctx[46](value);
	}

	let addeditfeaturestep_props = {
		index: /*index*/ ctx[1],
		imageStatus: /*imageStatus*/ ctx[6]
	};

	if (/*step*/ ctx[0] !== void 0) {
		addeditfeaturestep_props.step = /*step*/ ctx[0];
	}

	addeditfeaturestep = new AddEditFeatureStep({ props: addeditfeaturestep_props });
	binding_callbacks.push(() => bind(addeditfeaturestep, 'step', addeditfeaturestep_step_binding));

	return {
		c() {
			create_component(addeditfeaturestep.$$.fragment);
		},
		m(target, anchor) {
			mount_component(addeditfeaturestep, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const addeditfeaturestep_changes = {};
			if (dirty[0] & /*index*/ 2) addeditfeaturestep_changes.index = /*index*/ ctx[1];
			if (dirty[0] & /*imageStatus*/ 64) addeditfeaturestep_changes.imageStatus = /*imageStatus*/ ctx[6];

			if (!updating_step && dirty[0] & /*step*/ 1) {
				updating_step = true;
				addeditfeaturestep_changes.step = /*step*/ ctx[0];
				add_flush_callback(() => updating_step = false);
			}

			addeditfeaturestep.$set(addeditfeaturestep_changes);
		},
		i(local) {
			if (current) return;
			transition_in(addeditfeaturestep.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addeditfeaturestep.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(addeditfeaturestep, detaching);
		}
	};
}

// (867:60) 
function create_if_block_44(ctx) {
	let addeditsmarttipview;
	let updating_step;
	let current;

	function addeditsmarttipview_step_binding(value) {
		/*addeditsmarttipview_step_binding*/ ctx[45](value);
	}

	let addeditsmarttipview_props = {
		index: /*index*/ ctx[1],
		imageStatus: /*imageStatus*/ ctx[6]
	};

	if (/*step*/ ctx[0] !== void 0) {
		addeditsmarttipview_props.step = /*step*/ ctx[0];
	}

	addeditsmarttipview = new Empty({ props: addeditsmarttipview_props });
	binding_callbacks.push(() => bind(addeditsmarttipview, 'step', addeditsmarttipview_step_binding));

	return {
		c() {
			create_component(addeditsmarttipview.$$.fragment);
		},
		m(target, anchor) {
			mount_component(addeditsmarttipview, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const addeditsmarttipview_changes = {};
			if (dirty[0] & /*index*/ 2) addeditsmarttipview_changes.index = /*index*/ ctx[1];
			if (dirty[0] & /*imageStatus*/ 64) addeditsmarttipview_changes.imageStatus = /*imageStatus*/ ctx[6];

			if (!updating_step && dirty[0] & /*step*/ 1) {
				updating_step = true;
				addeditsmarttipview_changes.step = /*step*/ ctx[0];
				add_flush_callback(() => updating_step = false);
			}

			addeditsmarttipview.$set(addeditsmarttipview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(addeditsmarttipview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addeditsmarttipview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(addeditsmarttipview, detaching);
		}
	};
}

// (865:56) 
function create_if_block_43(ctx) {
	let addeditimagestep;
	let updating_step;
	let current;

	function addeditimagestep_step_binding(value) {
		/*addeditimagestep_step_binding*/ ctx[44](value);
	}

	let addeditimagestep_props = {
		index: /*index*/ ctx[1],
		imageStatus: /*imageStatus*/ ctx[6]
	};

	if (/*step*/ ctx[0] !== void 0) {
		addeditimagestep_props.step = /*step*/ ctx[0];
	}

	addeditimagestep = new Empty({ props: addeditimagestep_props });
	binding_callbacks.push(() => bind(addeditimagestep, 'step', addeditimagestep_step_binding));

	return {
		c() {
			create_component(addeditimagestep.$$.fragment);
		},
		m(target, anchor) {
			mount_component(addeditimagestep, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const addeditimagestep_changes = {};
			if (dirty[0] & /*index*/ 2) addeditimagestep_changes.index = /*index*/ ctx[1];
			if (dirty[0] & /*imageStatus*/ 64) addeditimagestep_changes.imageStatus = /*imageStatus*/ ctx[6];

			if (!updating_step && dirty[0] & /*step*/ 1) {
				updating_step = true;
				addeditimagestep_changes.step = /*step*/ ctx[0];
				add_flush_callback(() => updating_step = false);
			}

			addeditimagestep.$set(addeditimagestep_changes);
		},
		i(local) {
			if (current) return;
			transition_in(addeditimagestep.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addeditimagestep.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(addeditimagestep, detaching);
		}
	};
}

// (863:58) 
function create_if_block_42(ctx) {
	let addeditmessageview;
	let updating_step;
	let current;

	function addeditmessageview_step_binding(value) {
		/*addeditmessageview_step_binding*/ ctx[43](value);
	}

	let addeditmessageview_props = {
		index: /*index*/ ctx[1],
		imageStatus: /*imageStatus*/ ctx[6]
	};

	if (/*step*/ ctx[0] !== void 0) {
		addeditmessageview_props.step = /*step*/ ctx[0];
	}

	addeditmessageview = new Empty({ props: addeditmessageview_props });
	binding_callbacks.push(() => bind(addeditmessageview, 'step', addeditmessageview_step_binding));

	return {
		c() {
			create_component(addeditmessageview.$$.fragment);
		},
		m(target, anchor) {
			mount_component(addeditmessageview, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const addeditmessageview_changes = {};
			if (dirty[0] & /*index*/ 2) addeditmessageview_changes.index = /*index*/ ctx[1];
			if (dirty[0] & /*imageStatus*/ 64) addeditmessageview_changes.imageStatus = /*imageStatus*/ ctx[6];

			if (!updating_step && dirty[0] & /*step*/ 1) {
				updating_step = true;
				addeditmessageview_changes.step = /*step*/ ctx[0];
				add_flush_callback(() => updating_step = false);
			}

			addeditmessageview.$set(addeditmessageview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(addeditmessageview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addeditmessageview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(addeditmessageview, detaching);
		}
	};
}

// (861:6) {#if step.step_type === GmCXt.STEP_TYPE_INLINE}
function create_if_block_41(ctx) {
	let addeditstepview;
	let updating_step;
	let current;

	function addeditstepview_step_binding(value) {
		/*addeditstepview_step_binding*/ ctx[42](value);
	}

	let addeditstepview_props = {
		index: /*index*/ ctx[1],
		imageStatus: /*imageStatus*/ ctx[6]
	};

	if (/*step*/ ctx[0] !== void 0) {
		addeditstepview_props.step = /*step*/ ctx[0];
	}

	addeditstepview = new Empty({ props: addeditstepview_props });
	binding_callbacks.push(() => bind(addeditstepview, 'step', addeditstepview_step_binding));

	return {
		c() {
			create_component(addeditstepview.$$.fragment);
		},
		m(target, anchor) {
			mount_component(addeditstepview, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const addeditstepview_changes = {};
			if (dirty[0] & /*index*/ 2) addeditstepview_changes.index = /*index*/ ctx[1];
			if (dirty[0] & /*imageStatus*/ 64) addeditstepview_changes.imageStatus = /*imageStatus*/ ctx[6];

			if (!updating_step && dirty[0] & /*step*/ 1) {
				updating_step = true;
				addeditstepview_changes.step = /*step*/ ctx[0];
				add_flush_callback(() => updating_step = false);
			}

			addeditstepview.$set(addeditstepview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(addeditstepview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addeditstepview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(addeditstepview, detaching);
		}
	};
}

// (592:7) {#if step.step_settings?.startPoint}
function create_if_block_39(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.startPoint + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (599:8) {#if tour.filteredSteps.length > 1 && !tour.is_published && rootScope.hasTourAccess(tour) && !step.step_screen_temp && !rootScope.isDesktopApp() && !rootScope.hideMirrorAppCtrl() && !tour.isEditMode}
function create_if_block_38(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.dragStep + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_drag-step-icon-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (652:7) {:else}
function create_else_block_2$1(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	return {
		c() {
			img = element("img");
			attr(img, "class", "step-image mgPlayerJSTest_custom-image");

			if (!src_url_equal(img.src, img_src_value = /*step*/ ctx[0].step_screen_temp
			? /*step*/ ctx[0].step_screen_temp
			: /*step*/ ctx[0].preview_image
				? /*step*/ ctx[0].preview_image
				: /*imageUrl*/ ctx[5])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);

			if (!mounted) {
				dispose = listen(img, "error", /*error_handler_4*/ ctx[32]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step, imageUrl*/ 33 && !src_url_equal(img.src, img_src_value = /*step*/ ctx[0].step_screen_temp
			? /*step*/ ctx[0].step_screen_temp
			: /*step*/ ctx[0].preview_image
				? /*step*/ ctx[0].preview_image
				: /*imageUrl*/ ctx[5])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}

			mounted = false;
			dispose();
		}
	};
}

// (644:57) 
function create_if_block_37(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	return {
		c() {
			img = element("img");
			attr(img, "class", "step-image mgPlayerJSTest_custom-image");

			if (!src_url_equal(img.src, img_src_value = /*step*/ ctx[0].image_url
			? /*imageUrl*/ ctx[5]
			: /*step*/ ctx[0].step_screen_temp)) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);

			if (!mounted) {
				dispose = listen(img, "error", /*error_handler_3*/ ctx[31]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step, imageUrl*/ 33 && !src_url_equal(img.src, img_src_value = /*step*/ ctx[0].image_url
			? /*imageUrl*/ ctx[5]
			: /*step*/ ctx[0].step_screen_temp)) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}

			mounted = false;
			dispose();
		}
	};
}

// (619:7) {#if GmCXt.isOnboarding(tour)}
function create_if_block_33(ctx) {
	let if_block_anchor;

	function select_block_type_4(ctx, dirty) {
		if (/*tour*/ ctx[2].tour_settings.tutorial_tour_type === 'upload') return create_if_block_34;
		if (/*step*/ ctx[0].step_video == 0) return create_if_block_35;
		if (/*step*/ ctx[0].step_video != 0) return create_if_block_36;
	}

	let current_block_type = select_block_type_4(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) {
				if_block.d(detaching);
			}
		}
	};
}

// (639:39) 
function create_if_block_36(ctx) {
	let video;
	let source;
	let source_src_value;

	return {
		c() {
			video = element("video");
			source = element("source");

			if (!src_url_equal(source.src, source_src_value = /*step*/ ctx[0].step_screen_temp
			? /*step*/ ctx[0].step_screen_temp
			: /*imageUrl*/ ctx[5])) attr(source, "src", source_src_value);

			attr(source, "type", "video/mp4");
			attr(video, "class", "mgPlayerJSTest_tg-img svelte-hv9a3t");
			video.controls = true;
			attr(video, "controlslist", "nodownload");
			attr(video, "disablepictureinpicture", "");
			video.muted = true;
		},
		m(target, anchor) {
			insert(target, video, anchor);
			append(video, source);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step, imageUrl*/ 33 && !src_url_equal(source.src, source_src_value = /*step*/ ctx[0].step_screen_temp
			? /*step*/ ctx[0].step_screen_temp
			: /*imageUrl*/ ctx[5])) {
				attr(source, "src", source_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(video);
			}
		}
	};
}

// (626:39) 
function create_if_block_35(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	return {
		c() {
			img = element("img");
			attr(img, "class", "step-image mgPlayerJSTest_custom-image");
			set_style(img, "object-fit", "contain");
			set_style(img, "height", "250px");

			if (!src_url_equal(img.src, img_src_value = /*step*/ ctx[0].step_screen_temp
			? /*step*/ ctx[0].step_screen_temp
			: /*step*/ ctx[0].preview_image
				? /*step*/ ctx[0].preview_image
				: /*imageUrl*/ ctx[5])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);

			if (!mounted) {
				dispose = listen(img, "error", /*error_handler_2*/ ctx[30]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step, imageUrl*/ 33 && !src_url_equal(img.src, img_src_value = /*step*/ ctx[0].step_screen_temp
			? /*step*/ ctx[0].step_screen_temp
			: /*step*/ ctx[0].preview_image
				? /*step*/ ctx[0].preview_image
				: /*imageUrl*/ ctx[5])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}

			mounted = false;
			dispose();
		}
	};
}

// (620:8) {#if tour.tour_settings.tutorial_tour_type === 'upload'}
function create_if_block_34(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.pdf + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_document-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_margin-lr-10");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (668:7) {#if stepOperationMode === GmCXt.STEP_VIEW_OPERATION && rootScope.isUserLoggedIn() && GmCXt.FT.creatorApp && rootScope.hasTourAccess(tour) && !rootScope.hideMirrorAppCtrl() && !(tour.is_published && step.step_type === 'video')}
function create_if_block_25(ctx) {
	let wmgPlayerJSTest_5;
	let t0;
	let wmgPlayerJSTest_4;
	let t1;
	let t2;
	let show_if_2 = /*step*/ ctx[0].step_type !== 'image' && /*step*/ ctx[0].step_type !== 'video' && /*step*/ ctx[0].step_type !== 'guide' && !rootScope.isDesktopGuide(/*tour*/ ctx[2]) && !rootScope.isMobileGuide(/*tour*/ ctx[2]) && !rootScope.isElectron;
	let t3;
	let show_if_1 = !GmCXt.isOnboarding(/*tour*/ ctx[2]);
	let t4;
	let show_if = !GmCXt.isOnboarding(/*tour*/ ctx[2]) && rootScope.isOwnerOrAppAdmin() && /*step*/ ctx[0].step_type === 'inline';
	let t5;
	let t6;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.historyIcon + "";
	let t7;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_id_value;
	let wmgPlayerJSTest_2_class_value;
	let t9;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_4_id_value;
	let mounted;
	let dispose;
	let if_block0 = !(/*step*/ ctx[0].step_type === 'video' && /*tour*/ ctx[2].is_published) && create_if_block_32(ctx);
	let if_block1 = !/*tour*/ ctx[2].is_published && /*step*/ ctx[0].step_type !== 'guide' && create_if_block_31(ctx);
	let if_block2 = !/*tour*/ ctx[2].is_published && /*step*/ ctx[0].step_type === 'inline' && /*step*/ ctx[0].step_type !== 'guide' && create_if_block_30(ctx);
	let if_block3 = show_if_2 && create_if_block_29(ctx);
	let if_block4 = show_if_1 && create_if_block_28(ctx);
	let if_block5 = show_if && create_if_block_27(ctx);
	let if_block6 = !/*tour*/ ctx[2].is_published && create_if_block_26(ctx);

	return {
		c() {
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			if (if_block4) if_block4.c();
			t4 = space();
			if (if_block5) if_block5.c();
			t5 = space();
			if (if_block6) if_block6.c();
			t6 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t7 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.history}`;
			t9 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-history-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''));
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_horizontal-line");
			attr(wmgPlayerJSTest_4, "id", wmgPlayerJSTest_4_id_value = "step-menu-options-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_step-action-menu-options-dropdown");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_step-action-menu-container mgPlayerJSTest_step-action-menu-container-head");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_5, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_5, null);
			append(wmgPlayerJSTest_5, t0);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_4);
			if (if_block1) if_block1.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t1);
			if (if_block2) if_block2.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t2);
			if (if_block3) if_block3.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t3);
			if (if_block4) if_block4.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t4);
			if (if_block5) if_block5.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t5);
			if (if_block6) if_block6.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t6);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t7);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_4, t9);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_2, "click", /*click_handler_20*/ ctx[41]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!(/*step*/ ctx[0].step_type === 'video' && /*tour*/ ctx[2].is_published)) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_32(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_5, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!/*tour*/ ctx[2].is_published && /*step*/ ctx[0].step_type !== 'guide') {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_31(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_4, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!/*tour*/ ctx[2].is_published && /*step*/ ctx[0].step_type === 'inline' && /*step*/ ctx[0].step_type !== 'guide') {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_30(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_4, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty[0] & /*step, tour*/ 5) show_if_2 = /*step*/ ctx[0].step_type !== 'image' && /*step*/ ctx[0].step_type !== 'video' && /*step*/ ctx[0].step_type !== 'guide' && !rootScope.isDesktopGuide(/*tour*/ ctx[2]) && !rootScope.isMobileGuide(/*tour*/ ctx[2]) && !rootScope.isElectron;

			if (show_if_2) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_29(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_4, t3);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (dirty[0] & /*tour*/ 4) show_if_1 = !GmCXt.isOnboarding(/*tour*/ ctx[2]);

			if (show_if_1) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_28(ctx);
					if_block4.c();
					if_block4.m(wmgPlayerJSTest_4, t4);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (dirty[0] & /*tour, step*/ 5) show_if = !GmCXt.isOnboarding(/*tour*/ ctx[2]) && rootScope.isOwnerOrAppAdmin() && /*step*/ ctx[0].step_type === 'inline';

			if (show_if) {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block_27(ctx);
					if_block5.c();
					if_block5.m(wmgPlayerJSTest_4, t5);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (!/*tour*/ ctx[2].is_published) {
				if (if_block6) {
					if_block6.p(ctx, dirty);
				} else {
					if_block6 = create_if_block_26(ctx);
					if_block6.c();
					if_block6.m(wmgPlayerJSTest_4, t6);
				}
			} else if (if_block6) {
				if_block6.d(1);
				if_block6 = null;
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_id_value !== (wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-history-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_4_id_value !== (wmgPlayerJSTest_4_id_value = "step-menu-options-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_4, "id", wmgPlayerJSTest_4_id_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_5);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			mounted = false;
			dispose();
		}
	};
}

// (670:9) {#if !(step.step_type === 'video' && tour.is_published)}
function create_if_block_32(ctx) {
	let wmgPlayerJSTest_;
	let svg;
	let defs;
	let g2;
	let g1;
	let g0;
	let path;
	let wmgPlayerJSTest_id_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			svg = svg_element("svg");
			defs = svg_element("defs");
			g2 = svg_element("g");
			g1 = svg_element("g");
			g0 = svg_element("g");
			path = svg_element("path");
			attr(path, "d", "M3.5,9 C2.125,9 1,10.125 1,11.5 C1,12.875 2.125,14 3.5,14 C4.875,14 6,12.875 6,11.5 C6,10.125 4.875,9 3.5,9 L3.5,9 Z M18.5,9 C17.125,9 16,10.125 16,11.5 C16,12.875 17.125,14 18.5,14 C19.875,14 21,12.875 21,11.5 C21,10.125 19.875,9 18.5,9 L18.5,9 Z M11,9 C9.625,9 8.5,10.125 8.5,11.5 C8.5,12.875 9.625,14 11,14 C12.375,14 13.5,12.875 13.5,11.5 C13.5,10.125 12.375,9 11,9 L11,9 Z");
			attr(path, "id", "Shape");
			attr(g0, "id", "more-actions");
			attr(g1, "id", "mgPlayerJSTest_step-action-icons");
			attr(g1, "fill", "#757575");
			attr(g2, "id", "Page-1");
			attr(g2, "stroke", "none");
			attr(g2, "stroke-width", "1");
			attr(g2, "fill", "none");
			attr(g2, "fill-rule", "evenodd");
			attr(svg, "width", "18px");
			attr(svg, "height", "18px");
			attr(svg, "viewBox", "0 0 22 22");
			attr(svg, "version", "1.2");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(wmgPlayerJSTest_, "class", "step-pencil-icon " + (rootScope.pendingStepCount > 0 ? 'mgPlayerJSTest_disable-edit' : ''));
			attr(wmgPlayerJSTest_, "id", wmgPlayerJSTest_id_value = "step-pencil-icon-" + /*step*/ ctx[0].step_id);
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, svg);
			append(svg, defs);
			append(svg, g2);
			append(g2, g1);
			append(g1, g0);
			append(g0, path);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_, "click", /*click_handler_13*/ ctx[34]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_id_value !== (wmgPlayerJSTest_id_value = "step-pencil-icon-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_, "id", wmgPlayerJSTest_id_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			dispose();
		}
	};
}

// (699:10) {#if !tour.is_published && step.step_type !== 'guide'}
function create_if_block_31(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.iconEdit + "";
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_id_value;
	let wmgPlayerJSTest_2_class_value;
	let t2;
	let wmgPlayerJSTest_3;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.btnEdit}`;
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-edit-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''));
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_horizontal-line");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			insert(target, t2, anchor);
			insert(target, wmgPlayerJSTest_3, anchor);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_2, "click", /*click_handler_14*/ ctx[35]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_id_value !== (wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-edit-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
				detach(t2);
				detach(wmgPlayerJSTest_3);
			}

			mounted = false;
			dispose();
		}
	};
}

// (718:10) {#if !tour.is_published && step.step_type === 'inline' && step.step_type !== 'guide'}
function create_if_block_30(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.iconEdit + "";
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_id_value;
	let wmgPlayerJSTest_2_class_value;
	let t2;
	let wmgPlayerJSTest_3;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.editOnImg}`;
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-edit-img-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''));
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_horizontal-line");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			insert(target, t2, anchor);
			insert(target, wmgPlayerJSTest_3, anchor);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_2, "click", /*click_handler_15*/ ctx[36]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_id_value !== (wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-edit-img-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
				detach(t2);
				detach(wmgPlayerJSTest_3);
			}

			mounted = false;
			dispose();
		}
	};
}

// (737:10) {#if step.step_type !== 'image' && step.step_type !== 'video' && step.step_type !== 'guide' && !rootScope.isDesktopGuide(tour) && !rootScope.isMobileGuide(tour) && !rootScope.isElectron}
function create_if_block_29(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.iconGoToStepUrl + "";
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_id_value;
	let t2;
	let wmgPlayerJSTest_3;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.btnGoToStepUrl}`;
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-goto-step-url-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_horizontal-line");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			insert(target, t2, anchor);
			insert(target, wmgPlayerJSTest_3, anchor);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_2, "click", /*click_handler_16*/ ctx[37]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_id_value !== (wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-goto-step-url-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
				detach(t2);
				detach(wmgPlayerJSTest_3);
			}

			mounted = false;
			dispose();
		}
	};
}

// (753:10) {#if !GmCXt.isOnboarding(tour)}
function create_if_block_28(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.copyGuideIcon + "";
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_id_value;
	let wmgPlayerJSTest_2_class_value;
	let t2;
	let wmgPlayerJSTest_3;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.btnCopyStep}`;
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-copy-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''));
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_horizontal-line");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			insert(target, t2, anchor);
			insert(target, wmgPlayerJSTest_3, anchor);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_2, "click", /*click_handler_17*/ ctx[38]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_id_value !== (wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-copy-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
				detach(t2);
				detach(wmgPlayerJSTest_3);
			}

			mounted = false;
			dispose();
		}
	};
}

// (769:10) {#if !GmCXt.isOnboarding(tour) && rootScope.isOwnerOrAppAdmin() && step.step_type === 'inline'}
function create_if_block_27(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.copyGuideIcon + "";
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_id_value;
	let wmgPlayerJSTest_2_class_value;
	let t2;
	let wmgPlayerJSTest_3;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.findAndReplace}`;
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-find-replace-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''));
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_horizontal-line");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			insert(target, t2, anchor);
			insert(target, wmgPlayerJSTest_3, anchor);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_2, "click", /*click_handler_18*/ ctx[39]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_id_value !== (wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-find-replace-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
				detach(t2);
				detach(wmgPlayerJSTest_3);
			}

			mounted = false;
			dispose();
		}
	};
}

// (786:10) {#if !tour.is_published}
function create_if_block_26(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.iconDelete + "";
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_id_value;
	let wmgPlayerJSTest_2_class_value;
	let t2;
	let wmgPlayerJSTest_3;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.btnDelete}`;
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-delete-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''));
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_horizontal-line");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			insert(target, t2, anchor);
			insert(target, wmgPlayerJSTest_3, anchor);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_2, "click", /*click_handler_19*/ ctx[40]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_id_value !== (wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-delete-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
				detach(t2);
				detach(wmgPlayerJSTest_3);
			}

			mounted = false;
			dispose();
		}
	};
}

// (850:9) {#if stepOperationMode === GmCXt.STEP_VIEW_OPERATION}
function create_if_block_23(ctx) {
	let wmgPlayerJSTest_;
	let show_if = /*showTourActionMenu*/ ctx[10](/*step*/ ctx[0]) && !/*tour*/ ctx[2].is_published;
	let current;
	let if_block = show_if && create_if_block_24(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block) if_block.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_step-image-overlay");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block) if_block.m(wmgPlayerJSTest_, null);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step, tour*/ 5) show_if = /*showTourActionMenu*/ ctx[10](/*step*/ ctx[0]) && !/*tour*/ ctx[2].is_published;

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*step, tour*/ 5) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_24(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block) if_block.d();
		}
	};
}

// (852:11) {#if showTourActionMenu(step) && !tour.is_published}
function create_if_block_24(ctx) {
	let beforeafterstepdropdown;
	let current;
	beforeafterstepdropdown = new Empty({ props: { step: /*step*/ ctx[0] } });

	return {
		c() {
			create_component(beforeafterstepdropdown.$$.fragment);
		},
		m(target, anchor) {
			mount_component(beforeafterstepdropdown, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const beforeafterstepdropdown_changes = {};
			if (dirty[0] & /*step*/ 1) beforeafterstepdropdown_changes.step = /*step*/ ctx[0];
			beforeafterstepdropdown.$set(beforeafterstepdropdown_changes);
		},
		i(local) {
			if (current) return;
			transition_in(beforeafterstepdropdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(beforeafterstepdropdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(beforeafterstepdropdown, detaching);
		}
	};
}

// (463:8) {#if !step.step_type !== 'smartTip'}
function create_if_block_21(ctx) {
	let span;
	let raw_value = GmCXt.truncate(GmCXt.htmlToPlaintext(/*step*/ ctx[0].step_title), 110) + "";

	return {
		c() {
			span = element("span");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			span.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && raw_value !== (raw_value = GmCXt.truncate(GmCXt.htmlToPlaintext(/*step*/ ctx[0].step_title), 110) + "")) span.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (469:7) {#if stepOperationMode === GmCXt.STEP_VIEW_OPERATION && rootScope.isUserLoggedIn() && GmCXt.FT.creatorApp && rootScope.hasTourAccess(tour) && !rootScope.hideMirrorAppCtrl() && !(tour.is_published && step.step_type == 'video')}
function create_if_block_18$1(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let svg;
	let defs;
	let g2;
	let g1;
	let g0;
	let path;
	let wmgPlayerJSTest_0_id_value;
	let t0;
	let wmgPlayerJSTest_1;
	let t1;
	let wmgPlayerJSTest_1_id_value;
	let mounted;
	let dispose;
	let if_block0 = /*step*/ ctx[0].step_type !== 'tag' && !/*tour*/ ctx[2].is_published && create_if_block_20$1(ctx);
	let if_block1 = /*step*/ ctx[0].step_type !== 'inline' && !/*tour*/ ctx[2].is_published && create_if_block_19$1(ctx);

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			svg = svg_element("svg");
			defs = svg_element("defs");
			g2 = svg_element("g");
			g1 = svg_element("g");
			g0 = svg_element("g");
			path = svg_element("path");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			attr(path, "d", "M3.5,9 C2.125,9 1,10.125 1,11.5 C1,12.875 2.125,14 3.5,14 C4.875,14 6,12.875 6,11.5 C6,10.125 4.875,9 3.5,9 L3.5,9 Z M18.5,9 C17.125,9 16,10.125 16,11.5 C16,12.875 17.125,14 18.5,14 C19.875,14 21,12.875 21,11.5 C21,10.125 19.875,9 18.5,9 L18.5,9 Z M11,9 C9.625,9 8.5,10.125 8.5,11.5 C8.5,12.875 9.625,14 11,14 C12.375,14 13.5,12.875 13.5,11.5 C13.5,10.125 12.375,9 11,9 L11,9 Z");
			attr(path, "class", "shape");
			attr(g0, "id", "more-actions");
			attr(g1, "id", "mgPlayerJSTest_step-action-icons");
			attr(g1, "fill", "#757575");
			attr(g2, "id", "Page-1");
			attr(g2, "stroke", "none");
			attr(g2, "stroke-width", "1");
			attr(g2, "fill", "none");
			attr(g2, "fill-rule", "evenodd");
			attr(svg, "width", "18px");
			attr(svg, "height", "18px");
			attr(svg, "viewBox", "0 0 22 22");
			attr(svg, "version", "1.1");
			attr(wmgPlayerJSTest_0, "class", "step-pencil-icon");
			attr(wmgPlayerJSTest_0, "id", wmgPlayerJSTest_0_id_value = "step-pencil-icon-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_1, "id", wmgPlayerJSTest_1_id_value = "step-menu-options-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_step-action-menu-container");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, svg);
			append(svg, defs);
			append(svg, g2);
			append(g2, g1);
			append(g1, g0);
			append(g0, path);
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			if (if_block0) if_block0.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t1);
			if (if_block1) if_block1.m(wmgPlayerJSTest_1, null);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_0, "click", /*click_handler_6*/ ctx[23]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_0_id_value !== (wmgPlayerJSTest_0_id_value = "step-pencil-icon-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_0, "id", wmgPlayerJSTest_0_id_value);
			}

			if (/*step*/ ctx[0].step_type !== 'tag' && !/*tour*/ ctx[2].is_published) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_20$1(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*step*/ ctx[0].step_type !== 'inline' && !/*tour*/ ctx[2].is_published) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_19$1(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_1_id_value !== (wmgPlayerJSTest_1_id_value = "step-menu-options-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_1, "id", wmgPlayerJSTest_1_id_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

// (491:10) {#if step.step_type !== 'tag' && !tour.is_published}
function create_if_block_20$1(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let raw0_value = rootScope.svgs.iconEdit + "";
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_id_value;
	let wmgPlayerJSTest_2_class_value;
	let t2;
	let wmgPlayerJSTest_3;
	let t3;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_4;
	let raw1_value = rootScope.svgs.iconDelete + "";
	let t4;
	let wmgPlayerJSTest_5;
	let wmgPlayerJSTest_6_id_value;
	let wmgPlayerJSTest_6_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.btnEdit}`;
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t3 = space();
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			t4 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5.textContent = `${rootScope.labels.btnDelete}`;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-edit-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''));
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_horizontal-line");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_6, "id", wmgPlayerJSTest_6_id_value = "mgPlayerJSTest_option-step-delete-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_6, "class", wmgPlayerJSTest_6_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw0_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			insert(target, t2, anchor);
			insert(target, wmgPlayerJSTest_3, anchor);
			insert(target, t3, anchor);
			insert(target, wmgPlayerJSTest_6, anchor);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_4);
			wmgPlayerJSTest_4.innerHTML = raw1_value;
			append(wmgPlayerJSTest_6, t4);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_2, "click", /*click_handler_7*/ ctx[24]),
					listen(wmgPlayerJSTest_6, "click", /*click_handler_8*/ ctx[25])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_id_value !== (wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-edit-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_6_id_value !== (wmgPlayerJSTest_6_id_value = "mgPlayerJSTest_option-step-delete-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_6, "id", wmgPlayerJSTest_6_id_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_6_class_value !== (wmgPlayerJSTest_6_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_6, "class", wmgPlayerJSTest_6_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
				detach(t2);
				detach(wmgPlayerJSTest_3);
				detach(t3);
				detach(wmgPlayerJSTest_6);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (518:10) {#if step.step_type !== 'inline' && !tour.is_published}
function create_if_block_19$1(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let raw0_value = rootScope.svgs.iconEdit + "";
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_id_value;
	let wmgPlayerJSTest_2_class_value;
	let t2;
	let wmgPlayerJSTest_5;
	let wmgPlayerJSTest_3;
	let raw1_value = rootScope.svgs.iconDelete + "";
	let t3;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_5_id_value;
	let wmgPlayerJSTest_5_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.btnEdit}`;
			t2 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t3 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4.textContent = `${rootScope.labels.btnDelete}`;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-edit-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''));
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_5, "id", wmgPlayerJSTest_5_id_value = "mgPlayerJSTest_option-step-delete-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_5, "class", wmgPlayerJSTest_5_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw0_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			insert(target, t2, anchor);
			insert(target, wmgPlayerJSTest_5, anchor);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_3);
			wmgPlayerJSTest_3.innerHTML = raw1_value;
			append(wmgPlayerJSTest_5, t3);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_4);

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_2, "click", /*click_handler_9*/ ctx[26]),
					listen(wmgPlayerJSTest_5, "click", /*click_handler_10*/ ctx[27])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_id_value !== (wmgPlayerJSTest_2_id_value = "mgPlayerJSTest_option-step-edit-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_2, "id", wmgPlayerJSTest_2_id_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_5_id_value !== (wmgPlayerJSTest_5_id_value = "mgPlayerJSTest_option-step-delete-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_5, "id", wmgPlayerJSTest_5_id_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_5_class_value !== (wmgPlayerJSTest_5_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_5, "class", wmgPlayerJSTest_5_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
				detach(t2);
				detach(wmgPlayerJSTest_5);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (561:7) {#if showThumbnail()}
function create_if_block_13$2(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let show_if = /*showTourActionMenu*/ ctx[10](/*step*/ ctx[0]) && !/*tour*/ ctx[2].is_published;
	let t0;
	let t1;
	let t2;
	let wmgPlayerJSTest_1_class_value;
	let current;
	let if_block0 = show_if && create_if_block_17$1(ctx);
	let if_block1 = /*step*/ ctx[0].step_screen_temp && create_if_block_16$1(ctx);
	let if_block2 = /*step*/ ctx[0].previewImage && create_if_block_15$2(ctx);
	let if_block3 = /*step*/ ctx[0].image_url && create_if_block_14$2(ctx);

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-image-overlay");

			attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_step-image-wrapper " + (/*step*/ ctx[0].step_type === 'tag'
			? 'mgPlayerJSTest_tag-step-img-wrapper'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			if (if_block0) if_block0.m(wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_1, t0);
			if (if_block1) if_block1.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t1);
			if (if_block2) if_block2.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t2);
			if (if_block3) if_block3.m(wmgPlayerJSTest_1, null);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step, tour*/ 5) show_if = /*showTourActionMenu*/ ctx[10](/*step*/ ctx[0]) && !/*tour*/ ctx[2].is_published;

			if (show_if) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*step, tour*/ 5) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_17$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(wmgPlayerJSTest_0, null);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*step*/ ctx[0].step_screen_temp) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_16$1(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_1, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*step*/ ctx[0].previewImage) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_15$2(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_1, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*step*/ ctx[0].image_url) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_14$2(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_1, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (!current || dirty[0] & /*step*/ 1 && wmgPlayerJSTest_1_class_value !== (wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_step-image-wrapper " + (/*step*/ ctx[0].step_type === 'tag'
			? 'mgPlayerJSTest_tag-step-img-wrapper'
			: ''))) {
				attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
		}
	};
}

// (565:10) {#if showTourActionMenu(step) && !tour.is_published}
function create_if_block_17$1(ctx) {
	let beforeafterstepdropdown;
	let current;
	beforeafterstepdropdown = new Empty({ props: { step: /*step*/ ctx[0] } });

	return {
		c() {
			create_component(beforeafterstepdropdown.$$.fragment);
		},
		m(target, anchor) {
			mount_component(beforeafterstepdropdown, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const beforeafterstepdropdown_changes = {};
			if (dirty[0] & /*step*/ 1) beforeafterstepdropdown_changes.step = /*step*/ ctx[0];
			beforeafterstepdropdown.$set(beforeafterstepdropdown_changes);
		},
		i(local) {
			if (current) return;
			transition_in(beforeafterstepdropdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(beforeafterstepdropdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(beforeafterstepdropdown, detaching);
		}
	};
}

// (569:9) {#if step.step_screen_temp}
function create_if_block_16$1(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "step-image");
			if (!src_url_equal(img.src, img_src_value = /*step*/ ctx[0].step_screen_temp)) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && !src_url_equal(img.src, img_src_value = /*step*/ ctx[0].step_screen_temp)) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}
		}
	};
}

// (572:9) {#if step.previewImage}
function create_if_block_15$2(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "step-image");
			if (!src_url_equal(img.src, img_src_value = /*step*/ ctx[0].previewImage)) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && !src_url_equal(img.src, img_src_value = /*step*/ ctx[0].previewImage)) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}
		}
	};
}

// (575:9) {#if step.image_url}
function create_if_block_14$2(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	return {
		c() {
			img = element("img");
			attr(img, "class", "step-image mgPlayerJSTest_custom-image");
			if (!src_url_equal(img.src, img_src_value = /*step*/ ctx[0].image_url + rootScope.getCdnSign())) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);

			if (!mounted) {
				dispose = listen(img, "error", /*error_handler_1*/ ctx[28]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && !src_url_equal(img.src, img_src_value = /*step*/ ctx[0].image_url + rootScope.getCdnSign())) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}

			mounted = false;
			dispose();
		}
	};
}

// (266:6) {#if GmCXt.FT.creatorApp && rootScope.hasTourAccess(tour) && !rootScope.hideMirrorAppCtrl() && !rootScope.isAnnouncement(tour) && !rootScope.isUploadTutorial(tour) && !(tour.is_published && step.step_type == 'video')}
function create_if_block_8$5(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let svg;
	let defs;
	let g2;
	let g1;
	let g0;
	let path;
	let wmgPlayerJSTest_0_id_value;
	let t0;
	let wmgPlayerJSTest_1;
	let t1;
	let t2;
	let wmgPlayerJSTest_1_id_value;
	let mounted;
	let dispose;
	let if_block0 = !/*tour*/ ctx[2].is_published && create_if_block_11$3(ctx);
	let if_block1 = !/*step*/ ctx[0].step_screen_temp && create_if_block_10$3(ctx);
	let if_block2 = GmCXt.FT.creatorApp && create_if_block_9$4(ctx);

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			svg = svg_element("svg");
			defs = svg_element("defs");
			g2 = svg_element("g");
			g1 = svg_element("g");
			g0 = svg_element("g");
			path = svg_element("path");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			attr(path, "d", "M3.5,9 C2.125,9 1,10.125 1,11.5 C1,12.875 2.125,14 3.5,14 C4.875,14 6,12.875 6,11.5 C6,10.125 4.875,9 3.5,9 L3.5,9 Z M18.5,9 C17.125,9 16,10.125 16,11.5 C16,12.875 17.125,14 18.5,14 C19.875,14 21,12.875 21,11.5 C21,10.125 19.875,9 18.5,9 L18.5,9 Z M11,9 C9.625,9 8.5,10.125 8.5,11.5 C8.5,12.875 9.625,14 11,14 C12.375,14 13.5,12.875 13.5,11.5 C13.5,10.125 12.375,9 11,9 L11,9 Z");
			attr(path, "class", "shape");
			attr(g0, "id", "more-actions");
			attr(g1, "id", "mgPlayerJSTest_step-action-icons");
			attr(g1, "fill", "#757575");
			attr(g2, "id", "Page-1");
			attr(g2, "stroke", "none");
			attr(g2, "stroke-width", "1");
			attr(g2, "fill", "none");
			attr(g2, "fill-rule", "evenodd");
			attr(svg, "width", "18px");
			attr(svg, "height", "18px");
			attr(svg, "viewBox", "0 0 22 22");
			attr(svg, "version", "1.1");
			attr(wmgPlayerJSTest_0, "class", "step-pencil-icon");
			attr(wmgPlayerJSTest_0, "id", wmgPlayerJSTest_0_id_value = "step-pencil-icon-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_1, "id", wmgPlayerJSTest_1_id_value = "step-menu-options-" + /*step*/ ctx[0].step_id);
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_step-action-menu-container");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, svg);
			append(svg, defs);
			append(svg, g2);
			append(g2, g1);
			append(g1, g0);
			append(g0, path);
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			if (if_block0) if_block0.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t1);
			if (if_block1) if_block1.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t2);
			if (if_block2) if_block2.m(wmgPlayerJSTest_1, null);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_0, "click", /*click_handler*/ ctx[15]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_0_id_value !== (wmgPlayerJSTest_0_id_value = "step-pencil-icon-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_0, "id", wmgPlayerJSTest_0_id_value);
			}

			if (!/*tour*/ ctx[2].is_published) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_11$3(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!/*step*/ ctx[0].step_screen_temp) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_10$3(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_1, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (GmCXt.FT.creatorApp) if_block2.p(ctx, dirty);

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_1_id_value !== (wmgPlayerJSTest_1_id_value = "step-menu-options-" + /*step*/ ctx[0].step_id)) {
				attr(wmgPlayerJSTest_1, "id", wmgPlayerJSTest_1_id_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			mounted = false;
			dispose();
		}
	};
}

// (288:9) {#if !tour.is_published}
function create_if_block_11$3(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let raw0_value = rootScope.svgs.iconEdit + "";
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_class_value;
	let t2;
	let wmgPlayerJSTest_3;
	let t3;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_4;
	let raw1_value = rootScope.svgs.iconDelete + "";
	let t4;
	let wmgPlayerJSTest_5;
	let wmgPlayerJSTest_6_class_value;
	let t6;
	let wmgPlayerJSTest_7;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.btnEdit}`;
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t3 = space();
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			t4 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5.textContent = `${rootScope.labels.btnDelete}`;
			t6 = space();
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''));
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_horizontal-line");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_6, "class", wmgPlayerJSTest_6_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''));
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_horizontal-line");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw0_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			insert(target, t2, anchor);
			insert(target, wmgPlayerJSTest_3, anchor);
			insert(target, t3, anchor);
			insert(target, wmgPlayerJSTest_6, anchor);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_4);
			wmgPlayerJSTest_4.innerHTML = raw1_value;
			append(wmgPlayerJSTest_6, t4);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			insert(target, t6, anchor);
			insert(target, wmgPlayerJSTest_7, anchor);

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_2, "click", /*click_handler_1*/ ctx[16]),
					listen(wmgPlayerJSTest_6, "click", /*click_handler_2*/ ctx[17])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}

			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_6_class_value !== (wmgPlayerJSTest_6_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_6, "class", wmgPlayerJSTest_6_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
				detach(t2);
				detach(wmgPlayerJSTest_3);
				detach(t3);
				detach(wmgPlayerJSTest_6);
				detach(t6);
				detach(wmgPlayerJSTest_7);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (322:9) {#if !step.step_screen_temp}
function create_if_block_10$3(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.copyGuideIcon + "";
	let t0;
	let wmgPlayerJSTest_1;
	let t2;
	let wmgPlayerJSTest_3;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.btnCopyStep}`;
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_horizontal-line");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			insert(target, t2, anchor);
			insert(target, wmgPlayerJSTest_3, anchor);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_2, "click", /*click_handler_3*/ ctx[18]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
				detach(t2);
				detach(wmgPlayerJSTest_3);
			}

			mounted = false;
			dispose();
		}
	};
}

// (338:9) {#if GmCXt.FT.creatorApp}
function create_if_block_9$4(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.historyIcon + "";
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_2_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.textContent = `${rootScope.labels.history}`;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_step-action-menu-options-dropdown-item-label mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_2, "click", /*click_handler_4*/ ctx[19]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && wmgPlayerJSTest_2_class_value !== (wmgPlayerJSTest_2_class_value = "mgPlayerJSTest_step-action-menu-options-dropdown-item " + (/*step*/ ctx[0].step_screen_temp ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_2, "class", wmgPlayerJSTest_2_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			mounted = false;
			dispose();
		}
	};
}

// (360:3) {#if step.step_video > 0 || step.screen_url.indexOf('default_icon') == -1}
function create_if_block_6$6(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;

	function select_block_type_1(ctx, dirty) {
		if (/*step*/ ctx[0].step_video == 0) return create_if_block_7$5;
		return create_else_block$5;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			if_block.c();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tg-img-thumb mgPlayerJSTest_position-center");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tg-step-img-thumb-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			if_block.m(wmgPlayerJSTest_0, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(wmgPlayerJSTest_0, null);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			if_block.d();
		}
	};
}

// (372:6) {:else}
function create_else_block$5(ctx) {
	let video;
	let source;
	let source_src_value;

	return {
		c() {
			video = element("video");
			source = element("source");
			if (!src_url_equal(source.src, source_src_value = /*stepVideoURL*/ ctx[4])) attr(source, "src", source_src_value);
			attr(source, "type", "video/mp4");
			attr(video, "class", "mgPlayerJSTest_tg-img svelte-hv9a3t");
			video.controls = true;
			attr(video, "controlslist", "nodownload");
			attr(video, "disablepictureinpicture", "");
			video.muted = true;
		},
		m(target, anchor) {
			insert(target, video, anchor);
			append(video, source);
			/*video_binding*/ ctx[21](video);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*stepVideoURL*/ 16 && !src_url_equal(source.src, source_src_value = /*stepVideoURL*/ ctx[4])) {
				attr(source, "src", source_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(video);
			}

			/*video_binding*/ ctx[21](null);
		}
	};
}

// (363:6) {#if step.step_video == 0}
function create_if_block_7$5(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	return {
		c() {
			img = element("img");
			attr(img, "class", "mgPlayerJSTest_tg-img svelte-hv9a3t");
			if (!src_url_equal(img.src, img_src_value = /*step*/ ctx[0].screen_url + rootScope.getCdnSign())) attr(img, "src", img_src_value);
			attr(img, "alt", "Step Image Thumb");
		},
		m(target, anchor) {
			insert(target, img, anchor);

			if (!mounted) {
				dispose = listen(img, "error", /*error_handler*/ ctx[20]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1 && !src_url_equal(img.src, img_src_value = /*step*/ ctx[0].screen_url + rootScope.getCdnSign())) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}

			mounted = false;
			dispose();
		}
	};
}

// (387:3) {#if rootScope.isUploadTutorial(tour)}
function create_if_block_5$6(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = rootScope.svgs.pdfIcon + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_document-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_margin-lr-10");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (402:4) {#if !rootScope.isAnnouncement(tour)}
function create_if_block_4$7(ctx) {
	let wmgPlayerJSTest_1;
	let t0_value = rootScope.labels.showMe + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.guidePlayIconShowme + "";
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_margin-lr-10");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_play-step-icon-wrapper mgPlayerJSTest_position-center mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_font-size-16");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, t1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_1, "click", /*click_handler_5*/ ctx[22]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			mounted = false;
			dispose();
		}
	};
}

// (414:4) {#if !rootScope.hideMirrorAppCtrl() && !rootScope.isAnnouncement(tour) && !rootScope.isUploadTutorial(tour)}
function create_if_block_2$8(ctx) {
	let wmgPlayerJSTest_;
	let show_if = /*showTourActionMenu*/ ctx[10](/*step*/ ctx[0]) && !/*tour*/ ctx[2].is_published;
	let current;
	let if_block = show_if && create_if_block_3$8(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block) if_block.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_tour-action-wrapper mgPlayerJSTest_position-relative");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block) if_block.m(wmgPlayerJSTest_, null);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step, tour*/ 5) show_if = /*showTourActionMenu*/ ctx[10](/*step*/ ctx[0]) && !/*tour*/ ctx[2].is_published;

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*step, tour*/ 5) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_3$8(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block) if_block.d();
		}
	};
}

// (416:6) {#if showTourActionMenu(step) && !tour.is_published}
function create_if_block_3$8(ctx) {
	let beforeafterstepdropdown;
	let current;
	beforeafterstepdropdown = new Empty({ props: { step: /*step*/ ctx[0] } });

	return {
		c() {
			create_component(beforeafterstepdropdown.$$.fragment);
		},
		m(target, anchor) {
			mount_component(beforeafterstepdropdown, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const beforeafterstepdropdown_changes = {};
			if (dirty[0] & /*step*/ 1) beforeafterstepdropdown_changes.step = /*step*/ ctx[0];
			beforeafterstepdropdown.$set(beforeafterstepdropdown_changes);
		},
		i(local) {
			if (current) return;
			transition_in(beforeafterstepdropdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(beforeafterstepdropdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(beforeafterstepdropdown, detaching);
		}
	};
}

function create_fragment$d(ctx) {
	let show_if = !GmCXt.isEmpty(/*step*/ ctx[0]);
	let if_block_anchor;
	let current;
	let if_block = show_if && create_if_block$9(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*step*/ 1) show_if = !GmCXt.isEmpty(/*step*/ ctx[0]);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*step*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$9(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function getTutorialDesc(step) {
	if (!GmCXt.isEmpty(step.step_title)) {
		return step.step_title + step.step_description;
	} else {
		step.step_description = GmCXt.updateOrgAndAddSignature(GmCXt.restoreAssetSrc(step.step_description));
		return step.step_description;
	}
}

function instance$d($$self, $$props, $$invalidate) {
	let { step } = $$props;
	let stepVideoURL;
	let { index } = $$props;
	let { tour } = $$props;
	let { imageUploadData } = $$props;
	let cdn = false;
	let imageUrl = '';
	let imageStatus = 'loading';
	let stepOperationMode = get_store_value(Gm.stepOperationMode);

	const stepOperationModeSubscriber = Gm.stepOperationMode.subscribe(value => {
		$$invalidate(7, stepOperationMode = value);
	});

	function getImageUrl(url, step_type) {
		if (!GmCXt.isDefined(url)) {
			url = '';
			return;
		}

		if (GmCXt.isOnboarding(tour)) {
			if (step.step_video != 0) {
				return step.step_video_url + cdn;
			} else {
				return url + cdn;
			}
		}

		if (step_type === 'guide') {
			return url.split('.png')[0] + '_thumb.png' + cdn;
		} else if (step_type === 'video') {
			return url + cdn;
		} else if (step_type == 'survey' || step_type == 'transport') {
			if (step.image_url.indexOf('default_icon') == -1) return step.image_url + cdn; else return `${rootScope.staticContentPath}survey_step.png`;
		} else {
			return step.is_screen_url_processed
			? url.split('.png')[0] + '_cropped.png' + cdn
			: step.screen_url + cdn;
		}
	}

	const guideAction = (e, type, step) => {
		e.stopPropagation();

		// let step = tour.steps[0]
		if (type === 'doitforme' && GmCXt.disableDoItForMe) {
			modal.open(rootScope.labels.doitForMeWarning, 'warning');
			return false;
		}

		rootScope.guideAction(type, step, tour, get_store_value(Gm.CurrentPage), '');
	};

	function showThumbnail() {
		if (rootScope.onPrem) {
			return GmCXt.FT.showMe;
		} else {
			return true;
		}
	}

	const showTourActionMenu = function (step) {
		if (!step.step_type && step.type) step.step_type = step.type;

		if (step.step_type === GmCXt.STEP_TYPE_BRANCH || step.step_type === GmCXt.STEP_TYPE_ERROR_HANDLER) {
			return false;
		} else if (step.step_settings && step.step_settings.inlineBranch) {
			return false;
		} else if (step.hideStep) {
			return false;
		} else {
			return true;
		}
	};

	function showMenuActionDropdown(step_id, event) {
		event.stopPropagation();
		rootScope.hideUserImageDropDown();
		let stepWrapper = mg$('.mgPlayerJSTest_step-image-wrapper');
		mg$(stepWrapper).removeClass('active');
		mg$('.tour-action-dropdown').slideUp(200);
		mg$('.mgPlayerJSTest_detail-view-action-options-dropdownn').slideUp(200);
		mg$('.mgPlayerJSTest_detail-download-action-options-dropdown').slideUp(200);
		let isDropdownVisible = mg$('#step-menu-options-' + step_id).is(':visible');
		mg$('.mgPlayerJSTest_step-action-menu-options-dropdown').slideUp(200);

		if (!isDropdownVisible) {
			mg$('#step-menu-options-' + step_id).slideDown(200);
		}
	}

	let tutVideoElement;

	onMount(() => {
		//check and get cdn signature
		rootScope.checkCdnSignature().then(() => {
			$$invalidate(14, cdn = GmCXt.getCdnSign());
		});
	});

	onDestroy(() => {
		stepOperationModeSubscriber();
	});

	function setActiveStep(event) {
		if (!event.isTrusted || !(step.isEdit || step.isCreation)) return;

		if (stepOperationMode !== GmCXt.STEP_EDIT_OPERATION) {
			Gm.activeStepId.set(step.step_id);
		}
	}

	const click_handler = e => showMenuActionDropdown(step.step_id, e);

	const click_handler_1 = () => {
		rootScope.editStep(tour, step, index);
		rootScope.hideStepActionDropdown();
	};

	const click_handler_2 = () => {
		rootScope.deleteStep(step, false, tour);
		rootScope.hideStepActionDropdown();
	};

	const click_handler_3 = e => rootScope.copyStep(step.step_id, step.step_type, e, tour.tour_settings.tutorial_tour_type);

	const click_handler_4 = e => {
		rootScope.guideHistory(step, e, 'step');
		rootScope.hideStepActionDropdown();
	};

	const error_handler = e => {
		e.target.src = rootScope.staticContentPath + 'technology.jpg';
	};

	function video_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			tutVideoElement = $$value;
			$$invalidate(3, tutVideoElement);
		});
	}

	const click_handler_5 = e => guideAction(e, rootScope.playSlideshow, step);
	const click_handler_6 = e => showMenuActionDropdown(step.step_id, e);
	const click_handler_7 = () => editStep(step, index);
	const click_handler_8 = () => deleteStep(step);
	const click_handler_9 = () => rootScope.editTag(step, tour, index);
	const click_handler_10 = () => rootScope.deleteTag(step, tour, index);

	const error_handler_1 = e => {
		e.target.src = rootScope.staticContentPath + 'technology.jpg';
	};

	const click_handler_11 = e => guideAction(e, '', step);

	const error_handler_2 = e => {
		e.target.src = rootScope.staticContentPath + 'technology.jpg';
	};

	const error_handler_3 = e => {
		e.target.src = rootScope.staticContentPath + 'technology.jpg';
	};

	const error_handler_4 = e => {
		e.target.src = rootScope.staticContentPath + 'technology.jpg';
	};

	const click_handler_12 = e => guideAction(e, '', step);
	const click_handler_13 = e => showMenuActionDropdown(step.step_id, e);

	const click_handler_14 = () => {
		rootScope.editStep(tour, step, index, false);
		rootScope.hideStepActionDropdown();
	};

	const click_handler_15 = () => {
		rootScope.editStep(tour, step, index, true);
		rootScope.hideStepActionDropdown();
	};

	const click_handler_16 = () => rootScope.goToStepUrl(step, index);
	const click_handler_17 = e => rootScope.copyStep(step.step_id, step.step_type, e);
	const click_handler_18 = () => rootScope.handleFindAndReplaceClick(step);

	const click_handler_19 = () => {
		rootScope.deleteStep(step, false, tour);
		rootScope.hideStepActionDropdown();
	};

	const click_handler_20 = e => {
		rootScope.guideHistory(step, e, 'step');
		rootScope.hideStepActionDropdown();
	};

	function addeditstepview_step_binding(value) {
		step = value;
		$$invalidate(0, step);
	}

	function addeditmessageview_step_binding(value) {
		step = value;
		$$invalidate(0, step);
	}

	function addeditimagestep_step_binding(value) {
		step = value;
		$$invalidate(0, step);
	}

	function addeditsmarttipview_step_binding(value) {
		step = value;
		$$invalidate(0, step);
	}

	function addeditfeaturestep_step_binding(value) {
		step = value;
		$$invalidate(0, step);
	}

	$$self.$$set = $$props => {
		if ('step' in $$props) $$invalidate(0, step = $$props.step);
		if ('index' in $$props) $$invalidate(1, index = $$props.index);
		if ('tour' in $$props) $$invalidate(2, tour = $$props.tour);
		if ('imageUploadData' in $$props) $$invalidate(13, imageUploadData = $$props.imageUploadData);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*imageUploadData, step*/ 8193) {
			{
				if (!GmCXt.isEmpty(imageUploadData) && imageUploadData[step.step_id]) {
					switch (imageUploadData[step.step_id].image_upload) {
						case 'success':
							$$invalidate(6, imageStatus = 'pass');
							break;
						case 'fail':
							$$invalidate(6, imageStatus = 'fail');
							break;
						default:
							$$invalidate(6, imageStatus = 'loading');
					}
				}
			}
		}

		if ($$self.$$.dirty[0] & /*cdn, step*/ 16385) {
			{
				if (cdn && step) {
					$$invalidate(5, imageUrl = getImageUrl(
						step.step_type === GmCXt.STEP_TYPE_VIDEO
						? step.image_url
						: step.screen_url,
						step.step_type
					));
				}
			}
		}

		if ($$self.$$.dirty[0] & /*tutVideoElement, step*/ 9) {
			{
				if (tutVideoElement) {
					$$invalidate(4, stepVideoURL = '');
					$$invalidate(4, stepVideoURL = step.step_video_url + rootScope.getCdnSign());
					tutVideoElement.load();
				}
			}
		}
	};

	return [
		step,
		index,
		tour,
		tutVideoElement,
		stepVideoURL,
		imageUrl,
		imageStatus,
		stepOperationMode,
		guideAction,
		showThumbnail,
		showTourActionMenu,
		showMenuActionDropdown,
		setActiveStep,
		imageUploadData,
		cdn,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		error_handler,
		video_binding,
		click_handler_5,
		click_handler_6,
		click_handler_7,
		click_handler_8,
		click_handler_9,
		click_handler_10,
		error_handler_1,
		click_handler_11,
		error_handler_2,
		error_handler_3,
		error_handler_4,
		click_handler_12,
		click_handler_13,
		click_handler_14,
		click_handler_15,
		click_handler_16,
		click_handler_17,
		click_handler_18,
		click_handler_19,
		click_handler_20,
		addeditstepview_step_binding,
		addeditmessageview_step_binding,
		addeditimagestep_step_binding,
		addeditsmarttipview_step_binding,
		addeditfeaturestep_step_binding
	];
}

class StepView extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$d,
			create_fragment$d,
			safe_not_equal,
			{
				step: 0,
				index: 1,
				tour: 2,
				imageUploadData: 13
			},
			add_css$2,
			[-1, -1]
		);
	}
}

/* src/components/BranchView.svelte generated by Svelte v4.2.20 */

function add_css$1(target) {
	append_styles(target, "svelte-16e1c9u", ".branch.svelte-16e1c9u{z-index:99999}");
}

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[48] = list[i];
	child_ctx[50] = i;
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[51] = list[i];
	child_ctx[50] = i;
	return child_ctx;
}

// (892:1) {#if !GmCXt.FT.creatorApp}
function create_if_block_2$7(ctx) {
	let each_1_anchor;
	let each_value = ensure_array_like(/*displayStepsData*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*displayStepsData, toggleBranchDropdown, selectedValue, OnDropDownChange, playTourFromBranchView, getImageUrl, cdn*/ 1815) {
				each_value = ensure_array_like(/*displayStepsData*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (946:4) {:else}
function create_else_block$4(ctx) {
	let wmgPlayerJSTest_8;
	let wmgPlayerJSTest_7;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let t0_value = htmlToPlaintext$1(/*step*/ ctx[48].step_title) + "";
	let t0;
	let t1;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let t2_value = htmlToPlaintext$1(/*step*/ ctx[48].step_title) + "";
	let t2;
	let t3;
	let wmgPlayerJSTest_5;
	let t4;
	let wmgPlayerJSTest_6;
	let mounted;
	let dispose;
	let if_block = /*cdn*/ ctx[0] && create_if_block_4$6(ctx);

	function click_handler_2() {
		return /*click_handler_2*/ ctx[15](/*step*/ ctx[48]);
	}

	return {
		c() {
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t2 = text(t2_value);
			t3 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			t4 = space();
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			if (if_block) if_block.c();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_guide-title mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-right mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_step-title-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_position-relative");
			attr(wmgPlayerJSTest_4, "id", "step");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_clear");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_step-image-wrapper");
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_step-item");
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_collapse mgPlayerJSTest_player-step mgPlayerJSTest_step-wrapper branchTreeHead2");
			set_style(wmgPlayerJSTest_8, "display", "block");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_8, anchor);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_3, t1);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t2);
			append(wmgPlayerJSTest_7, t3);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_7, t4);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_6);
			if (if_block) if_block.m(wmgPlayerJSTest_6, null);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_6, "click", click_handler_2);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*displayStepsData*/ 2 && t0_value !== (t0_value = htmlToPlaintext$1(/*step*/ ctx[48].step_title) + "")) set_data(t0, t0_value);
			if (dirty[0] & /*displayStepsData*/ 2 && t2_value !== (t2_value = htmlToPlaintext$1(/*step*/ ctx[48].step_title) + "")) set_data(t2, t2_value);

			if (/*cdn*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4$6(ctx);
					if_block.c();
					if_block.m(wmgPlayerJSTest_6, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_8);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (898:4) {#if step.step_type === GmCXt.STEP_TYPE_BRANCH || step.step_type === GmCXt.STEP_TYPE_ERROR_HANDLER || GmCXt.isTrue(step.step_settings && step.step_settings.inlineBranch)}
function create_if_block_3$7(ctx) {
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_5;
	let wmgPlayerJSTest_0;
	let raw0_value = rootScope.svgs.branch_head_icon + "";
	let t0;
	let wmgPlayerJSTest_1;
	let t1_value = htmlToPlaintext$1(/*step*/ ctx[48].step_title) + "";
	let t1;
	let t2;
	let button;
	let wmgPlayerJSTest_2;

	let t3_value = (/*selectedValue*/ ctx[2]
	? /*selectedValue*/ ctx[2]
	: /*step*/ ctx[48].step_settings.branch[0].branchName) + "";

	let t3;
	let t4;
	let wmgPlayerJSTest_3;
	let raw1_value = rootScope.svgs.down_arrow_icon + "";
	let t5;
	let wmgPlayerJSTest_4;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[12](/*step*/ ctx[48]);
	}

	let each_value_1 = ensure_array_like(/*step*/ ctx[48].step_settings.branch);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	}

	function click_handler_1(...args) {
		return /*click_handler_1*/ ctx[13](/*index*/ ctx[50], ...args);
	}

	return {
		c() {
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			t2 = space();
			button = element("button");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t3 = text(t3_value);
			t4 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t5 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_head-branch-icon");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_branch-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_branch-dropdown-selected-item mgPlayerJSTest_pointer-events-none");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_filter-dropdown-arrow mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between mgPlayerJSTest_pointer-events-none");
			attr(wmgPlayerJSTest_4, "id", "mgPlayerJSTest_branch-dropdown-list-wrapper-" + /*index*/ ctx[50]);
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_branch-dropdown-list-wrapper mgPlayerJSTest_branch-dropdown-list-wrapper-" + /*index*/ ctx[50] + " mgPlayerJSTest_open-down mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y" + " svelte-16e1c9u");
			attr(button, "id", "mgPlayerJSTest_branch-dropdown-wrapper-0");
			attr(button, "class", "mgPlayerJSTest_branch-dropdown-wrapper mgPlayerJSTest_position-relative mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between mgPlayerJSTest_lbl-btn");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_branch-head");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_branch-wrapper-player branchTreeHead0");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_6, anchor);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw0_value;
			append(wmgPlayerJSTest_5, t0);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t1);
			append(wmgPlayerJSTest_5, t2);
			append(wmgPlayerJSTest_5, button);
			append(button, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, t3);
			append(button, t4);
			append(button, wmgPlayerJSTest_3);
			wmgPlayerJSTest_3.innerHTML = raw1_value;
			append(button, t5);
			append(button, wmgPlayerJSTest_4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(wmgPlayerJSTest_4, null);
				}
			}

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_1, "click", click_handler),
					listen(button, "click", click_handler_1)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*displayStepsData*/ 2 && t1_value !== (t1_value = htmlToPlaintext$1(/*step*/ ctx[48].step_title) + "")) set_data(t1, t1_value);

			if (dirty[0] & /*selectedValue, displayStepsData*/ 6 && t3_value !== (t3_value = (/*selectedValue*/ ctx[2]
			? /*selectedValue*/ ctx[2]
			: /*step*/ ctx[48].step_settings.branch[0].branchName) + "")) set_data(t3, t3_value);

			if (dirty[0] & /*selectedValue, displayStepsData, OnDropDownChange*/ 1030) {
				each_value_1 = ensure_array_like(/*step*/ ctx[48].step_settings.branch);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(wmgPlayerJSTest_4, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_6);
			}

			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (963:8) {#if cdn}
function create_if_block_4$6(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	return {
		c() {
			img = element("img");
			attr(img, "class", "step-image mgPlayerJSTest_custom-image");
			if (!src_url_equal(img.src, img_src_value = /*getImageUrl*/ ctx[4](/*step*/ ctx[48]))) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);

			if (!mounted) {
				dispose = listen(img, "error", /*error_handler*/ ctx[14]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*displayStepsData*/ 2 && !src_url_equal(img.src, img_src_value = /*getImageUrl*/ ctx[4](/*step*/ ctx[48]))) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(img);
			}

			mounted = false;
			dispose();
		}
	};
}

// (930:9) {#each step.step_settings.branch as branch, index}
function create_each_block_1$2(ctx) {
	let button;
	let t0_value = /*branch*/ ctx[51].branchName + "";
	let t0;
	let t1;
	let button_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t0 = text(t0_value);
			t1 = space();

			attr(button, "class", button_class_value = "mgPlayerJSTest_branch-dropdown-list-item mgPlayerJSTest_lbl-btn mgPlayerJSTest_branch-dropdown-list-item " + (/*selectedValue*/ ctx[2] === /*step*/ ctx[48].step_settings.branch[/*index*/ ctx[50]].branchName
			? 'mgPlayerJSTest_active-item'
			: ''));

			button.value = /*index*/ ctx[50];
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t0);
			append(button, t1);

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(/*OnDropDownChange*/ ctx[10](/*step*/ ctx[48], /*index*/ ctx[50]))) /*OnDropDownChange*/ ctx[10](/*step*/ ctx[48], /*index*/ ctx[50]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*displayStepsData*/ 2 && t0_value !== (t0_value = /*branch*/ ctx[51].branchName + "")) set_data(t0, t0_value);

			if (dirty[0] & /*selectedValue, displayStepsData*/ 6 && button_class_value !== (button_class_value = "mgPlayerJSTest_branch-dropdown-list-item mgPlayerJSTest_lbl-btn mgPlayerJSTest_branch-dropdown-list-item " + (/*selectedValue*/ ctx[2] === /*step*/ ctx[48].step_settings.branch[/*index*/ ctx[50]].branchName
			? 'mgPlayerJSTest_active-item'
			: ''))) {
				attr(button, "class", button_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (893:2) {#each displayStepsData as step, index}
function create_each_block$4(ctx) {
	let wmgPlayerJSTest_;
	let show_if;
	let t;

	function select_block_type(ctx, dirty) {
		if (dirty[0] & /*displayStepsData*/ 2) show_if = null;
		if (show_if == null) show_if = !!(/*step*/ ctx[48].step_type === GmCXt.STEP_TYPE_BRANCH || /*step*/ ctx[48].step_type === GmCXt.STEP_TYPE_ERROR_HANDLER || GmCXt.isTrue(/*step*/ ctx[48].step_settings && /*step*/ ctx[48].step_settings.inlineBranch));
		if (show_if) return create_if_block_3$7;
		return create_else_block$4;
	}

	let current_block_type = select_block_type(ctx, [-1, -1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if_block.c();
			t = space();
			attr(wmgPlayerJSTest_, "class", "svelte-16e1c9u");
			toggle_class(wmgPlayerJSTest_, "branch", /*step*/ ctx[48].step_type === GmCXt.STEP_TYPE_BRANCH || GmCXt.isTrue(/*step*/ ctx[48].step_settings && /*step*/ ctx[48].step_settings.inlineBranch));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if_block.m(wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(wmgPlayerJSTest_, t);
				}
			}

			if (dirty[0] & /*displayStepsData*/ 2) {
				toggle_class(wmgPlayerJSTest_, "branch", /*step*/ ctx[48].step_type === GmCXt.STEP_TYPE_BRANCH || GmCXt.isTrue(/*step*/ ctx[48].step_settings && /*step*/ ctx[48].step_settings.inlineBranch));
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if_block.d();
		}
	};
}

// (981:0) {#if mergeActive}
function create_if_block_1$8(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = GmCXt.svgs.close + "";
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_icon-cancel-merge");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_cancel-branch-merge");
			attr(wmgPlayerJSTest_, "title", "Cancel Merge Branch");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_, "click", /*cancelMerge*/ ctx[5]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			dispose();
		}
	};
}

// (986:0) {#if GmCXt.FT.creatorApp}
function create_if_block$8(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let raw0_value = rootScope.svgs.zoomIn + "";
	let t;
	let wmgPlayerJSTest_1;
	let raw1_value = rootScope.svgs.zoomOut + "";
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "id", "mgPlayerJSTest_zoomin-branching-view");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_zoomin-branching-view mgPlayerJSTest_icons-hover-effect mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_zoomout-branching-view");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_zoomout-branching-view mgPlayerJSTest_icons-hover-effect mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_view-zoomin-zoomout");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw0_value;
			append(wmgPlayerJSTest_2, t);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			wmgPlayerJSTest_1.innerHTML = raw1_value;

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_0, "click", /*zoomInView*/ ctx[6]),
					listen(wmgPlayerJSTest_1, "click", /*zoomOutView*/ ctx[7])
				];

				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$c(ctx) {
	let wmgPlayerJSTest_;
	let t0;
	let t1;
	let if_block2_anchor;
	let if_block0 = !GmCXt.FT.creatorApp && create_if_block_2$7(ctx);
	let if_block1 = /*mergeActive*/ ctx[3] && create_if_block_1$8(ctx);
	let if_block2 = GmCXt.FT.creatorApp && create_if_block$8(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_step-view-type-branching");
			set_style(wmgPlayerJSTest_, "transform", "scale(1) translate(0px, 0px)");
			toggle_class(wmgPlayerJSTest_, "mgPlayerJSTest_no-padding", GmCXt.FT.isPlayer);
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_, null);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, if_block2_anchor, anchor);
		},
		p(ctx, dirty) {
			if (!GmCXt.FT.creatorApp) if_block0.p(ctx, dirty);

			if (/*mergeActive*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$8(ctx);
					if_block1.c();
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (GmCXt.FT.creatorApp) if_block2.p(ctx, dirty);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
				detach(t0);
				detach(t1);
				detach(if_block2_anchor);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d(detaching);
			if (if_block2) if_block2.d(detaching);
		}
	};
}

function htmlToPlaintext$1(text) {
	return text ? String(text).replace(/<[^>]+>/gm, '') : '';
}

function getScaleViewValues(zoom) {
	let position = {};

	switch (zoom) {
		case 3:
			position.scale = 0.3;
			position.transformLeft = '-90%';
			position.transformRight = '-90%';
			break;
		case 4:
			position.scale = 0.4;
			position.transformLeft = '-70%';
			position.transformRight = '-70%';
			break;
		case 5:
			position.scale = 0.5;
			position.transformLeft = '-45%';
			position.transformRight = '-45%';
			break;
		case 6:
			position.scale = 0.6;
			position.transformLeft = '-30%';
			position.transformRight = '-30%';
			break;
		case 7:
			position.scale = 0.7;
			position.transformLeft = '-20%';
			position.transformRight = '-20%';
			break;
		case 8:
			position.scale = 0.8;
			position.transformLeft = '-12%';
			position.transformRight = '-12%';
			break;
		case 9:
			position.scale = 0.9;
			position.transformLeft = '-5%';
			position.transformRight = '-5%';
			break;
		case 10:
			position.scale = 1;
			position.transformLeft = '0%';
			position.transformRight = '0%';
			break;
		case 11:
			position.scale = 1.1;
			position.transformLeft = '5%';
			position.transformRight = '5%';
			break;
		case 12:
			position.scale = 1.2;
			position.transformLeft = '9%';
			position.transformRight = '8%';
			break;
		case 13:
			position.scale = 1.3;
			position.transformLeft = '12%';
			position.transformRight = '12%';
			break;
		case 14:
			position.scale = 1.4;
			position.transformLeft = '15%';
			position.transformRight = '15%';
			break;
		case 15:
			position.scale = 1.5;
			position.transformLeft = '17%';
			position.transformRight = '17%';
			break;
	}

	return position;
}

function instance$c($$self, $$props, $$invalidate) {
	let currentTour = get_store_value(Gm.currentTour);
	let cdn = false;
	let displayStepsData = false;
	let stepsData = false;
	let stepIds = [];
	let selectedValue = false;
	let treeData;
	let branchStepProcessing = false;
	let branchingViewZoom = 10;
	let branchPopulated = false;
	let firstDropId = false;
	let mergeActive = false;
	let mergeArr = [];
	let branchHeadIds = [];
	let branches;
	let play_structure = [];

	let unSubscribe = Gm.selectedBranch.subscribe(value => {
		$$invalidate(2, selectedValue = value);
	});

	const currentTourSubscriber = Gm.currentTour.subscribe(value => {
		$$invalidate(11, currentTour = value);
	});

	function getImageUrl(step) {
		if (cdn) {
			step.screen_url = GmCXt.restoreAssetSrc(step.screen_url);

			return step.is_screen_url_processed
			? step.screen_url.split('.png')[0] + '_cropped.png' + cdn
			: step.screen_url + cdn;
		}
	}

	function getMessageStepThumbnail(step) {
		let imgUrl = rootScope.staticContentPath + 'technology.jpg';

		if (step.screen_url) {
			let domElems = step.step_settings.domElems;

			if (domElems && domElems.length > 0 && step.is_thumbnail_processed) {
				imgUrl = rootScope.getImageURL(step.screen_url, '_thumb.png');
			} else if (step.is_screen_url_processed) {
				imgUrl = rootScope.getImageURL(step.screen_url, '_cropped.png');
			} else {
				imgUrl = GmCXt.restoreAssetSrc(step.screen_url);
			}
		}

		return imgUrl;
	}

	function getNodeFromTreeData(id) {
		id = parseInt(id);

		for (let i = 0; i < treeData.length; i++) {
			if (treeData[i].id === id) {
				return treeData[i];
			}
		}
	}

	function getMatchingHead(nodeId) {
		if (treeData[nodeId].type !== 'p' && mg$.inArray(nodeId, mergeArr) === -1) {
			mergeArr.push(nodeId);
		}

		if (nodeId !== 0) {
			for (let i = 0; i < treeData[nodeId].head.length; i++) {
				getMatchingHead(treeData[nodeId].head[0]);
			}
		}
	}

	function getMatchingOthers(argument) {
		for (let i = 0; i < treeData.length; i++) {
			if (mg$.inArray(treeData[i].tail, mergeArr) > -1) {
				getMatchingHead(i);
			}
		}
	}

	let stepMergeBranchInd = false;
	let stepMergeId;

	function addMergeStep(node, stepId) {
		mergeArr = [];
		getMatchingHead(node.id);
		getMatchingOthers();
		$$invalidate(3, mergeActive = true);
		stepMergeId = stepId;

		if (node.branch && node.branch.index >= 0) {
			stepMergeBranchInd = node.branch.index;
		} else {
			stepMergeBranchInd = false;
		}

		mg$('.mgPlayerJSTest_delete-connection').css('display', 'none');
		mg$('.mgPlayerJSTest_plus-step').css('display', 'none');
		mg$('.mgPlayerJSTest_step-view-type-branching').empty();
		updateViewTree();
	}

	function mergeNodeStep(stepId, nodeId) {
		if (mg$.inArray(nodeId, mergeArr) === -1 && mergeActive) {
			stepId = stepId.toString();
			Gm.loading.set(true);
			let PS = currentTour.tour_settings.play_structure;

			for (let i = 0; i < PS.length; i++) {
				if (PS[i].id === stepMergeId && stepMergeBranchInd && PS[i].branch !== null) {
					PS[i].branch[stepMergeBranchInd].tail = stepId;
					break;
				} else if (PS[i].id === stepMergeId && PS[i].branch !== null) {
					PS[i].tail = stepId;
					break;
				}
			}

			$$invalidate(11, currentTour.tour_settings.play_structure = PS, currentTour);
			mergeArr = [];
			$$invalidate(3, mergeActive = false);
			rootScope.routeToStepContainer('updateTourWithApi', currentTour);
		} else {
			rootScope.showPopup('You cannot merge this step here.');
		}
	}

	function cancelMerge() {
		$$invalidate(3, mergeActive = false);
		mg$('.mgPlayerJSTest_delete-connection').css('display', 'block');
		mg$('.mgPlayerJSTest_plus-step').css('display', 'block');
		mg$('.mgPlayerJSTest_step-view-type-branching').empty();
		updateViewTree();
	}

	function zoomInView() {
		if (branchingViewZoom < 15) {
			branchingViewZoom++;
			let position = getScaleViewValues(branchingViewZoom);

			if (position) {
				mg$('.mgPlayerJSTest_step-view-type-branching').css({
					transform: 'scale(' + position.scale + ') translate(' + position.transformLeft + ', ' + position.transformRight + ')'
				});
			}
		}
	}

	function zoomOutView() {
		if (branchingViewZoom > 2) {
			branchingViewZoom--;
			let position = getScaleViewValues(branchingViewZoom);

			if (position) {
				mg$('.mgPlayerJSTest_step-view-type-branching').css({
					transform: 'scale(' + position.scale + ') translate(' + position.transformLeft + ', ' + position.transformRight + ')'
				});
			}
		}
	}

	function deleteConnection(nodeId, stepId, ev) {
		let tail = treeData[nodeId].tail;

		if (treeData[tail] && treeData[tail].head.length > 1) {
			mg$('.horizontalConnector' + nodeId).remove();
			treeData[nodeId].tail = null;
			let branchIndex = mg$(ev.target).closest('.mgPlayerJSTest_delete-connection').attr('branchindex');
			rootScope.getStepFromTour(stepId, currentTour);

			for (let i = 0; i < currentTour.tour_settings.play_structure.length; i++) {
				if (currentTour.tour_settings.play_structure[i].id === stepId.toString()) {
					if (branchIndex) {
						$$invalidate(11, currentTour.tour_settings.play_structure[i].branch[branchIndex].tail = null, currentTour);
					} else {
						$$invalidate(11, currentTour.tour_settings.play_structure[i].tail = null, currentTour);
					}
				}
			}

			rootScope.routeToStepContainer('updateTourWithApi', currentTour);
		}
	}

	function populateMergeBranch() {
		mg$('.mgPlayerJSTest_branch-vconnector').remove();
		mg$('.mgPlayerJSTest_branch-hconnector').remove();

		for (let i = 0; i < treeData.length; i++) {
			let node = treeData[i];

			if (node.head.length >= 2) {
				for (let j = 0; j < node.head.length; j++) {
					let headTop = mg$('.branchTreeHead' + node.id).offset().top;
					let nodeTop = mg$('.branchTreeHead' + node.head[j]).offset().top;
					let branchTop = mg$(mg$('.branchTreeHead' + node.id).parents('.mgPlayerJSTest_branch-wrapper')[0]).offset().top;
					let headLeft = mg$('.branchTreeHead' + node.id).offset().left;
					let nodeLeft = mg$('.branchTreeHead' + node.head[j]).offset().left;
					let branchLeft = mg$(mg$('.branchTreeHead' + node.id).parents('.mgPlayerJSTest_branch-wrapper')[0]).offset().left;
					let width = parseInt(nodeLeft - headLeft);
					let left = parseInt(headLeft - branchLeft);
					let top = nodeTop - branchTop;

					if (headTop < nodeTop) {
						let height = parseInt(nodeTop - headTop) + 105;
						mg$('.branchTreeHead' + node.id).before("<wmgPlayerJSTest_ class='mgPlayerJSTest_branch-vconnector' style='height:" + height + "px'></wmgPlayerJSTest_>");
					} else if (nodeTop + 120 < headTop) {
						top = nodeTop - branchTop + (headTop - nodeTop) - 75;
						let height = parseInt(headTop - nodeTop);

						if (mg$('.branchTreeHead' + node.head[j]).parent().hasClass('mgPlayerJSTest_branch-wrapper')) {
							height = height - 105;
						} else {
							height = height - 65;
						}

						mg$('.branchTreeHead' + node.head[j]).append("<wmgPlayerJSTest_ class='mgPlayerJSTest_branch-vconnector mgPlayerJSTest_branch-vconnector-right' style='height:" + height + "px'></wmgPlayerJSTest_>");
					}

					mg$(mg$('.branchTreeHead' + node.id).parents('.mgPlayerJSTest_branch-wrapper')[0]).append("<wmgPlayerJSTest_ class='mgPlayerJSTest_branch-hconnector' style='top:" + top + 'px;left:' + left + 'px;width:' + width + "px'></wmgPlayerJSTest_>");
				}
			}
		}
	}

	function getDeleteNodeClassName(nodeId) {
		if (nodeId && treeData[nodeId]) {
			if (treeData[nodeId].id === nodeId) {
				if (treeData[nodeId].head.length > 1) {
					return 'mgPlayerJSTest_allow-delete-connection';
				} else if (treeData[nodeId].branch) {
					branches = treeData[nodeId].branch;
					let numOfMergedBranch = 0;

					for (let i = 0; i < branches.length; i++) {
						if (branches[i].tail === -1) {
							numOfMergedBranch++;
						}
					}

					if (numOfMergedBranch > 1) {
						return 'mgPlayerJSTest_allow-delete-connection';
					} else {
						return 'mgPlayerJSTest_hide-delete-connection';
					}
				} else {
					return 'mgPlayerJSTest_hide-delete-connection';
				}
			}
		} else {
			return 'mgPlayerJSTest_hide-delete-connection';
		}
	}

	function appendBranch(node) {
		let targetElement = document.querySelector('.mgPlayerJSTest_step-view-type-branching');
		if (mg$.inArray(node.head[0], branchHeadIds) !== -1 && GmCXt.FT.creatorApp) targetElement = document.querySelector('.branchTreeHead' + node.head[0]);
		branchHeadIds.push(node.id);

		new Empty({
				target: targetElement,
				props: {
					node,
					mergeActive,
					currentTour,
					mergeArr,
					addMergeStep,
					mergeNodeStep,
					playTourFromBranchView
				}
			});
	}

	function appendStep(node) {
		let targetElement = document.querySelector('.mgPlayerJSTest_step-view-type-branching');

		if (mg$.inArray(node.head[0], branchHeadIds) !== -1 && GmCXt.FT.creatorApp) {
			targetElement = document.querySelector('.branchTreeHead' + node.head[0]);
			branchHeadIds.push(node.id);
		}

		let step_img = GmCXt.conf.staticContentPath + 'technology.jpg';
		let err_img = rootScope.staticContentPath + 'technology.jpg';

		if (node.step.step_screen) {
			switch (node.step.step_type) {
				case 'inline':
				case 'image':
					if (!node.step.is_screen_url_processed) {
						step_img = GmCXt.restoreAssetSrc(node.step.screen_url);
					} else {
						step_img = rootScope.getImageURL(node.step.screen_url, '_cropped.png');
					}
					break;
				case 'message':
					if (!node.step.is_screen_url_processed) {
						step_img = GmCXt.restoreAssetSrc(node.step.screen_url);
					} else {
						step_img = getMessageStepThumbnail(node.step);
					}
					break;
				case 'smartTip':
					step_img = GmCXt.restoreAssetSrc(node.step.screen_url);
					break;
				case 'guide':
					step_img = rootScope.getImageURL(node.step.screen_url, '_thumb.png');
					break;
				case 'video':
					step_img = GmCXt.restoreAssetSrc(node.step.image_url);
					break;
				case 'survey':
					if (node.step.image_url.indexOf('default_icon') !== -1) {
						step_img = rootScope.getDefaultSurveyStepIcon();
					} else {
						step_img = GmCXt.restoreAssetSrc(node.step.image_url);
					}
					break;
			}
		} else if (node.step.step_video_url && node.step.step_type === 'video') {
			step_img = GmCXt.restoreAssetSrc(node.step.image_url);
			err_img = 'https://salesuapi.blob.core.windows.net/default/video-thumb.png';
		}

		new Empty({
				target: targetElement,
				props: {
					node,
					mergeActive,
					currentTour,
					step_img,
					err_img,
					mergeArr,
					addMergeStep,
					mergeNodeStep,
					playTourFromBranchView
				}
			});
	}

	function appendPlus(node) {
		let prevNodeBranch = getNodeFromTreeData(node.head[0]);
		let targetElement = document.querySelector('.mgPlayerJSTest_step-view-type-branching');
		let branchName = node.branch && node.branch.name ? node.branch.name : '';
		let lastStepWrapper = 'step-tail-large';
		let deleteClass = getDeleteNodeClassName(node.tail);

		if (prevNodeBranch.type === 'b' && branchName) {
			mg$('#mgPlayerJSTest_branch-dropdown-list-wrapper-' + prevNodeBranch.id).append("<button class='mgPlayerJSTest_branch-dropdown-list-item mgPlayerJSTest_lbl-btn mgPlayerJSTest_branch-dropdown-list-item-" + node.id + "' value='" + node.id + "'>" + branchName + '</button>');
			if (!firstDropId && branchPopulated) firstDropId = node.id;
		}

		if (mg$.inArray(node.head[0], branchHeadIds) !== -1 && GmCXt.FT.creatorApp) {
			targetElement = document.querySelector('.branchTreeHead' + node.head[0]);
			branchHeadIds.push(node.id);
		}

		if (!node.tail) lastStepWrapper = 'step-tail-small';
		if (node.branch) lastStepWrapper = '';

		new Empty({
				target: targetElement,
				props: {
					node,
					deleteClass,
					mergeActive,
					currentTour,
					branchName,
					lastStepWrapper,
					mergeArr,
					addMergeStep,
					deleteConnection,
					playTourFromBranchView
				}
			});
	}

	function populateTreeHTML(data) {
		branchingViewZoom = 10;
		branchPopulated = false;
		treeData = data;
		firstDropId = false;

		for (let i = 0; i < treeData.length; i++) {
			let type = treeData[i].type;
			let prevNode = undefined;
			let prevPlusNodeId = treeData[i].head[0];

			if (prevPlusNodeId !== undefined && prevPlusNodeId !== null) {
				if (treeData[prevPlusNodeId].head[0] !== undefined && treeData[prevPlusNodeId].head[0] !== null) {
					let prevStepNodeId = treeData[prevPlusNodeId].head[0];
					prevNode = treeData[prevStepNodeId];
				}
			}

			treeData[i].prevNode = prevNode;

			switch (type) {
				case 's':
					appendStep(treeData[i]);
					break;
				case 'b':
					appendBranch(treeData[i]);
					branchPopulated = true;
					break;
				case 'p':
					treeData[i].prevNode = treeData[prevPlusNodeId];
					appendPlus(treeData[i]);
					break;
			}
		}

		mg$('.mgPlayerJSTest_collapse').css('display', 'none');

		setTimeout(
			function () {
				populateMergeBranch();
			},
			0
		);
	}

	function findNextNonAutomationStepInThisBranch(stepId, tour) {
		let itr = function (id) {
			let step = rootScope.getStepFromTour(id, tour);

			if (GmCXt.isAutomationStep(step)) {
				let node = rootScope.getNode(id, currentTour.tour_settings.play_structure);

				if (node && node.tail) {
					return itr(node.tail);
				} else {
					return;
				}
			}

			return step;
		};

		return itr(stepId);
	}

	function updateViewTree() {
		if (!GmCXt.FT.creatorApp) return;
		let NODE_PLUS = 'p';
		let NODE_STEP = 's';
		let NODE_BRANCH = 'b';
		let treeLineNumber = 1;
		let tree = [];
		let PS = currentTour.tour_settings.play_structure;
		let steps = currentTour.steps;
		PS = GmCXt.repairPlayStructure(PS, currentTour.steps);
		let mainStepId;

		if (PS && PS.length > 0) {
			mainStepId = PS[0].id.toString();
		} else {
			mainStepId = null;
		}

		let lastNode = null;
		let nodeId = 0;
		let numberOfBranchSteps = 0;

		if (GmCXt.FT.creatorApp) {
			for (let i = 0; i < steps.length; i++) {
				if (GmCXt.checkForBranchVariationSteps(steps[i])) numberOfBranchSteps++;
			}
		}

		function addStep(stepId, branch, head1) {
			if (!branch) branch = null;
			if (head1 === undefined) head1 = null;

			if ((stepId === null || stepId === false || stepId === -1) && treeLineNumber === 1 && !branchStepProcessing && numberOfBranchSteps === 0) {
				lastNode = addNode(NODE_PLUS, stepId, branch, head1);
				populateTreeHTML(tree);
				return;
			} else if (stepId === null || stepId === false || stepId === -1) {
				lastNode = addNode(NODE_PLUS, stepId, branch, head1);
				treeLineNumber--;
				return;
			}

			let step = JSON.parse(JSON.stringify(getStep(stepId)));

			// Add plus button for every step except first step in a guide.
			if (step && stepId !== mainStepId) {
				if (branch != null) {
					lastNode = addNode(NODE_PLUS, null, branch, head1);
				} else {
					lastNode = addNode(NODE_PLUS, null, null, head1);
				}
			}

			if (lastNode && head1 !== null) updateTail(head1, lastNode.id);

			// If step node already exists, update it's head and return
			if (GmCXt.FT.creatorApp) {
				let nodeIndex = indexOfNode(stepId);

				if (nodeIndex !== -1) {
					updateHead(nodeIndex);
					updateTail(lastNode.id, nodeIndex);

					if (treeLineNumber === 1 && !branchStepProcessing && numberOfBranchSteps === 0) {
						populateTreeHTML(tree);
					} else treeLineNumber--;

					return;
				}
			}

			if (GmCXt.checkForBranchVariationSteps(step)) {
				addBranchStep(step, rootScope.getNode(step.step_id, currentTour.tour_settings.play_structure));
			} else if (step) {
				// Add step node
				lastNode = addNode(NODE_STEP, step, branch);

				// Repeat for next step
				addStep(getTail(step.step_id), null, lastNode.id);
			}
		}

		if (mainStepId) {
			let step = findNextNonAutomationStepInThisBranch(mainStepId, currentTour);
			if (step) mainStepId = step.step_id;
		}

		if (mainStepId !== null) {
			addStep(mainStepId);
		}

		function updateHead(index) {
			let node = tree[index];
			node.head.push(lastNode.id);
		}

		function updateTail(index, nodeId) {
			if (GmCXt.FT.creatorApp || tree[index].tail === null) tree[index].tail = nodeId;
		}

		function indexOfNode(stepId) {
			let index = -1;

			for (let i = 0, j = tree.length; i < j; i++) {
				let step = tree[i].step;

				if (step && step.step_id === stepId) {
					index = i;
					break;
				}
			}

			return index;
		}

		function addNode(type, step, branch, head) {
			if (!step) step = null;
			if (!branch) branch = null;

			if (head === undefined || head === null || head.length === 0) {
				head = [];

				if (lastNode) {
					head = lastNode.id;
				} else {
					head = null;
				}
			}

			let node = {
				id: nodeId++,
				type,
				step,
				head: [head],
				tail: null,
				branch
			};

			tree[node.id] = node;
			if (head) updateTail(head, node.id);
			return node;
		}

		function getStep(id) {
			// fetch step from step id
			for (let i = 0; i < steps.length; i++) {
				if (steps[i].step_id === id) {
					return steps[i];
				}
			}
		}

		function getTail(id) {
			for (let i = 0; i < PS.length; i++) {
				if (PS[i].id === id) {
					id = PS[i].tail;
					break;
				}
			}

			let nextStep = findNextNonAutomationStepInThisBranch(id, currentTour);
			if (nextStep) return nextStep.step_id; else return null;
		}

		function addBranchStep(step, nodeBranch) {
			if (!GmCXt.FT.creatorApp) numberOfBranchSteps++;
			let branches = JSON.parse(JSON.stringify(nodeBranch.branch));
			let stepBranches = JSON.parse(JSON.stringify(step.step_settings.branch));
			let stepBranchIndex = 0;
			let branchNode = addNode(NODE_BRANCH, step);
			let stepId;
			lastNode = branchNode;

			function processBranch(branch) {
				if (branches.indexOf(branch) === branches.length - 1) {
					branchStepProcessing = false;
				}

				let nonAutoStep = findNextNonAutomationStepInThisBranch(branch.tail, currentTour);
				if (nonAutoStep) stepId = nonAutoStep.step_id; else stepId = null;

				let obj = {
					name: stepBranches[stepBranchIndex].branchName,
					index: branches.indexOf(branch).toString(),
					tail: stepId,
					head: branchNode.id,
					stepType: step.step_type
				};

				if (branch.tail !== null && branch.tail !== false && branch.tail !== -1) {
					addStep(stepId, obj, branchNode.id);
				} else {
					addStep(null, obj, branchNode.id);
				}
			}

			branchStepProcessing = true;

			if (branches) {
				for (let i = 0; i < branches.length; i++) {
					stepBranchIndex = i;

					if (branches[i]) {
						if (i > 0) {
							treeLineNumber++;
						}

						if (i === branches.length - 1) {
							numberOfBranchSteps--;
						}

						processBranch(branches[i]);
					}
				}
			}

			branchStepProcessing = false;
		}
	}

	onMount(() => {
		rootScope.checkCdnSignature().then(() => {
			$$invalidate(0, cdn = GmCXt.getCdnSign());
		});

		stepsData = currentTour.steps;
		let isBranchStepPresent = GmCXt.containBranchStep(currentTour);

		if (isBranchStepPresent && !GmCXt.FT.creatorApp) {
			sortSteps();
		} else {
			$$invalidate(1, displayStepsData = stepsData);
		}

		function sortPs(node) {
			play_structure.push(node);
			stepsData.push(rootScope.getStepFromTour(node.id, currentTour));

			if (node.tail) {
				sortPs(rootScope.getNode(node.tail, currentTour.tour_settings.play_structure));
			} else if (node.branch) {
				for (let index in node.branch) {
					sortPs(rootScope.getNode(node.branch[index].tail, currentTour.tour_settings.play_structure));
				}
			}
		}

		function sortSteps() {
			play_structure = [];
			stepsData = [];
			sortPs(currentTour.tour_settings.play_structure[0]);

			for (const item of play_structure) {
				if (item.branch && stepIds.length == 0) {
					/* Check if first step is Branch or not. */
					stepIds.push(item.id);

					stepIds.push(item.branch[0].tail);
					continue;
				} else if (item.id === stepIds[stepIds.length - 1]) {
					/*Compares last index of stepIds with current stepId to connect tails. */
					if (item.tail) stepIds.push(item.tail);

					if (item.branch) stepIds.push(item.branch[0].tail);
					continue;
				} else if (item.tail && stepIds.length == 0) {
					/* Check if first step is normal step or not.*/
					stepIds.push(item.id);

					stepIds.push(item.tail);
					continue;
				}
			}

			insertStepsData(stepIds);
		}
	});

	function insertStepsData(stepIds) {
		$$invalidate(1, displayStepsData = []);
		let stepindex = 0;

		stepsData.forEach(step => {
			if (step.step_type != 'branch') {
				step.countid = ++stepindex;
			}

			if (stepIds.includes(step.step_id)) {
				if (typeof step.step_settings === 'string') {
					step.step_settings = JSON.parse(step.step_settings);
				}

				displayStepsData.push(step);
			}
		});
	}

	function playTourFromBranchView(stepId) {
		let step = rootScope.getStepFromTour(stepId, currentTour);
		rootScope.guideAction('', step, currentTour, '', '');
	}

	const toggleBranchDropdown = function (index, event) {
		mg$('.mgPlayerJSTest_branch-dropdown-list-wrapper').slideUp(200);
		let dropdownEl = mg$('.mgPlayerJSTest_branch-dropdown-list-wrapper-' + index);

		if (dropdownEl && !dropdownEl.is(':visible')) {
			dropdownEl.slideDown(200);
		}
	};

	function OnDropDownChange(step, index) {
		let stepId = step.step_id;
		Gm.selectedBranch.set(step.step_settings.branch[index].branchName);
		const indexof = stepIds.indexOf(stepId) + 1;
		const stepLength = stepIds.length - 1;
		stepIds.splice(indexof, stepLength);
		const play_structure = currentTour.tour_settings.play_structure;

		play_structure.forEach(item => {
			if (stepIds[stepIds.length - 1] === stepId && item.id === stepId) {
				stepIds.push(item.branch[index].tail);
			} else if (stepIds[stepIds.length - 1] === item.id) {
				if (item.tail) stepIds.push(item.tail);
				if (item.branch) stepIds.push(item.branch[0].tail);
			}
		});

		insertStepsData(stepIds);
	}

	onDestroy(() => {
		unSubscribe();
		currentTourSubscriber();
		Gm.selectedBranch.set(false);
	});

	const click_handler = step => playTourFromBranchView(step.step_id);
	const click_handler_1 = (index, e) => toggleBranchDropdown(index);

	const error_handler = e => {
		e.target.src = rootScope.staticContentPath + 'technology.jpg';
	};

	const click_handler_2 = step => playTourFromBranchView(step.step_id);

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*currentTour*/ 2048) {
			{
				if (currentTour && GmCXt.FT.creatorApp && get_store_value(Gm.CurrentPage) === 'stepview') {
					GmCXt.timeout(
						function () {
							mg$('.mgPlayerJSTest_step-view-type-branching').empty();
							updateViewTree();
						},
						500
					);
				}
			}
		}
	};

	return [
		cdn,
		displayStepsData,
		selectedValue,
		mergeActive,
		getImageUrl,
		cancelMerge,
		zoomInView,
		zoomOutView,
		playTourFromBranchView,
		toggleBranchDropdown,
		OnDropDownChange,
		currentTour,
		click_handler,
		click_handler_1,
		error_handler,
		click_handler_2
	];
}

class BranchView extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$c, create_fragment$c, safe_not_equal, {}, add_css$1, [-1, -1]);
	}
}

/* src/components/StepContainer.svelte generated by Svelte v4.2.20 */

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[82] = list[i];
	child_ctx[83] = list;
	child_ctx[84] = i;
	return child_ctx;
}

function get_each_context_3$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[82] = list[i];
	child_ctx[88] = list;
	child_ctx[86] = i;
	return child_ctx;
}

function get_each_context_2$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[82] = list[i];
	child_ctx[87] = list;
	child_ctx[86] = i;
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[82] = list[i];
	child_ctx[85] = list;
	child_ctx[86] = i;
	return child_ctx;
}

// (1518:0) {#if currentTour.filteredSteps && currentTour.filteredSteps.length > 0 && currentPage !== 'copySteps'}
function create_if_block_15$1(ctx) {
	let stepmodes;
	let current;
	stepmodes = new StepModes({});

	return {
		c() {
			create_component(stepmodes.$$.fragment);
		},
		m(target, anchor) {
			mount_component(stepmodes, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(stepmodes.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(stepmodes.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(stepmodes, detaching);
		}
	};
}

// (1523:0) {#if currentPage !== 'copySteps' && !rootScope.isApiCallOn}
function create_if_block_5$5(ctx) {
	let wmgPlayerJSTest_;
	let show_if;
	let show_if_1;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_6$5, create_if_block_13$1, create_if_block_14$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty[0] & /*rootScope, currentTour*/ 9) show_if = null;
		if (dirty[0] & /*currentTour, rootScope*/ 9) show_if_1 = null;
		if (/*currentTour*/ ctx[0].filteredSteps && /*currentTour*/ ctx[0].filteredSteps.length > 0) return 0;
		if (show_if == null) show_if = !!/*rootScope*/ ctx[3].isLocked(/*currentTour*/ ctx[0]);
		if (show_if) return 1;
		if (show_if_1 == null) show_if_1 = !!!(/*currentTour*/ ctx[0]?.filteredSteps?.length > 0 || /*currentTour*/ ctx[0]?.filteredSteps?.length === 0 && /*rootScope*/ ctx[3].isLocked(/*currentTour*/ ctx[0]));
		if (show_if_1) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, [-1, -1, -1]))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block) if_block.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_category-list");
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_category-list");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(wmgPlayerJSTest_, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(wmgPlayerJSTest_, null);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};
}

// (1612:135) 
function create_if_block_14$1(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[3].svgs.noStep + "";
	let t0;
	let label;
	let t1_value = /*rootScope*/ ctx[3].labels.startYoursmartWalkthrough + "";
	let t1;
	let t2;
	let beforeafterstepdropdown;
	let current;
	beforeafterstepdropdown = new Empty({ props: { step: {} } });

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			label = element("label");
			t1 = text(t1_value);
			t2 = space();
			create_component(beforeafterstepdropdown.$$.fragment);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_no-step-created");
			attr(wmgPlayerJSTest_1, "class", "add-branching-container");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, label);
			append(label, t1);
			append(wmgPlayerJSTest_1, t2);
			mount_component(beforeafterstepdropdown, wmgPlayerJSTest_1, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*rootScope*/ 8) && raw_value !== (raw_value = /*rootScope*/ ctx[3].svgs.noStep + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if ((!current || dirty[0] & /*rootScope*/ 8) && t1_value !== (t1_value = /*rootScope*/ ctx[3].labels.startYoursmartWalkthrough + "")) set_data(t1, t1_value);
		},
		i(local) {
			if (current) return;
			transition_in(beforeafterstepdropdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(beforeafterstepdropdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			destroy_component(beforeafterstepdropdown);
		}
	};
}

// (1599:44) 
function create_if_block_13$1(ctx) {
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[3].svgs.no_guides_image + "";
	let t0;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;
	let t1_value = /*rootScope*/ ctx[3].labels.lockedTourNoStep + "";
	let t1;

	return {
		c() {
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_no-guide-image-cartoon");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_no-guide-image-wrapper");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_no-guide-msg");
			attr(wmgPlayerJSTest_2, "tabindex", "0");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_no-guide-text-wrapper");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_no-tour-message-wrapper mgPlayerJSTest_position-center");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_4, anchor);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_4, t0);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, t1);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 8 && raw_value !== (raw_value = /*rootScope*/ ctx[3].svgs.no_guides_image + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if (dirty[0] & /*rootScope*/ 8 && t1_value !== (t1_value = /*rootScope*/ ctx[3].labels.lockedTourNoStep + "")) set_data(t1, t1_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_4);
			}
		}
	};
}

// (1525:2) {#if currentTour.filteredSteps && currentTour.filteredSteps.length > 0}
function create_if_block_6$5(ctx) {
	let show_if;
	let show_if_1;
	let current_block_type_index;
	let if_block0;
	let t;
	let if_block1_anchor;
	let current;
	const if_block_creators = [create_if_block_8$4, create_if_block_10$2, create_else_block_2];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (dirty[0] & /*rootScope, currentTour*/ 9) show_if = null;
		if (dirty[0] & /*currentTour, reloadView*/ 65) show_if_1 = null;
		if (show_if == null) show_if = !!/*rootScope*/ ctx[3].showBranchView(/*currentTour*/ ctx[0]);
		if (show_if) return 0;
		if (show_if_1 == null) show_if_1 = !!(!GmCXt.isOnboarding(/*currentTour*/ ctx[0]) && !/*reloadView*/ ctx[6]);
		if (show_if_1) return 1;
		return 2;
	}

	current_block_type_index = select_block_type_1(ctx, [-1, -1, -1]);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = GmCXt.FT.creatorApp && /*currentTour*/ ctx[0].isEditMode && create_if_block_7$4(ctx);

	return {
		c() {
			if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(t.parentNode, t);
			}

			if (GmCXt.FT.creatorApp && /*currentTour*/ ctx[0].isEditMode) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_7$4(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(if_block1_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
			if (if_block1) if_block1.d(detaching);
		}
	};
}

// (1572:3) {:else}
function create_else_block_2(ctx) {
	let each_1_anchor;
	let current;
	let each_value_3 = ensure_array_like(/*currentTour*/ ctx[0].filteredSteps);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*currentTour, imageUploadData*/ 33) {
				each_value_3 = ensure_array_like(/*currentTour*/ ctx[0].filteredSteps);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_3$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (1538:60) 
function create_if_block_10$2(ctx) {
	let wmgPlayerJSTest_;
	let current;
	let each_value_2 = ensure_array_like(/*currentTour*/ ctx[0].filteredSteps);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(wmgPlayerJSTest_, "class", "step-view-type-default");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(wmgPlayerJSTest_, null);
				}
			}

			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*mouseYCoordinate, draggingItem, currentTour, draggingItemIndex, draggingItemId, distanceTopGrabbedVsPointer, hoveredItemIndex, dragSteps, imageUploadData, rootScope*/ 8404015) {
				each_value_2 = ensure_array_like(/*currentTour*/ ctx[0].filteredSteps);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_2$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(wmgPlayerJSTest_, null);
					}
				}

				group_outros();

				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (1527:3) {#if rootScope.showBranchView(currentTour)}
function create_if_block_8$4(ctx) {
	let branchview;
	let t;
	let each_1_anchor;
	let current;
	branchview = new BranchView({});
	let each_value_1 = ensure_array_like(/*currentTour*/ ctx[0].filteredSteps);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			create_component(branchview.$$.fragment);
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			mount_component(branchview, target, anchor);
			insert(target, t, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*currentTour, imageUploadData*/ 33) {
				each_value_1 = ensure_array_like(/*currentTour*/ ctx[0].filteredSteps);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(branchview.$$.fragment, local);

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out(branchview.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(each_1_anchor);
			}

			destroy_component(branchview, detaching);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (1573:4) {#each currentTour.filteredSteps as step, index}
function create_each_block_3$1(ctx) {
	let wmgPlayerJSTest_;
	let stepview;
	let updating_step;
	let t;
	let wmgPlayerJSTest_id_value;
	let current;

	function stepview_step_binding_4(value) {
		/*stepview_step_binding_4*/ ctx[32](value, /*step*/ ctx[82], /*each_value_3*/ ctx[88], /*index*/ ctx[86]);
	}

	let stepview_props = {
		index: /*index*/ ctx[86],
		tour: /*currentTour*/ ctx[0],
		imageUploadData: /*imageUploadData*/ ctx[5]
	};

	if (/*step*/ ctx[82] !== void 0) {
		stepview_props.step = /*step*/ ctx[82];
	}

	stepview = new StepView({ props: stepview_props });
	binding_callbacks.push(() => bind(stepview, 'step', stepview_step_binding_4));

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(stepview.$$.fragment);
			t = space();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_tg-view-container");
			attr(wmgPlayerJSTest_, "id", wmgPlayerJSTest_id_value = "mgPlayerJSTest_tg-view-container-" + /*step*/ ctx[82].step_id);
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(stepview, wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const stepview_changes = {};
			if (dirty[0] & /*currentTour*/ 1) stepview_changes.tour = /*currentTour*/ ctx[0];
			if (dirty[0] & /*imageUploadData*/ 32) stepview_changes.imageUploadData = /*imageUploadData*/ ctx[5];

			if (!updating_step && dirty[0] & /*currentTour*/ 1) {
				updating_step = true;
				stepview_changes.step = /*step*/ ctx[82];
				add_flush_callback(() => updating_step = false);
			}

			stepview.$set(stepview_changes);

			if (!current || dirty[0] & /*currentTour*/ 1 && wmgPlayerJSTest_id_value !== (wmgPlayerJSTest_id_value = "mgPlayerJSTest_tg-view-container-" + /*step*/ ctx[82].step_id)) {
				attr(wmgPlayerJSTest_, "id", wmgPlayerJSTest_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(stepview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(stepview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(stepview);
		}
	};
}

// (1567:6) {:else}
function create_else_block_1(ctx) {
	let stepview;
	let updating_step;
	let current;

	function stepview_step_binding_3(value) {
		/*stepview_step_binding_3*/ ctx[31](value, /*step*/ ctx[82], /*each_value_2*/ ctx[87], /*index*/ ctx[86]);
	}

	let stepview_props = {
		index: /*index*/ ctx[86],
		tour: /*currentTour*/ ctx[0],
		imageUploadData: /*imageUploadData*/ ctx[5]
	};

	if (/*step*/ ctx[82] !== void 0) {
		stepview_props.step = /*step*/ ctx[82];
	}

	stepview = new StepView({ props: stepview_props });
	binding_callbacks.push(() => bind(stepview, 'step', stepview_step_binding_3));

	return {
		c() {
			create_component(stepview.$$.fragment);
		},
		m(target, anchor) {
			mount_component(stepview, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const stepview_changes = {};
			if (dirty[0] & /*currentTour*/ 1) stepview_changes.tour = /*currentTour*/ ctx[0];
			if (dirty[0] & /*imageUploadData*/ 32) stepview_changes.imageUploadData = /*imageUploadData*/ ctx[5];

			if (!updating_step && dirty[0] & /*currentTour*/ 1) {
				updating_step = true;
				stepview_changes.step = /*step*/ ctx[82];
				add_flush_callback(() => updating_step = false);
			}

			stepview.$set(stepview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(stepview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(stepview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(stepview, detaching);
		}
	};
}

// (1565:48) 
function create_if_block_12$1(ctx) {
	let stepview;
	let updating_step;
	let current;

	function stepview_step_binding_2(value) {
		/*stepview_step_binding_2*/ ctx[30](value, /*step*/ ctx[82], /*each_value_2*/ ctx[87], /*index*/ ctx[86]);
	}

	let stepview_props = {
		index: /*index*/ ctx[86],
		tour: /*currentTour*/ ctx[0],
		imageUploadData: /*imageUploadData*/ ctx[5]
	};

	if (/*step*/ ctx[82] !== void 0) {
		stepview_props.step = /*step*/ ctx[82];
	}

	stepview = new StepView({ props: stepview_props });
	binding_callbacks.push(() => bind(stepview, 'step', stepview_step_binding_2));

	return {
		c() {
			create_component(stepview.$$.fragment);
		},
		m(target, anchor) {
			mount_component(stepview, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const stepview_changes = {};
			if (dirty[0] & /*currentTour*/ 1) stepview_changes.tour = /*currentTour*/ ctx[0];
			if (dirty[0] & /*imageUploadData*/ 32) stepview_changes.imageUploadData = /*imageUploadData*/ ctx[5];

			if (!updating_step && dirty[0] & /*currentTour*/ 1) {
				updating_step = true;
				stepview_changes.step = /*step*/ ctx[82];
				add_flush_callback(() => updating_step = false);
			}

			stepview.$set(stepview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(stepview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(stepview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(stepview, detaching);
		}
	};
}

// (1541:6) {#if !rootScope.isTrackingGuide(currentTour) && !(rootScope.user.role === 'user' || !GmCXt.FT.creatorApp || currentTour.is_published || rootScope.isLocked(currentTour) || currentTour.filteredSteps.length <= 1 || rootScope.pendingStepCount > 0 || rootScope.isDesktopApp() || rootScope.hideMirrorAppCtrl() || currentTour.isEditMode)}
function create_if_block_11$2(ctx) {
	let wmgPlayerJSTest_;
	let stepview;
	let updating_step;
	let t;
	let current;
	let mounted;
	let dispose;

	function stepview_step_binding_1(value) {
		/*stepview_step_binding_1*/ ctx[25](value, /*step*/ ctx[82], /*each_value_2*/ ctx[87], /*index*/ ctx[86]);
	}

	let stepview_props = {
		index: /*index*/ ctx[86],
		tour: /*currentTour*/ ctx[0],
		imageUploadData: /*imageUploadData*/ ctx[5]
	};

	if (/*step*/ ctx[82] !== void 0) {
		stepview_props.step = /*step*/ ctx[82];
	}

	stepview = new StepView({ props: stepview_props });
	binding_callbacks.push(() => bind(stepview, 'step', stepview_step_binding_1));

	function dragstart_handler(...args) {
		return /*dragstart_handler*/ ctx[26](/*step*/ ctx[82], /*index*/ ctx[86], ...args);
	}

	function dragover_handler(...args) {
		return /*dragover_handler*/ ctx[28](/*index*/ ctx[86], ...args);
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(stepview.$$.fragment);
			t = space();
			attr(wmgPlayerJSTest_, "draggable", "true");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(stepview, wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			current = true;

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_, "dragstart", dragstart_handler),
					listen(wmgPlayerJSTest_, "drag", /*drag_handler*/ ctx[27]),
					listen(wmgPlayerJSTest_, "dragover", dragover_handler),
					listen(wmgPlayerJSTest_, "dragend", /*dragend_handler*/ ctx[29])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const stepview_changes = {};
			if (dirty[0] & /*currentTour*/ 1) stepview_changes.tour = /*currentTour*/ ctx[0];
			if (dirty[0] & /*imageUploadData*/ 32) stepview_changes.imageUploadData = /*imageUploadData*/ ctx[5];

			if (!updating_step && dirty[0] & /*currentTour*/ 1) {
				updating_step = true;
				stepview_changes.step = /*step*/ ctx[82];
				add_flush_callback(() => updating_step = false);
			}

			stepview.$set(stepview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(stepview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(stepview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(stepview);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (1540:5) {#each currentTour.filteredSteps as step, index}
function create_each_block_2$1(ctx) {
	let show_if;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_11$2, create_if_block_12$1, create_else_block_1];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (dirty[0] & /*rootScope, currentTour*/ 9) show_if = null;
		if (show_if == null) show_if = !!(!/*rootScope*/ ctx[3].isTrackingGuide(/*currentTour*/ ctx[0]) && !(/*rootScope*/ ctx[3].user.role === 'user' || !GmCXt.FT.creatorApp || /*currentTour*/ ctx[0].is_published || /*rootScope*/ ctx[3].isLocked(/*currentTour*/ ctx[0]) || /*currentTour*/ ctx[0].filteredSteps.length <= 1 || /*rootScope*/ ctx[3].pendingStepCount > 0 || /*rootScope*/ ctx[3].isDesktopApp() || /*rootScope*/ ctx[3].hideMirrorAppCtrl() || /*currentTour*/ ctx[0].isEditMode));
		if (show_if) return 0;
		if (!/*rootScope*/ ctx[3].pendingStepCount > 0) return 1;
		return 2;
	}

	current_block_type_index = select_block_type_2(ctx, [-1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

// (1530:5) {#if (step.isEdit || step.isCreation) && currentTour.isEditMode}
function create_if_block_9$3(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let stepview;
	let updating_step;
	let t;
	let current;

	function stepview_step_binding(value) {
		/*stepview_step_binding*/ ctx[24](value, /*step*/ ctx[82], /*each_value_1*/ ctx[85], /*index*/ ctx[86]);
	}

	let stepview_props = {
		index: /*index*/ ctx[86],
		tour: /*currentTour*/ ctx[0],
		imageUploadData: /*imageUploadData*/ ctx[5]
	};

	if (/*step*/ ctx[82] !== void 0) {
		stepview_props.step = /*step*/ ctx[82];
	}

	stepview = new StepView({ props: stepview_props });
	binding_callbacks.push(() => bind(stepview, 'step', stepview_step_binding));

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			create_component(stepview.$$.fragment);
			t = space();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_captured-settings-container");
			attr(wmgPlayerJSTest_1, "class", "step-view-type-default");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			mount_component(stepview, wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_1, t);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const stepview_changes = {};
			if (dirty[0] & /*currentTour*/ 1) stepview_changes.tour = /*currentTour*/ ctx[0];
			if (dirty[0] & /*imageUploadData*/ 32) stepview_changes.imageUploadData = /*imageUploadData*/ ctx[5];

			if (!updating_step && dirty[0] & /*currentTour*/ 1) {
				updating_step = true;
				stepview_changes.step = /*step*/ ctx[82];
				add_flush_callback(() => updating_step = false);
			}

			stepview.$set(stepview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(stepview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(stepview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			destroy_component(stepview);
		}
	};
}

// (1529:4) {#each currentTour.filteredSteps as step, index}
function create_each_block_1$1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = (/*step*/ ctx[82].isEdit || /*step*/ ctx[82].isCreation) && /*currentTour*/ ctx[0].isEditMode && create_if_block_9$3(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if ((/*step*/ ctx[82].isEdit || /*step*/ ctx[82].isCreation) && /*currentTour*/ ctx[0].isEditMode) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*currentTour*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_9$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (1579:3) {#if GmCXt.FT.creatorApp && currentTour.isEditMode}
function create_if_block_7$4(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[3].labels.save + "";
	let t0;
	let wmgPlayerJSTest_0_class_value;
	let t1;
	let wmgPlayerJSTest_1;
	let t2_value = /*rootScope*/ ctx[3].labels.btnCancel + "";
	let t2;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t2 = text(t2_value);
			attr(wmgPlayerJSTest_0, "id", "mgPlayerJSTest_step-edit-save");

			attr(wmgPlayerJSTest_0, "class", wmgPlayerJSTest_0_class_value = "mgPlayerJSTest_btn-default mgPlayerJSTest_margin-lr-25 mgPlayerJSTest_disabledSaveBtn " + (/*currentTour*/ ctx[0].disableSaveButton
			? 'mgPlayerJSTest_disabled'
			: ''));

			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_step-edit-cancel");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_btn-default mgPlayerJSTest_btn-neutral mgPlayerJSTest_margin-lr-25 mgPlayerJSTest_disabledSaveBtn");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_step-edit-footer-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_2, t1);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t2);

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_0, "click", /*click_handler*/ ctx[33]),
					listen(wmgPlayerJSTest_1, "click", /*click_handler_1*/ ctx[34])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 8 && t0_value !== (t0_value = /*rootScope*/ ctx[3].labels.save + "")) set_data(t0, t0_value);

			if (dirty[0] & /*currentTour*/ 1 && wmgPlayerJSTest_0_class_value !== (wmgPlayerJSTest_0_class_value = "mgPlayerJSTest_btn-default mgPlayerJSTest_margin-lr-25 mgPlayerJSTest_disabledSaveBtn " + (/*currentTour*/ ctx[0].disableSaveButton
			? 'mgPlayerJSTest_disabled'
			: ''))) {
				attr(wmgPlayerJSTest_0, "class", wmgPlayerJSTest_0_class_value);
			}

			if (dirty[0] & /*rootScope*/ 8 && t2_value !== (t2_value = /*rootScope*/ ctx[3].labels.btnCancel + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (1622:0) {#if currentPage === 'copySteps'}
function create_if_block$7(ctx) {
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_5;
	let wmgPlayerJSTest_4;
	let label;
	let input0;
	let input0_value_value;
	let t0;
	let span;
	let label_class_value;
	let t1;
	let wmgPlayerJSTest_0;
	let t2_value = /*rootScope*/ ctx[3].labels.btnSelectAll + "";
	let t2;
	let t3;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let raw0_value = /*rootScope*/ ctx[3].svgs.search + "";
	let t4;
	let input1;
	let input1_placeholder_value;
	let t5;
	let button;
	let raw1_value = /*rootScope*/ ctx[3].svgs.search_close + "";
	let button_class_value;
	let t6;
	let t7;
	let show_if = /*setHeight*/ ctx[14]() && /*displaySteps*/ ctx[7];
	let mounted;
	let dispose;

	function select_block_type_3(ctx, dirty) {
		if (/*displaySteps*/ ctx[7] && /*showSteps*/ ctx[9].length) return create_if_block_3$6;
		return create_else_block$3;
	}

	let current_block_type = select_block_type_3(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = show_if && create_if_block_1$7(ctx);

	return {
		c() {
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			label = element("label");
			input0 = element("input");
			t0 = space();
			span = element("span");
			t1 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t2 = text(t2_value);
			t3 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t4 = space();
			input1 = element("input");
			t5 = space();
			button = element("button");
			t6 = space();
			if_block0.c();
			t7 = space();
			if (if_block1) if_block1.c();
			attr(input0, "type", "checkbox");
			attr(input0, "class", "mgPlayerJSTest_export-guide-checkbox mgPlayerJSTest_inline-block-vm mgPlayerJSTest_input-checkbox-custom");
			attr(input0, "name", "export-guide-checkbox");
			input0.__value = input0_value_value = /*rootScope*/ ctx[3].labels.btnSelectAll;
			set_input_value(input0, input0.__value);
			attr(span, "class", "mgPlayerJSTest_checkmark");
			attr(label, "class", label_class_value = "mgPlayerJSTest_checkbox-container " + (!/*displaySteps*/ ctx[7] ? 'mgPlayerJSTest_disabled' : ''));
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_margin-lr-25");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_search-icon mgPlayerJSTest_inline-block-vm");
			attr(input1, "id", "mgPlayerJSTest_search-text-input");
			attr(input1, "class", "mgPlayerJSTest_search-input mgPlayerJSTest_inline-block-vm mgPlayerJSTest_width-100 mgPlayerJSTest_height-100");
			attr(input1, "maxlength", "100");
			attr(input1, "type", "text");
			attr(input1, "placeholder", input1_placeholder_value = /*rootScope*/ ctx[3].labels.btnSearchSteps);
			attr(input1, "autocomplete", "off");
			attr(button, "id", "mgPlayerJSTest_icon-search-close");

			attr(button, "class", button_class_value = "mgPlayerJSTest_search-close-icon mgPlayerJSTest_cursor-pointer mgPlayerJSTest_inline-block-vm mgPlayerJSTest_lbl-btn " + (/*rootScope*/ ctx[3].searchStepKeyword && /*rootScope*/ ctx[3].searchStepKeyword.length
			? 'mgPlayerJSTest_active'
			: ''));

			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_search-input-wrapper mgPlayerJSTest_position-relative mgPlayerJSTest_float-left");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_search-bar-container");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_step-copy-delete-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_auto-header-bar-container");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_step-copy-delete-container");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_6, anchor);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, label);
			append(label, input0);
			input0.checked = /*selectedAll*/ ctx[8];
			append(label, t0);
			append(label, span);
			append(wmgPlayerJSTest_4, t1);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t2);
			append(wmgPlayerJSTest_4, t3);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			wmgPlayerJSTest_1.innerHTML = raw0_value;
			append(wmgPlayerJSTest_2, t4);
			append(wmgPlayerJSTest_2, input1);
			set_input_value(input1, /*rootScope*/ ctx[3].searchStepKeyword);
			append(wmgPlayerJSTest_2, t5);
			append(wmgPlayerJSTest_2, button);
			button.innerHTML = raw1_value;
			append(wmgPlayerJSTest_6, t6);
			if_block0.m(wmgPlayerJSTest_6, null);
			append(wmgPlayerJSTest_6, t7);
			if (if_block1) if_block1.m(wmgPlayerJSTest_6, null);

			if (!mounted) {
				dispose = [
					listen(input0, "change", /*input0_change_handler*/ ctx[35]),
					listen(input0, "click", /*click_handler_2*/ ctx[36]),
					listen(input1, "input", /*input1_input_handler*/ ctx[37]),
					listen(input1, "keyup", /*keyup_handler*/ ctx[38]),
					listen(button, "click", /*click_handler_3*/ ctx[39])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 8 && input0_value_value !== (input0_value_value = /*rootScope*/ ctx[3].labels.btnSelectAll)) {
				input0.__value = input0_value_value;
				set_input_value(input0, input0.__value);
			}

			if (dirty[0] & /*selectedAll*/ 256) {
				input0.checked = /*selectedAll*/ ctx[8];
			}

			if (dirty[0] & /*displaySteps*/ 128 && label_class_value !== (label_class_value = "mgPlayerJSTest_checkbox-container " + (!/*displaySteps*/ ctx[7] ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(label, "class", label_class_value);
			}

			if (dirty[0] & /*rootScope*/ 8 && t2_value !== (t2_value = /*rootScope*/ ctx[3].labels.btnSelectAll + "")) set_data(t2, t2_value);
			if (dirty[0] & /*rootScope*/ 8 && raw0_value !== (raw0_value = /*rootScope*/ ctx[3].svgs.search + "")) wmgPlayerJSTest_1.innerHTML = raw0_value;
			if (dirty[0] & /*rootScope*/ 8 && input1_placeholder_value !== (input1_placeholder_value = /*rootScope*/ ctx[3].labels.btnSearchSteps)) {
				attr(input1, "placeholder", input1_placeholder_value);
			}

			if (dirty[0] & /*rootScope*/ 8 && input1.value !== /*rootScope*/ ctx[3].searchStepKeyword) {
				set_input_value(input1, /*rootScope*/ ctx[3].searchStepKeyword);
			}

			if (dirty[0] & /*rootScope*/ 8 && raw1_value !== (raw1_value = /*rootScope*/ ctx[3].svgs.search_close + "")) button.innerHTML = raw1_value;
			if (dirty[0] & /*rootScope*/ 8 && button_class_value !== (button_class_value = "mgPlayerJSTest_search-close-icon mgPlayerJSTest_cursor-pointer mgPlayerJSTest_inline-block-vm mgPlayerJSTest_lbl-btn " + (/*rootScope*/ ctx[3].searchStepKeyword && /*rootScope*/ ctx[3].searchStepKeyword.length
			? 'mgPlayerJSTest_active'
			: ''))) {
				attr(button, "class", button_class_value);
			}

			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_6, t7);
				}
			}

			if (dirty[0] & /*displaySteps*/ 128) show_if = /*setHeight*/ ctx[14]() && /*displaySteps*/ ctx[7];

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$7(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_6, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_6);
			}

			if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (1706:2) {:else}
function create_else_block$3(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t_value = /*rootScope*/ ctx[3].labels.stepNotFound + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_no-step-found-msg");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_category-list");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 8 && t_value !== (t_value = /*rootScope*/ ctx[3].labels.stepNotFound + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}
		}
	};
}

// (1670:2) {#if displaySteps && showSteps.length}
function create_if_block_3$6(ctx) {
	let wmgPlayerJSTest_;
	let each_value = ensure_array_like(/*showSteps*/ ctx[9]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_category-list");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(wmgPlayerJSTest_, null);
				}
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*showSteps, toggleSelectAll*/ 524800) {
				each_value = ensure_array_like(/*showSteps*/ ctx[9]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(wmgPlayerJSTest_, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (1673:5) {#if !step.hide}
function create_if_block_4$5(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let label;
	let input;
	let input_value_value;
	let t0;
	let span;
	let span_class_value;
	let t1;
	let wmgPlayerJSTest_0;

	let raw_value = htmlToPlaintext(/*step*/ ctx[82].step_order + '. ' + /*step*/ ctx[82].step_title + ' ' + /*step*/ ctx[82].step_description + (/*step*/ ctx[82].step_settings.smartTip.guidanceMessage
	? /*step*/ ctx[82].step_settings.smartTip.guidanceMessage
	: /*step*/ ctx[82].step_settings.smartTip.validationMessage
		? /*step*/ ctx[82].step_settings.smartTip.validationMessage
		: '')) + "";

	let t2;
	let mounted;
	let dispose;

	function input_change_handler() {
		/*input_change_handler*/ ctx[40].call(input, /*each_value*/ ctx[83], /*step_index*/ ctx[84]);
	}

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			label = element("label");
			input = element("input");
			t0 = space();
			span = element("span");
			t1 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t2 = space();
			attr(input, "type", "checkbox");
			attr(input, "class", "mgPlayerJSTest_export-guide-checkbox mgPlayerJSTest_inline-block-vm mgPlayerJSTest_input-checkbox-custom");
			attr(input, "name", "copy-guide-checkbox");
			input.__value = input_value_value = /*step*/ ctx[82].step_id;
			set_input_value(input, input.__value);

			attr(span, "class", span_class_value = "mgPlayerJSTest_checkmark " + (/*step*/ ctx[82].step_type === 'branch'
			? 'mgPlayerJSTest_disabled'
			: ''));

			attr(label, "class", "mgPlayerJSTest_checkbox-container");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_margin-lr-25 mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_1, "class", "tour-list-copy-delete-wrapper");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_tour-item");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, label);
			append(label, input);
			input.checked = /*step*/ ctx[82].copy;
			append(label, t0);
			append(label, span);
			append(wmgPlayerJSTest_1, t1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t2);

			if (!mounted) {
				dispose = [
					listen(input, "change", input_change_handler),
					listen(input, "change", /*change_handler*/ ctx[41])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*showSteps*/ 512 && input_value_value !== (input_value_value = /*step*/ ctx[82].step_id)) {
				input.__value = input_value_value;
				set_input_value(input, input.__value);
			}

			if (dirty[0] & /*showSteps*/ 512) {
				input.checked = /*step*/ ctx[82].copy;
			}

			if (dirty[0] & /*showSteps*/ 512 && span_class_value !== (span_class_value = "mgPlayerJSTest_checkmark " + (/*step*/ ctx[82].step_type === 'branch'
			? 'mgPlayerJSTest_disabled'
			: ''))) {
				attr(span, "class", span_class_value);
			}

			if (dirty[0] & /*showSteps*/ 512 && raw_value !== (raw_value = htmlToPlaintext(/*step*/ ctx[82].step_order + '. ' + /*step*/ ctx[82].step_title + ' ' + /*step*/ ctx[82].step_description + (/*step*/ ctx[82].step_settings.smartTip.guidanceMessage
			? /*step*/ ctx[82].step_settings.smartTip.guidanceMessage
			: /*step*/ ctx[82].step_settings.smartTip.validationMessage
				? /*step*/ ctx[82].step_settings.smartTip.validationMessage
				: '')) + "")) wmgPlayerJSTest_0.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (1672:4) {#each showSteps as step}
function create_each_block$3(ctx) {
	let if_block_anchor;
	let if_block = !/*step*/ ctx[82].hide && create_if_block_4$5(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (!/*step*/ ctx[82].hide) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4$5(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (1712:2) {#if setHeight() && displaySteps}
function create_if_block_1$7(ctx) {
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[3].labels.btnCancel + "";
	let t0;
	let t1;
	let t2;
	let wmgPlayerJSTest_1;
	let t3_value = /*rootScope*/ ctx[3].labels.btnCopySteps + "";
	let t3;
	let mounted;
	let dispose;
	let if_block = !/*currentTour*/ ctx[0].is_published && create_if_block_2$6(ctx);

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t3 = text(t3_value);
			attr(wmgPlayerJSTest_0, "class", "action-btn mgPlayerJSTest_btn-default mgPlayerJSTest_btn-neutral");
			attr(wmgPlayerJSTest_1, "class", "action-btn mgPlayerJSTest_btn-default");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_auto-btn-wrapper");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_list-page-btn-wrapper mgPlayerJSTest_no-padding");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_2, t1);
			if (if_block) if_block.m(wmgPlayerJSTest_2, null);
			append(wmgPlayerJSTest_2, t2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t3);

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_0, "click", /*click_handler_4*/ ctx[42]),
					listen(wmgPlayerJSTest_1, "click", /*click_handler_6*/ ctx[44])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 8 && t0_value !== (t0_value = /*rootScope*/ ctx[3].labels.btnCancel + "")) set_data(t0, t0_value);

			if (!/*currentTour*/ ctx[0].is_published) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$6(ctx);
					if_block.c();
					if_block.m(wmgPlayerJSTest_2, t2);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*rootScope*/ 8 && t3_value !== (t3_value = /*rootScope*/ ctx[3].labels.btnCopySteps + "")) set_data(t3, t3_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}

			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (1718:5) {#if !currentTour.is_published}
function create_if_block_2$6(ctx) {
	let wmgPlayerJSTest_;
	let t_value = /*rootScope*/ ctx[3].labels.btnDeleteSteps + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "action-btn mgPlayerJSTest_btn-default mgPlayerJSTest_btn-neutral");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_, "click", /*click_handler_5*/ ctx[43]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 8 && t_value !== (t_value = /*rootScope*/ ctx[3].labels.btnDeleteSteps + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			dispose();
		}
	};
}

function create_fragment$b(ctx) {
	let t0;
	let t1;
	let if_block2_anchor;
	let current;
	let if_block0 = /*currentTour*/ ctx[0].filteredSteps && /*currentTour*/ ctx[0].filteredSteps.length > 0 && /*currentPage*/ ctx[4] !== 'copySteps' && create_if_block_15$1();
	let if_block1 = /*currentPage*/ ctx[4] !== 'copySteps' && !/*rootScope*/ ctx[3].isApiCallOn && create_if_block_5$5(ctx);
	let if_block2 = /*currentPage*/ ctx[4] === 'copySteps' && create_if_block$7(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*currentTour*/ ctx[0].filteredSteps && /*currentTour*/ ctx[0].filteredSteps.length > 0 && /*currentPage*/ ctx[4] !== 'copySteps') {
				if (if_block0) {
					if (dirty[0] & /*currentTour, currentPage*/ 17) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_15$1();
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*currentPage*/ ctx[4] !== 'copySteps' && !/*rootScope*/ ctx[3].isApiCallOn) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*currentPage, rootScope*/ 24) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_5$5(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*currentPage*/ ctx[4] === 'copySteps') {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$7(ctx);
					if_block2.c();
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(if_block2_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d(detaching);
			if (if_block2) if_block2.d(detaching);
		}
	};
}

function stepExistsInTour(steps, st) {
	let fg = false;

	steps.forEach(function (step, key) {
		if (step.step_id === st.step_id || step.creation_id === st.creation_id) {
			fg = true;
		}
	});

	return fg;
}

function getVisibleStepIndex(stepIndex, steps) {
	let newIndex = 0;
	let i = 0;

	while (stepIndex !== i && i < steps.length) {
		if (!GmCXt.isAutomationStep(steps[i])) {
			newIndex++;
		}

		i++;
	}

	return newIndex;
}

function updateStepAudioUrl(step, data) {
	step.step_audio_text = ' ';
	step.audio = GmCXt.getPathnameFromUrl(data.audio_url);
	step.step_settings = step.step_settings || {};
	step.step_settings.customAudioText = false;

	if (step.recordedBlobs && step.recordedBlobs.size > 0) {
		step.step_settings.recordedAudio = true;
		step.step_settings.uploadedAudio = false;
	} else {
		step.step_settings.uploadedAudio = true;
		step.step_settings.recordedAudio = false;
	}
}

function htmlToPlaintext(text) {
	return text ? String(text).replace(/<[^>]+>/gm, '') : '';
}

function instance$b($$self, $$props, $$invalidate) {
	let currentTour = get_store_value(Gm.currentTour);
	let originalTour = GmCXt.createDeepCopy(get_store_value(Gm.currentTour));
	let currentPage = false;
	let imageUploadData = {};
	let reloadView = false;
	let lang;
	let isTrackingGuide;
	rootScope.activeTourId;
	let displaySteps = true;
	let selectedAll = false;
	let showSteps = currentTour.steps;
	currentTour.disableSaveButton = true;
	let stepOperationMode = get_store_value(Gm.stepOperationMode);
	let activeScreenCastTourId = rootScope.activeScreenCastTourId;
	activeScreenCastTourId = activeScreenCastTourId ? activeScreenCastTourId : 0;
	rootScope.currentTour = get_store_value(Gm.currentTour);
	GmCXt.saveToDapStorage('currentTour', rootScope.currentTour);

	if (rootScope.enableTranslation) {
		if (GmCXt.getLXPLang()) {
			lang = GmCXt.getLXPLang();
		} else if (rootScope.language) {
			lang = rootScope.language;
		}
	}

	let tourModel = {
		tour_type: rootScope.currentTour && rootScope.currentTour.tour_type || ''
	};

	const currentTourSubscriber = Gm.currentTour.subscribe(value => {
		$$invalidate(0, currentTour = value);

		if (stepOperationMode === GmCXt.STEP_VIEW_OPERATION) {
			$$invalidate(3, rootScope.currentTour = currentTour, rootScope);
			GmCXt.saveToDapStorage('currentTour', rootScope.currentTour);
			originalTour = GmCXt.createDeepCopy(currentTour);
		} else if (rootScope.bulkStepCount === 0 && stepOperationMode === GmCXt.STEP_CREATE_OPERATION) {
			cancelCreation();
		} else if (currentTour.isEditMode) {
			// Reload all the steps as we need to alter variable in case of element/rule change
			$$invalidate(6, reloadView = true);

			GmCXt.timeout(
				function () {
					$$invalidate(6, reloadView = false);
				},
				100
			);
		}
	});

	const selectedLangSubscriber = Gm.selectedLang.subscribe(value => {
		if (!GmCXt.isEmpty(currentTour)) {
			$$invalidate(0, currentTour.selectedLang = value, currentTour);
			$$invalidate(0, currentTour = rootScope.getTranslatedTourAndSteps(currentTour, value));
		}
	});

	const currentPageSubscriber = Gm.CurrentPage.subscribe(value => {
		$$invalidate(4, currentPage = value);
	});

	const stepEditModeSubscriber = Gm.stepEditMode.subscribe(value => {
	});

	const stepOperationModeSubscriber = Gm.stepOperationMode.subscribe(value => {
		stepOperationMode = value;
	});

	let setHeight = function () {
		//TODO
		let guideViewHeaderPanelContainerHeight = mg$('.mgPlayerJSTest_guide-view-header-panel-container').innerHeight()
		? mg$('.mgPlayerJSTest_guide-view-header-panel-container').innerHeight()
		: 0;

		let listPageHeaderHeight = mg$('.mgPlayerJSTest_list-page-header').innerHeight()
		? mg$('.mgPlayerJSTest_list-page-header').innerHeight()
		: 0;

		let egeHeaderHeight = mg$('#mgPlayerJSTest_ege-header').innerHeight()
		? mg$('#mgPlayerJSTest_ege-header').innerHeight()
		: 0;

		let egePanelHeaderSubMenuUrlsHeight = mg$('.mgPlayerJSTest_ege-panel-header-sub-menu-urls').innerHeight()
		? mg$('.mgPlayerJSTest_ege-panel-header-sub-menu-urls').innerHeight()
		: 0;

		let footerHeight = mg$('#mgPlayerJSTest_footer-panel-container').innerHeight()
		? mg$('#mgPlayerJSTest_footer-panel-container').innerHeight()
		: 0;

		let listPageBtnHeight = mg$('.mgPlayerJSTest_list-page-btn-wrapper').innerHeight()
		? mg$('.mgPlayerJSTest_list-page-btn-wrapper').innerHeight()
		: 0;

		mg$('.mgPlayerJSTest_category-list').css({
			height: window.innerHeight - guideViewHeaderPanelContainerHeight - footerHeight - egePanelHeaderSubMenuUrlsHeight - listPageHeaderHeight - egeHeaderHeight - listPageBtnHeight - 20
		});

		if (egeHeaderHeight === 0) {
			GmCXt.timeout(
				function () {
					setHeight();
				},
				500
			);
		}

		return true;
	};

	/* set the list hight on window resize */
	mg$(window).off('resize').on('resize', setHeight);

	setTimeout(
		function () {
			setHeight();
		},
		500
	);

	const updateTourPlayStructure = function (data, callApi) {
		let stepObj = data.step;
		let playStructure = currentTour.tour_settings.play_structure;
		if (!data.prevStepData) data.prevStepData = rootScope.prevStepData;

		if (playStructure) {
			let d = GmCXt.updateTourPlayStructure(data);

			if (d) {
				$$invalidate(0, currentTour.tour_settings.play_structure = d.prevStepData.tour.tour_settings.play_structure, currentTour);
			}

			rootScope.setTour(currentTour);

			if (stepObj.step_type === 'guide' || stepObj.step_type === 'video' || GmCXt.isDefined(rootScope.copiedStep) || stepObj.step_type === 'textSlide') {
				$$invalidate(3, rootScope.pendingStepCount = 0, rootScope);
				Gm.statusBar.set('updateTourPlayStructure');
				updateTourWithApiCall(currentTour, callApi);
			} else {
				gotTour(currentTour);
			}
		} else {
			Gm.loading.set(false);
		}
	};

	const updateStepThumbUrl = function (step) {
		if (!step.is_screen_url_processed) {
			step.step_thumb = step.screen_url + rootScope.getCdnSign();
		} else if (step.step_settings.element && step.step_settings.element.version) {
			let version = GmCXt.decodeVersion(step.step_settings.element.version);

			if (GmCXt.conf.env === 'Prod' && version > 40509 || GmCXt.conf.env === 'Test' && version > 40601) {
				step.step_thumb = rootScope.getImageURL(step.screen_url, '_cropped.png');
			} else {
				step.step_thumb = rootScope.getImageURL(step.screen_url, '_thumb.png');
			}
		} else {
			step.step_thumb = rootScope.getImageURL(step.screen_url, '_thumb.png');
		}

		return step;
	};

	const createStepCompleted = function (data) {
		let stepObj = GmCXt.validateDataModel(data.step, GmCXt.model.step);
		if (stepObj.tour_id !== currentTour.tour_id) return;
		let prevStepData = data.prevStepData || null;
		let stepIndex = data.stepIndex;
		isTrackingGuide = rootScope.isTrackingGuide(currentTour);
		let allSteps = currentTour.steps;

		if (data.tour) {
			$$invalidate(0, currentTour = data.tour);
		}

		$$invalidate(0, currentTour.steps = allSteps, currentTour);

		if (data.linkGuidePlayMode && stepObj.step_type === 'guide') {
			stepObj.linkGuidePlayMode = data.linkGuidePlayMode;
		}

		if (prevStepData) {
			$$invalidate(3, rootScope.prevStepData = prevStepData, rootScope);

			if (rootScope.pendingStepCount) {
				$$invalidate(3, rootScope.prevStepData.step_id = stepObj.step_id, rootScope);
				$$invalidate(3, rootScope.prevStepData.step_type = stepObj.step_type, rootScope);
			}
		}

		if (stepObj.step_type === GmCXt.STEP_TYPE_BRANCH || stepObj.step_type === GmCXt.STEP_TYPE_ERROR_HANDLER) {
			stepObj.branch = stepObj.step_settings.branch;
		}

		if (stepObj.step_type === 'guide' || data.isPaste) {
			currentTour.steps.splice(stepIndex, 0, stepObj);
		} else if (!isTrackingGuide) {
			$$invalidate(0, currentTour.steps[stepIndex] = GmCXt.createDeepCopy(stepObj), currentTour);
		}

		if (currentTour.steps[stepIndex] && !isTrackingGuide) {
			stepObj.step_screen_temp = '';
			stepObj = updateStepThumbUrl(stepObj);

			for (let i = stepIndex; i < currentTour.steps.length; i++) {
				$$invalidate(0, currentTour.steps[i].step_order = i + 1, currentTour);
			}
		}

		$$invalidate(0, currentTour.step_count = currentTour.steps.length, currentTour);

		if (stepObj.step_type === 'guide' || data.isPaste) {
			updateTourPlayStructure(data);
		} else if (!isTrackingGuide) {
			gotTour(currentTour);
		} else if (GmCXt.isTrue(stepObj.step_settings.inlineBranch)) {
			updateTourPlayStructure(data);
		}

		Gm.loading.set(false);

		if (isTrackingGuide) {
			$$invalidate(0, currentTour = rootScope.allTourList['cat_' + currentTour.category_id]['tour_' + currentTour.tour_id]);
			currentTour.steps.push(data.step);
			$$invalidate(0, currentTour.step_count++, currentTour);
			refreshView();
		} else {
			$$invalidate(3, rootScope.prevStepData = undefined, rootScope);
			rootScope.setTour(currentTour);
		}

		if (stepObj.step_type !== GmCXt.STEP_TYPE_BRANCH && stepObj.step_type !== GmCXt.STEP_TYPE_ERROR_HANDLER) {
			$$invalidate(3, rootScope.showStepCreatedSuccessMsg = true, rootScope);
			Gm.statusBar.set('createStepCompleted');
		}
	};

	function refreshStep(data) {
		if (!GmCXt.isEmpty(data) && !GmCXt.isEmpty(data.step)) {
			let step = data.step;

			if (step.tour_id === currentTour.tour_id) {
				$$invalidate(0, currentTour.steps = [], currentTour);
				if (currentTour.is_locked) $$invalidate(0, currentTour.isLocked = true, currentTour);
				updateTourPlayStructure(data, true);
			}
		}
	}

	const createCapturedStep = function (steps) {
		if (!GmCXt.isEmpty(steps)) {
			if (!rootScope.bulkStepCount) $$invalidate(3, rootScope.bulkStepCount = steps.length, rootScope);
			$$invalidate(0, currentTour.disableSaveButton = true, currentTour);
			$$invalidate(0, currentTour.isEditMode = true, currentTour);
			$$invalidate(0, currentTour.isBranchTour = GmCXt.containBranchStep(originalTour), currentTour);

			if (rootScope.isTrackingGuide(currentTour)) {
				if (steps.elTags) {
					Gm.stepOperationMode.set(GmCXt.STEP_CREATE_OPERATION);
					$$invalidate(0, currentTour = GmCXt.createDeepCopy(originalTour));
					steps.step_id = GmCXt.getCurrentTimeInMilSec();
					steps.isCreation = true;
					currentTour.filteredSteps.push(steps);
				} else if (steps.data && steps.data.elTags) {
					Gm.stepOperationMode.set(GmCXt.STEP_EDIT_OPERATION);
					steps.isEdit = true;

					$$invalidate(
						0,
						currentTour.filteredSteps = currentTour.filteredSteps.map(function (step) {
							if (steps.data.step_id === step.step_id) {
								return steps;
							} else {
								return step;
							}
						}),
						currentTour
					);
				}

				steps.step_type = GmCXt.STEP_TYPE_TAG;
				$$invalidate(0, currentTour.isEditMode = true, currentTour);
				$$invalidate(0, currentTour.disableSaveButton = false, currentTour);

				// Reload all the steps as we need to alter variable in case of element/rule change
				$$invalidate(6, reloadView = true);

				GmCXt.timeout(
					function () {
						$$invalidate(6, reloadView = false);
					},
					100
				);
			} else if (steps.length === 1 && (steps[0].recapture || steps[0].isMessageTooltip || steps[0].isImageEdit)) {
				// For operations with page interations from adv settings or Edit step
				if (stepOperationMode === GmCXt.STEP_VIEW_OPERATION) {
					Gm.stepOperationMode.set(GmCXt.STEP_EDIT_OPERATION);
				}

				if (steps[0].element) steps[0].step_settings.element = steps[0].element;

				$$invalidate(
					0,
					currentTour.steps = currentTour.steps.map(function (step) {
						if (steps[0].step_id === step.step_id) {
							return steps[0];
						} else {
							return step;
						}
					}),
					currentTour
				);

				gotTour(currentTour);
			} else {
				// For create mode from bulk captures
				Gm.stepOperationMode.set(GmCXt.STEP_CREATE_OPERATION);

				originalTour = GmCXt.createDeepCopy(currentTour);

				steps.forEach(function (step) {
					let stepIndex = step.step_order - 1;
					$$invalidate(0, currentTour.step_count++, currentTour);
					currentTour.steps.splice(stepIndex, 0, step);
				});

				gotTour(currentTour);
			}

			GmCXt.timeout(
				() => {
					if (steps[0]) {
						rootScope.changeActiveStep(steps[0].step_id);

						if (steps[0].step_type === 'image') {
							Gm.routeAction.set({ action: 'loadImageStepView' });
						}
					}
				},
				200
			);

			mg$('#mgPlayerJSTest_add-step-bottom-btn').hide();
			GmCXt.increaseSidePanelWidth();
		} else {
			let activeStepId = get_store_value(Gm.activeStepId);
			rootScope.changeActiveStep(activeStepId);
		}
	};

	function updateImagesInSteps(data) {
		let flag = false;

		Object.keys(data).forEach(s => {
			if (data[s].image_upload === 'fail') {
				flag = true;
			}

			$$invalidate(5, imageUploadData[s] = data[s], imageUploadData);
		});

		$$invalidate(0, currentTour.disableSaveButton = flag, currentTour);
	}

	let resetCreationView = function () {
		Gm.stepOperationMode.set(GmCXt.STEP_VIEW_OPERATION);
		$$invalidate(0, currentTour.isEditMode = false, currentTour);
		originalTour.isEditMode = false;
		$$invalidate(0, currentTour.disableSaveButton = true, currentTour);
		$$invalidate(3, rootScope.bulkStepCount = 0, rootScope);
		$$invalidate(3, rootScope.section = '', rootScope);
		$$invalidate(5, imageUploadData = {});
		mg$('#mgPlayerJSTest_add-step-bottom-btn').show();
		mg$('.mgPlayerJSTest_sidepanel-screen-blackout').empty();
		document.getElementById('mgPlayerJSTest_step-creation-preview-image').innerHTML = '';
		rootScope.hidePanelOverlay();
		GmCXt.reduceSidePanelWidth();
		GmCXt.clearStepReq();
		Gm.panelAlignment.set('right');
		mg$('.mgPlayerJSTest_ege-panel').removeAttr('style');
	};

	function save() {
		let activeStepId = get_store_value(Gm.activeStepId);
		let step = currentTour.filteredSteps.find(step => step.step_id === activeStepId);
		Gm.loading.set(true);

		if (!GmCXt.isEmpty(step)) {
			if (step.isEditOnImage) {
				step.step_type = GmCXt.STEP_TYPE_INLINE;
			}
		}

		if (!GmCXt.isEmpty(step) && (step.step_type === 'image' || step.isEditOnImage)) {
			mg$(document).off('mouseover', '#mgPlayerJSTest_canvas-draw');
			mg$(document).off('mouseout', '#mgPlayerJSTest_canvas-draw');
			mg$(document).off('mouseover', '.mgPlayerJSTest_open-create-step-panel');
			mg$(document).off('click', '.mgPlayerJSTest_open-create-step-panel');
			if (GmCXt.isEmpty(step.step_title)) step.step_title = ' ';
			if (GmCXt.isEmpty(step.step_audio_text)) step.step_audio_text = ' ';
			let canvasImage = GmCXt.getCanvasImageUrl();
			step.image_orig = document.querySelector('#mgPlayerJSTest_image_canvas').toDataURL('image/png', 1);
			step.screen_url = canvasImage;

			step.highlightedArea.forEach(function (val, ind) {
				if (!GmCXt.isEmpty(step.highlightedArea[ind].title)) {
					step.highlightedArea[ind].title = GmCXt.stripAssetSrcToPathname(step.highlightedArea[ind].title);
				}
			});

			step.step_settings.highlightedArea = step.highlightedArea;
			step.step_settings.imageDimension = step.imageDimension;
			step.step_settings.version = GmCXt.conf.version;
			let refImg = get_store_value(Gm.imagePaintRef);
			let imgEditCount = -1;

			if (!GmCXt.isEmpty(refImg)) {
				imgEditCount = refImg.getImageEditCount();
			}

			if (imgEditCount && imgEditCount.length > 2) {
				let m = {
					action: 'mgPlayerJSTest_action:save_image',
					data: step
				};

				GmCXt.sendMessageToBackgroundService(m);
				return;
			}
		}

		if (step?.step_settings?.domElems && step.step_type === 'message') {
			step.step_settings.domElems.forEach(function (val, ind) {
				if (!GmCXt.isEmpty(step.step_settings.domElems[ind].title)) {
					step.step_settings.domElems[ind].title = GmCXt.stripAssetSrcToPathname(step.step_settings.domElems[ind].title);
				}
			});
		}

		if (stepOperationMode === GmCXt.STEP_CREATE_OPERATION) {
			createBulkSteps();
		} else if (stepOperationMode === GmCXt.STEP_EDIT_OPERATION) {
			saveEditedStep();
		}
	}

	function uploadAudio(step) {
		return new Promise((resolve, reject) => {
				if (step.audioUplodedFile) {
					let file = step.audioUplodedFile;

					rootScope.uploadAudioData(file, file.type, data => {
						if (data && data.audio_url) {
							updateStepAudioUrl(step, data);
							resolve(data);
						} else {
							console.error('uploadAudioFile returned invalid data:', data);
							reject(new Error('Audio upload failed or returned invalid data'));
						}
					});
				} else if (step.recordedBlobs && step.recordedBlobs.size > 0) {
					let fileName = step.step_title ? step.step_title.trim() : '';
					let file = new File([step.recordedBlobs], fileName + '.wav', { type: step.recordedBlobs.type });

					rootScope.uploadAudioData(file, step.recordedBlobs.type, data => {
						if (data && data.audio_url) {
							updateStepAudioUrl(step, data);
							resolve(data);
						} else {
							console.error('uploadAudioFile returned invalid data:', data);
							reject(new Error('Audio upload failed or returned invalid data'));
						}
					});
				} else {
					resolve();
				}
			});
	}

	async function saveEditedStep() {
		if (rootScope.isTrackingGuide(currentTour)) {
			rootScope.processFeatureSteps(currentTour, resetCreationView);
			return;
		}

		let step = currentTour.filteredSteps.find(step => step.isEdit);
		step.error = false;

		if (step.step_type !== GmCXt.STEP_TYPE_SMART_TIP && GmCXt.validateStep(step, step.step_settings.automation)) {
			Gm.loading.set(false);
			step.error = true;
		}

		if (step.step_type === GmCXt.STEP_TYPE_SMART_TIP) {
			step = rootScope.getSmartTipSettingsConfig(step);
		} else if (!step.error) {
			step = rootScope.getStepSettingsConfig(step);
		}

		if (step.error) {
			rootScope.changeActiveStep(step.step_id);
			return;
		}

		const hasAudioURL = step.step_settings?.uploadedAudio || step.step_settings?.recordedAudio;
		const hasAudioURLData = !GmCXt.isEmpty(step.uploadedPreviewAudioUrl) || !GmCXt.isEmpty(step.recordedPreviewAudioUrl);

		if (step.audioUplodedFile || step.recordedBlobs && step.recordedBlobs.size > 0) {
			await uploadAudio(step);
		} else if (hasAudioURL && hasAudioURLData) {
			step.audio = GmCXt.getPathnameFromUrl(step.step_audio);
			step.step_audio_text = ' ';
		}

		if (!GmCXt.isEmpty(imageUploadData)) {
			step.step_image = imageUploadData[step.step_id].step_image;
			step.step_screen = imageUploadData[step.step_id].step_image;
		}

		if (step && !step.error) {
			let stepObj = {
				tour_id: step.tour_id,
				step_title: step.step_title,
				step_description: GmCXt.stripAssetSrcToPathname(step.step_description),
				step_type: step.step_type,
				step_settings: step.step_settings,
				step_image: step.step_image,
				step_screen: step.step_screen,
				step_url: step.step_url,
				step_audio_text: step.step_audio_text,
				step_video_id: 0,
				step_audio: !step.audio || step.audio === '0' ? 0 : step.audio,
				step_order: step.step_order,
				step_id: step.step_id,
				category_id: currentTour.category_id,
				creation_id: GmCXt.getUUID(),
				language: step.language
			};

			let data = { stepObj };
			rootScope.updateStep(data, currentTour);
			resetCreationView();
		}
	}

	async function createBulkSteps() {
		if (currentTour.tour_type.includes('walkthrough_tour')) {
			await processWorkFlowSteps(currentTour.filteredSteps);
		} else if (currentTour.tour_type === 'smartTip') {
			await processSmartTipSteps(currentTour.filteredSteps);
		} else if (currentTour.tour_type === 'insights') {
			rootScope.processFeatureSteps(currentTour, resetCreationView);
		} else {
			console.error('Unknown step type:', currentTour.type);
		}
	}

	async function processWorkFlowSteps(steps) {
		let bulkSteps = [];
		let invalidStep = false;
		let startPointInfo = [];

		if (!GmCXt.isEmpty(currentTour.tour_settings.start_point_info)) {
			startPointInfo = GmCXt.createDeepCopy(currentTour.tour_settings.start_point_info);
		}

		let lastStep = {};

		for (let step of currentTour.filteredSteps) {
			if (step.isCreation) {
				if (GmCXt.validateStep(step, step.step_settings.automation)) {
					rootScope.changeActiveStep(step.step_id);
					invalidStep = true;
					Gm.loading.set(false);
					break;
				}

				if (step.audioUplodedFile || step.recordedBlobs && step.recordedBlobs.size > 0) {
					await uploadAudio(step);
				}

				if (step.isCreation || step.step_type === 'image' && parseInt(step.step_image) === 0) {
					step.step_image = imageUploadData[step.step_id].step_image;
					step.step_screen = imageUploadData[step.step_id].step_image;
				} else if (step.step_type === 'image' && parseInt(step.step_image) !== 0) {
					step.step_screen = step.step_image;
				}

				step = rootScope.getStepSettingsConfig(step);

				if (step.step_settings.startPoint) {
					startPointInfo.push({
						step_id: step.step_id,
						step_index: step.step_order + '',
						step_url: step.step_url
					});
				}

				lastStep = step;

				bulkSteps.push({
					category_id: currentTour.category_id,
					creation_id: GmCXt.getUUID(),
					language: rootScope.language,
					step_id: step.step_id,
					step_audio: !step.audio || step.audio === '0' ? 0 : step.audio,
					step_audio_text: step.step_audio_text,
					step_description: GmCXt.stripAssetSrcToPathname(step.step_description),
					step_image: step.step_image,
					step_order: parseInt(step.step_order),
					step_screen: step.step_screen,
					step_settings: step.step_settings,
					step_title: step.step_title,
					step_type: step.step_type,
					step_url: step.step_url,
					step_video_id: 0,
					tour_id: currentTour.tour_id,
					translation_required: '0'
				});
			}
		}

		if (!invalidStep && !GmCXt.isEmpty(bulkSteps)) {
			let pS = {};

			if (currentTour.isBranchTour || bulkSteps.length === 1 && !GmCXt.isEmpty(bulkSteps[0].step_settings.branch)) {
				let d = GmCXt.updateTourPlayStructure({
					step: lastStep,
					prevStepData: lastStep.data.prevStepData
				});

				pS = d.prevStepData.tour.tour_settings.play_structure;
			} else {
				pS = GmCXt.getGuidePlayStructure(currentTour);
			}

			$$invalidate(0, currentTour.tour_settings.play_structure = pS, currentTour);

			let data = {
				tour_id: currentTour.tour_id,
				steps: bulkSteps,
				play_structure: pS,
				start_point_info: startPointInfo,
				has_branch_step: GmCXt.containBranchStep(originalTour)
			};

			resetCreationView();

			// Call API from here
			GmCXt.sendMessageToBackgroundService({
				action: 'mgPlayerJSTest_action:to_background;task:create_bulk_step',
				data
			});
		} else if (!GmCXt.isEmpty(currentTour.tour_settings.start_point_info)) {
			startPointInfo = GmCXt.createDeepCopy(currentTour.tour_settings.start_point_info);
		}
	}

	async function processSmartTipSteps(steps) {
		let bulkSteps = [];
		let invalidStep = false;

		for (let step of currentTour.filteredSteps) {
			if (step.isCreation) {
				step = rootScope.getSmartTipSettingsConfig(step);

				if (step.error) {
					Gm.loading.set(false);
					rootScope.changeActiveStep(step.step_id);
					invalidStep = true;
					return;
				}

				step.step_image = imageUploadData[step.step_id].step_image;
				step.step_screen = imageUploadData[step.step_id].step_image;

				bulkSteps.push({
					category_id: currentTour.category_id,
					creation_id: GmCXt.getUUID(),
					language: rootScope.language,
					step_id: step.step_id,
					step_audio: !step.audio || step.audio === '0' ? 0 : step.audio,
					step_audio_text: step.step_audio_text,
					step_description: step.step_description,
					step_image: step.step_image,
					step_order: parseInt(step.step_order),
					step_screen: step.step_screen,
					step_settings: step.step_settings,
					step_title: step.step_title,
					step_type: step.step_type,
					step_url: step.step_url,
					step_video_id: 0,
					tour_id: currentTour.tour_id,
					translation_required: '0'
				});
			}
		}

		let pS = {};
		pS = GmCXt.getGuidePlayStructure(currentTour);

		if (!invalidStep && !GmCXt.isEmpty(bulkSteps)) {
			let data = {
				tour_id: currentTour.tour_id,
				steps: bulkSteps,
				play_structure: pS,
				has_branch_step: false
			};

			resetCreationView();

			// Call API from here
			GmCXt.sendMessageToBackgroundService({
				action: 'mgPlayerJSTest_action:to_background;task:create_bulk_step',
				data
			});
		}
	}

	function cancelCreation() {
		resetCreationView();
		Gm.currentTour.set(originalTour);
	}

	const createStep = function (data) {
		if (stepExistsInTour(currentTour.steps, data.stepObj)) return;
		rootScope.incrementPendingStepCount();

		if (GmCXt.checkForBranchVariationSteps(data.stepObj)) {
			Gm.loading.set(true);
		}

		let stepIndex = data.stepIndex;
		let stepObj = data.stepObj;
		stepObj.step_id = GmCXt.getCurrentTimeInMilSec();
		$$invalidate(0, currentTour.step_count++, currentTour);

		if (GmCXt.isAutomationStep(stepObj)) {
			Gm.loading.set(true);
		}

		/**
		 * Show step preview
		 * stepObj.step_screen is base64 encoded string.
		 */
		if (stepObj.step_screen && stepObj.step_screen.length > 100 || stepObj.step_type === 'guide') {
			let tempStep = GmCXt.createDeepCopy(stepObj);
			tempStep.step_screen_temp = tempStep.step_screen;
			tempStep.step_screen = '';

			if (tempStep.step_type === 'guide') {
				tempStep.step_screen_temp = rootScope.staticContentPath + 'technology.jpg';
			}

			if (!currentTour.steps) $$invalidate(0, currentTour.steps = [], currentTour);

			if (!rootScope.isTrackingGuide(currentTour)) {
				currentTour.steps.splice(stepIndex, 0, tempStep);
				gotTour(currentTour);

				for (let i = tempStep.step_order; i < currentTour.steps.length; i++) {
					$$invalidate(0, currentTour.steps[i].step_order++, currentTour);
				}
			} else {
				currentTour.filteredSteps.push(tempStep);
			}

			if (GmCXt.isTrue(stepObj.step_settings.inlineBranch)) {
				Gm.loading.set(true);
			}
		}

		setTimeout(
			function () {
				let autoSteps = mg$('.mgPlayerJSTest_step-item-auto');

				if (currentTour.filteredSteps) {
					if (stepIndex) {
						stepIndex = getVisibleStepIndex(stepIndex, currentTour.steps);
						let items = mg$('.mgPlayerJSTest_step-item');

						if (items[stepIndex]) {
							items[stepIndex].scrollIntoView();
						}
					}
				} else if (autoSteps && autoSteps[autoSteps.length - 1]) {
					autoSteps[autoSteps.length - 1].scrollIntoView();
				}
			},
			20
		);
	};

	const copyMultipleSteps = function () {
		let copiedSteps = [];

		showSteps.forEach(function (step) {
			if (step.copy) {
				copiedSteps.push(parseInt(step.step_id));
			}
		});

		$$invalidate(
			3,
			rootScope.copyStepsList = {
				steps: copiedSteps,
				tourId: currentTour.tour_id,
				tourType: currentTour.tour_type,
				stepType: currentTour.steps[0].step_type
			},
			rootScope
		);

		if (rootScope.copyStepsList.tourType.indexOf('onboarding_tour') >= 0) {
			$$invalidate(3, rootScope.copyStepsList.tourType = currentTour.tour_settings.tutorial_tour_type, rootScope);
		}

		if (rootScope.copyStepsList.steps.length) {
			$$invalidate(3, rootScope.copiedStep = false, rootScope);
			$$invalidate(3, rootScope.pasteStep = true, rootScope);
			clearAll();
		} else {
			rootScope.showPopup(GmCXt.label.unselectedStepsErrorMsg, '', 'warning');
		}
	};

	const searchStep = function () {
		let count = 0;
		$$invalidate(7, displaySteps = true);

		$$invalidate(9, showSteps = showSteps.map(function (step) {
			if (step.step_title.toLowerCase().includes(rootScope.searchStepKeyword.toLowerCase()) || step.step_description.toLowerCase().includes(rootScope.searchStepKeyword.toLowerCase())) {
				// show step
				step.hide = false;

				count += 1;
			} else {
				step.hide = true;
			}

			return step;
		}));

		if (count === 0) {
			$$invalidate(7, displaySteps = false);
		}

		toggleSelectAll();
	};

	const toggleSelectAll = function () {
		let status = true;

		for (let i in showSteps) {
			if (!showSteps[i].copy) {
				status = false;
				break;
			}
		}

		$$invalidate(8, selectedAll = status);
	};

	const clearAll = function () {
		$$invalidate(9, showSteps = showSteps.map(function (step) {
			step.copy = false;
			return step;
		}));

		$$invalidate(3, rootScope.copySteps = false, rootScope);
		$$invalidate(3, rootScope.searchStepKeyword = '', rootScope);
		$$invalidate(8, selectedAll = false);
		rootScope.setCurrentPage('stepview');

		setTimeout(
			() => {
				setHeight();
			},
			100
		);
	};

	const selectAll = function () {
		$$invalidate(9, showSteps = showSteps.map(function (step) {
			if (step.step_type !== GmCXt.STEP_TYPE_BRANCH || !step.step_settings.inlineBranch || step.step_type !== GmCXt.STEP_TYPE_ERROR_HANDLER) {
				step.copy = selectedAll ? false : true;
			}

			return step;
		}));

		$$invalidate(8, selectedAll = selectedAll ? false : true);
	};

	const deleteMultipleSteps = function () {
		let steps = [];
		let remainingSteps = [];

		showSteps.forEach(function (step) {
			if (step.copy) {
				steps.push(parseInt(step.step_id));
			} else {
				remainingSteps.push(step);
			}
		});

		let deleteStepsList = { tour_id: currentTour.tour_id };

		if (showSteps.step_count !== steps.length) {
			deleteStepsList.step_ids = '[' + steps + ']';
		}

		if (steps.length) {
			mgError.try(
				function () {
					rootScope.showPopup(
						rootScope.labels.confirmDeletMultipleSteps,
						function () {
							function onSuccess() {
								$$invalidate(3, rootScope.pasteStep = false, rootScope);

								if (!deleteStepsList.step_ids) {
									$$invalidate(0, currentTour.tour_settings.play_structure = [], currentTour);
									$$invalidate(0, currentTour.steps = [], currentTour);
									$$invalidate(0, currentTour.step_count = 0, currentTour);
								} else {
									$$invalidate(0, currentTour.is_locked = true, currentTour);
									$$invalidate(0, currentTour.steps = remainingSteps, currentTour);
									$$invalidate(0, currentTour.step_count = remainingSteps.length, currentTour);
									let playStructure = GmCXt.getGuidePlayStructure(currentTour);
									$$invalidate(0, currentTour.tour_settings.play_structure = playStructure, currentTour);
								}

								rootScope.setTour(currentTour);
								gotTour(currentTour);
							}

							Gm.loading.set(true);
							api.bulkStepDelete(deleteStepsList, onSuccess);
							clearAll();
						},
						'confirm'
					);
				},
				117
			);
		} else {
			rootScope.showPopup(GmCXt.label.unselectedStepsErrorMsg, '', 'warning');
		}
	};

	const updateTourWithApiCall = function (tour, callApi) {
		mgError.try(
			function () {
				Gm.loading.set(true);

				let data = {
					category_id: tour.category_id,
					tour_title: tour.tour_title,
					tour_description: tour.tour_description,
					tour_image: tour.tour_image,
					tour_settings: tour.tour_settings,
					tour_type: tour.tour_type,
					tour_url: tour.tour_url,
					tour_id: tour.tour_id,
					is_locked: tour.is_locked,
					keywords: tour.keywords
				};

				function onSuccess() {
					Gm.loading.set(false);
					processTours(callApi);

					if (GmCXt.isFeatureTags(tour)) {
						gotTour(tour);
					}
				} // scope.disableDoItForMe = $rootScope.checkStepsForDoItForMeMode(tour);

				function onError(response) {
					Gm.loading.set(false);
				}

				api.tourUpdate(
					data,
					function () {
						
					},
					onError,
					onSuccess
				);
			},
			121
		);
	};

	const updateStepCompleted = function (data) {
		if (data.step) {
			data.step.step_screen_temp = '';
			let stepObj = GmCXt.validateDataModel(data.step, GmCXt.model.step);
			stepObj = updateStepThumbUrl(stepObj);
			$$invalidate(0, currentTour.steps[data.stepIndex] = stepObj, currentTour);
		} else if (data.langUpdated) {
			$$invalidate(0, currentTour.steps[data.stepIndex].step_screen_temp = '', currentTour);
		}

		if (data.langUpdated) {
			$$invalidate(0, currentTour = rootScope.getTranslatedTourAndSteps(currentTour, rootScope.language));
		}

		$$invalidate(0, currentTour.is_locked = true, currentTour);
		let playStructureModified = false;
		let stepObj = currentTour.steps[data.stepIndex];

		if (stepObj.step_type === GmCXt.STEP_TYPE_BRANCH && stepObj.step_settings.branch_type !== 'Quick Branch') {
			Gm.loading.set(true);
			let node = rootScope.getNode(stepObj.step_id, currentTour.tour_settings.play_structure);
			let nodeIndex = currentTour.tour_settings.play_structure.indexOf(node);

			// If any existing branch is deleted from branch edit popup.
			$$invalidate(0, currentTour.tour_settings.play_structure[nodeIndex].branch = [], currentTour);

			for (let i = 0; i < stepObj.step_settings.branch.length; i++) {
				let obj = {};
				obj.tail = stepObj.step_settings.branch[i].tail;
				currentTour.tour_settings.play_structure[nodeIndex].branch.push(obj);
				playStructureModified = true;
			}
		}

		if (!GmCXt.isEmpty(rootScope.allTourList)) rootScope.setTour(currentTour);

		if (playStructureModified && rootScope.isGuideInOriginalLang(currentTour)) {
			updateTourWithApiCall(currentTour);
		} else {
			gotTour(currentTour);
		}

		Gm.loading.set(false);

		if (stepObj.step_type !== GmCXt.STEP_TYPE_BRANCH && stepObj.step_type !== GmCXt.STEP_TYPE_ERROR_HANDLER) {
			$$invalidate(3, rootScope.showStepUpdatedSuccessMsg = true, rootScope);
			Gm.statusBar.set('updateStepCompleted');
		}
	};

	const updateStepFailed = function () {
		processTours();
	};

	const gotTour = function (_tour) {
		if (!_tour) return;
		_tour.filteredSteps = GmCXt.filterOutAutomationSteps(_tour.steps);
		$$invalidate(0, currentTour = _tour);
		isTrackingGuide = rootScope.isTrackingGuide(_tour);

		if (isTrackingGuide) {
			$$invalidate(0, currentTour.filteredSteps = [], currentTour);
		}

		$$invalidate(0, currentTour.uuid = GmCXt.getUUID(), currentTour);

		if (currentTour.tour_id === activeScreenCastTourId && !rootScope.isScreenRecorderClose) {
			$$invalidate(0, currentTour.screencastInProgress = true, currentTour);
		} else {
			$$invalidate(0, currentTour.screencastInProgress = false, currentTour);
		}

		if (rootScope.isPublicApp) $$invalidate(0, currentTour.is_public = true, currentTour);

		if (!lang && rootScope.language) {
			lang = rootScope.language;
		}

		$$invalidate(3, rootScope.isDefaultLang = GmCXt.checkDefaultLangForTour(currentTour, lang), rootScope);
		let thereExistBranchStep = false;
		let tagGroups = [];
		let stepOrder = 0;

		if (rootScope.deletedTagsList && rootScope.deletedTagsList.length) {
			$$invalidate(
				0,
				currentTour.steps = currentTour.steps.filter(function (s) {
					return !rootScope.deletedTagsList.includes(parseInt(s.step_id));
				}),
				currentTour
			);
		}

		currentTour.steps.forEach(function (step, key) {
			if (step.step_id && typeof step.step_id !== 'string') {
				step.step_id = step.step_id.toString();
			}

			step = updateStepThumbUrl(step);

			if (typeof step.step_screen !== 'string') {
				step.step_screen = step.step_screen.toString();
			}

			if (step.step_type === 'video' && step.step_screen.indexOf('guideme-defaults/default.png') === -1) {
				step.step_video_thumbnail = step.step_video_url;
			} else if (step.step_type === GmCXt.STEP_TYPE_BRANCH || step.step_type === GmCXt.STEP_TYPE_ERROR_HANDLER || GmCXt.isTrue(step.step_settings.inlineBranch) && step.step_settings.completionEvent !== 'keepNext') {
				thereExistBranchStep = true;
				let step_settings = step.step_settings;
				step.branch = step_settings.branch;

				for (let i = 0; i < step.branch.length; i++) {
					if (step.branch[i].tourId > 0) {
						for (let j = 0; j < currentTour.steps.length; j++) {
							if (currentTour.steps[j].step_id === step.branch[i].tail) {
								$$invalidate(0, currentTour.steps[j].hideStep = true, currentTour);
								step.branch[i].tourData = currentTour.steps[j];
							}
						}
					}
				}
			}

			if (isTrackingGuide) {
				let groupId = step.step_settings.groupId;

				if (groupId) {
					if (!tagGroups[groupId]) tagGroups[groupId] = [];
					tagGroups[groupId].push(step);
				} else {
					currentTour.filteredSteps.push(step);
				}

				stepOrder = Math.max(stepOrder, step.step_order);
			}
		});

		if (thereExistBranchStep) {
			rootScope.branchGuideDownloadOpts(currentTour.tour_settings.downloadGuideFiles);
		}

		$$invalidate(0, currentTour.downloadOpts = currentTour.tour_settings.downloadGuideFiles, currentTour);

		// $scope.hideDownload = GmCXt.isFalseObj(currentTour.downloadOpts);
		if (currentTour.tour_type === 'insights') {
			let groups = Object.keys(tagGroups);

			groups.forEach(function (gId) {
				let g = tagGroups[gId];

				let group = {
					step_id: gId,
					steps: g,
					image_url: g[0].thumbnail_url,
					step_title: g[0].step_settings.groupTitle,
					step_type: 'tag',
					stepOrder: ++stepOrder
				};

				currentTour.filteredSteps.push(group);
			});
		}

		if (!isTrackingGuide) {
			$$invalidate(0, currentTour = GmCXt.checkAndCorrectPS(currentTour));
		}

		if (GmCXt.isOnboarding(currentTour)) ;

		if (lang && !rootScope.isGuideInOriginalLang(currentTour)) {
			$$invalidate(0, currentTour.selectedLang = lang, currentTour);
			let languageData = currentTour.language_data;

			if (languageData && languageData[lang]) {
				$$invalidate(0, currentTour = rootScope.getTranslatedTourAndSteps(currentTour, lang));
			}
		}

		// if (
		//   rootScope.isDesktopGuide(currentTour) ||
		//   rootScope.isMobileGuide(currentTour) ||
		//   currentTour.tour_type.indexOf("onboarding_tour") > -1
		// ) {
		//   $scope.stepPlayString = rootScope.labels.showMe;
		// } else {
		//   $scope.stepPlayString = rootScope.labels.guideMe;
		// }
		//Set height to category-list element to properly apply slider
		setTimeout(
			function () {
				setHeight();
			},
			200
		);

		Gm.currentTour.set(currentTour);

		// $scope.scrollToStep();
		$$invalidate(3, rootScope.isApiCallOn = false, rootScope);

		Gm.loading.set(false);

		if (rootScope.showStepCreatedSuccessMsg) {
			Gm.statusBar.set('createBulkStepCompleted');
		}

		// rootScope.focusAccessibilityBtn();
		GmCXt.sendMessageToBackgroundService({ action: 'mgPlayerJSTest_action:load_step_previews' });
	};

	const processTours = function (callApi) {
		function errorCb() {
			Gm.loading.set(false);
			$$invalidate(0, currentTour = false);
		}

		Gm.loading.set(true);

		if (!(currentTour && currentTour.tour_id)) {
			$$invalidate(0, currentTour = GmCXt.validateDataModel(tourModel, GmCXt.model.guide));
		}

		$$invalidate(3, rootScope.isDefaultLang = GmCXt.checkDefaultLangForTour(currentTour, lang), rootScope);
		if (currentTour.is_locked) ;

		// showAddStep("#tour-add-dropdown-" + currentTour.tour_id);
		let params = {
			tour_id: currentTour.tour_id,
			isPublic: false,
			category_id: rootScope?.currentTour.category_id
		};

		if (!GmCXt.checkDefaultLangForTour(currentTour, lang)) params.language = lang;

		if (stepOperationMode === GmCXt.STEP_VIEW_OPERATION && (callApi || GmCXt.isEmpty(currentTour) || parseInt(currentTour.step_count) !== currentTour.steps.length)) {
			api.getTour(params, gotTour, errorCb, true);
		} else {
			gotTour(currentTour);
		}
	};

	const refreshView = function (callApi) {
		Gm.loading.set(true);

		// $scope.settings = GmCXt.getOrgSettings(rootScopeisPublicApp);
		processTours(callApi);
	}; // rootScopetoggleGuideViewFullScreen();

	if (rootScope.isScreenRecorderClose) {
		rootScope.showPopup(
			rootScope.labels.screeRecordingError,
			function () {
				GmCXt.storage().remove(['screen_recorder_close']);
				$$invalidate(3, rootScope.isScreenRecorderClose = false, rootScope);
			},
			'alert'
		);
	}

	let dragSteps = function (steps) {
		mgError.try(
			function () {
				function correctStepOrderByIncludingAutomationSteps(sortedSteps, originalSteps) {
					let finalStepOrder = [];
					let index = 0;

					let push = function (step) {
						finalStepOrder.push({
							step_id: step.step_id,
							step_order: ++index
						});
					};

					let pushAllBeginningAutomationSteps = function () {
						for (let i = 0; i < originalSteps.length; i++) {
							if (!GmCXt.isAutomationStep(originalSteps[i])) {
								break;
							} else {
								push(originalSteps[i]);
							}
						}
					};

					// For guide level Automation steps
					pushAllBeginningAutomationSteps();

					sortedSteps.forEach(function (step, i) {
						push(step);

						let currentStep = originalSteps.find(function (st) {
							return st.step_id === step.step_id;
						});

						let autoStepsAfterThisStep = rootScope.getAutomationSteps(originalSteps, currentStep);

						if (autoStepsAfterThisStep.length > 0) {
							autoStepsAfterThisStep.forEach(function (autoStep) {
								push(autoStep);
							});
						}
					});

					return finalStepOrder;
				}

				function onFail(data) {
					rootScope.showPopup(data.message);
				}

				function onSuccess(data) {
					$$invalidate(0, currentTour.tour_settings.play_structure = GmCXt.buildGuidePlayStructure(currentTour), currentTour);
					updateTourWithApiCall(currentTour);
				}

				if (!currentTour.is_published && rootScope.user.role !== 'user' && (!currentTour.is_locked || currentTour.user_id === rootScope.user.user_id)) {
					let sortedSteps = [];

					// steps.splice($index, 1);
					steps.filter(function (el, index) {
						sortedSteps.push({
							step_id: el.step_id,
							step_order: index + 1
						});
					});

					sortedSteps = correctStepOrderByIncludingAutomationSteps(sortedSteps, currentTour.steps);
					$$invalidate(0, currentTour.steps = rootScope.sortTourSteps(sortedSteps, currentTour.steps), currentTour);

					let data = {
						tour_id: currentTour.tour_id,
						json: sortedSteps
					};

					api.stepsDrag(data, onSuccess, onFail);
				}
			},
			120
		);
	};

	let mouseYCoordinate = null; // pointer y coordinate within client
	let distanceTopGrabbedVsPointer = null;
	let draggingItem = null;
	let draggingItemId = null;
	let draggingItemIndex = null;
	let hoveredItemIndex = null;

	onMount(() => {
		refreshView();

		if (GmCXt.isPlayer()) {
			rootScope.bindPlayerTheme();
		}
	});

	const routeActionSubscriber = Gm.routeAction.subscribe(value => {
		if (value && value.data) {
			switch (value.action) {
				case 'createStepCompleted':
					createStepCompleted(value.data);
					Gm.routeAction.set(null);
					break;
				case 'updateStepCompleted':
					updateStepCompleted(value.data);
					Gm.routeAction.set(null);
					break;
				case 'updateStepFailed':
					updateStepFailed(value.data);
					Gm.routeAction.set(null);
					break;
				case 'updateTourWithApi':
					updateTourWithApiCall(value.data);
					Gm.routeAction.set(null);
					break;
				case 'createStepPreview':
					createStep(value.data);
					Gm.routeAction.set(null);
					break;
				case 'refreshStep':
					refreshStep(value.data);
					Gm.routeAction.set(null);
					break;
				case 'refreshView':
					refreshView(value.data);
					Gm.routeAction.set(null);
					break;
				case 'mgPlayerJSTest_action:create_bulk_step_failed':
					rootScope.showPopup(
						value.data[0],
						function () {
							refreshView(true);
						},
						'error'
					);
					Gm.loading.set(false);
					Gm.routeAction.set(null);
					break;
				case 'mgPlayerJSTest_action:capture_step_completed,type:inline':
				case 'mgPlayerJSTest_action:capture_step_completed,type:message':
				case 'mgPlayerJSTest_action:capture_step_completed,type:tag':
					createCapturedStep(value.data);
					Gm.routeAction.set(null);
					break;
				case 'mgPlayerJSTest_action:capture_step_image_upload_completed,type:inline':
					updateImagesInSteps(value.data);
					Gm.routeAction.set(null);
					break;
				case 'mgPlayerJSTest_action:capture_step_image_upload_completed,type:message':
					updateImagesInSteps(value.data);
					Gm.routeAction.set(null);
					break;
				case 'mgPlayerJSTest_action:open_image_step_editor_view':
					createCapturedStep([value.data]);
					Gm.routeAction.set(null);
					break;
				case 'mgPlayerJSTest_action:capture_step_image_upload_completed,type:image':
					$$invalidate(5, imageUploadData[value.data.step_id] = value.data, imageUploadData);
					$$invalidate(0, currentTour.disableSaveButton = false, currentTour);
					Gm.routeAction.set(null);
					break;
				case 'reset_step_creation_panel':
					if (value.data && value.data.data && value.data.data.isCancel) {
						Gm.loading.set(false);
					}
					resetCreationView();
					Gm.routeAction.set(null);
					break;
				case 'mgPlayerJSTest_action:update_capture_image_src':
					let refImg = get_store_value(Gm.imagePaintRef);
					if (refImg) {
						refImg.onChangeCaptureImageURL();
					}
					Gm.routeAction.set(null);
					break;
				case 'save_image_done':
					const sindex = currentTour.filteredSteps.findIndex(s => s.step_id === value.data.step_id);
					value.data.stepIndex = sindex;
					let step = value.data;
					$$invalidate(0, currentTour.filteredSteps[sindex] = step, currentTour);
					$$invalidate(5, imageUploadData[step.step_id] = step, imageUploadData);
					if (stepOperationMode === GmCXt.STEP_CREATE_OPERATION) {
						createBulkSteps();
					} else if (stepOperationMode === GmCXt.STEP_EDIT_OPERATION) {
						saveEditedStep();
					}
					Gm.routeAction.set(null);
					break;
			}
		} // Clear the action so it doesn't trigger again
	});

	onDestroy(() => {
		currentTourSubscriber();
		currentPageSubscriber();
		selectedLangSubscriber();
		routeActionSubscriber();
		stepEditModeSubscriber();
		stepOperationModeSubscriber();
	});

	function stepview_step_binding(value, step, each_value_1, index) {
		each_value_1[index] = value;
		(($$invalidate(0, currentTour), $$invalidate(1, draggingItemIndex)), $$invalidate(2, hoveredItemIndex));
	}

	function stepview_step_binding_1(value, step, each_value_2, index) {
		each_value_2[index] = value;
		(($$invalidate(0, currentTour), $$invalidate(1, draggingItemIndex)), $$invalidate(2, hoveredItemIndex));
	}

	const dragstart_handler = (step, index, e) => {
		$$invalidate(10, mouseYCoordinate = e.clientY);
		$$invalidate(12, draggingItem = step);
		$$invalidate(1, draggingItemIndex = index);
		$$invalidate(13, draggingItemId = step.step_id);
		$$invalidate(11, distanceTopGrabbedVsPointer = e.target.getBoundingClientRect().y - e.clientY);
	};

	const drag_handler = e => {
		$$invalidate(10, mouseYCoordinate = e.clientY);
	};

	const dragover_handler = (index, e) => {
		$$invalidate(2, hoveredItemIndex = index);
	};

	const dragend_handler = e => {
		dragSteps(currentTour.filteredSteps);
		$$invalidate(13, draggingItemId = null); // makes item visible
		$$invalidate(2, hoveredItemIndex = null); // prevents instant swap
	};

	function stepview_step_binding_2(value, step, each_value_2, index) {
		each_value_2[index] = value;
		(($$invalidate(0, currentTour), $$invalidate(1, draggingItemIndex)), $$invalidate(2, hoveredItemIndex));
	}

	function stepview_step_binding_3(value, step, each_value_2, index) {
		each_value_2[index] = value;
		(($$invalidate(0, currentTour), $$invalidate(1, draggingItemIndex)), $$invalidate(2, hoveredItemIndex));
	}

	function stepview_step_binding_4(value, step, each_value_3, index) {
		each_value_3[index] = value;
		(($$invalidate(0, currentTour), $$invalidate(1, draggingItemIndex)), $$invalidate(2, hoveredItemIndex));
	}

	const click_handler = () => save();
	const click_handler_1 = () => cancelCreation();

	function input0_change_handler() {
		selectedAll = this.checked;
		$$invalidate(8, selectedAll);
	}

	const click_handler_2 = () => selectAll();

	function input1_input_handler() {
		rootScope.searchStepKeyword = this.value;
		$$invalidate(3, rootScope);
	}

	const keyup_handler = () => searchStep();
	const click_handler_3 = () => clearSearch();

	function input_change_handler(each_value, step_index) {
		each_value[step_index].copy = this.checked;
		((($$invalidate(9, showSteps), $$invalidate(0, currentTour)), $$invalidate(1, draggingItemIndex)), $$invalidate(2, hoveredItemIndex));
	}

	const change_handler = () => toggleSelectAll();
	const click_handler_4 = () => clearAll();
	const click_handler_5 = () => deleteMultipleSteps();
	const click_handler_6 = () => copyMultipleSteps();

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*draggingItemIndex, hoveredItemIndex, currentTour*/ 7) {
			{
				if (draggingItemIndex != null && hoveredItemIndex != null && draggingItemIndex != hoveredItemIndex) {
					// swap items
					$$invalidate(
						0,
						[
							currentTour.filteredSteps[draggingItemIndex],
							currentTour.filteredSteps[hoveredItemIndex]
						] = [
							currentTour.filteredSteps[hoveredItemIndex],
							currentTour.filteredSteps[draggingItemIndex]
						],
						currentTour
					);

					// balance
					$$invalidate(1, draggingItemIndex = hoveredItemIndex);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*currentTour*/ 1) {
			{
				if (currentTour) {
					$$invalidate(9, showSteps = currentTour.steps);
				}
			}
		}
	};

	return [
		currentTour,
		draggingItemIndex,
		hoveredItemIndex,
		rootScope,
		currentPage,
		imageUploadData,
		reloadView,
		displaySteps,
		selectedAll,
		showSteps,
		mouseYCoordinate,
		distanceTopGrabbedVsPointer,
		draggingItem,
		draggingItemId,
		setHeight,
		save,
		cancelCreation,
		copyMultipleSteps,
		searchStep,
		toggleSelectAll,
		clearAll,
		selectAll,
		deleteMultipleSteps,
		dragSteps,
		stepview_step_binding,
		stepview_step_binding_1,
		dragstart_handler,
		drag_handler,
		dragover_handler,
		dragend_handler,
		stepview_step_binding_2,
		stepview_step_binding_3,
		stepview_step_binding_4,
		click_handler,
		click_handler_1,
		input0_change_handler,
		click_handler_2,
		input1_input_handler,
		keyup_handler,
		click_handler_3,
		input_change_handler,
		change_handler,
		click_handler_4,
		click_handler_5,
		click_handler_6
	];
}

class StepContainer extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$b, create_fragment$b, safe_not_equal, {}, null, [-1, -1, -1]);
	}
}

/* src/components/StepHeader.svelte generated by Svelte v4.2.20 */

function create_if_block_9$2(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t_value = /*currentTour*/ ctx[1]?.tour_description + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tooltip-tour-desc");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-right");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t);
		},
		p(ctx, dirty) {
			if (dirty & /*currentTour*/ 2 && t_value !== (t_value = /*currentTour*/ ctx[1]?.tour_description + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}
		}
	};
}

// (118:2) {#if GmCXt.FT.creatorApp}
function create_if_block_3$5(ctx) {
	let show_if_3 = /*rootScope*/ ctx[0].showPublishBtn(/*currentTour*/ ctx[1]) && !/*rootScope*/ ctx[0].isDesktopApp() && !/*rootScope*/ ctx[0].hideMirrorAppCtrl();
	let t0;
	let show_if_2 = /*rootScope*/ ctx[0].showSchedulePublish(/*currentTour*/ ctx[1]) && !/*rootScope*/ ctx[0].isDesktopApp() && !/*rootScope*/ ctx[0].hideMirrorAppCtrl();
	let t1;
	let show_if_1 = GmCXt.FT.publish && /*currentTour*/ ctx[1].is_published && /*rootScope*/ ctx[0].isOwnerOrAppAdmin() && !/*rootScope*/ ctx[0].isDesktopApp() && !/*rootScope*/ ctx[0].hideMirrorAppCtrl() && /*rootScope*/ ctx[0].showUnpublish(/*currentTour*/ ctx[1]);
	let t2;
	let show_if = GmCXt.containBranchStep(/*currentTour*/ ctx[1]) && GmCXt.FT.creatorApp;
	let if_block3_anchor;
	let if_block0 = show_if_3 && create_if_block_8$3(ctx);
	let if_block1 = show_if_2 && create_if_block_7$3(ctx);
	let if_block2 = show_if_1 && create_if_block_6$4(ctx);
	let if_block3 = show_if && create_if_block_4$4(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			if_block3_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t2, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert(target, if_block3_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope, currentTour*/ 3) show_if_3 = /*rootScope*/ ctx[0].showPublishBtn(/*currentTour*/ ctx[1]) && !/*rootScope*/ ctx[0].isDesktopApp() && !/*rootScope*/ ctx[0].hideMirrorAppCtrl();

			if (show_if_3) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_8$3(ctx);
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*rootScope, currentTour*/ 3) show_if_2 = /*rootScope*/ ctx[0].showSchedulePublish(/*currentTour*/ ctx[1]) && !/*rootScope*/ ctx[0].isDesktopApp() && !/*rootScope*/ ctx[0].hideMirrorAppCtrl();

			if (show_if_2) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_7$3(ctx);
					if_block1.c();
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*currentTour, rootScope*/ 3) show_if_1 = GmCXt.FT.publish && /*currentTour*/ ctx[1].is_published && /*rootScope*/ ctx[0].isOwnerOrAppAdmin() && !/*rootScope*/ ctx[0].isDesktopApp() && !/*rootScope*/ ctx[0].hideMirrorAppCtrl() && /*rootScope*/ ctx[0].showUnpublish(/*currentTour*/ ctx[1]);

			if (show_if_1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_6$4(ctx);
					if_block2.c();
					if_block2.m(t2.parentNode, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*currentTour*/ 2) show_if = GmCXt.containBranchStep(/*currentTour*/ ctx[1]) && GmCXt.FT.creatorApp;

			if (show_if) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_4$4(ctx);
					if_block3.c();
					if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(t2);
				detach(if_block3_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d(detaching);
			if (if_block2) if_block2.d(detaching);
			if (if_block3) if_block3.d(detaching);
		}
	};
}

// (119:3) {#if rootScope.showPublishBtn(currentTour) && !rootScope.isDesktopApp() && !rootScope.hideMirrorAppCtrl()}
function create_if_block_8$3(ctx) {
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;
	let button;
	let raw_value = /*rootScope*/ ctx[0].svgs.publish + "";
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t1_value = /*rootScope*/ ctx[0].labels.publish + "";
	let t1;
	let wmgPlayerJSTest_3_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_ege-inline-block-vt");
			attr(button, "aria-label", "publish");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_status-publish mgPlayerJSTest_status-publish-unpublish mgPlayerJSTest_icons-hover-effect mgPlayerJSTest_header-icon-wrapper mgPlayerJSTest_ege-inline-block-vt");
			attr(wmgPlayerJSTest_3, "id", "mgPlayerJSTest_btn-guide-view-publish");

			attr(wmgPlayerJSTest_3, "class", wmgPlayerJSTest_3_class_value = "mgPlayerJSTest_guide-status-wrapper " + (/*rootScope*/ ctx[0].pendingStepCount > 0 || /*rootScope*/ ctx[0].draftExists(/*currentTour*/ ctx[1].tour_id, /*currentTour*/ ctx[1].category_id)
			? 'mgPlayerJSTest_disabled'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t1);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.publish + "")) button.innerHTML = raw_value;			if (dirty & /*rootScope*/ 1 && t1_value !== (t1_value = /*rootScope*/ ctx[0].labels.publish + "")) set_data(t1, t1_value);

			if (dirty & /*rootScope, currentTour*/ 3 && wmgPlayerJSTest_3_class_value !== (wmgPlayerJSTest_3_class_value = "mgPlayerJSTest_guide-status-wrapper " + (/*rootScope*/ ctx[0].pendingStepCount > 0 || /*rootScope*/ ctx[0].draftExists(/*currentTour*/ ctx[1].tour_id, /*currentTour*/ ctx[1].category_id)
			? 'mgPlayerJSTest_disabled'
			: ''))) {
				attr(wmgPlayerJSTest_3, "class", wmgPlayerJSTest_3_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}

			mounted = false;
			dispose();
		}
	};
}

// (144:3) {#if rootScope.showSchedulePublish(currentTour) && !rootScope.isDesktopApp() && !rootScope.hideMirrorAppCtrl()}
function create_if_block_7$3(ctx) {
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;
	let button;
	let raw_value = /*rootScope*/ ctx[0].svgs.publish + "";
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t1_value = /*rootScope*/ ctx[0].labels.btnScheduledPublish + "";
	let t1;
	let wmgPlayerJSTest_3_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_ege-inline-block-vt");
			attr(button, "aria-label", "publish");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_status-publish mgPlayerJSTest_status-publish-unpublish mgPlayerJSTest_icons-hover-effect mgPlayerJSTest_header-icon-wrapper mgPlayerJSTest_ege-inline-block-vt");
			attr(wmgPlayerJSTest_3, "id", "mgPlayerJSTest_btn-guide-view-schedule");

			attr(wmgPlayerJSTest_3, "class", wmgPlayerJSTest_3_class_value = "mgPlayerJSTest_guide-status-wrapper " + (/*rootScope*/ ctx[0].pendingStepCount > 0 || /*rootScope*/ ctx[0].draftExists(/*currentTour*/ ctx[1].tour_id, /*currentTour*/ ctx[1].category_id)
			? 'mgPlayerJSTest_disabled'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t1);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_1*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.publish + "")) button.innerHTML = raw_value;			if (dirty & /*rootScope*/ 1 && t1_value !== (t1_value = /*rootScope*/ ctx[0].labels.btnScheduledPublish + "")) set_data(t1, t1_value);

			if (dirty & /*rootScope, currentTour*/ 3 && wmgPlayerJSTest_3_class_value !== (wmgPlayerJSTest_3_class_value = "mgPlayerJSTest_guide-status-wrapper " + (/*rootScope*/ ctx[0].pendingStepCount > 0 || /*rootScope*/ ctx[0].draftExists(/*currentTour*/ ctx[1].tour_id, /*currentTour*/ ctx[1].category_id)
			? 'mgPlayerJSTest_disabled'
			: ''))) {
				attr(wmgPlayerJSTest_3, "class", wmgPlayerJSTest_3_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}

			mounted = false;
			dispose();
		}
	};
}

// (169:3) {#if GmCXt.FT.publish && currentTour.is_published && rootScope.isOwnerOrAppAdmin() && !rootScope.isDesktopApp() && !rootScope.hideMirrorAppCtrl() && rootScope.showUnpublish(currentTour)}
function create_if_block_6$4(ctx) {
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;
	let button;
	let raw_value = /*rootScope*/ ctx[0].svgs.unpublish + "";
	let t0;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t1_value = /*rootScope*/ ctx[0].labels.btnUnpublish + "";
	let t1;
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_ege-inline-block-vt");
			attr(button, "aria-label", "unpublish");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_status-unpublish mgPlayerJSTest_status-publish-unpublish mgPlayerJSTest_icons-hover-effect mgPlayerJSTest_header-icon-wrapper mgPlayerJSTest_ege-inline-block-vt");
			attr(wmgPlayerJSTest_3, "id", "mgPlayerJSTest_btn-guide-view-unpublish");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_guide-status-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_3, anchor);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t1);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_2*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.unpublish + "")) button.innerHTML = raw_value;			if (dirty & /*rootScope*/ 1 && t1_value !== (t1_value = /*rootScope*/ ctx[0].labels.btnUnpublish + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_3);
			}

			mounted = false;
			dispose();
		}
	};
}

// (188:3) {#if GmCXt.containBranchStep(currentTour) && GmCXt.FT.creatorApp}
function create_if_block_4$4(ctx) {
	let wmgPlayerJSTest_;

	function select_block_type(ctx, dirty) {
		if (!/*rootScope*/ ctx[0].guideViewFullScreen) return create_if_block_5$4;
		return create_else_block$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if_block.c();
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_btn-guide-view-full-screen");
			attr(wmgPlayerJSTest_, "class", "guide-view-full-screen");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if_block.m(wmgPlayerJSTest_, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(wmgPlayerJSTest_, null);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if_block.d();
		}
	};
}

// (198:5) {:else}
function create_else_block$2(ctx) {
	let button;
	let raw_value = /*rootScope*/ ctx[0].svgs.smallscreenIcon + "";
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			attr(button, "class", "mgPlayerJSTest_lbl-btn guide-view-full-screen-icon mgPlayerJSTest_icons-hover-effect mgPlayerJSTest_header-icon-wrapper mgPlayerJSTest_ege-inline-block-vt");
			attr(button, "aria-label", "smallscreen");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			button.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_4*/ ctx[9]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.smallscreenIcon + "")) button.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (190:5) {#if !rootScope.guideViewFullScreen}
function create_if_block_5$4(ctx) {
	let button;
	let raw_value = /*rootScope*/ ctx[0].svgs.fullscreen + "";
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			attr(button, "class", "mgPlayerJSTest_lbl-btn guide-view-full-screen-icon mgPlayerJSTest_icons-hover-effect mgPlayerJSTest_header-icon-wrapper mgPlayerJSTest_ege-inline-block-vt");
			attr(button, "aria-label", "fullscreen");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			button.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_3*/ ctx[8]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.fullscreen + "")) button.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (210:2) {#if !GmCXt.isFalseObj(currentTour.tour_settings.downloadGuideFiles)}
function create_if_block_2$5(ctx) {
	let downloadmedia;
	let current;
	downloadmedia = new DownloadMedia({ props: { tour: /*currentTour*/ ctx[1] } });

	return {
		c() {
			create_component(downloadmedia.$$.fragment);
		},
		m(target, anchor) {
			mount_component(downloadmedia, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const downloadmedia_changes = {};
			if (dirty & /*currentTour*/ 2) downloadmedia_changes.tour = /*currentTour*/ ctx[1];
			downloadmedia.$set(downloadmedia_changes);
		},
		i(local) {
			if (current) return;
			transition_in(downloadmedia.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(downloadmedia.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(downloadmedia, detaching);
		}
	};
}

// (216:2) {#if GmCXt.FT.creatorApp && ((currentTour.is_locked && currentTour.user_id == rootScope.user.user_id) || !currentTour.is_locked || !currentTour.is_published || rootScope.isOwnerOrAppAdmin()) && !rootScope.isUserRole() && !rootScope.isDesktopApp() && !rootScope.hideMirrorAppCtrl()}
function create_if_block_1$6(ctx) {
	let wmgPlayerJSTest_;
	let button;
	let guidedropdown;
	let wmgPlayerJSTest_id_value;
	let wmgPlayerJSTest_class_value;
	let current;
	guidedropdown = new Empty({ props: { tour: /*currentTour*/ ctx[1] } });

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			button = element("button");
			create_component(guidedropdown.$$.fragment);
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_icons-hover-effect mgPlayerJSTest_header-icon-wrapper mgPlayerJSTest_inline-block-vm");
			attr(button, "aria-label", "tour action dropdown");
			attr(wmgPlayerJSTest_, "id", wmgPlayerJSTest_id_value = `tour-pencil-icon-${/*step*/ ctx[2] && /*step*/ ctx[2]?.step_id || /*currentTour*/ ctx[1]?.tour_id || /*child*/ ctx[3] && /*child*/ ctx[3]?.entity_code}`);

			attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value = `mgPlayerJSTest_inline-block-vm mgPlayerJSTest_tour-more-option-icon ${!/*currentTour*/ ctx[1].is_published
			? 'tour-pencil-icon-unpublish'
			: ''}`);
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, button);
			mount_component(guidedropdown, button, null);
			current = true;
		},
		p(ctx, dirty) {
			const guidedropdown_changes = {};
			if (dirty & /*currentTour*/ 2) guidedropdown_changes.tour = /*currentTour*/ ctx[1];
			guidedropdown.$set(guidedropdown_changes);

			if (!current || dirty & /*currentTour*/ 2 && wmgPlayerJSTest_id_value !== (wmgPlayerJSTest_id_value = `tour-pencil-icon-${/*step*/ ctx[2] && /*step*/ ctx[2]?.step_id || /*currentTour*/ ctx[1]?.tour_id || /*child*/ ctx[3] && /*child*/ ctx[3]?.entity_code}`)) {
				attr(wmgPlayerJSTest_, "id", wmgPlayerJSTest_id_value);
			}

			if (!current || dirty & /*currentTour*/ 2 && wmgPlayerJSTest_class_value !== (wmgPlayerJSTest_class_value = `mgPlayerJSTest_inline-block-vm mgPlayerJSTest_tour-more-option-icon ${!/*currentTour*/ ctx[1].is_published
			? 'tour-pencil-icon-unpublish'
			: ''}`)) {
				attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(guidedropdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(guidedropdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(guidedropdown);
		}
	};
}

// (230:2) {#if rootScope.jsonEditor}
function create_if_block$6(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = /*rootScope*/ ctx[0].svgs.iconEdit + "";
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_icon-edit-json");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_tour-more-option-icon mgPlayerJSTest_header-icon-wrapper mgPlayerJSTest_json-editor-icon");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_, "click", /*click_handler_5*/ ctx[10]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.iconEdit + "")) wmgPlayerJSTest_.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			dispose();
		}
	};
}

function create_fragment$a(ctx) {
	let wmgPlayerJSTest_8;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_2;
	let button;
	let raw_value = /*rootScope*/ ctx[0].svgs.iconBack + "";
	let t0;
	let wmgPlayerJSTest_1;
	let t2;
	let wmgPlayerJSTest_3;
	let label;
	let t3_value = /*currentTour*/ ctx[1].tour_title + "";
	let t3;
	let t4;
	let t5;
	let wmgPlayerJSTest_5;
	let t6;
	let show_if_1 = !GmCXt.isFalseObj(/*currentTour*/ ctx[1].tour_settings.downloadGuideFiles);
	let t7;
	let wmgPlayerJSTest_7;
	let show_if = GmCXt.FT.creatorApp && (/*currentTour*/ ctx[1].is_locked && /*currentTour*/ ctx[1].user_id == /*rootScope*/ ctx[0].user.user_id || !/*currentTour*/ ctx[1].is_locked || !/*currentTour*/ ctx[1].is_published || /*rootScope*/ ctx[0].isOwnerOrAppAdmin()) && !/*rootScope*/ ctx[0].isUserRole() && !/*rootScope*/ ctx[0].isDesktopApp() && !/*rootScope*/ ctx[0].hideMirrorAppCtrl();
	let t8;
	let t9;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_8_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*currentTour*/ ctx[1].tour_description && create_if_block_9$2(ctx);
	let if_block1 = GmCXt.FT.creatorApp && create_if_block_3$5(ctx);
	let if_block2 = show_if_1 && create_if_block_2$5(ctx);
	let if_block3 = show_if && create_if_block_1$6(ctx);
	let if_block4 = /*rootScope*/ ctx[0].jsonEditor && create_if_block$6(ctx);

	return {
		c() {
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			button = element("button");
			t0 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1.innerHTML = `<wmgPlayerJSTest_ class="mgPlayerJSTest_tooltip-title">Back</wmgPlayerJSTest_>`;
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			label = element("label");
			t3 = text(t3_value);
			t4 = space();
			if (if_block0) if_block0.c();
			t5 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			if (if_block1) if_block1.c();
			t6 = space();
			if (if_block2) if_block2.c();
			t7 = space();
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			if (if_block3) if_block3.c();
			t8 = space();
			if (if_block4) if_block4.c();
			t9 = space();
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			attr(button, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_ege-inline-block-vt mgPlayerJSTest_margin-t-13");
			attr(button, "aria-label", "back");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-right");
			attr(wmgPlayerJSTest_2, "id", "mgPlayerJSTest_btn-guide-view-back");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_back-button mgPlayerJSTest_ege-inline-block-vm mgPlayerJSTest_no-padding");
			attr(label, "class", "mgPlayerJSTest_tour-view-tour-title mgPlayerJSTest_ege-inline-block-vm mgPlayerJSTest_position-relative mgPlayerJSTest_width-100");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_tour-title-wrapper mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_4, "class", "header-detail-view-tour-title");
			attr(wmgPlayerJSTest_5, "class", "header-detail-view-tour-download-container");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_clear");
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_header-detail-view-tour-edit-container");
			attr(wmgPlayerJSTest_8, "class", wmgPlayerJSTest_8_class_value = "mgPlayerJSTest_ege-panel-header-detail-view " + (/*currentTour*/ ctx[1].isEditMode ? 'mgPlayerJSTest_disabled' : ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_8, anchor);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, button);
			button.innerHTML = raw_value;
			append(wmgPlayerJSTest_2, t0);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_4, t2);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, label);
			append(label, t3);
			append(wmgPlayerJSTest_3, t4);
			if (if_block0) if_block0.m(wmgPlayerJSTest_3, null);
			append(wmgPlayerJSTest_8, t5);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_5);
			if (if_block1) if_block1.m(wmgPlayerJSTest_5, null);
			append(wmgPlayerJSTest_5, t6);
			if (if_block2) if_block2.m(wmgPlayerJSTest_5, null);
			append(wmgPlayerJSTest_8, t7);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_7);
			if (if_block3) if_block3.m(wmgPlayerJSTest_7, null);
			append(wmgPlayerJSTest_7, t8);
			if (if_block4) if_block4.m(wmgPlayerJSTest_7, null);
			append(wmgPlayerJSTest_7, t9);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_6);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(/*rootScope*/ ctx[0].backHandler)) /*rootScope*/ ctx[0].backHandler.apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			if ((!current || dirty & /*rootScope*/ 1) && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.iconBack + "")) button.innerHTML = raw_value;			if ((!current || dirty & /*currentTour*/ 2) && t3_value !== (t3_value = /*currentTour*/ ctx[1].tour_title + "")) set_data(t3, t3_value);

			if (/*currentTour*/ ctx[1].tour_description) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_9$2(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_3, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (GmCXt.FT.creatorApp) if_block1.p(ctx, dirty);
			if (dirty & /*currentTour*/ 2) show_if_1 = !GmCXt.isFalseObj(/*currentTour*/ ctx[1].tour_settings.downloadGuideFiles);

			if (show_if_1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*currentTour*/ 2) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_2$5(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(wmgPlayerJSTest_5, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (dirty & /*currentTour, rootScope*/ 3) show_if = GmCXt.FT.creatorApp && (/*currentTour*/ ctx[1].is_locked && /*currentTour*/ ctx[1].user_id == /*rootScope*/ ctx[0].user.user_id || !/*currentTour*/ ctx[1].is_locked || !/*currentTour*/ ctx[1].is_published || /*rootScope*/ ctx[0].isOwnerOrAppAdmin()) && !/*rootScope*/ ctx[0].isUserRole() && !/*rootScope*/ ctx[0].isDesktopApp() && !/*rootScope*/ ctx[0].hideMirrorAppCtrl();

			if (show_if) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty & /*currentTour, rootScope*/ 3) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_1$6(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(wmgPlayerJSTest_7, t8);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*rootScope*/ ctx[0].jsonEditor) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block$6(ctx);
					if_block4.c();
					if_block4.m(wmgPlayerJSTest_7, t9);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (!current || dirty & /*currentTour*/ 2 && wmgPlayerJSTest_8_class_value !== (wmgPlayerJSTest_8_class_value = "mgPlayerJSTest_ege-panel-header-detail-view " + (/*currentTour*/ ctx[1].isEditMode ? 'mgPlayerJSTest_disabled' : ''))) {
				attr(wmgPlayerJSTest_8, "class", wmgPlayerJSTest_8_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block2);
			transition_in(if_block3);
			current = true;
		},
		o(local) {
			transition_out(if_block2);
			transition_out(if_block3);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_8);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			mounted = false;
			dispose();
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let currentTour = false;
	currentTour = get_store_value(Gm.currentTour);
	let breadcrumb;
	let step;
	let child;
	rootScope.isTooltip(currentTour);

	const unsubscribe = Gm.currentTour.subscribe(value => {
		$$invalidate(1, currentTour = value);
	});

	Gm.breadCrumb.subscribe(value => {
		breadcrumb = value;
	});

	const selectedLangSubscriber = Gm.selectedLang.subscribe(value => {
		if (!GmCXt.isEmpty(currentTour)) {
			$$invalidate(1, currentTour.selectedLang = value, currentTour);
			$$invalidate(1, currentTour = rootScope.getTranslatedTourAndSteps(currentTour, value));
		}
	});

	const currentTourSubscriber = Gm.currentTour.subscribe(value => {
		$$invalidate(1, currentTour = value);
	});

	onDestroy(() => {
		unsubscribe();
		selectedLangSubscriber();
		currentTourSubscriber();
	});

	const guideViewFullScreen = function (val) {
		$$invalidate(0, rootScope.guideViewFullScreen = val, rootScope);
		rootScope.toggleGuideViewFullScreen();
	};

	rootScope.backHandler = () => {
		if (rootScope.guideViewFullScreen) {
			$$invalidate(0, rootScope.guideViewFullScreen = false, rootScope);
			GmCXt.reduceSidePanelWidth();
		}

		if (breadcrumb.length > 0) {
			let cat = breadcrumb[breadcrumb.length - 1];

			let customObject = {
				parent: cat,
				hasTour: cat.has_tour,
				hasChild: cat.has_child
			};

			const event = { detail: customObject };
			let backwardAction = { action: 'backwardTraversal', data: event };
			Gm.routeAction.update(n => backwardAction);
			rootScope.setCurrentPage('allguides');
		} else {
			rootScope.setCurrentPage('currentpage');
		}
	};

	const click_handler = e => rootScope.changeStatus(currentTour, 'publish', 0, e);
	const click_handler_1 = () => rootScope.schedulePubTour(currentTour);
	const click_handler_2 = e => rootScope.changeStatus(currentTour, 'unpublish', 0, e);
	const click_handler_3 = () => guideViewFullScreen(!rootScope.guideViewFullScreen);
	const click_handler_4 = () => guideViewFullScreen(!rootScope.guideViewFullScreen);
	const click_handler_5 = () => rootScope.editJson(currentTour, 'guide');

	return [
		rootScope,
		currentTour,
		step,
		child,
		guideViewFullScreen,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5
	];
}

class StepHeader extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});
	}
}

/* src/components/SearchPage.svelte generated by Svelte v4.2.20 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

// (99:1) {:else}
function create_else_block$1(ctx) {
	let each_1_anchor;
	let current;
	let each_value = ensure_array_like(rootScope.sortDataByActiveFilter(/*searchTours*/ ctx[0], 'tour_title', /*activeSortFilter*/ ctx[1]));
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*searchTours, activeSortFilter*/ 3) {
				each_value = ensure_array_like(rootScope.sortDataByActiveFilter(/*searchTours*/ ctx[0], 'tour_title', /*activeSortFilter*/ ctx[1]));
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (85:1) {#if searchTours.length < 1}
function create_if_block$5(ctx) {
	let wmgPlayerJSTest_5;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw_value = rootScope.svgs.no_guides_image + "";
	let t0;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_2;
	let t2;
	let wmgPlayerJSTest_3;

	return {
		c() {
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2.textContent = `${rootScope.labels.noGuideAvailableFor}`;
			t2 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3.textContent = `${rootScope.labels.tryModifyingYourSearch}`;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_no-guide-found-search-icon");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_no-guide-image-wrapper mgPlayerJSTest_no-guide-search-wrapper");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_no-guide-msg");
			attr(wmgPlayerJSTest_2, "tabindex", "0");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_instruction-add-category");
			attr(wmgPlayerJSTest_3, "tabindex", "0");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_no-guide-text-wrapper mgPlayerJSTest_no-guide-text-search-wrapper");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_no-tour-message-wrapper mgPlayerJSTest_position-center");
			toggle_class(wmgPlayerJSTest_5, "mgPlayerJSTest_margin-t-50", !rootScope.isMicroPlayer);
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_5, anchor);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_5, t0);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_4, t2);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_5);
			}
		}
	};
}

// (100:2) {#each rootScope.sortDataByActiveFilter(searchTours, 'tour_title', activeSortFilter) as tour}
function create_each_block$2(ctx) {
	let wmgPlayerJSTest_;
	let tourview;
	let t;
	let current;
	tourview = new TourView({ props: { tour: /*tour*/ ctx[10] } });

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(tourview.$$.fragment);
			t = space();

			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_tour-item mgPlayerJSTest_guide-list-view " + (rootScope.isMicroPlayer
			? 'mgPlayerJSTest_guide-list-view-mplayer'
			: ''));

			attr(wmgPlayerJSTest_, "aria-live", rootScope.labels.searchResult);
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(tourview, wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			current = true;
		},
		p(ctx, dirty) {
			const tourview_changes = {};
			if (dirty & /*searchTours, activeSortFilter*/ 3) tourview_changes.tour = /*tour*/ ctx[10];
			tourview.$set(tourview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tourview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tourview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(tourview);
		}
	};
}

function create_fragment$9(ctx) {
	let wmgPlayerJSTest_;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$5, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*searchTours*/ ctx[0].length < 1) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if_block.c();
			attr(wmgPlayerJSTest_, "class", "search-list");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if_blocks[current_block_type_index].m(wmgPlayerJSTest_, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(wmgPlayerJSTest_, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if_blocks[current_block_type_index].d();
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let searchTours;
	GmCXt.user;
	let activeSortFilter;
	let selectedLang;
	if (GmCXt.getLXPLang()) selectedLang = GmCXt.getLXPLang();

	const currentPageSubscriber = Gm.CurrentPage.subscribe(value => {
	});

	const searchToursSubscriber = Gm.searchTours.subscribe(value => {
		if (value) {
			$$invalidate(0, searchTours = rootScope.getTranslatedTours(value, selectedLang));
		}
	});

	onDestroy(() => {
		currentPageSubscriber();
		searchToursSubscriber();
		selectedLangSubscriber();
	});

	const selectedLangSubscriber = Gm.selectedLang.subscribe(value => {
		if (!GmCXt.getLXPLang()) {
			selectedLang = value;
		}

		$$invalidate(0, searchTours = rootScope.getTranslatedTours(searchTours, selectedLang));
	});

	Gm.activeSortFilterStore.subscribe(value => {
		$$invalidate(1, activeSortFilter = value);
	});

	const setHeight = function () {
		//Set height to search-list element to properly apply slider
		let guideViewHeaderPanelContainerHeight = mg$('.mgPlayerJSTest_guide-view-header-panel-container').innerHeight()
		? mg$('.mgPlayerJSTest_guide-view-header-panel-container').innerHeight()
		: 0;

		let listPageHeaderHeight = mg$('.mgPlayerJSTest_list-page-header').innerHeight()
		? mg$('.mgPlayerJSTest_list-page-header').innerHeight()
		: 0;

		let egeHeaderHeight = mg$('#mgPlayerJSTest_ege-header').innerHeight()
		? mg$('#mgPlayerJSTest_ege-header').innerHeight()
		: 0;

		let egePanelHeaderSubMenuUrlsHeight = mg$('.mgPlayerJSTest_ege-panel-header-sub-menu-urls').innerHeight()
		? mg$('.mgPlayerJSTest_ege-panel-header-sub-menu-urls').innerHeight()
		: 0;

		let footerHeight = mg$('#mgPlayerJSTest_footer-panel-container').innerHeight()
		? mg$('#mgPlayerJSTest_footer-panel-container').innerHeight()
		: 0;

		mg$('.search-list').css({
			height: window.innerHeight - guideViewHeaderPanelContainerHeight - footerHeight - egePanelHeaderSubMenuUrlsHeight - listPageHeaderHeight - egeHeaderHeight
		});
	};

	setTimeout(
		function () {
			setHeight();
		},
		100
	);

	/* set the list hight on window resize */
	mg$(window).off('resize').on('resize', setHeight);

	onMount(() => {
		setHeight();
	});

	return [searchTours, activeSortFilter];
}

class SearchPage extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});
	}
}

/* src/components/MyGuides.svelte generated by Svelte v4.2.20 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (160:1) {#each tours as tour}
function create_each_block$1(ctx) {
	let wmgPlayerJSTest_;
	let tourview;
	let wmgPlayerJSTest_class_value;
	let current;
	tourview = new TourView({ props: { tour: /*tour*/ ctx[14] } });

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(tourview.$$.fragment);

			attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value = "mgPlayerJSTest_tour-item mgPlayerJSTest_guide-list-view " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_guide-list-view-mplayer'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(tourview, wmgPlayerJSTest_, null);
			current = true;
		},
		p(ctx, dirty) {
			const tourview_changes = {};
			if (dirty & /*tours*/ 2) tourview_changes.tour = /*tour*/ ctx[14];
			tourview.$set(tourview_changes);

			if (!current || dirty & /*rootScope*/ 1 && wmgPlayerJSTest_class_value !== (wmgPlayerJSTest_class_value = "mgPlayerJSTest_tour-item mgPlayerJSTest_guide-list-view " + (/*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_guide-list-view-mplayer'
			: ''))) {
				attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(tourview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tourview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(tourview);
		}
	};
}

function create_fragment$8(ctx) {
	let wmgPlayerJSTest_1;
	let t;
	let wmgPlayerJSTest_0;
	let current;
	let each_value = ensure_array_like(/*tours*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_ege-clear");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_category-list");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(wmgPlayerJSTest_1, null);
				}
			}

			append(wmgPlayerJSTest_1, t);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*rootScope, tours*/ 3) {
				each_value = ensure_array_like(/*tours*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(wmgPlayerJSTest_1, t);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

let limit = 50;

function instance$8($$self, $$props, $$invalidate) {
	rootScope.filterByPublishedGuides;
	rootScope.currentUserFilter;
	rootScope.currentAssigneeFilter;
	rootScope.currentView = 'filter-list';
	let offset = 0;
	let toursFetchedInLastApiCall = 0;
	let tours = [];
	let isPreviousEventComplete = true;
	let activeTourId = rootScope.activeTourId;
	activeTourId = activeTourId ? activeTourId : 0;

	const myGuidePageToursSubscriber = Gm.MyGuidePageTours.subscribe(value => {
		$$invalidate(1, tours = value);
	});

	onDestroy(() => {
		myGuidePageToursSubscriber();
	});

	const refreshView = function (append) {
		Gm.loading.set(true);
		let param = { limit, offset };

		// if (rootScope.myGuidesFilter) {
		param.my_guides = rootScope.user.user_id;

		// }
		// if (
		//   rootScope.currentUserFilter &&
		//   rootScope.currentUserFilter.user_id !== 0
		// ) {
		//   param.my_guides = rootScope.currentUserFilter.user_id;
		// }
		// if (filterByPublishedGuides === rootScope.labels.published) {
		//   param.published_guides = "1";
		// } else if (filterByPublishedGuides === rootScope.labels.unpublished)
		//   param.published_guides = "0";
		// if (
		//   rootScope.currentAssigneeFilter &&
		//   rootScope.currentAssigneeFilter.user_id !== 0
		// )
		//   param.my_locked_guides = rootScope.currentAssigneeFilter.user_id;
		// if (rootScope.searchKeyword) {
		//   param.search_text = rootScope.searchKeyword;
		// }
		if (GmCXt.getLXPLang()) param.language = GmCXt.getLXPLang();

		function cb(_tours) {
			processTourResponse(append, _tours);
		}

		api.getTourList(param, cb);
	};

	refreshView(0);

	const processTourResponse = function (append, _tours) {
		_tours = rootScope.getTranslatedTours(_tours);

		if (_tours && _tours.length > 0) {
			if (append) $$invalidate(1, tours = mg$.merge(tours, _tours)); else $$invalidate(1, tours = _tours);
			Gm.MyGuidePageTours.set(tours);
			toursFetchedInLastApiCall = _tours.length;
		}

		isPreviousEventComplete = true;

		tours.forEach(function (tour) {
			if (tour.tour_id === activeTourId) {
				tour.screencastInProgress = true;
			}
		});

		Gm.MyGuidePageTours.set(tours);

		//Set height to category-list element to properly apply slider
		setHeight();
	};

	mg$('.mgPlayerJSTest_category-list').off('scroll').on('scroll', function () {
		if (!isPreviousEventComplete) return true;

		if (mg$(this).scrollTop() + mg$(this).innerHeight() >= mg$(this)[0].scrollHeight - 20 && mg$(this)[0].scrollHeight + 20 > mg$(this).innerHeight()) {
			isPreviousEventComplete = false;

			if (toursFetchedInLastApiCall === limit) {
				Gm.loading.set(true);
				offset = offset + limit;
				refreshView(1);
			}
		}
	});

	const setHeight = function () {
		let listPageHeaderHeight = mg$('.mgPlayerJSTest_list-page-header').innerHeight()
		? mg$('.mgPlayerJSTest_list-page-header').innerHeight()
		: 0;

		let egeHeaderHeight = mg$('#mgPlayerJSTest_ege-header').innerHeight()
		? mg$('#mgPlayerJSTest_ege-header').innerHeight()
		: 0;

		let egePanelHeaderSubMenuUrlsHeight = mg$('.mgPlayerJSTest_ege-panel-header-sub-menu-urls').innerHeight()
		? mg$('.mgPlayerJSTest_ege-panel-header-sub-menu-urls').innerHeight()
		: 0;

		let footerHeight = mg$('#mgPlayerJSTest_footer-panel-container').innerHeight()
		? mg$('#mgPlayerJSTest_footer-panel-container').innerHeight()
		: 0;

		mg$('.mgPlayerJSTest_category-list').css({
			height: window.innerHeight - footerHeight - egePanelHeaderSubMenuUrlsHeight - listPageHeaderHeight - egeHeaderHeight
		});
	};

	mg$(window).off('resize').on('resize', setHeight);
	return [rootScope, tours];
}

class MyGuides extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});
	}
}

/* src/components/NoApp.svelte generated by Svelte v4.2.20 */

function create_fragment$7(ctx) {
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw0_value = /*rootScope*/ ctx[0].svgs.no_guides_image + "";
	let t0;
	let wmgPlayerJSTest_2;
	let t1_value = /*rootScope*/ ctx[0].labels.noGuidesOnDomain + "";
	let t1;
	let t2;
	let wmgPlayerJSTest_4;
	let t3_value = /*rootScope*/ ctx[0].labels.noAppOnDomain + "";
	let t3;
	let t4;
	let wmgPlayerJSTest_3;
	let t5;
	let t6;
	let t7;
	let t8;
	let wmgPlayerJSTest_5;
	let raw1_value = /*rootScope*/ ctx[0].labels.contactAdmin + "";

	return {
		c() {
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			t2 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			t3 = text(t3_value);
			t4 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t5 = text("(");
			t6 = text(/*domain*/ ctx[1]);
			t7 = text(")");
			t8 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_no-app-icon mgPlayerJSTest_position-relative mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_no-app-icon-wrapper mgPlayerJSTest_display-inline-block mgPlayerJSTest_text-align-center mgPlayerJSTest_margin-tb-30");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_no-guide-msg mgPlayerJSTest_text-align-center mgPlayerJSTest_font-size-20 mgPlayerJSTest_text-align-center mgPlayerJSTest_font-weight-550 mgPlayerJSTest_text-color-dark");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_font-weight-550");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_default-app-msg mgPlayerJSTest_display-inline-block mgPlayerJSTest_text-align-center mgPlayerJSTest_font-size-16 mgPlayerJSTest_margin-tb-10");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_contact-support-msg mgPlayerJSTest_display-inline-block mgPlayerJSTest_text-align-center mgPlayerJSTest_font-size-16 mgPlayerJSTest_margin-tb-10");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_no-app-container mgPlayerJSTest_text-align-center");
			toggle_class(wmgPlayerJSTest_6, "mgPlayerJSTest_no-margin", !/*rootScope*/ ctx[0].isMicroPlayer);
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_6, anchor);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw0_value;
			append(wmgPlayerJSTest_6, t0);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, t1);
			append(wmgPlayerJSTest_6, t2);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, t3);
			append(wmgPlayerJSTest_4, t4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, t5);
			append(wmgPlayerJSTest_3, t6);
			append(wmgPlayerJSTest_3, t7);
			append(wmgPlayerJSTest_6, t8);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			wmgPlayerJSTest_5.innerHTML = raw1_value;
		},
		p(ctx, [dirty]) {
			if (dirty & /*rootScope*/ 1 && raw0_value !== (raw0_value = /*rootScope*/ ctx[0].svgs.no_guides_image + "")) wmgPlayerJSTest_0.innerHTML = raw0_value;			if (dirty & /*rootScope*/ 1 && t1_value !== (t1_value = /*rootScope*/ ctx[0].labels.noGuidesOnDomain + "")) set_data(t1, t1_value);
			if (dirty & /*rootScope*/ 1 && t3_value !== (t3_value = /*rootScope*/ ctx[0].labels.noAppOnDomain + "")) set_data(t3, t3_value);
			if (dirty & /*domain*/ 2) set_data(t6, /*domain*/ ctx[1]);
			if (dirty & /*rootScope*/ 1 && raw1_value !== (raw1_value = /*rootScope*/ ctx[0].labels.contactAdmin + "")) wmgPlayerJSTest_5.innerHTML = raw1_value;
			if (dirty & /*rootScope*/ 1) {
				toggle_class(wmgPlayerJSTest_6, "mgPlayerJSTest_no-margin", !/*rootScope*/ ctx[0].isMicroPlayer);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_6);
			}
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	GmCXt.log(21, 'NO APPS found');
	rootScope.currentView = 'no-app';
	rootScope.resetAppData();
	let domain = '';

	{
		if (GmCXt.urlParts && GmCXt.urlParts.host) {
			$$invalidate(1, domain = GmCXt.urlParts.host);
		}
	}

	return [rootScope, domain];
}

class NoApp extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});
	}
}

/* src/components/Home.svelte generated by Svelte v4.2.20 */

function create_if_block_20(ctx) {
	let statusbar;
	let current;
	statusbar = new Empty({});

	return {
		c() {
			create_component(statusbar.$$.fragment);
		},
		m(target, anchor) {
			mount_component(statusbar, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(statusbar.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(statusbar.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(statusbar, detaching);
		}
	};
}

// (140:2) {#if currentPage !== 'addCategory' && currentPage !== 'addGuide' && currentPage !== 'addSurveyStep' && currentPage !== 'addTransportStep' && currentPage !== 'addVideoStep' && currentPage !== 'addTextSlideStep' && currentPage !== 'copySteps' && !rootScope.automationSelectionMode}
function create_if_block_19(ctx) {
	let wmgPlayerJSTest_;
	let addcategorydir;
	let current;

	addcategorydir = new Empty({
			props: {
				currentPageRoute: /*breadcrumb*/ ctx[2].length > 0 && /*currentPage*/ ctx[0] !== 'stepview'
				? 'categorylist'
				: /*currentPage*/ ctx[0]
			}
		});

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(addcategorydir.$$.fragment);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_float-right mgPlayerJSTest_margin-lr-5");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(addcategorydir, wmgPlayerJSTest_, null);
			current = true;
		},
		p(ctx, dirty) {
			const addcategorydir_changes = {};

			if (dirty & /*breadcrumb, currentPage*/ 5) addcategorydir_changes.currentPageRoute = /*breadcrumb*/ ctx[2].length > 0 && /*currentPage*/ ctx[0] !== 'stepview'
			? 'categorylist'
			: /*currentPage*/ ctx[0];

			addcategorydir.$set(addcategorydir_changes);
		},
		i(local) {
			if (current) return;
			transition_in(addcategorydir.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addcategorydir.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(addcategorydir);
		}
	};
}

// (149:2) {#if currentPage == 'stepview' || currentPage == 'addLinkGuide' || currentPage == 'copySteps'}
function create_if_block_18(ctx) {
	let stepheader;
	let current;
	stepheader = new StepHeader({});

	return {
		c() {
			create_component(stepheader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(stepheader, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(stepheader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(stepheader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(stepheader, detaching);
		}
	};
}

// (153:2) {#if currentPage !== 'addCategory' && currentPage !== 'addGuide' && currentPage !== 'stepview' && currentPage !== 'addSurveyStep' && currentPage !== 'addTransportStep' && currentPage !== 'addLinkGuide' && currentPage !== 'addVideoStep' && currentPage !== 'addTextSlideStep' && currentPage !== 'copySteps'}
function create_if_block_16(ctx) {
	let show_if = get_store_value(Gm.activeView) != 'tour-view' && get_store_value(Gm.activeView) != 'chatbot' && get_store_value(Gm.activeView) != 'login-view' && get_store_value(Gm.activeView) != 'forgot-password-view' && get_store_value(Gm.activeView) != 'task-status-list' && get_store_value(Gm.activeView) != 'insights-tag-view' && get_store_value(Gm.activeView) != 'add-guide' && get_store_value(Gm.activeView) != 'add-category' && get_store_value(Gm.activeView) != 'add-smartTip' && get_store_value(Gm.activeView) != 'change-password-view' && get_store_value(Gm.activeView) != 'survey-step' && get_store_value(Gm.activeView) != 'bot-conv-step' && get_store_value(Gm.activeView) !== 'video-step' && (GmCXt.FT.creatorApp || rootScope.showAppSwitcher && rootScope.user.app_access.length > 1) && !rootScope.maintenance;
	let if_block_anchor;
	let current;
	let if_block = show_if && create_if_block_17();

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (154:3) {#if get(Gm.activeView) != 'tour-view' && get(Gm.activeView) != 'chatbot' && get(Gm.activeView) != 'login-view' && get(Gm.activeView) != 'forgot-password-view' && get(Gm.activeView) != 'task-status-list' && get(Gm.activeView) != 'insights-tag-view' && get(Gm.activeView) != 'add-guide' && get(Gm.activeView) != 'add-category' && get(Gm.activeView) != 'add-smartTip' && get(Gm.activeView) != 'change-password-view' && get(Gm.activeView) != 'survey-step' && get(Gm.activeView) != 'bot-conv-step' && get(Gm.activeView) !== 'video-step' && (GmCXt.FT.creatorApp || (rootScope.showAppSwitcher && rootScope.user.app_access.length > 1)) && !rootScope.maintenance}
function create_if_block_17(ctx) {
	let appheader;
	let current;
	appheader = new Empty({});

	return {
		c() {
			create_component(appheader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(appheader, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(appheader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(appheader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(appheader, detaching);
		}
	};
}

// (183:1) {:else}
function create_else_block(ctx) {
	let wmgPlayerJSTest_;
	let wmgPlayerJSTest_class_value;
	let current;
	let if_block = /*currentPage*/ ctx[0] !== '' && create_if_block_10$1(ctx);

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			if (if_block) if_block.c();
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_home-page-container");

			attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value = "mgPlayerJSTest_ege-panel-main-container mgPlayerJSTest_home-page-container " + (/*currentPage*/ ctx[0] == 'allguidesSearchPage' || /*currentPage*/ ctx[0] == 'currentPageSearchPage'
			? 'mgPlayerJSTest_search-page-container'
			: ''));
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			if (if_block) if_block.m(wmgPlayerJSTest_, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*currentPage*/ ctx[0] !== '') {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*currentPage*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_10$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*currentPage*/ 1 && wmgPlayerJSTest_class_value !== (wmgPlayerJSTest_class_value = "mgPlayerJSTest_ege-panel-main-container mgPlayerJSTest_home-page-container " + (/*currentPage*/ ctx[0] == 'allguidesSearchPage' || /*currentPage*/ ctx[0] == 'currentPageSearchPage'
			? 'mgPlayerJSTest_search-page-container'
			: ''))) {
				attr(wmgPlayerJSTest_, "class", wmgPlayerJSTest_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			if (if_block) if_block.d();
		}
	};
}

// (181:34) 
function create_if_block_9$1(ctx) {
	let noapp;
	let current;
	noapp = new NoApp({});

	return {
		c() {
			create_component(noapp.$$.fragment);
		},
		m(target, anchor) {
			mount_component(noapp, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(noapp.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(noapp.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(noapp, detaching);
		}
	};
}

// (174:100) 
function create_if_block_7$2(ctx) {
	let wmgPlayerJSTest_;
	let stepcontainer;
	let t;
	let current;
	stepcontainer = new StepContainer({});
	let if_block = /*currentPage*/ ctx[0] == 'addLinkGuide' && create_if_block_8$2();

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(stepcontainer.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_tour-view-page-container");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_ege-panel-main-container mgPlayerJSTest_tour-view-page-container");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(stepcontainer, wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);
			if (if_block) if_block.m(wmgPlayerJSTest_, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*currentPage*/ ctx[0] == 'addLinkGuide') {
				if (if_block) {
					if (dirty & /*currentPage*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_8$2();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(wmgPlayerJSTest_, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(stepcontainer.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(stepcontainer.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(stepcontainer);
			if (if_block) if_block.d();
		}
	};
}

// (172:45) 
function create_if_block_6$3(ctx) {
	let addtextslide;
	let current;
	addtextslide = new Empty({});

	return {
		c() {
			create_component(addtextslide.$$.fragment);
		},
		m(target, anchor) {
			mount_component(addtextslide, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(addtextslide.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addtextslide.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(addtextslide, detaching);
		}
	};
}

// (170:41) 
function create_if_block_5$3(ctx) {
	let addvideo;
	let current;
	addvideo = new Empty({});

	return {
		c() {
			create_component(addvideo.$$.fragment);
		},
		m(target, anchor) {
			mount_component(addvideo, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(addvideo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addvideo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(addvideo, detaching);
		}
	};
}

// (168:45) 
function create_if_block_4$3(ctx) {
	let addtransportstep;
	let current;
	addtransportstep = new Empty({});

	return {
		c() {
			create_component(addtransportstep.$$.fragment);
		},
		m(target, anchor) {
			mount_component(addtransportstep, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(addtransportstep.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addtransportstep.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(addtransportstep, detaching);
		}
	};
}

// (166:42) 
function create_if_block_3$4(ctx) {
	let addsurvey;
	let current;
	addsurvey = new Empty({});

	return {
		c() {
			create_component(addsurvey.$$.fragment);
		},
		m(target, anchor) {
			mount_component(addsurvey, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(addsurvey.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addsurvey.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(addsurvey, detaching);
		}
	};
}

// (164:37) 
function create_if_block_2$4(ctx) {
	let addguides;
	let current;
	addguides = new Empty({});

	return {
		c() {
			create_component(addguides.$$.fragment);
		},
		m(target, anchor) {
			mount_component(addguides, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(addguides.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addguides.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(addguides, detaching);
		}
	};
}

// (162:40) 
function create_if_block_1$5(ctx) {
	let addcategory;
	let current;
	addcategory = new Empty({});

	return {
		c() {
			create_component(addcategory.$$.fragment);
		},
		m(target, anchor) {
			mount_component(addcategory, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(addcategory.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addcategory.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(addcategory, detaching);
		}
	};
}

// (160:1) {#if rootScope.isOwnerOrAppAdmin() && currentPage == 'appsettings'}
function create_if_block$4(ctx) {
	let appsettings;
	let current;
	appsettings = new Empty({});

	return {
		c() {
			create_component(appsettings.$$.fragment);
		},
		m(target, anchor) {
			mount_component(appsettings, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(appsettings.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(appsettings.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(appsettings, detaching);
		}
	};
}

// (191:3) {#if currentPage !== ''}
function create_if_block_10$1(ctx) {
	let wmgPlayerJSTest_;
	let filter;
	let t;
	let current_block_type_index;
	let if_block;
	let current;
	filter = new Filter({});

	const if_block_creators = [
		create_if_block_11$1,
		create_if_block_12,
		create_if_block_13,
		create_if_block_14,
		create_if_block_15
	];

	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*currentPage*/ ctx[0] === 'currentpage') return 0;
		if (/*currentPage*/ ctx[0] === 'myguides') return 1;
		if (/*currentPage*/ ctx[0] == 'allguides') return 2;
		if (/*currentPage*/ ctx[0] == 'allguidesSearchPage' || /*currentPage*/ ctx[0] == 'currentPageSearchPage') return 3;
		if (/*currentPage*/ ctx[0] == 'listView') return 4;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			create_component(filter.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_tour-list-page-container");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			mount_component(filter, wmgPlayerJSTest_, null);
			append(wmgPlayerJSTest_, t);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(wmgPlayerJSTest_, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(wmgPlayerJSTest_, null);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(filter.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(filter.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_component(filter);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};
}

// (202:41) 
function create_if_block_15(ctx) {
	let listview;
	let current;
	listview = new Empty({});

	return {
		c() {
			create_component(listview.$$.fragment);
		},
		m(target, anchor) {
			mount_component(listview, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(listview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(listview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(listview, detaching);
		}
	};
}

// (200:94) 
function create_if_block_14(ctx) {
	let searchpage;
	let current;
	searchpage = new SearchPage({});

	return {
		c() {
			create_component(searchpage.$$.fragment);
		},
		m(target, anchor) {
			mount_component(searchpage, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(searchpage.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(searchpage.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(searchpage, detaching);
		}
	};
}

// (198:42) 
function create_if_block_13(ctx) {
	let allguide;
	let current;
	allguide = new AllGuide({});

	return {
		c() {
			create_component(allguide.$$.fragment);
		},
		m(target, anchor) {
			mount_component(allguide, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(allguide.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(allguide.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(allguide, detaching);
		}
	};
}

// (196:42) 
function create_if_block_12(ctx) {
	let myguides;
	let current;
	myguides = new MyGuides({});

	return {
		c() {
			create_component(myguides.$$.fragment);
		},
		m(target, anchor) {
			mount_component(myguides, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(myguides.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(myguides.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(myguides, detaching);
		}
	};
}

// (194:5) {#if currentPage === 'currentpage'}
function create_if_block_11$1(ctx) {
	let currentpage;
	let current;
	currentpage = new CurrentPage({});

	return {
		c() {
			create_component(currentpage.$$.fragment);
		},
		m(target, anchor) {
			mount_component(currentpage, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(currentpage.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(currentpage.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(currentpage, detaching);
		}
	};
}

// (177:3) {#if currentPage == 'addLinkGuide'}
function create_if_block_8$2(ctx) {
	let addlinkguide;
	let current;
	addlinkguide = new Empty({});

	return {
		c() {
			create_component(addlinkguide.$$.fragment);
		},
		m(target, anchor) {
			mount_component(addlinkguide, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(addlinkguide.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(addlinkguide.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(addlinkguide, detaching);
		}
	};
}

// (125:0) {#key renderKey}
function create_key_block$1(ctx) {
	let wmgPlayerJSTest_1;
	let t0;
	let wmgPlayerJSTest_0;
	let usermenu;
	let t1;
	let t2;
	let t3;
	let t4;
	let show_if;
	let current_block_type_index;
	let if_block4;
	let t5;
	let wmgPlayerJSTest_2;
	let t6;
	let wmgPlayerJSTest_3;
	let t7;
	let wmgPlayerJSTest_4;
	let t8;
	let wmgPlayerJSTest_5;
	let t9;
	let wmgPlayerJSTest_6;
	let t10;
	let wmgPlayerJSTest_7;
	let t11;
	let wmgPlayerJSTest_8;
	let t12;
	let footer;
	let current;
	let if_block0 = /*statusBar*/ ctx[1] && create_if_block_20();
	usermenu = new UserMenu({});
	let if_block1 = /*currentPage*/ ctx[0] !== 'addCategory' && /*currentPage*/ ctx[0] !== 'addGuide' && /*currentPage*/ ctx[0] !== 'addSurveyStep' && /*currentPage*/ ctx[0] !== 'addTransportStep' && /*currentPage*/ ctx[0] !== 'addVideoStep' && /*currentPage*/ ctx[0] !== 'addTextSlideStep' && /*currentPage*/ ctx[0] !== 'copySteps' && !rootScope.automationSelectionMode && create_if_block_19(ctx);
	let if_block2 = (/*currentPage*/ ctx[0] == 'stepview' || /*currentPage*/ ctx[0] == 'addLinkGuide' || /*currentPage*/ ctx[0] == 'copySteps') && create_if_block_18();
	let if_block3 = /*currentPage*/ ctx[0] !== 'addCategory' && /*currentPage*/ ctx[0] !== 'addGuide' && /*currentPage*/ ctx[0] !== 'stepview' && /*currentPage*/ ctx[0] !== 'addSurveyStep' && /*currentPage*/ ctx[0] !== 'addTransportStep' && /*currentPage*/ ctx[0] !== 'addLinkGuide' && /*currentPage*/ ctx[0] !== 'addVideoStep' && /*currentPage*/ ctx[0] !== 'addTextSlideStep' && /*currentPage*/ ctx[0] !== 'copySteps' && create_if_block_16();

	const if_block_creators = [
		create_if_block$4,
		create_if_block_1$5,
		create_if_block_2$4,
		create_if_block_3$4,
		create_if_block_4$3,
		create_if_block_5$3,
		create_if_block_6$3,
		create_if_block_7$2,
		create_if_block_9$1,
		create_else_block
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*currentPage*/ 1) show_if = null;
		if (show_if == null) show_if = !!(rootScope.isOwnerOrAppAdmin() && /*currentPage*/ ctx[0] == 'appsettings');
		if (show_if) return 0;
		if (/*currentPage*/ ctx[0] == 'addCategory') return 1;
		if (/*currentPage*/ ctx[0] == 'addGuide') return 2;
		if (/*currentPage*/ ctx[0] == 'addSurveyStep') return 3;
		if (/*currentPage*/ ctx[0] == 'addTransportStep') return 4;
		if (/*currentPage*/ ctx[0] == 'addVideoStep') return 5;
		if (/*currentPage*/ ctx[0] == 'addTextSlideStep') return 6;
		if (/*currentPage*/ ctx[0] == 'stepview' || /*currentPage*/ ctx[0] == 'addLinkGuide' || /*currentPage*/ ctx[0] == 'copySteps') return 7;
		if (/*currentPage*/ ctx[0] == 'noapp') return 8;
		return 9;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block4 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	footer = new Footer({});

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t0 = space();
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			create_component(usermenu.$$.fragment);
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			if (if_block3) if_block3.c();
			t4 = space();
			if_block4.c();
			t5 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			t6 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t7 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			t8 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			t9 = space();
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			t10 = space();
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			t11 = space();
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			t12 = space();
			create_component(footer.$$.fragment);

			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_panel-header-wrapper mgPlayerJSTest_width-100 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between " + (rootScope.isMicroPlayer
			? 'mgPlayerJSTest_br-white mgPlayerJSTest_panel-header-micro-wrapper'
			: ''));

			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_ege-header");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_ege-panel-header");
			attr(wmgPlayerJSTest_2, "id", "add-branch-view");
			attr(wmgPlayerJSTest_3, "id", "add-history-view");
			attr(wmgPlayerJSTest_4, "id", "automation-url-results");
			attr(wmgPlayerJSTest_5, "id", "mgPlayerJSTest_step-creation-preview-image");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_sidepanel-screen-blackout");
			attr(wmgPlayerJSTest_7, "id", "beacon-creation-preview-image");
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_smarttip-icon");
			attr(wmgPlayerJSTest_8, "id", "guideme-beacon-icon");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			if (if_block0) if_block0.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t0);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			mount_component(usermenu, wmgPlayerJSTest_0, null);
			append(wmgPlayerJSTest_1, t1);
			if (if_block1) if_block1.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t2);
			if (if_block2) if_block2.m(wmgPlayerJSTest_1, null);
			append(wmgPlayerJSTest_1, t3);
			if (if_block3) if_block3.m(wmgPlayerJSTest_1, null);
			insert(target, t4, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, t5, anchor);
			insert(target, wmgPlayerJSTest_2, anchor);
			insert(target, t6, anchor);
			insert(target, wmgPlayerJSTest_3, anchor);
			insert(target, t7, anchor);
			insert(target, wmgPlayerJSTest_4, anchor);
			insert(target, t8, anchor);
			insert(target, wmgPlayerJSTest_5, anchor);
			insert(target, t9, anchor);
			insert(target, wmgPlayerJSTest_6, anchor);
			insert(target, t10, anchor);
			insert(target, wmgPlayerJSTest_7, anchor);
			insert(target, t11, anchor);
			insert(target, wmgPlayerJSTest_8, anchor);
			insert(target, t12, anchor);
			mount_component(footer, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*statusBar*/ ctx[1]) {
				if (if_block0) {
					if (dirty & /*statusBar*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_20();
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(wmgPlayerJSTest_1, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*currentPage*/ ctx[0] !== 'addCategory' && /*currentPage*/ ctx[0] !== 'addGuide' && /*currentPage*/ ctx[0] !== 'addSurveyStep' && /*currentPage*/ ctx[0] !== 'addTransportStep' && /*currentPage*/ ctx[0] !== 'addVideoStep' && /*currentPage*/ ctx[0] !== 'addTextSlideStep' && /*currentPage*/ ctx[0] !== 'copySteps' && !rootScope.automationSelectionMode) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*currentPage*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_19(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(wmgPlayerJSTest_1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*currentPage*/ ctx[0] == 'stepview' || /*currentPage*/ ctx[0] == 'addLinkGuide' || /*currentPage*/ ctx[0] == 'copySteps') {
				if (if_block2) {
					if (dirty & /*currentPage*/ 1) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_18();
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(wmgPlayerJSTest_1, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*currentPage*/ ctx[0] !== 'addCategory' && /*currentPage*/ ctx[0] !== 'addGuide' && /*currentPage*/ ctx[0] !== 'stepview' && /*currentPage*/ ctx[0] !== 'addSurveyStep' && /*currentPage*/ ctx[0] !== 'addTransportStep' && /*currentPage*/ ctx[0] !== 'addLinkGuide' && /*currentPage*/ ctx[0] !== 'addVideoStep' && /*currentPage*/ ctx[0] !== 'addTextSlideStep' && /*currentPage*/ ctx[0] !== 'copySteps') {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty & /*currentPage*/ 1) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_16();
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(wmgPlayerJSTest_1, null);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block4 = if_blocks[current_block_type_index];

				if (!if_block4) {
					if_block4 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block4.c();
				} else {
					if_block4.p(ctx, dirty);
				}

				transition_in(if_block4, 1);
				if_block4.m(t5.parentNode, t5);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(usermenu.$$.fragment, local);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(footer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(usermenu.$$.fragment, local);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(footer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
				detach(t4);
				detach(t5);
				detach(wmgPlayerJSTest_2);
				detach(t6);
				detach(wmgPlayerJSTest_3);
				detach(t7);
				detach(wmgPlayerJSTest_4);
				detach(t8);
				detach(wmgPlayerJSTest_5);
				detach(t9);
				detach(wmgPlayerJSTest_6);
				detach(t10);
				detach(wmgPlayerJSTest_7);
				detach(t11);
				detach(wmgPlayerJSTest_8);
				detach(t12);
			}

			if (if_block0) if_block0.d();
			destroy_component(usermenu);
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if_blocks[current_block_type_index].d(detaching);
			destroy_component(footer, detaching);
		}
	};
}

function create_fragment$6(ctx) {
	let previous_key = /*renderKey*/ ctx[3];
	let key_block_anchor;
	let current;
	let key_block = create_key_block$1(ctx);

	return {
		c() {
			key_block.c();
			key_block_anchor = empty();
		},
		m(target, anchor) {
			key_block.m(target, anchor);
			insert(target, key_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*renderKey*/ 8 && safe_not_equal(previous_key, previous_key = /*renderKey*/ ctx[3])) {
				group_outros();
				transition_out(key_block, 1, 1, noop);
				check_outros();
				key_block = create_key_block$1(ctx);
				key_block.c();
				transition_in(key_block, 1);
				key_block.m(key_block_anchor.parentNode, key_block_anchor);
			} else {
				key_block.p(ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(key_block);
			current = true;
		},
		o(local) {
			transition_out(key_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(key_block_anchor);
			}

			key_block.d(detaching);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let currentPage = '';
	let statusBar = false;
	let breadcrumb = [];
	let renderKey = 0;

	// Function to trigger the re-render
	function resetRenderComponent() {
		$$invalidate(3, renderKey += 1); // Changing the key will force reinitialization
	}

	const breadcrumbDataSubscriber = Gm.breadCrumb.subscribe(value => {
		if (value === false) {
			// value = [];
			Gm.breadCrumb.set([]);
		}

		$$invalidate(2, breadcrumb = value);
		GmCXt.saveToStorage('breadCrumb', value);
	});

	Gm.statusBar.subscribe(val => {
		$$invalidate(1, statusBar = false);

		setTimeout(
			() => {
				$$invalidate(1, statusBar = true);
			},
			10
		);
	});

	const currentPageSubscriber = Gm.CurrentPage.subscribe(value => {
		$$invalidate(0, currentPage = value);
		resetRenderComponent();

		if (value === 'stepview' || value === 'allguides' || value === 'myguides' || value === 'currentpage' || value === 'noapp') {
			GmCXt.saveToStorage('currentPage', value);
		}
	});

	onMount(() => {
		$$invalidate(2, breadcrumb = get_store_value(Gm.breadCrumb));
		$$invalidate(0, currentPage = get_store_value(Gm.CurrentPage));
		get_store_value(Gm.currentTour);

		if (GmCXt.FT.isPlayer && currentPage !== 'noapp') {
			rootScope.setCurrentPage('currentpage');
		} else if (GmCXt.FT.isPlayer && currentPage === 'noapp') {
			rootScope.setCurrentPage('noapp');
		} else {
			if (breadcrumb.length > 0) {
				let category = breadcrumb[breadcrumb.length - 1];

				let customObject = {
					parent: category,
					hasTour: category.has_tour,
					hasChild: category.has_child
				};

				const event = { detail: customObject };
				Gm.routeAction.set({ action: 'forwardTraversal', data: event });
			}

			if (!currentPage || currentPage === false) {
				if (rootScope.allGuideView) {
					rootScope.setCurrentPage('allguides');
				} else {
					rootScope.setCurrentPage('currentpage');
				}
			}
		}
	});

	onDestroy(() => {
		breadcrumbDataSubscriber();
		currentPageSubscriber();
	});

	return [currentPage, statusBar, breadcrumb, renderKey];
}

class Home extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});
	}
}

/* src/components/ForgotPwd.svelte generated by Svelte v4.2.20 */

function create_if_block_1$4(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.captchaLbl + "";
	let t0;
	let t1;
	let captcha;
	let updating_captchaValid;
	let updating_showCaptchaError;
	let updating_inputCaptchaRef;
	let current;

	function captcha_captchaValid_binding(value) {
		/*captcha_captchaValid_binding*/ ctx[12](value);
	}

	function captcha_showCaptchaError_binding(value) {
		/*captcha_showCaptchaError_binding*/ ctx[13](value);
	}

	function captcha_inputCaptchaRef_binding(value) {
		/*captcha_inputCaptchaRef_binding*/ ctx[14](value);
	}

	let captcha_props = {};

	if (/*validCaptcha*/ ctx[2] !== void 0) {
		captcha_props.captchaValid = /*validCaptcha*/ ctx[2];
	}

	if (/*showCapError*/ ctx[3] !== void 0) {
		captcha_props.showCaptchaError = /*showCapError*/ ctx[3];
	}

	if (/*captchaRef*/ ctx[4] !== void 0) {
		captcha_props.inputCaptchaRef = /*captchaRef*/ ctx[4];
	}

	captcha = new Captcha({ props: captcha_props });
	binding_callbacks.push(() => bind(captcha, 'captchaValid', captcha_captchaValid_binding));
	binding_callbacks.push(() => bind(captcha, 'showCaptchaError', captcha_showCaptchaError_binding));
	binding_callbacks.push(() => bind(captcha, 'inputCaptchaRef', captcha_inputCaptchaRef_binding));

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			create_component(captcha.$$.fragment);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_text-align-left mgPlayerJSTest_login-field-label");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_margin-tb-10");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_1, t1);
			mount_component(captcha, wmgPlayerJSTest_1, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*rootScope*/ 1) && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.captchaLbl + "")) set_data(t0, t0_value);
			const captcha_changes = {};

			if (!updating_captchaValid && dirty & /*validCaptcha*/ 4) {
				updating_captchaValid = true;
				captcha_changes.captchaValid = /*validCaptcha*/ ctx[2];
				add_flush_callback(() => updating_captchaValid = false);
			}

			if (!updating_showCaptchaError && dirty & /*showCapError*/ 8) {
				updating_showCaptchaError = true;
				captcha_changes.showCaptchaError = /*showCapError*/ ctx[3];
				add_flush_callback(() => updating_showCaptchaError = false);
			}

			if (!updating_inputCaptchaRef && dirty & /*captchaRef*/ 16) {
				updating_inputCaptchaRef = true;
				captcha_changes.inputCaptchaRef = /*captchaRef*/ ctx[4];
				add_flush_callback(() => updating_inputCaptchaRef = false);
			}

			captcha.$set(captcha_changes);
		},
		i(local) {
			if (current) return;
			transition_in(captcha.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(captcha.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			destroy_component(captcha);
		}
	};
}

function create_fragment$5(ctx) {
	let header;
	let t0;
	let wmgPlayerJSTest_8;
	let h2;
	let t1_value = /*rootScope*/ ctx[0].labels.forgetPassTitl + "";
	let t1;
	let t2;
	let wmgPlayerJSTest_7;
	let form;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_0;
	let t3_value = /*rootScope*/ ctx[0].labels.placeholderEmail + "";
	let t3;
	let t4;
	let input;
	let input_placeholder_value;
	let t5;
	let wmgPlayerJSTest_1;
	let t6_value = /*rootScope*/ ctx[0].labels.emailError + "";
	let t6;
	let t7;
	let t8;
	let wmgPlayerJSTest_4;
	let button0;
	let t9_value = /*rootScope*/ ctx[0].labels.forgetPassTitl + "";
	let t9;
	let button0_aria_disabled_value;
	let button0_aria_label_value;
	let t10;
	let wmgPlayerJSTest_5;
	let button1;
	let t11_value = /*rootScope*/ ctx[0].labels.backToLogin + "";
	let t11;
	let button1_aria_label_value;
	let t12;
	let t13;
	let footer;
	let current;
	let mounted;
	let dispose;
	header = new Header({});
	let if_block0 = !GmCXt.conf.hideCaptcha && create_if_block_1$4(ctx);
	footer = new Footer({});

	return {
		c() {
			create_component(header.$$.fragment);
			t0 = space();
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			h2 = element("h2");
			t1 = text(t1_value);
			t2 = space();
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			form = element("form");
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t3 = text(t3_value);
			t4 = space();
			input = element("input");
			t5 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t6 = text(t6_value);
			t7 = space();
			if (if_block0) if_block0.c();
			t8 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			button0 = element("button");
			t9 = text(t9_value);
			t10 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			button1 = element("button");
			t11 = text(t11_value);
			t12 = space();
			t13 = space();
			create_component(footer.$$.fragment);
			attr(h2, "class", "mgPlayerJSTest_font-size-24 mgPlayerJSTest_text-align-center mgPlayerJSTest_margin-25");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_text-align-left mgPlayerJSTest_login-field-label");
			attr(input, "id", "mgPlayerJSTest_input-forgot-email");
			attr(input, "class", "mgPlayerJSTest_input-type-text mgPlayerJSTest_font-size-16 mgPlayerJSTest_inline-block-vm");
			attr(input, "maxlength", "50");
			attr(input, "spellcheck", "true");
			attr(input, "type", "email");
			attr(input, "placeholder", input_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderEmail);
			attr(input, "name", "email");
			attr(input, "aria-describedby", "mgPlayerJSTest_input-forgot-email-err-msg");
			attr(input, "autocomplete", "email");
			attr(input, "aria-label", "Email ID");
			input.required = true;
			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_input-forgot-email-err-msg");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_error-input-wrapper");
			toggle_class(wmgPlayerJSTest_1, "active", /*emailRequired*/ ctx[7]);
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_input-email-wrapper mgPlayerJSTest_margin-tb-10");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_signin-form-input");
			attr(button0, "id", "mgPlayerJSTest_btn-reset-pass");
			attr(button0, "type", "button");
			attr(button0, "class", "mgPlayerJSTest_btn-default mgPlayerJSTest_font-size-15");
			attr(button0, "aria-disabled", button0_aria_disabled_value = /*emailRequired*/ ctx[7] || !/*validCaptcha*/ ctx[2]);
			attr(button0, "aria-label", button0_aria_label_value = /*rootScope*/ ctx[0].labels.forgetPassTitl);
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_btn-login-wrapper mgPlayerJSTest_text-align-center");
			attr(button1, "id", "mgPlayerJSTest_label-forgot-back-to-login");
			attr(button1, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_back-to-login mgPlayerJSTest_theme-color mgPlayerJSTest_text-align-center mgPlayerJSTest_cursor-pointer mgPlayerJSTest_font-weight-550 mgPlayerJSTest_inline-block-vm");
			attr(button1, "type", "button");
			attr(button1, "aria-label", button1_aria_label_value = /*rootScope*/ ctx[0].labels.backToLogin);
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_width-100 mgPlayerJSTest_text-align-center");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_signin-form-container");
			attr(form, "name", "forgotPasswordForm");
			attr(form, "autocomplete", "off");
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_signin-page-wrapper");
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_ege-panel-main-container mgPlayerJSTest_signin-page-container mgPlayerJSTest_forgot-password-page-container");
		},
		m(target, anchor) {
			mount_component(header, target, anchor);
			insert(target, t0, anchor);
			insert(target, wmgPlayerJSTest_8, anchor);
			append(wmgPlayerJSTest_8, h2);
			append(h2, t1);
			append(wmgPlayerJSTest_8, t2);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_7, form);
			append(form, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t3);
			append(wmgPlayerJSTest_2, t4);
			append(wmgPlayerJSTest_2, input);
			set_input_value(input, /*email*/ ctx[1]);
			/*input_binding*/ ctx[11](input);
			append(wmgPlayerJSTest_2, t5);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t6);
			append(wmgPlayerJSTest_3, t7);
			if (if_block0) if_block0.m(wmgPlayerJSTest_3, null);
			append(wmgPlayerJSTest_6, t8);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, button0);
			append(button0, t9);
			append(wmgPlayerJSTest_6, t10);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_5, button1);
			append(button1, t11);
			append(wmgPlayerJSTest_8, t12);
			insert(target, t13, anchor);
			mount_component(footer, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[10]),
					listen(button0, "click", /*sendCallToVerifyUser*/ ctx[9]),
					listen(button1, "click", function () {
						if (is_function(/*rootScope*/ ctx[0].goToLogin)) /*rootScope*/ ctx[0].goToLogin.apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			if ((!current || dirty & /*rootScope*/ 1) && t1_value !== (t1_value = /*rootScope*/ ctx[0].labels.forgetPassTitl + "")) set_data(t1, t1_value);
			if ((!current || dirty & /*rootScope*/ 1) && t3_value !== (t3_value = /*rootScope*/ ctx[0].labels.placeholderEmail + "")) set_data(t3, t3_value);

			if (!current || dirty & /*rootScope*/ 1 && input_placeholder_value !== (input_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderEmail)) {
				attr(input, "placeholder", input_placeholder_value);
			}

			if (dirty & /*email*/ 2 && input.value !== /*email*/ ctx[1]) {
				set_input_value(input, /*email*/ ctx[1]);
			}

			if ((!current || dirty & /*rootScope*/ 1) && t6_value !== (t6_value = /*rootScope*/ ctx[0].labels.emailError + "")) set_data(t6, t6_value);

			if (!current || dirty & /*emailRequired*/ 128) {
				toggle_class(wmgPlayerJSTest_1, "active", /*emailRequired*/ ctx[7]);
			}

			if (!GmCXt.conf.hideCaptcha) if_block0.p(ctx, dirty);
			if ((!current || dirty & /*rootScope*/ 1) && t9_value !== (t9_value = /*rootScope*/ ctx[0].labels.forgetPassTitl + "")) set_data(t9, t9_value);

			if (!current || dirty & /*emailRequired, validCaptcha*/ 132 && button0_aria_disabled_value !== (button0_aria_disabled_value = /*emailRequired*/ ctx[7] || !/*validCaptcha*/ ctx[2])) {
				attr(button0, "aria-disabled", button0_aria_disabled_value);
			}

			if (!current || dirty & /*rootScope*/ 1 && button0_aria_label_value !== (button0_aria_label_value = /*rootScope*/ ctx[0].labels.forgetPassTitl)) {
				attr(button0, "aria-label", button0_aria_label_value);
			}

			if ((!current || dirty & /*rootScope*/ 1) && t11_value !== (t11_value = /*rootScope*/ ctx[0].labels.backToLogin + "")) set_data(t11, t11_value);

			if (!current || dirty & /*rootScope*/ 1 && button1_aria_label_value !== (button1_aria_label_value = /*rootScope*/ ctx[0].labels.backToLogin)) {
				attr(button1, "aria-label", button1_aria_label_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(if_block0);
			transition_in(footer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(header.$$.fragment, local);
			transition_out(if_block0);
			transition_out(footer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(wmgPlayerJSTest_8);
				detach(t13);
			}

			destroy_component(header, detaching);
			/*input_binding*/ ctx[11](null);
			if (if_block0) if_block0.d();
			destroy_component(footer, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let email = '';
	let validCaptcha = false;
	let showCapError = false;
	let captchaRef;
	let pwd = '';
	let cpwd = '';
	let emailRequired = false;
	rootScope.currentView = 'forgot-password-view';
	let inputEmailRef;

	function forgotPassword() {
		let data = { email };

		function onSuccess(response) {
			let str = rootScope.labels.otpSentDesc + ' ' + GmCXt.conf.adminEmail;

			modal.open(
				str,
				'info',
				function () {
					rootScope.goToLogin();
				},
				false,
				false,
				false,
				rootScope.labels.forgetPassTitl
			);
		}

		function onFail(data) {
			rootScope.showPopup(data.message);
		}

		Gm.loading.set(true);
		api.forgetPassword(data, onSuccess, onFail);
	}

	function validateEmail() {
		const pattern = /^[^\s@]+@[^\s@]+\.[^\s@]{2,}$/;
		return email.trim() !== '' && pattern.test(email);
	}

	function sendCallToVerifyUser() {
		$$invalidate(3, showCapError = false);
		$$invalidate(7, emailRequired = false);

		if (!validCaptcha && !GmCXt.conf.hideCaptcha) {
			$$invalidate(3, showCapError = true);
			captchaRef?.focus();
			return;
		}

		if (!validateEmail()) {
			$$invalidate(7, emailRequired = true);
			inputEmailRef?.focus();
			return;
		}

		forgotPassword();
	}

	function input_input_handler() {
		email = this.value;
		$$invalidate(1, email);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEmailRef = $$value;
			$$invalidate(8, inputEmailRef);
		});
	}

	function captcha_captchaValid_binding(value) {
		validCaptcha = value;
		$$invalidate(2, validCaptcha);
	}

	function captcha_showCaptchaError_binding(value) {
		showCapError = value;
		$$invalidate(3, showCapError);
	}

	function captcha_inputCaptchaRef_binding(value) {
		captchaRef = value;
		$$invalidate(4, captchaRef);
	}

	function input0_input_handler() {
		email = this.value;
		$$invalidate(1, email);
	}

	function input1_input_handler() {
		email = this.value;
		$$invalidate(1, email);
	}

	function input2_input_handler() {
		pwd = this.value;
		$$invalidate(5, pwd);
	}

	function input3_input_handler() {
		cpwd = this.value;
		$$invalidate(6, cpwd);
	}

	return [
		rootScope,
		email,
		validCaptcha,
		showCapError,
		captchaRef,
		pwd,
		cpwd,
		emailRequired,
		inputEmailRef,
		sendCallToVerifyUser,
		input_input_handler,
		input_binding,
		captcha_captchaValid_binding,
		captcha_showCaptchaError_binding,
		captcha_inputCaptchaRef_binding,
		input0_input_handler,
		input1_input_handler,
		input2_input_handler,
		input3_input_handler
	];
}

class ForgotPwd extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});
	}
}

/* src/components/Bot.svelte generated by Svelte v4.2.20 */

function create_fragment$4(ctx) {
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let usermenu;
	let t0;
	let wmgPlayerJSTest_15;
	let wmgPlayerJSTest_11;
	let wmgPlayerJSTest_10;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_3;
	let raw_value = /*rootScope*/ ctx[0].svgs.iconBack + "";
	let t1;
	let wmgPlayerJSTest_5;
	let wmgPlayerJSTest_4;
	let t2_value = /*rootScope*/ ctx[0].labels.back + "";
	let t2;
	let t3;
	let wmgPlayerJSTest_7;
	let span;
	let t4_value = /*rootScope*/ ctx[0].labels.chatbot + "";
	let t4;
	let t5;
	let wmgPlayerJSTest_8;
	let t6;
	let wmgPlayerJSTest_9;
	let t7;
	let wmgPlayerJSTest_14;
	let t9;
	let footer;
	let current;
	let mounted;
	let dispose;
	usermenu = new UserMenu({});
	footer = new Footer({});

	return {
		c() {
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			create_component(usermenu.$$.fragment);
			t0 = space();
			wmgPlayerJSTest_15 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_11 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_10 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			t1 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			t2 = text(t2_value);
			t3 = space();
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			span = element("span");
			t4 = text(t4_value);
			t5 = space();
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			t6 = space();
			wmgPlayerJSTest_9 = element("wmgPlayerJSTest_");
			t7 = space();
			wmgPlayerJSTest_14 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_14.innerHTML = `<wmgPlayerJSTest_ id="mgPlayerJSTest_botdiv"></wmgPlayerJSTest_> <wmgPlayerJSTest_ id="mgPlayerJSTest_div_bottom" class="mgPlayerJSTest_div-bottom"></wmgPlayerJSTest_>`;
			t9 = space();
			create_component(footer.$$.fragment);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_width-100");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_panel-header-wrapper mgPlayerJSTest_width-100 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
			toggle_class(wmgPlayerJSTest_1, "mgPlayerJSTest_bg-white", /*rootScope*/ ctx[0].isMicroPlayer);
			toggle_class(wmgPlayerJSTest_1, "mgPlayerJSTest_panel-header-micro-wrapper", /*rootScope*/ ctx[0].isMicroPlayer);
			attr(wmgPlayerJSTest_2, "id", "mgPlayerJSTest_ege-header");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_ege-panel-header");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_ege-inline-block-vm");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-left");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_ege-inline-block-vm mgPlayerJSTest_chat-back-btn mgPlayerJSTest_position-relative");
			attr(span, "class", "mgPlayerJSTest_mychat-label mgPlayerJSTest_ege-inline-block-vt");
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_chatbot-add-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_ege-clear");
			attr(wmgPlayerJSTest_9, "class", "mgPlayerJSTest_ege-clear");
			attr(wmgPlayerJSTest_11, "class", "mgPlayerJSTest_chat-page-header mgPlayerJSTest_list-page-header");
			toggle_class(wmgPlayerJSTest_11, "mgPlayerJSTest_chat-page-header-miniplayer", /*rootScope*/ ctx[0].isMicroPlayer);
			attr(wmgPlayerJSTest_14, "id", "mgPlayerJSTest_uilb-main-container");
			attr(wmgPlayerJSTest_14, "scroll-bottom", "mgPlayerJSTest_uilb-main-container");
			attr(wmgPlayerJSTest_14, "class", "mgPlayerJSTest_uilb-main-container");
			attr(wmgPlayerJSTest_15, "class", "mgPlayerJSTest_ege-panel-main-container mgPlayerJSTest_chatbot-page-container");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_2, anchor);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			mount_component(usermenu, wmgPlayerJSTest_0, null);
			insert(target, t0, anchor);
			insert(target, wmgPlayerJSTest_15, anchor);
			append(wmgPlayerJSTest_15, wmgPlayerJSTest_11);
			append(wmgPlayerJSTest_11, wmgPlayerJSTest_10);
			append(wmgPlayerJSTest_10, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_3);
			wmgPlayerJSTest_3.innerHTML = raw_value;
			append(wmgPlayerJSTest_6, t1);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, t2);
			append(wmgPlayerJSTest_10, t3);
			append(wmgPlayerJSTest_10, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_7, span);
			append(span, t4);
			append(wmgPlayerJSTest_10, t5);
			append(wmgPlayerJSTest_10, wmgPlayerJSTest_8);
			append(wmgPlayerJSTest_10, t6);
			append(wmgPlayerJSTest_10, wmgPlayerJSTest_9);
			append(wmgPlayerJSTest_15, t7);
			append(wmgPlayerJSTest_15, wmgPlayerJSTest_14);
			append(wmgPlayerJSTest_15, t9);
			mount_component(footer, wmgPlayerJSTest_15, null);
			current = true;

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_6, "click", /*onBack*/ ctx[1]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!current || dirty[0] & /*rootScope*/ 1) {
				toggle_class(wmgPlayerJSTest_1, "mgPlayerJSTest_bg-white", /*rootScope*/ ctx[0].isMicroPlayer);
			}

			if (!current || dirty[0] & /*rootScope*/ 1) {
				toggle_class(wmgPlayerJSTest_1, "mgPlayerJSTest_panel-header-micro-wrapper", /*rootScope*/ ctx[0].isMicroPlayer);
			}

			if ((!current || dirty[0] & /*rootScope*/ 1) && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.iconBack + "")) wmgPlayerJSTest_3.innerHTML = raw_value;			if ((!current || dirty[0] & /*rootScope*/ 1) && t2_value !== (t2_value = /*rootScope*/ ctx[0].labels.back + "")) set_data(t2, t2_value);
			if ((!current || dirty[0] & /*rootScope*/ 1) && t4_value !== (t4_value = /*rootScope*/ ctx[0].labels.chatbot + "")) set_data(t4, t4_value);

			if (!current || dirty[0] & /*rootScope*/ 1) {
				toggle_class(wmgPlayerJSTest_11, "mgPlayerJSTest_chat-page-header-miniplayer", /*rootScope*/ ctx[0].isMicroPlayer);
			}
		},
		i(local) {
			if (current) return;
			transition_in(usermenu.$$.fragment, local);
			transition_in(footer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(usermenu.$$.fragment, local);
			transition_out(footer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_2);
				detach(t0);
				detach(wmgPlayerJSTest_15);
			}

			destroy_component(usermenu);
			destroy_component(footer);
			mounted = false;
			dispose();
		}
	};
}

function onRemoveElement(elem) {
	let element = elem.parentElement;
	if (element.parentElement !== null) element.parentElement.removeChild(element);
}

function addRangeQuestion(question) {
	let optList = [];

	for (let i = question.options[0]; i <= question.options[1]; i++) {
		optList.push({
			text: i,
			value: i,
			cssClass: 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight mgPlayerJSTest_uilb-button-opt-range'
		});
	}

	return optList;
}

function addRateQuestion(question) {
	let optList = [];

	for (let i = question.options[0]; i <= question.options[1]; i++) {
		optList.push({
			id: 'mgPlayerJSTest_rate-' + i,
			text: '&#9733;',
			value: i,
			cssClass: 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight mgPlayerJSTest_uilb-button-opt-range'
		});
	}

	return optList;
}

function addRateAnswer(question, ans) {
	let html = "<wmgPlayerJSTest_ class='mgPlayerJSTest_rating' style='font-size:20px;'>";

	for (let i = question.options[0]; i <= question.options[1]; i++) {
		let className = 'mgPlayerJSTest_lbl-btn mgPlayerJSTest_stars-rate';

		if (i < parseInt(ans) + 1) {
			html += "<button class='" + className + "' id='mgPlayerJSTest_rate-" + i + "' aria-label='rate' >&#9733;</button>";
		} else {
			html += "<button class='" + className + "' id='mgPlayerJSTest_rate-" + i + "' aria-label='rate' >&#9734;</button>";
		}
	}

	html += '</wmgPlayerJSTest_>';
	return html;
}

function filterTourBytext(t, word) {
	let tlist = t.filter(function (r) {
		if (r.tour_title.toLowerCase().indexOf(word.toLowerCase()) !== -1) {
			return r;
		}
	});

	return tlist;
}

function instance$4($$self, $$props, $$invalidate) {
	class UILandingBot {
		constructor(node) {
			this.domNode = node;
			this.domNode.classList.add('mgPlayerJSTest_uilb');
		}

		createtypingodots() {
			const typediv = document.createElement('wmgPlayerJSTest_');
			typediv.setAttribute('class', 'mgPlayerJSTest_typing-indicator mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft');
			const typespan1 = document.createElement('mgPlayerJSTest_uilb-span');
			const typespan2 = document.createElement('mgPlayerJSTest_uilb-span');
			const typespan3 = document.createElement('mgPlayerJSTest_uilb-span');
			typediv.appendChild(typespan1);
			typediv.appendChild(typespan2);
			typediv.appendChild(typespan3);
			this.domNode.appendChild(typediv);
			return typediv;
		}

		createContainer({ human, cssClass, delay, resolve }) {
			const container = document.createElement('wmgPlayerJSTest_');
			container.className = `mgPlayerJSTest_uilb-container ${human ? 'human' : 'bot'} ${cssClass}`;
			container.style.opacity = 0;
			container.style.transform = `translateX(${human ? '' : '-'}8%)`;

			setTimeout(
				() => {
					this.domNode.appendChild(container);
				},
				delay
			);

			setTimeout(
				() => {
					container.style.opacity = 1;
					container.style.transform = 'translateX(0)';

					if (resolve) {
						resolve(container);
					}
				},
				delay + 200
			);

			return container;
		}

		htmlToText(text) {
			return text ? String(text).replace(/<[^>]+>/gm, '') : '';
		}

		message({ id, content, cssClass, delay, human, isHtmlContent }) {
			return new Promise((resolve, reject) => {
					const container = this.createContainer({
						human,
						cssClass,
						delay,
						isHtmlContent,
						resolve
					});

					const message = document.createElement('wmgPlayerJSTest_');
					if (id !== '') message.setAttribute('id', id);
					message.className = `mgPlayerJSTest_uilb-message mgPlayerJSTest_showtextdelay  ${human ? 'human' : 'bot'} ${cssClass}`;

					if (id !== 'msg_search' && id !== 'msg-vid' && !isHtmlContent) {
						if (content === '') {
							message.innerHTML = "<wmgPlayerJSTest_ id='mgPlayerJSTest_wave'><span class='mgPlayerJSTest_dot'></span><span class='mgPlayerJSTest_dot'></span><span class='mgPlayerJSTest_dot'></span></wmgPlayerJSTest_>";
						} else {
							message.innerHTML = "<wmgPlayerJSTest_ id='mgPlayerJSTest_hideMe'><wmgPlayerJSTest_ id='mgPlayerJSTest_wave'><span class='mgPlayerJSTest_dot'></span><span class='mgPlayerJSTest_dot'></span><span class='mgPlayerJSTest_dot'></span></wmgPlayerJSTest_></wmgPlayerJSTest_>";
						}

						message.innerHTML += this.htmlToText(content);
					} else if (isHtmlContent) {
						message.innerHTML = content;
					} else {
						message.innerHTML = this.htmlToText(content);
					}

					container.appendChild(message);

					if (document.getElementById('mgPlayerJSTest_uilb-main-container')) {
						document.getElementById('mgPlayerJSTest_uilb-main-container').scrollTop = 300;
					}
				});
		}

		action(obj) {
			return this[`${obj.type}Action`](obj);
		}

		buttonAction({ id, items, delay, human, cssClass, tag }) {
			const multiValue = [];

			return new Promise((resolve, reject) => {
					const container = this.createContainer({ human, delay, cssClass: 'no-icon' });
					if (id !== '') container.id = id;
					const form = document.createElement('form');
					form.className = `mgPlayerJSTest_uilb-action ${human ? 'human' : 'bot'} ${cssClass}`;
					form.addEventListener('submit', e => e.preventDefault());

					if (id === 'mgPlayerJSTest_uilb-btn-action') {
						const imgback = document.createElement('wmgPlayerJSTest_');
						imgback.id = 'mgPlayerJSTest_uilb-back-chat';
						imgback.title = 'Back';
						imgback.setAttribute('class', 'mgPlayerJSTest_uilb-action-opt-back');
						const inputbackbtn = document.createElement('button');
						inputbackbtn.id = 'mgPlayerJSTest_uilb-back-btn';
						inputbackbtn.className = 'mgPlayerJSTest_uilb-back';
						imgback.appendChild(inputbackbtn);
						const lblback = document.createElement('wmgPlayerJSTest_');
						lblback.innerHTML = 'Back';
						lblback.setAttribute('class', 'mgPlayerJSTest_uilb-back-label');
						imgback.appendChild(lblback);
						form.style = 'width: 360px;height: 100px;overflow: hidden;';
						container.appendChild(imgback);
					}

					let items_cnt = 0;

					items.forEach(item => {
						const button = document.createElement('button');
						if (item.id !== '') button.id = item.id;
						button.className = `mgPlayerJSTest_uilb-button ${item.cssClass}`;
						button.type = 'button';
						button.innerHTML = item.text;
						button.tag = item.tag;

						if (id === 'mgPlayerJSTest_uilb-btn-action') {
							button.id = `mgPlayerJSTest_uilb-btnresult${items_cnt}`;
							button.style.display = items_cnt === 0 || items_cnt === 1 ? 'block' : 'none';
						}

						button.title = item.text;

						button.addEventListener('click', ({ target }) => {
							if (item.tag !== 'multiselect') {
								if (multiValue && multiValue.length) {
									resolve(multiValue);
								} else {
									resolve(item.value);
								}

								container.style.opacity = 0;
								const cont = document.getElementById('mgPlayerJSTest_uilb-searchagain');

								if (cont && button.id !== 'mgPlayerJSTest_uilb-searchagain' && button.className.includes('mgPlayerJSTest_uilb-button-opt')) {
									setTimeout(
										() => {
											cont.parentElement.removeChild(cont);
											container.parentElement.removeChild(container);
										},
										200
									);
								} else {
									setTimeout(() => this.domNode.removeChild(container), 200);
								}
							} else {
								if (!multiValue.includes(item.value)) {
									multiValue.push(item.value);
									target.innerHTML = target.title.replace('&#9744;', '&#9989;');
								} else {
									const ind = multiValue.indexOf(item.value);

									if (ind > -1) {
										multiValue.splice(ind, 1);
									}

									target.innerHTML = target.title.replace('&#9989;', '&#9744;');
								}
							}
						});

						form.appendChild(button);
						items_cnt += 1;
					});

					container.appendChild(form);

					if (id === 'mgPlayerJSTest_uilb-btn-action' && items_cnt > 2) {
						const divtotalresult = document.createElement('wmgPlayerJSTest_');
						divtotalresult.id = 'uilb_totalresult';
						divtotalresult.style.fontSize = '12px';
						divtotalresult.style.marginTop = '10px';
						divtotalresult.innerHTML = `Total Guides: ${items_cnt}`;
						container.appendChild(divtotalresult);
						const imglft = document.createElement('wmgPlayerJSTest_');
						imglft.id = 'mgPlayerJSTest_uilb-leftarrow';
						container.appendChild(imglft);
						const imgrgt = document.createElement('wmgPlayerJSTest_');
						imgrgt.id = 'mgPlayerJSTest_uilb-rightarrow';
						imgrgt.style.display = 'none';
						container.appendChild(imgrgt);
					}
				});
		}

		textAction({ tag, validate, delay, human, cssClass }) {
			return new Promise((resolve, reject) => {
					const container = this.createContainer({ human, delay, cssClass: 'no-icon' });
					const inputbackdiv = document.createElement('wmgPlayerJSTest_');
					inputbackdiv.id = 'mgPlayerJSTest_uilb-back-chat';
					inputbackdiv.title = 'Back';
					inputbackdiv.setAttribute('class', 'mgPlayerJSTest_uilb-action-opt-back');
					inputbackdiv.setAttribute('style', 'margin-left: -60px; margin-top: -10px;');
					const inputbackbtn = document.createElement('button');
					inputbackbtn.id = 'mgPlayerJSTest_uilb-back-btn';
					inputbackbtn.className = 'mgPlayerJSTest_uilb-back';
					inputbackdiv.appendChild(inputbackbtn);
					const lblback = document.createElement('wmgPlayerJSTest_');
					lblback.innerHTML = 'Back';
					lblback.setAttribute('class', 'mgPlayerJSTest_uilb-back-label');
					inputbackdiv.appendChild(lblback);
					const inputdiv = document.createElement('wmgPlayerJSTest_');
					inputdiv.className = 'mgPlayerJSTest_uilb-text-div';
					const input = document.createElement('input');
					input.className = 'mgPlayerJSTest_uilb-text';
					input.id = 'txtsearch';
					input.type = 'text';
					input.placeholder = 'Type here';
					input.autocomplete = 'off';
					input.tag = tag;
					input.validate = validate;
					const entericon = document.createElement('wmgPlayerJSTest_');
					entericon.id = 'mgPlayerJSTest_uilb-txt-enter';
					entericon.className = 'mgPlayerJSTest_uilb-enter';
					inputdiv.appendChild(inputbackdiv);
					inputdiv.appendChild(input);
					inputdiv.appendChild(entericon);
					container.appendChild(inputdiv);
				});
		}
	}

	function onBack() {
		Gm.activeView.set('home');
	}

	let scope_tours = [];
	rootScope.botTourPlayList = [];
	let allBotGuides = [];
	let ansData = [];
	GmCXt.reduceSidePanelWidth();
	let uilb;
	let currentTour;
	let surveyQuestionCount = 0;
	let surveyQList = [];
	let surveyQuestionIndex = -1;
	let surveyBranchNodes = [];
	let currentBSPageIndex = -1;
	let as = GmCXt.appList['app:' + GmCXt.activeAppId].settings;
	if (GmCXt.isEmpty(rootScope.chatLabels)) rootScope.setDefaultChatLabels();
	rootScope.getChatLabels(as.chatLabels);

	function reInitSurveyVar() {
		surveyQuestionCount = 0;
		surveyQList = [];
		surveyQuestionIndex = -1;
		surveyBranchNodes = [];
		currentBSPageIndex = -1;
		ansData = [];
	}

	let myChatStr = {
		noDataFound: 'No Data Found'};

	function showMsg(id, msg, css, delay, isHtmlContent) {
		return uilb.message({
			id,
			content: msg,
			cssClass: css,
			isHtmlContent,
			delay
		});
	}

	function showHumanMsg(str, isHtmlContent) {
		return uilb.message({
			human: true,
			content: str,
			cssClass: 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight',
			isHtmlContent,
			delay: 0
		});
	}

	function showActionButton(id, css, itemlist, delay) {
		return uilb.action({
			id,
			type: 'button',
			cssClass: css,
			items: itemlist,
			delay
		});
	}

	function handleGetBotConvDetail(data, cb) {
		let sendResponse = function (r) {
			if (cb) {
				cb(r);
			}
		};

		let objToSend = {};
		objToSend.conversation_code = data.conversation.conversationCode;
		objToSend.user = rootScope.user;
		let applist = GmCXt.appList;
		let activeAppId = GmCXt.activeAppId;

		if (data.isExit) {
			objToSend.app_code = '';
		} else {
			objToSend.app_code = applist['app:' + activeAppId].external_id;
		}

		GmCXt.api.getGetBotConv(objToSend).then(sendResponse).catch(function (result) {
			sendResponse(false);
		});
	}

	function showSurveyQuestion(qlist, tour) {
		if (surveyQuestionCount !== surveyQuestionIndex) {
			let ques = qlist[surveyQuestionIndex];
			displaySurveyQues(ques, tour);
		}
	}

	function getSurveyQuestion(tour) {
		let data = {};
		data.conversation = tour.tour_settings.conversation;

		handleGetBotConvDetail(data, function (res) {
			surveyQuestionCount = res.data.questions.length;
			surveyQList = res.data.questions;
			surveyQuestionIndex++;
			showSurveyQuestion(surveyQList, tour);
		});
	}

	function showNextBotStep(step) {
		let nextStepId = GmCXt.getTail(step.step_id, currentTour.tour_settings.play_structure, null, currentTour);

		if (nextStepId) {
			let nstep = GmCXt.getNextBotStepFromTour(nextStepId, currentTour);

			if (nstep) {
				showBotStepQuestion(currentTour.steps, nstep.step_id);
			} else {
				endMessage();
			}
		} else {
			endMessage();
		}
	}

	function updateStepInCurrentTour(step, botData) {
		for (let cs = 0; cs < currentTour.steps.length; cs++) {
			if (step.step_id === currentTour.steps[cs].step_id) {
				currentTour.steps[cs].step_settings.automation.defaultData = botData;
				currentTour.steps[cs].step_settings.automation.enableDefaultData = true;
				currentTour.steps[cs].step_settings.automation.hasHumanInteraction = false;
			}
		}
	}

	function showSelectOption(question, options, step) {
		showMsg('', question, 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft', 0).then(function () {
			let optList = [];

			if (options && options.length > 0) {
				mg$.each(options, function (key, opt) {
					optList.push({
						text: opt.name,
						value: opt,
						cssClass: 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight mgPlayerJSTest_uilb-button-opt'
					});
				});

				showActionButton('', 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight', optList, 200).then(function (res) {
					updateStepInCurrentTour(step, res);

					showHumanMsg(res.name).then(function () {
						showNextBotStep(step);
					});
				});
			}
		});
	}

	function showLinkGuideQuestion(nstep, resultCB) {
		let ts = [];

		function finalcb(steps) {
			currentTour.steps = steps;

			if (resultCB) {
				resultCB(ts[0]);
			}
		}

		function cb(ps) {
			if (!ts.length) return;
			currentTour.tour_settings.play_structure = ps;
			GmCXt.concatLinkGuideSteps(ts, currentTour, nstep.step_id, finalcb);
		}

		let d = { tour_id: nstep.step_settings.tour_id };

		GmCXt.getSteps(d).then(function (tour) {
			if (!tour) {
				return;
			}

			let playerInstance = {
				currentStepId: nstep.step_id,
				playStructure: currentTour.tour_settings.play_structure
			};

			ts = tour.steps;
			GmCXt.updatePlayStructureLinkGuide(tour, playerInstance, cb);
		});
	}

	function showBotStepQuestion(steps, step_id) {
		let botStepId;

		if (step_id) {
			botStepId = step_id;
		} else {
			botStepId = steps[0].step_id;
		}

		let botStep = GmCXt.getStepFromTourData(botStepId, currentTour);

		if (botStep && botStep.step_settings && botStep.step_settings.automation && botStep.step_settings.automation.enableBot && botStep.step_settings.automation.botQuestion) {
			let ss = botStep.step_settings;
			let ques = ss.automation.botQuestion;

			if (ss.element && ss.element.targetInfo && ss.element.targetInfo.tagName === 'SELECT' && ss.element.elOptions && ss.element.elOptions.length > 0) {
				showSelectOption(ques, ss.element.elOptions, botStep);
			} else if (ss.branch && ss.branch.length > 0) {
				showBranchQuestions(ques, ss.branch, botStep);
			} else if (botStep.step_type !== GmCXt.STEP_TYPE_GUIDE) {
				showMsg('', ques, 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft', 0).then(function () {
					uilb.action({
						type: 'text',
						cssClass: 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft',
						delay: 100,
						tag: botStep
					});
				});
			}
		} else if (botStep.step_type === GmCXt.STEP_TYPE_GUIDE) {
			showLinkGuideQuestion(botStep, function (lstep) {
				showBotStepQuestion(currentTour.steps, lstep.step_id);
			});
		} else if (currentTour.tour_type.includes('onboarding_tour')) {
			if (!GmCXt.isEmpty(botStep.step_settings.tutorialUploadUrl) && currentTour.tour_settings.tutorial_tour_type === 'upload') {
				let tutUrl = botStep.step_settings.tutorialUploadUrl;

				if (tutUrl.indexOf(GmCXt.conf.cdn) !== -1) {
					tutUrl = botStep.step_settings.tutorialUploadUrl + GmCXt.getCdnSign();
				}

				showMsg('', "<a alt='' href='" + tutUrl + "' target='_blank' >" + botStep.step_settings.tutorialUploadUrl + '</a> ', 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft', 0, true).then(function () {
					showNextBotStep(botStep);
				});
			} else {
				let tutInlineHtml = "<wmgPlayerJSTest_ class='mgPlayerJSTest_chat-tg-content-wrapper'>";
				let stepText = '';

				if (botStep.step_description) {
					stepText = GmCXt.replaceVariableWithValue(GmCXt.updateOrgAndAddSignature(botStep.step_description));
				}

				if (botStep && botStep.step_video > 0 && botStep.step_video_url) {
					tutInlineHtml = tutInlineHtml + "<wmgPlayerJSTest_ class='mgPlayerJSTest_chat-guide-info-wrapper mgPlayerJSTest_video-info-wrapper'>" + "<video controls autoplay controlsList='nodownload' disablePictureInPicture >" + "<source src='" + botStep.step_video_url + GmCXt.getCdnSign() + "' type='video/mp4'>" + '</video></wmgPlayerJSTest_>';
				} else if (botStep && botStep.image_url.indexOf('default') < 0) {
					tutInlineHtml = tutInlineHtml + "<wmgPlayerJSTest_ class='mgPlayerJSTest_chat-info-wrapper mgPlayerJSTest_img-info-wrapper'>" + "<img class='mgPlayerJSTest_chat-tg-image' src='" + botStep.image_url + GmCXt.getCdnSign() + "' /></wmgPlayerJSTest_>";
				}

				tutInlineHtml = tutInlineHtml + "<wmgPlayerJSTest_ class='mgPlayerJSTest_chat-tg-step-content' > " + stepText + ' </wmgPlayerJSTest_>' + '</wmgPlayerJSTest_>';

				showMsg('', tutInlineHtml, 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft', 0, true).then(function () {
					showNextBotStep(botStep);
				});
			}
		} else if (GmCXt.isLastStep(botStep.step_id, currentTour.tour_settings.play_structure)) {
			endMessage();
		} else if (botStep) {
			let nstep = GmCXt.getNextBotStepFromTour(botStep.step_id, currentTour);

			if (nstep) {
				showBotStepQuestion(currentTour.steps, nstep.step_id);
			} else {
				endMessage();
			}
		}
	}

	function processBotGuides(_tours) {
		let guides = rootScope.filterBotGuides(_tours);

		if (guides && guides.length) {
			scope_tours = guides;
			let guidesarr = [];

			mg$.each(scope_tours, function (key, tour) {
				guidesarr.push({
					text: tour.tour_title,
					value: tour,
					cssClass: 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight mgPlayerJSTest_uilb-button-options'
				});
			});

			showActionButton('', 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInUp', guidesarr, 200).then(function (res) {
				currentTour = res;

				showHumanMsg(currentTour.tour_title).then(function (res) {
					let params = {
						tour_id: currentTour.tour_id,
						category_id: currentTour.category_id
					};

					api.getTour(params, function (t) {
						currentTour = t;

						if (!GmCXt.containBranchStep(currentTour)) {
							currentTour.tour_settings.play_structure = GmCXt.buildGuidePlayStructure(currentTour);
						}

						if (GmCXt.isBotGuide(currentTour)) {
							getSurveyQuestion(currentTour);
						} else {
							showBotStepQuestion(currentTour.steps);
						}
					});
				});
			});
		} else {
			showMsg('', myChatStr.noDataFound, 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft', 100);
		}
	}

	function getBotGuides() {
		let res = rootScope.readLocalCT(rootScope.pageUrl, GmCXt.pageTitle);

		if (res && res.length) {
			allBotGuides = res;
			processBotGuides(res);
		} else {
			let param = { url: rootScope.pageUrl };

			api.getContextualTour(param, function (r) {
				GmCXt.log(30, 'FETCHED tours from API');
				res = rootScope.processContextualGuide(r, param.url);
				allBotGuides = res;
				processBotGuides(res);
			});
		}
	}

	function checkIfAllowTourPlay() {
		let allowPlay = true;

		if (rootScope.botTourPlayList && rootScope.botTourPlayList.length) {
			let btlist = rootScope.botTourPlayList.filter(function (t) {
				if (!(GmCXt.isBotGuide(t) || t.tour_type.indexOf('onboarding_tour') !== -1)) {
					return t;
				}
			});

			$$invalidate(0, rootScope.botTourPlayList = btlist, rootScope);

			if (rootScope.botTourPlayList.length > 0) {
				allowPlay = true;
			} else {
				allowPlay = false;
			}
		}

		return allowPlay;
	}

	function endMessage() {
		showMsg('', rootScope.chatLabels.botEndingMessage, 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft', 500).then(function () {
			let itemlist2 = [
				{
					text: rootScope.labels.btnYes,
					value: rootScope.labels.btnYes,
					cssClass: 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInUp mgPlayerJSTest_uilb-button-opt-yesno'
				},
				{
					text: rootScope.labels.btnNo,
					value: rootScope.labels.btnNo,
					cssClass: 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInUp mgPlayerJSTest_uilb-button-opt-yesno'
				}
			];

			showActionButton('', 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInUp', itemlist2, 100).then(function (res) {
				rootScope.botTourPlayList.push(currentTour);

				//store bot tour list;
				GmCXt.storage().set({
					botTourPlayList: rootScope.botTourPlayList
				});

				if (GmCXt.isOnboarding(currentTour) && rootScope.isUploadTutorial(currentTour)) {
					GmCXt.trackerV1.trackTutGuide(currentTour, 'upload_tutorial_guide_new_tab', 'bot');
				} else if (GmCXt.isOnboarding(currentTour)) {
					GmCXt.trackerV1.trackTutGuide(currentTour, 'create_tutorial_guide', 'bot');
				}

				if (GmCXt.isBotGuide(currentTour)) {
					let idata = {
						trigger_source_type: 'bot',
						trigger_source_id: currentTour.tour_id,
						conversationCode: currentTour.tour_settings.conversation.conversationCode
					};

					GmCXt.trackerV1.trackConversationResponse(ansData, idata);
				}

				reInitSurveyVar();

				if (res === rootScope.labels.btnNo) {
					showHumanMsg(res).then(function () {
						if (checkIfAllowTourPlay()) {
							rootScope.guideAction(rootScope.playAuto, null, rootScope.botTourPlayList[0], 'bot');
						}

						onBack();
					});
				} else {
					getBotGuides();
				}
			});
		});
	}

	function surveyIterOfNonBranch(ques, tour) {
		if (surveyQuestionIndex < surveyQList.length - 1) {
			if (!ques.isBranchNode && (currentBSPageIndex === surveyQList[surveyQuestionIndex + 1].pageIndex || !surveyBranchNodes.includes(surveyQList[surveyQuestionIndex + 1].pageIndex))) {
				surveyQuestionIndex++;
				showSurveyQuestion(surveyQList, tour);
			} else if (GmCXt.isEmpty(surveyBranchNodes)) {
				surveyQuestionIndex++;
				showSurveyQuestion(surveyQList, tour);
			} else {
				surveyQuestionIndex++;
				surveyIterOfNonBranch(ques, tour);
			}
		} else {
			endMessage();
		}
	}

	function getBranchNodes(id) {
		let playStructure = currentTour.tour_settings.play_structure;
		let node = null;

		for (let i = 0; i < playStructure.length; i++) {
			if (parseInt(playStructure[i].id) === parseInt(id)) {
				node = playStructure[i];
			}
		}

		return node;
	}

	function showBranchQuestions(question, branches, bstep) {
		showMsg('', question, 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft', 0).then(function () {
			let optList = [];

			if (branches && branches.length > 0) {
				mg$.each(branches, function (key, opt) {
					optList.push({
						text: opt.branchName,
						value: opt,
						cssClass: 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight mgPlayerJSTest_uilb-button-opt'
					});
				});

				showActionButton('', 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight', optList, 200).then(function (res) {
					let tailStepId = res.tail;

					if (!tailStepId) {
						let nodes = getBranchNodes(bstep.step_id);
						let bIndex = branches.indexOf(res);
						tailStepId = nodes.branch[bIndex].tail;
					}

					updateStepInCurrentTour(bstep, res);

					showHumanMsg(res.branchName).then(function () {
						if (tailStepId) {
							let tailStep = GmCXt.getNextBotStepFromTour(tailStepId, currentTour);

							if (tailStep) {
								showBotStepQuestion(currentTour.steps, tailStep.step_id);
							} else {
								showNextBotStep(tailStep);
							}
						} else {
							endMessage();
						}
					});
				});
			}
		});
	}

	function getQuesIndexByPI(pageIndex) {
		let qi = -1;

		for (let i = 0; i < surveyQList.length; i++) {
			if (surveyQList[i].pageIndex === pageIndex) {
				qi = i;
				break;
			}
		}

		return qi;
	}

	function trackAns(ques, answer) {
		let ans = {
			question_id: ques.questionID ? ques.questionID : '',
			question_type: ques.type,
			question_name: ques.question ? ques.question : ''
		};

		switch (ques.type) {
			case 'yes-no':
				if (answer !== undefined) {
					let valueData = answer === 'Yes' ? true : false;
					ans.is_answer_yes = valueData;
				}
				break;
			case 'comment':
				ans.comment = answer;
				break;
			case 'multi-select':
				ans.option = answer.split(',');
				break;
			case 'select':
			case 'range':
			case 'rating':
				ans.option = answer.toString().split();
				break;
		}

		ansData.push(ans);
	}

	function showSingleSelectQuestion(ques, tour) {
		showMsg('', ques.question, 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft', 0).then(function () {
			let optList = [];

			if (ques.options && ques.options.length > 0) {
				let cssClass = 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight mgPlayerJSTest_uilb-button-opt';
				if (ques.type === 'yes-no') cssClass = 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInUp mgPlayerJSTest_uilb-button-opt-yesno';

				mg$.each(ques.options, function (key, opt) {
					optList.push({ text: opt.option, value: opt, cssClass });

					if (ques.isBranchNode) {
						surveyBranchNodes.push(opt.nextHopOnBranch);
					}
				});

				showActionButton('', 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight', optList, 200).then(function (o) {
					if (o.optionReferenceLink) {
						window.open(o.optionReferenceLink, '_blank');
					}

					trackAns(ques, o.option);

					showHumanMsg(o.option).then(function () {
						if (surveyQuestionIndex < surveyQList.length - 1) {
							if (ques.isBranchNode) {
								let index = getQuesIndexByPI(o.nextHopOnBranch);
								currentBSPageIndex = o.nextHopOnBranch;
								surveyQuestionIndex = index;
								showSurveyQuestion(surveyQList, tour);
							} else {
								surveyIterOfNonBranch(ques, tour);
							}
						} else {
							endMessage();
						}
					});
				});
			}
		});
	}

	function showMultiSelectQuestion(ques, tour) {
		showMsg('', ques.question, 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft', 0).then(function () {
			let optList = [];

			if (ques.options && ques.options.length > 0) {
				mg$.each(ques.options, function (key, opt) {
					optList.push({
						text: '&#9744; ' + opt.option,
						value: opt,
						cssClass: 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight mgPlayerJSTest_uilb-button-multi-opt',
						tag: 'multiselect'
					});
				});

				let selecOpList = [];

				optList.push({
					text: 'Done',
					value: selecOpList,
					cssClass: 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight mgPlayerJSTest_uilb-button-multi-opt-done'
				});

				showActionButton('mgPlayerJSTest_multi', 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight', optList, 200).then(function (o) {
					let optionStr = '';

					if (o && o.length) {
						for (let i = 0; i < o.length; i++) {
							if (GmCXt.isEmpty(optionStr)) {
								optionStr = o[i].option;
							} else {
								optionStr = optionStr + ' , ' + o[i].option;
							}
						}

						trackAns(ques, optionStr);

						showHumanMsg(optionStr).then(function () {
							surveyIterOfNonBranch(ques, tour);
						});
					} else {
						showHumanMsg(rootScope.labels.multiSelectOptionError).then(function () {
							showMultiSelectQuestion(ques, tour);
						});
					}
				});
			}
		});
	}

	function displaySurveyQues(ques, tour) {
		ques.pageIndex;

		switch (ques.type) {
			case 'select':
			case 'yes-no':
				showSingleSelectQuestion(ques, tour);
				break;
			case 'multi-select':
				showMultiSelectQuestion(ques, tour);
				break;
			case 'comment':
				showMsg('', ques.question, 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft', 0).then(function () {
					uilb.action({
						type: 'text',
						cssClass: 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft',
						delay: 100,
						tag: 'comment_' + tour.tour_id,
						validate: ques.validateEmail
					});
				});
				break;
			case 'range':
				showMsg('', ques.question, 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft', 0).then(function () {
					showActionButton('mgPlayerJSTest_uilb-btn-range', 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight', addRangeQuestion(ques), 200).then(function (str) {
						trackAns(ques, str);

						showHumanMsg(str).then(function () {
							surveyIterOfNonBranch(ques, tour);
						});
					});
				});
				break;
			case 'rating':
				showMsg('', ques.question, 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft', 0).then(function () {
					showActionButton('mgPlayerJSTest_uilb-btn-rate', 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInRight', addRateQuestion(ques), 200).then(function (str) {
						trackAns(ques, str);

						showHumanMsg(addRateAnswer(ques, str), true).then(function () {
							surveyIterOfNonBranch(ques, tour);
						});
					});
				});
				break;
		}
	}

	function onloadchat() {
		$$invalidate(0, rootScope.botTourPlayList = [], rootScope);
		GmCXt.storage().remove(['botTourPlayList']);

		showMsg('', rootScope.chatLabels.greetingMessage, 'mgPlayerJSTest_animated mgPlayerJSTest_fadeInLeft', 0).then(function () {
			getBotGuides();
		});
	}

	function textSearch(isValidate) {
		let txtsearch = document.getElementById('txtsearch');

		if (txtsearch !== null && txtsearch.value.length > 0) {
			let txtparent = txtsearch.parentElement;
			let container = txtparent.parentElement;
			let stext = txtsearch.value;

			if (txtsearch.tag && typeof txtsearch.tag !== 'object' && txtsearch.tag.indexOf('comment_') !== -1 && stext) {
				txtsearch.tag.replace('comment_', '');

				//var s = GmCXt.getStepFromTourData(stepId, currentTour);
				if (isValidate) {
					let emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,3}$/i;

					if (emailRegex.test(stext)) {
						stext = txtsearch.value;
					} else {
						stext = rootScope.labels.emailError;
					}
				}

				showHumanMsg(stext).then(function () {
					if (stext === rootScope.labels.emailError) {
						showSurveyQuestion(surveyQList, currentTour);
					} else {
						let q = surveyQList[surveyQuestionIndex];
						trackAns(q, stext);
						surveyIterOfNonBranch(q, currentTour);
					}
				});
			} else if (txtsearch.tag && typeof txtsearch.tag !== 'object' && txtsearch.tag === 'searchGuide' && stext) {
				let tourdiv = document.getElementsByClassName('mgPlayerJSTest_uilb-button-options')[0];
				let tourDivParent = tourdiv.parentElement;
				let tlist = filterTourBytext(allBotGuides, stext);

				if (tlist) {
					processBotGuides(tlist);
					GmCXt.timeout(onRemoveElement(tourDivParent), 200);
				}
			} else {
				let step = txtsearch.tag;
				container.style.opacity = 0;

				showHumanMsg(stext).then(function (r) {
					updateStepInCurrentTour(step, stext);

					if (GmCXt.isLastStep(step.step_id, currentTour.tour_settings.play_structure)) {
						endMessage();
					} else {
						showNextBotStep(step);
					}
				});
			}

			GmCXt.timeout(onRemoveElement(txtparent), 200);
		}
	}

	mg$(document).off('keypress', '#txtsearch');

	mg$(document).on('keypress', '#txtsearch', function (e) {
		let keycode = e.keyCode ? e.keyCode : e.which;

		if (keycode === 13) {
			let isValidate = false;
			if (e.target.validate) isValidate = true;
			textSearch(isValidate);
		}
	});

	onMount(() => {
		uilb = new UILandingBot(document.getElementById('mgPlayerJSTest_botdiv'));
		onloadchat();
	});

	return [rootScope, onBack];
}

class Bot extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {}, null, [-1, -1]);
	}
}

/* src/components/TaskList.svelte generated by Svelte v4.2.20 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[34] = list[i];
	child_ctx[36] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[37] = list[i];
	child_ctx[39] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[40] = list[i];
	child_ctx[42] = i;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[40] = list[i];
	child_ctx[44] = i;
	return child_ctx;
}

// (370:3) {#if openTaskId !== -1}
function create_if_block_11(ctx) {
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_3;
	let span;
	let t0;
	let t1;
	let t2;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_3_class_value;

	return {
		c() {
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			span = element("span");
			t0 = text(/*taskProgress*/ ctx[2]);
			t1 = text("%");
			t2 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_2.innerHTML = `<wmgPlayerJSTest_ class="mgPlayerJSTest_task-prog-first50-bar"></wmgPlayerJSTest_> <wmgPlayerJSTest_ class="mgPlayerJSTest_task-prog-value-bar"></wmgPlayerJSTest_>`;
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_task-prog-left-half-clipper");
			attr(wmgPlayerJSTest_3, "class", wmgPlayerJSTest_3_class_value = "mgPlayerJSTest_task-progress-circle p" + /*taskProgress*/ ctx[2]);
			toggle_class(wmgPlayerJSTest_3, "over50", /*taskProgress*/ ctx[2] > 50);
			toggle_class(wmgPlayerJSTest_3, "mgPlayerJSTest_task-progress-circle-mplayer", /*rootScope*/ ctx[0].isMicroPlayer);
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_4, anchor);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, span);
			append(span, t0);
			append(span, t1);
			append(wmgPlayerJSTest_3, t2);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*taskProgress*/ 4) set_data(t0, /*taskProgress*/ ctx[2]);

			if (dirty[0] & /*taskProgress*/ 4 && wmgPlayerJSTest_3_class_value !== (wmgPlayerJSTest_3_class_value = "mgPlayerJSTest_task-progress-circle p" + /*taskProgress*/ ctx[2])) {
				attr(wmgPlayerJSTest_3, "class", wmgPlayerJSTest_3_class_value);
			}

			if (dirty[0] & /*taskProgress, taskProgress*/ 4) {
				toggle_class(wmgPlayerJSTest_3, "over50", /*taskProgress*/ ctx[2] > 50);
			}

			if (dirty[0] & /*taskProgress, rootScope*/ 5) {
				toggle_class(wmgPlayerJSTest_3, "mgPlayerJSTest_task-progress-circle-mplayer", /*rootScope*/ ctx[0].isMicroPlayer);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_4);
			}
		}
	};
}

// (386:4) {#if openTaskId !== -1}
function create_if_block_10(ctx) {
	let wmgPlayerJSTest_0;
	let t0_value = /*allTaskList*/ ctx[1][/*openTaskId*/ ctx[3]].task_list_title + "";
	let t0;
	let wmgPlayerJSTest_0_title_value;
	let t1;
	let wmgPlayerJSTest_1;
	let t2;
	let t3;
	let t4;
	let t5;

	return {
		c() {
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t2 = text("Completed task: ");
			t3 = text(/*completedTask*/ ctx[8]);
			t4 = text("/");
			t5 = text(/*totalTask*/ ctx[7]);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_task-list-header-title mgPlayerJSTest_inline-block-vm mgPlayerJSTest_font-size-12 mgPlayerJSTest_task-list-header");
			attr(wmgPlayerJSTest_0, "title", wmgPlayerJSTest_0_title_value = /*allTaskList*/ ctx[1][/*openTaskId*/ ctx[3]].title);
			toggle_class(wmgPlayerJSTest_0, "mgPlayerJSTest_font-size-14", !/*rootScope*/ ctx[0].isMicroPlayer);
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_task-count mgPlayerJSTest_inline-block-vm mgPlayerJSTest_margin-tb-5");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_0, anchor);
			append(wmgPlayerJSTest_0, t0);
			insert(target, t1, anchor);
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, t2);
			append(wmgPlayerJSTest_1, t3);
			append(wmgPlayerJSTest_1, t4);
			append(wmgPlayerJSTest_1, t5);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*allTaskList, openTaskId*/ 10 && t0_value !== (t0_value = /*allTaskList*/ ctx[1][/*openTaskId*/ ctx[3]].task_list_title + "")) set_data(t0, t0_value);

			if (dirty[0] & /*allTaskList, openTaskId*/ 10 && wmgPlayerJSTest_0_title_value !== (wmgPlayerJSTest_0_title_value = /*allTaskList*/ ctx[1][/*openTaskId*/ ctx[3]].title)) {
				attr(wmgPlayerJSTest_0, "title", wmgPlayerJSTest_0_title_value);
			}

			if (dirty[0] & /*rootScope*/ 1) {
				toggle_class(wmgPlayerJSTest_0, "mgPlayerJSTest_font-size-14", !/*rootScope*/ ctx[0].isMicroPlayer);
			}

			if (dirty[0] & /*completedTask*/ 256) set_data(t3, /*completedTask*/ ctx[8]);
			if (dirty[0] & /*totalTask*/ 128) set_data(t5, /*totalTask*/ ctx[7]);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_0);
				detach(t1);
				detach(wmgPlayerJSTest_1);
			}
		}
	};
}

// (421:5) {#if openTaskId === index}
function create_if_block_9(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = /*rootScope*/ ctx[0].svgs.iconDownArrow + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_icon-collapse-expand mgPlayerJSTest_float-right mgPlayerJSTest_ege-inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.iconDownArrow + "")) wmgPlayerJSTest_.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (426:5) {#if openTaskId !== index}
function create_if_block_8$1(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = /*rootScope*/ ctx[0].svgs.iconUpArrow + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_icon-collapse-expand mgPlayerJSTest_float-right mgPlayerJSTest_ege-inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.iconUpArrow + "")) wmgPlayerJSTest_.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (432:4) {#if task.guides && task.guides.length > 0 && openTaskId === index}
function create_if_block_6$2(ctx) {
	let wmgPlayerJSTest_;
	let each_value_3 = ensure_array_like(/*task*/ ctx[34].guides);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_chapter-container mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y mgPlayerJSTest_padding-tb-10");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(wmgPlayerJSTest_, null);
				}
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*forceCompletion, activeGuideOrder, playGuide, allTaskList, guidePlayActionTitle, getPlayActionIcon*/ 27154) {
				each_value_3 = ensure_array_like(/*task*/ ctx[34].guides);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(wmgPlayerJSTest_, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (470:9) {#if guide.is_guide_complete}
function create_if_block_7$1(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw_value = GmCXt.svgs.taskCompleted + "";

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_guide-complete-icon");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_guide-complete-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}
		}
	};
}

// (434:6) {#each task.guides as guide, inn}
function create_each_block_3(ctx) {
	let button;
	let wmgPlayerJSTest_7;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = /*getPlayActionIcon*/ ctx[13](/*guide*/ ctx[40]) + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let t1_value = /*guidePlayActionTitle*/ ctx[14](/*guide*/ ctx[40]) + "";
	let t1;
	let t2;
	let wmgPlayerJSTest_5;
	let wmgPlayerJSTest_4;
	let t3_value = /*guide*/ ctx[40].tour_title + "";
	let t3;
	let wmgPlayerJSTest_4_title_value;
	let t4;
	let t5;
	let mounted;
	let dispose;
	let if_block = /*guide*/ ctx[40].is_guide_complete && create_if_block_7$1();

	function click_handler_1(...args) {
		return /*click_handler_1*/ ctx[17](/*guide*/ ctx[40], /*task*/ ctx[34], ...args);
	}

	return {
		c() {
			button = element("button");
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			t2 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			t3 = text(t3_value);
			t4 = space();
			if (if_block) if_block.c();
			t5 = space();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_published-tour-icon mgPlayerJSTest_inline-block-vm");
			toggle_class(wmgPlayerJSTest_0, "mgPlayerJSTest_published-tour-icon-disable", /*forceCompletion*/ ctx[4] && /*guide*/ ctx[40].content_order > /*activeGuideOrder*/ ctx[9]);
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title mgPlayerJSTest_text-align-center");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-right");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_guide-play-icon-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_position-relative");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_chapter-title mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_4, "title", wmgPlayerJSTest_4_title_value = /*guide*/ ctx[40].tour_title);
			toggle_class(wmgPlayerJSTest_4, "mgPlayerJSTest_chapter-title-complete", /*forceCompletion*/ ctx[4] && /*guide*/ ctx[40].is_guide_complete);
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_chapter-content-wrapper mgPlayerJSTest_margin-lr-15 mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center");
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_chapter-content-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
			attr(button, "class", "mgPlayerJSTest_chapter-box mgPlayerJSTest_chapter-box-folder-guide mgPlayerJSTest_lbl-btn");
			toggle_class(button, "mgPlayerJSTest_chapter-box-disable", /*forceCompletion*/ ctx[4] && /*inn*/ ctx[44] + 1 > /*activeGuideOrder*/ ctx[9]);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t1);
			append(wmgPlayerJSTest_6, t2);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, t3);
			append(wmgPlayerJSTest_7, t4);
			if (if_block) if_block.m(wmgPlayerJSTest_7, null);
			append(button, t5);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*allTaskList*/ 2 && raw_value !== (raw_value = /*getPlayActionIcon*/ ctx[13](/*guide*/ ctx[40]) + "")) wmgPlayerJSTest_0.innerHTML = raw_value;
			if (dirty[0] & /*forceCompletion, allTaskList, activeGuideOrder*/ 530) {
				toggle_class(wmgPlayerJSTest_0, "mgPlayerJSTest_published-tour-icon-disable", /*forceCompletion*/ ctx[4] && /*guide*/ ctx[40].content_order > /*activeGuideOrder*/ ctx[9]);
			}

			if (dirty[0] & /*allTaskList*/ 2 && t1_value !== (t1_value = /*guidePlayActionTitle*/ ctx[14](/*guide*/ ctx[40]) + "")) set_data(t1, t1_value);
			if (dirty[0] & /*allTaskList*/ 2 && t3_value !== (t3_value = /*guide*/ ctx[40].tour_title + "")) set_data(t3, t3_value);

			if (dirty[0] & /*allTaskList*/ 2 && wmgPlayerJSTest_4_title_value !== (wmgPlayerJSTest_4_title_value = /*guide*/ ctx[40].tour_title)) {
				attr(wmgPlayerJSTest_4, "title", wmgPlayerJSTest_4_title_value);
			}

			if (dirty[0] & /*forceCompletion, allTaskList*/ 18) {
				toggle_class(wmgPlayerJSTest_4, "mgPlayerJSTest_chapter-title-complete", /*forceCompletion*/ ctx[4] && /*guide*/ ctx[40].is_guide_complete);
			}

			if (/*guide*/ ctx[40].is_guide_complete) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_7$1();
					if_block.c();
					if_block.m(wmgPlayerJSTest_7, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*forceCompletion, activeGuideOrder*/ 528) {
				toggle_class(button, "mgPlayerJSTest_chapter-box-disable", /*forceCompletion*/ ctx[4] && /*inn*/ ctx[44] + 1 > /*activeGuideOrder*/ ctx[9]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (482:4) {#if task.folders && task.folders.length > 0 && openTaskId === index}
function create_if_block$3(ctx) {
	let wmgPlayerJSTest_;
	let each_value_1 = ensure_array_like(/*task*/ ctx[34].folders);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_chapter-container mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(wmgPlayerJSTest_, null);
				}
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*openTaskFolder, allTaskList, forceCompletion, activeFolderOrder, activeGuideOrder, playGuide, guidePlayActionTitle, getPlayActionIcon, openTaskFolderId, rootScope*/ 31347) {
				each_value_1 = ensure_array_like(/*task*/ ctx[34].folders);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(wmgPlayerJSTest_, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (485:7) {#if folder.guides && folder.guides.length > 0}
function create_if_block_1$3(ctx) {
	let wmgPlayerJSTest_4;
	let button;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[0].svgs.folder + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let t1_value = /*folder*/ ctx[37].folder_title + "";
	let t1;
	let wmgPlayerJSTest_1_title_value;
	let t2;
	let t3;
	let t4;
	let t5;
	let mounted;
	let dispose;
	let if_block0 = /*openTaskFolderId*/ ctx[6] === /*i*/ ctx[39] && create_if_block_5$2(ctx);
	let if_block1 = /*openTaskFolderId*/ ctx[6] !== /*i*/ ctx[39] && create_if_block_4$2(ctx);
	let if_block2 = /*folder*/ ctx[37].guides.length > 0 && /*openTaskFolderId*/ ctx[6] === /*i*/ ctx[39] && create_if_block_2$3(ctx);

	function click_handler_3(...args) {
		return /*click_handler_3*/ ctx[19](/*folder*/ ctx[37], /*i*/ ctx[39], /*index*/ ctx[36], ...args);
	}

	return {
		c() {
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			button = element("button");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_category-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_chapter-title mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_1, "title", wmgPlayerJSTest_1_title_value = /*folder*/ ctx[37].folder_title);
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_chapter-content-wrapper mgPlayerJSTest_margin-10 mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_inline-block-vm");
			attr(button, "class", "mgPlayerJSTest_chapter-box mgPlayerJSTest_chapter-box-folder mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between mgPlayerJSTest_lbl-btn");
			toggle_class(button, "mgPlayerJSTest_chapter-box-disable", /*forceCompletion*/ ctx[4] && /*activeFolderOrder*/ ctx[5].indexOf(/*folder*/ ctx[37].folder_id) === -1);
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_4, anchor);
			append(wmgPlayerJSTest_4, button);
			append(button, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t1);
			append(button, t2);
			if (if_block0) if_block0.m(button, null);
			append(button, t3);
			if (if_block1) if_block1.m(button, null);
			append(wmgPlayerJSTest_4, t4);
			if (if_block2) if_block2.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t5);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_4, "click", click_handler_3);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.folder + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if (dirty[0] & /*allTaskList*/ 2 && t1_value !== (t1_value = /*folder*/ ctx[37].folder_title + "")) set_data(t1, t1_value);

			if (dirty[0] & /*allTaskList*/ 2 && wmgPlayerJSTest_1_title_value !== (wmgPlayerJSTest_1_title_value = /*folder*/ ctx[37].folder_title)) {
				attr(wmgPlayerJSTest_1, "title", wmgPlayerJSTest_1_title_value);
			}

			if (/*openTaskFolderId*/ ctx[6] === /*i*/ ctx[39]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_5$2(ctx);
					if_block0.c();
					if_block0.m(button, t3);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*openTaskFolderId*/ ctx[6] !== /*i*/ ctx[39]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_4$2(ctx);
					if_block1.c();
					if_block1.m(button, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*forceCompletion, activeFolderOrder, allTaskList*/ 50) {
				toggle_class(button, "mgPlayerJSTest_chapter-box-disable", /*forceCompletion*/ ctx[4] && /*activeFolderOrder*/ ctx[5].indexOf(/*folder*/ ctx[37].folder_id) === -1);
			}

			if (/*folder*/ ctx[37].guides.length > 0 && /*openTaskFolderId*/ ctx[6] === /*i*/ ctx[39]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_2$3(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_4, t5);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_4);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			mounted = false;
			dispose();
		}
	};
}

// (504:10) {#if openTaskFolderId === i}
function create_if_block_5$2(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = /*rootScope*/ ctx[0].svgs.iconDownArrow + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_icon-collapse-expand mgPlayerJSTest_float-right mgPlayerJSTest_ege-inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.iconDownArrow + "")) wmgPlayerJSTest_.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (509:10) {#if openTaskFolderId !== i}
function create_if_block_4$2(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = /*rootScope*/ ctx[0].svgs.iconUpArrow + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_icon-collapse-expand mgPlayerJSTest_float-right mgPlayerJSTest_ege-inline-block-vm");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.iconUpArrow + "")) wmgPlayerJSTest_.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (515:9) {#if folder.guides.length > 0 && openTaskFolderId === i}
function create_if_block_2$3(ctx) {
	let wmgPlayerJSTest_;
	let each_value_2 = ensure_array_like(/*folder*/ ctx[37].guides);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_chapter-container mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y mgPlayerJSTest_ml-15 mgPlayerJSTest_padding-b-15");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(wmgPlayerJSTest_, null);
				}
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*forceCompletion, activeFolderOrder, allTaskList, activeGuideOrder, playGuide, guidePlayActionTitle, getPlayActionIcon*/ 27186) {
				each_value_2 = ensure_array_like(/*folder*/ ctx[37].guides);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(wmgPlayerJSTest_, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (552:14) {#if guide.is_guide_complete}
function create_if_block_3$3(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let raw_value = GmCXt.svgs.taskCompleted + "";

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_guide-complete-icon");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_guide-complete-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}
		}
	};
}

// (517:11) {#each folder.guides as guide, ind}
function create_each_block_2(ctx) {
	let button;
	let wmgPlayerJSTest_7;
	let wmgPlayerJSTest_6;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = /*getPlayActionIcon*/ ctx[13](/*guide*/ ctx[40]) + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let t1_value = /*guidePlayActionTitle*/ ctx[14](/*guide*/ ctx[40]) + "";
	let t1;
	let t2;
	let wmgPlayerJSTest_5;
	let wmgPlayerJSTest_4;
	let t3_value = /*guide*/ ctx[40].tour_title + "";
	let t3;
	let wmgPlayerJSTest_4_title_value;
	let t4;
	let t5;
	let mounted;
	let dispose;
	let if_block = /*guide*/ ctx[40].is_guide_complete && create_if_block_3$3();

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[18](/*guide*/ ctx[40], /*task*/ ctx[34], ...args);
	}

	return {
		c() {
			button = element("button");
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			t2 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			t3 = text(t3_value);
			t4 = space();
			if (if_block) if_block.c();
			t5 = space();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_published-tour-icon mgPlayerJSTest_inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title mgPlayerJSTest_text-align-center");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-right");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_guide-play-icon-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_position-relative");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_chapter-title mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_4, "title", wmgPlayerJSTest_4_title_value = /*guide*/ ctx[40].tour_title);
			toggle_class(wmgPlayerJSTest_4, "mgPlayerJSTest_chapter-title-complete", /*forceCompletion*/ ctx[4] && /*guide*/ ctx[40].is_guide_complete);
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_chapter-content-wrapper mgPlayerJSTest_margin-lr-15 mgPlayerJSTest_inline-block-vm mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_chapter-content-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center");
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_chapter-content-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between");
			attr(button, "class", "mgPlayerJSTest_chapter-box mgPlayerJSTest_chapter-box-folder-guide mgPlayerJSTest_lbl-btn");
			toggle_class(button, "mgPlayerJSTest_chapter-box-disable", /*forceCompletion*/ ctx[4] && (/*activeFolderOrder*/ ctx[5].indexOf(/*folder*/ ctx[37].folder_id) === -1 || /*ind*/ ctx[42] + 1 > /*activeGuideOrder*/ ctx[9]));
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t1);
			append(wmgPlayerJSTest_6, t2);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, t3);
			append(wmgPlayerJSTest_7, t4);
			if (if_block) if_block.m(wmgPlayerJSTest_7, null);
			append(button, t5);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_2);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*allTaskList*/ 2 && raw_value !== (raw_value = /*getPlayActionIcon*/ ctx[13](/*guide*/ ctx[40]) + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if (dirty[0] & /*allTaskList*/ 2 && t1_value !== (t1_value = /*guidePlayActionTitle*/ ctx[14](/*guide*/ ctx[40]) + "")) set_data(t1, t1_value);
			if (dirty[0] & /*allTaskList*/ 2 && t3_value !== (t3_value = /*guide*/ ctx[40].tour_title + "")) set_data(t3, t3_value);

			if (dirty[0] & /*allTaskList*/ 2 && wmgPlayerJSTest_4_title_value !== (wmgPlayerJSTest_4_title_value = /*guide*/ ctx[40].tour_title)) {
				attr(wmgPlayerJSTest_4, "title", wmgPlayerJSTest_4_title_value);
			}

			if (dirty[0] & /*forceCompletion, allTaskList*/ 18) {
				toggle_class(wmgPlayerJSTest_4, "mgPlayerJSTest_chapter-title-complete", /*forceCompletion*/ ctx[4] && /*guide*/ ctx[40].is_guide_complete);
			}

			if (/*guide*/ ctx[40].is_guide_complete) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3$3();
					if_block.c();
					if_block.m(wmgPlayerJSTest_7, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*forceCompletion, activeFolderOrder, allTaskList, activeGuideOrder*/ 562) {
				toggle_class(button, "mgPlayerJSTest_chapter-box-disable", /*forceCompletion*/ ctx[4] && (/*activeFolderOrder*/ ctx[5].indexOf(/*folder*/ ctx[37].folder_id) === -1 || /*ind*/ ctx[42] + 1 > /*activeGuideOrder*/ ctx[9]));
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (484:6) {#each task.folders as folder, i}
function create_each_block_1(ctx) {
	let if_block_anchor;
	let if_block = /*folder*/ ctx[37].guides && /*folder*/ ctx[37].guides.length > 0 && create_if_block_1$3(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*folder*/ ctx[37].guides && /*folder*/ ctx[37].guides.length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (402:2) {#each allTaskList as task, index}
function create_each_block(ctx) {
	let wmgPlayerJSTest_4;
	let button;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[0].svgs.tasklist + "";
	let t0;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let t1_value = /*task*/ ctx[34].task_list_title + "";
	let t1;
	let wmgPlayerJSTest_1_title_value;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let mounted;
	let dispose;
	let if_block0 = /*openTaskId*/ ctx[3] === /*index*/ ctx[36] && create_if_block_9(ctx);
	let if_block1 = /*openTaskId*/ ctx[3] !== /*index*/ ctx[36] && create_if_block_8$1(ctx);
	let if_block2 = /*task*/ ctx[34].guides && /*task*/ ctx[34].guides.length > 0 && /*openTaskId*/ ctx[3] === /*index*/ ctx[36] && create_if_block_6$2(ctx);
	let if_block3 = /*task*/ ctx[34].folders && /*task*/ ctx[34].folders.length > 0 && /*openTaskId*/ ctx[3] === /*index*/ ctx[36] && create_if_block$3(ctx);

	function click_handler_4() {
		return /*click_handler_4*/ ctx[20](/*task*/ ctx[34], /*index*/ ctx[36]);
	}

	return {
		c() {
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			button = element("button");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t1 = text(t1_value);
			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			if (if_block3) if_block3.c();
			t6 = space();
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_task-list-icon mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_assign-title mgPlayerJSTest_margin-lr-5 mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_1, "title", wmgPlayerJSTest_1_title_value = /*task*/ ctx[34].task_list_title);
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_assign-content-wrapper mgPlayerJSTest_margin-10 mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center");
			attr(button, "class", "mgPlayerJSTest_assignment-box mgPlayerJSTest_margin-15 mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between mgPlayerJSTest_lbl-btn");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_4, anchor);
			append(wmgPlayerJSTest_4, button);
			append(button, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t0);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t1);
			append(button, t2);
			if (if_block0) if_block0.m(button, null);
			append(button, t3);
			if (if_block1) if_block1.m(button, null);
			append(wmgPlayerJSTest_4, t4);
			if (if_block2) if_block2.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t5);
			if (if_block3) if_block3.m(wmgPlayerJSTest_4, null);
			append(wmgPlayerJSTest_4, t6);

			if (!mounted) {
				dispose = listen(wmgPlayerJSTest_4, "click", click_handler_4);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*rootScope*/ 1 && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.tasklist + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if (dirty[0] & /*allTaskList*/ 2 && t1_value !== (t1_value = /*task*/ ctx[34].task_list_title + "")) set_data(t1, t1_value);

			if (dirty[0] & /*allTaskList*/ 2 && wmgPlayerJSTest_1_title_value !== (wmgPlayerJSTest_1_title_value = /*task*/ ctx[34].task_list_title)) {
				attr(wmgPlayerJSTest_1, "title", wmgPlayerJSTest_1_title_value);
			}

			if (/*openTaskId*/ ctx[3] === /*index*/ ctx[36]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_9(ctx);
					if_block0.c();
					if_block0.m(button, t3);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*openTaskId*/ ctx[3] !== /*index*/ ctx[36]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_8$1(ctx);
					if_block1.c();
					if_block1.m(button, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*task*/ ctx[34].guides && /*task*/ ctx[34].guides.length > 0 && /*openTaskId*/ ctx[3] === /*index*/ ctx[36]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_6$2(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_4, t5);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*task*/ ctx[34].folders && /*task*/ ctx[34].folders.length > 0 && /*openTaskId*/ ctx[3] === /*index*/ ctx[36]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block$3(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_4, t6);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_4);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$3(ctx) {
	let header;
	let t0;
	let wmgPlayerJSTest_9;
	let wmgPlayerJSTest_7;
	let wmgPlayerJSTest_4;
	let button;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[0].svgs.iconBack + "";
	let t1;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let t2_value = /*rootScope*/ ctx[0].labels.back + "";
	let t2;
	let t3;
	let wmgPlayerJSTest_3;
	let t5;
	let wmgPlayerJSTest_6;
	let t6;
	let wmgPlayerJSTest_5;
	let wmgPlayerJSTest_6_class_value;
	let t7;
	let wmgPlayerJSTest_8;
	let t8;
	let footer;
	let current;
	let mounted;
	let dispose;
	header = new Header({});
	let if_block0 = /*openTaskId*/ ctx[3] !== -1 && create_if_block_11(ctx);
	let if_block1 = /*openTaskId*/ ctx[3] !== -1 && create_if_block_10(ctx);
	let each_value = ensure_array_like(/*allTaskList*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	footer = new Footer({});

	return {
		c() {
			create_component(header.$$.fragment);
			t0 = space();
			wmgPlayerJSTest_9 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			button = element("button");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t1 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t2 = text(t2_value);
			t3 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3.textContent = "Task List";
			t5 = space();
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t6 = space();
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			if (if_block1) if_block1.c();
			t7 = space();
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t8 = space();
			create_component(footer.$$.fragment);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_ege-inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-left");
			attr(button, "class", "mgPlayerJSTest_task-back-btn mgPlayerJSTest_position-relative mgPlayerJSTest_lbl-btn");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_task-list-header-title mgPlayerJSTest_font-size-15 mgPlayerJSTest_margin-lr-10");
			toggle_class(wmgPlayerJSTest_3, "mgPlayerJSTest_font-size-18", !/*rootScope*/ ctx[0].isMicroPlayer);
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_task-list-go-back-container mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_task-header-details mgPlayerJSTest_display-flex mgPlayerJSTest_flex-direction-column");

			attr(wmgPlayerJSTest_6, "class", wmgPlayerJSTest_6_class_value = "mgPlayerJSTest_progress-details-container mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center " + (/*openTaskId*/ ctx[3] !== -1 && /*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_padding-5'
			: '') + " " + (/*openTaskId*/ ctx[3] !== -1
			? 'mgPlayerJSTest_margin-b-10 mgPlayerJSTest_progress-alignment'
			: ''));

			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_task-list-header mgPlayerJSTest_display-flex mgPlayerJSTest_justify-content-space-between mgPlayerJSTest_flex-direction-column mgPlayerJSTest_position-relative mgPlayerJSTest_width-100");
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_assign-container mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y mgPlayerJSTest_bg-white");
			attr(wmgPlayerJSTest_9, "class", "mgPlayerJSTest_task-list-container");
		},
		m(target, anchor) {
			mount_component(header, target, anchor);
			insert(target, t0, anchor);
			insert(target, wmgPlayerJSTest_9, anchor);
			append(wmgPlayerJSTest_9, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, button);
			append(button, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(button, t1);
			append(button, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t2);
			append(wmgPlayerJSTest_4, t3);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_7, t5);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_6);
			if (if_block0) if_block0.m(wmgPlayerJSTest_6, null);
			append(wmgPlayerJSTest_6, t6);
			append(wmgPlayerJSTest_6, wmgPlayerJSTest_5);
			if (if_block1) if_block1.m(wmgPlayerJSTest_5, null);
			append(wmgPlayerJSTest_9, t7);
			append(wmgPlayerJSTest_9, wmgPlayerJSTest_8);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(wmgPlayerJSTest_8, null);
				}
			}

			insert(target, t8, anchor);
			mount_component(footer, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[16]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*rootScope*/ 1) && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.iconBack + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if ((!current || dirty[0] & /*rootScope*/ 1) && t2_value !== (t2_value = /*rootScope*/ ctx[0].labels.back + "")) set_data(t2, t2_value);

			if (!current || dirty[0] & /*rootScope*/ 1) {
				toggle_class(wmgPlayerJSTest_3, "mgPlayerJSTest_font-size-18", !/*rootScope*/ ctx[0].isMicroPlayer);
			}

			if (/*openTaskId*/ ctx[3] !== -1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_11(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_6, t6);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*openTaskId*/ ctx[3] !== -1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_10(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_5, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty[0] & /*openTaskId, rootScope*/ 9 && wmgPlayerJSTest_6_class_value !== (wmgPlayerJSTest_6_class_value = "mgPlayerJSTest_progress-details-container mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center " + (/*openTaskId*/ ctx[3] !== -1 && /*rootScope*/ ctx[0].isMicroPlayer
			? 'mgPlayerJSTest_padding-5'
			: '') + " " + (/*openTaskId*/ ctx[3] !== -1
			? 'mgPlayerJSTest_margin-b-10 mgPlayerJSTest_progress-alignment'
			: ''))) {
				attr(wmgPlayerJSTest_6, "class", wmgPlayerJSTest_6_class_value);
			}

			if (dirty[0] & /*openTask, allTaskList, openTaskFolder, forceCompletion, activeFolderOrder, activeGuideOrder, playGuide, guidePlayActionTitle, getPlayActionIcon, openTaskFolderId, rootScope, openTaskId*/ 32379) {
				each_value = ensure_array_like(/*allTaskList*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(wmgPlayerJSTest_8, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(footer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(header.$$.fragment, local);
			transition_out(footer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(wmgPlayerJSTest_9);
				detach(t8);
			}

			destroy_component(header, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			destroy_each(each_blocks, detaching);
			destroy_component(footer, detaching);
			mounted = false;
			dispose();
		}
	};
}

function setHeight() {
	let egeHeaderHeight = mg$('#mgPlayerJSTest_ege-header').innerHeight()
	? mg$('#mgPlayerJSTest_ege-header').innerHeight()
	: 0;

	let listPageHeaderHeight = mg$('.mgPlayerJSTest_task-list-header').innerHeight()
	? mg$('.mgPlayerJSTest_task-list-header').innerHeight()
	: 0;

	let footerHeight = mg$('#mgPlayerJSTest_footer-panel-container').innerHeight()
	? mg$('#mgPlayerJSTest_footer-panel-container').innerHeight()
	: 0;

	mg$('.mgPlayerJSTest_assign-container').css({
		height: window.innerHeight - egeHeaderHeight - listPageHeaderHeight - footerHeight
	});
}

function instance$3($$self, $$props, $$invalidate) {
	let completedGuides;
	let activeGuideOrder;
	rootScope.currentView = 'taskList';
	let allTaskList = [];
	let taskProgress = 0;
	let openTaskId = -1;
	GmCXt.t.ruleTimeOut15ms;
	rootScope.isTaskListActive = true;
	let forceCompletion = false;
	let activeFolderOrder = [];
	let totalGuideCount = 0;
	let openTaskFolderId;
	Gm.loading.set(true);
	let totalTask;
	let completedTask;

	const allTaskListSubscriber = Gm.allTaskList.subscribe(value => {
		$$invalidate(1, allTaskList = value);
	});

	const showTaskList = () => {
		Gm.loading.set(true);

		let taskListCb = function (taskList) {
			if (mg$('.mgPlayerJSTest_push-notification-container').is(':visible')) {
				mg$('.mgPlayerJSTest_ege-panel').css({ width: '500px', right: '-9550px' });
			}

			if (taskList.length) {
				$$invalidate(1, allTaskList = rootScope.processTaskListByRules(taskList));
				$$invalidate(3, openTaskId = -1);
				$$invalidate(6, openTaskFolderId = -1);
			}

			Gm.loading.set(false);
		};

		if (!GmCXt.isEmpty(GmCXt.user) && GmCXt.isPlayer()) {
			if (GmCXt.isEmpty(rootScope.taskList)) {
				$$invalidate(0, rootScope.taskList = null, rootScope);
			} else {
				$$invalidate(0, rootScope.taskList = rootScope.filterCompleatedTasks(rootScope.taskList), rootScope);
			}

			rootScope.getTaskListData(taskListCb, 0);
		}
	};

	showTaskList();

	const openTask = (task, index) => {
		if (task && task.task_list_id && openTaskId !== index) {
			$$invalidate(3, openTaskId = index);
			Gm.loading.set(true);

			api.getTaskDetails(task.task_list_id).then(function (res) {
				Gm.loading.set(false);

				if (!res.data.completion_percent) {
					$$invalidate(2, taskProgress = 0);
				} else {
					$$invalidate(2, taskProgress = res.data.completion_percent);
				}

				completedGuides = res.data.completed_guide_ids;
				$$invalidate(8, completedTask = res.data.completed_count);
				totalGuideCount = parseInt(res.data.total_count);

				if (task.guides && task.guides.length) {
					$$invalidate(1, allTaskList[index] = setCompleteGuide(task), allTaskList);
					checkFolderGuidesOrder(task.guides);
				}

				if (task.folders && task.folders.length) {
					$$invalidate(1, allTaskList[index] = setCompleteFolder(task), allTaskList);
				}

				if (task.task_list_setting.force_completion) {
					$$invalidate(4, forceCompletion = task.task_list_setting.force_completion);
				}

				$$invalidate(7, totalTask = res.data.total_count);
				$$invalidate(6, openTaskFolderId = -1);
			});
		} else {
			$$invalidate(3, openTaskId = -1);
		}

		GmCXt.timeout(
			function () {
				setHeight();

				if (GmCXt.isPlayer()) {
					rootScope.bindPlayerTheme();
				}
			},
			500
		);
	};

	const playGuide = (guide, ev, task) => {
		GmCXt.parseJSON(task.task_list_setting);
		ev.stopPropagation();
		let guideComp = false;
		if (guide.is_guide_complete) guideComp = true;
		let param = { tour_id: guide.tour_id };
		Gm.loading.set(true);

		api.getTour(
			param,
			function (_tour) {
				Gm.loading.set(false);

				let taskObj = {
					taskId: task.task_list_id,
					isComplete: guideComp,
					complete_count: completedTask,
					total_count: totalGuideCount
				};

				$$invalidate(3, openTaskId = -1);
				$$invalidate(6, openTaskFolderId = -1);
				let defaultPlayAction = rootScope.getDefaultPlayAction(_tour);

				if (defaultPlayAction === 'Default') {
					defaultPlayAction = GmCXt.getAppSetting('defaultPlayAction');
				}

				rootScope.guideAction(defaultPlayAction, false, _tour, 'task_list', _tour.category_title, taskObj);
				$$invalidate(0, rootScope.isTaskListActive = false, rootScope);
				Gm.activeView.set('home');
			},
			errorCb
		);
	};

	var errorCb = function () {
		rootScope.showPopup(rootScope.labels.tourPlayError);
	};

	const openTaskFolder = (folder, index, parentIndex, ev) => {
		if (openTaskFolderId !== index) {
			ev.stopPropagation();
			$$invalidate(6, openTaskFolderId = index);
			Gm.loading.set(true);

			api.getTaskFolderDetails(folder.folder_id).then(function (res) {
				Gm.loading.set(false);
				checkFolderGuidesOrder(res.data.content_list);
			});
		} else {
			$$invalidate(6, openTaskFolderId = -1);
		}

		GmCXt.timeout(
			function () {
				setHeight();

				if (GmCXt.isPlayer()) {
					rootScope.bindPlayerTheme();
				}
			},
			500
		);
	};

	const checkFolderGuidesOrder = guides => {
		if (guides) {
			$$invalidate(9, activeGuideOrder = 1);

			for (let f = 0; f < guides.length; f++) {
				if (guides[f].is_guide_complete == '1' && Boolean(Number(guides[0].is_guide_complete))) {
					$$invalidate(9, activeGuideOrder = f + 2);
				}
			}
		}
	};

	const setCompleteGuide = task => {
		if (task.guides) {
			for (let f = 0; f < task.guides.length; f++) {
				if (completedGuides.indexOf(task.guides[f].tour_id.toString()) !== -1) {
					task.guides[f].is_guide_complete = true;
				}
			}
		}

		return task;
	};

	const setCompleteFolder = task => {
		if (task.folders) {
			$$invalidate(5, activeFolderOrder = []);

			if (task.folders.length > 0) {
				activeFolderOrder.push(task.folders[0].folder_id);
			}

			for (let i = 0; i < task.folders.length; i++) {
				let compCount = 0;

				for (let f = 0; f < task.folders[i].guides.length; f++) {
					if (completedGuides.indexOf(task.folders[i].guides[f].tour_id.toString()) !== -1) {
						task.folders[i].guides[f].is_guide_complete = true;
						compCount++;
					}

					if (task.folders[i].guides.length === compCount && task.folders[i + 1] && !GmCXt.isEmpty(task.folders[i + 1]) && activeFolderOrder.indexOf(task.folders[i + 1].folder_id) === -1) {
						activeFolderOrder.push(task.folders[i + 1].folder_id);
					}
				}
			}
		}

		return task;
	};

	const getPlayActionIcon = guide => {
		let t = {
			tour_settings: GmCXt.parseJSON(guide.tour_settings)
		};

		let da = rootScope.getDefaultPlayAction(t);

		if (GmCXt.isOnboarding(guide)) {
			return rootScope.svgs.guide_onboarding;
		}

		if (da === rootScope.playSlideshow || t.tour_settings.defaultPlayAction === 'Default' && GmCXt.getAppSetting('defaultPlayAction') === rootScope.playSlideshow) {
			return rootScope.svgs.guideShowMe;
		}

		if (da === rootScope.playAuto || t.tour_settings.defaultPlayAction === 'Default' && GmCXt.getAppSetting('defaultPlayAction') === rootScope.playAuto) {
			return rootScope.svgs.guideDoItForMe;
		}

		return rootScope.svgs.default_guide;
	};

	const guidePlayActionTitle = guide => {
		let t = {
			tour_settings: GmCXt.parseJSON(guide.tour_settings)
		};

		let da = rootScope.getDefaultPlayAction(t);

		if (GmCXt.isOnboarding(guide)) {
			return rootScope.labels.showMe;
		}

		if (da === rootScope.playSlideshow || t.tour_settings.defaultPlayAction === 'Default' && GmCXt.getAppSetting('defaultPlayAction') === rootScope.playSlideshow) {
			return rootScope.labels.showMe;
		}

		if (da === rootScope.playAuto || t.tour_settings.defaultPlayAction === 'Default' && GmCXt.getAppSetting('defaultPlayAction') === rootScope.playAuto) {
			return rootScope.labels.doItForMe;
		}

		return rootScope.labels.guideMe;
	};

	const onBack = () => {
		$$invalidate(0, rootScope.isTaskListActive = false, rootScope);
		rootScope.refreshCurrentPage();
		Gm.activeView.set('home');
	};

	GmCXt.timeout(
		function () {
			setHeight();
		},
		500
	);

	/* set the list hight on window resize */
	mg$(window).off('resize').on('resize', setHeight);

	onMount(() => {
		if (GmCXt.isPlayer()) {
			rootScope.bindPlayerTheme();
		}
	});

	onDestroy(() => {
		allTaskListSubscriber();
	});

	const click_handler = () => onBack();
	const click_handler_1 = (guide, task, e) => playGuide(guide, e, task);
	const click_handler_2 = (guide, task, e) => playGuide(guide, e, task);
	const click_handler_3 = (folder, i, index, e) => openTaskFolder(folder, i, index, e);
	const click_handler_4 = (task, index) => openTask(task, index);
	completedGuides = [];
	$$invalidate(9, activeGuideOrder = 1);

	return [
		rootScope,
		allTaskList,
		taskProgress,
		openTaskId,
		forceCompletion,
		activeFolderOrder,
		openTaskFolderId,
		totalTask,
		completedTask,
		activeGuideOrder,
		openTask,
		playGuide,
		openTaskFolder,
		getPlayActionIcon,
		guidePlayActionTitle,
		onBack,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4
	];
}

class TaskList extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {}, null, [-1, -1]);
	}
}

/* src/components/ChangePassword.svelte generated by Svelte v4.2.20 */

function create_if_block_6$1(ctx) {
	let wmgPlayerJSTest_;
	let t_value = /*rootScope*/ ctx[0].labels.passFieldIsEmpty + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_error-text-color");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t);
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.passFieldIsEmpty + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (154:6) {#if showCurrentPwError}
function create_if_block_5$1(ctx) {
	let wmgPlayerJSTest_;
	let t_value = /*rootScope*/ ctx[0].labels.passwordError + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_error-input-wrapper password-error-wrapper active");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t);
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.passwordError + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (179:6) {#if newPwEmpty || !newPw.trim()}
function create_if_block_4$1(ctx) {
	let wmgPlayerJSTest_;
	let t_value = /*rootScope*/ ctx[0].labels.passFieldIsEmpty + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_error-text-color");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t);
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.passFieldIsEmpty + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (185:6) {#if showNewPwError}
function create_if_block_3$2(ctx) {
	let wmgPlayerJSTest_;
	let t_value = /*rootScope*/ ctx[0].labels.passwordError + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_error-input-wrapper password-error-wrapper active");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t);
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.passwordError + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (209:6) {#if confirmPwEmpty || !confirmPw.trim()}
function create_if_block_2$2(ctx) {
	let wmgPlayerJSTest_;
	let t_value = /*rootScope*/ ctx[0].labels.passFieldIsEmpty + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_error-text-color");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t);
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.passFieldIsEmpty + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (215:6) {#if showConfirmPwError}
function create_if_block_1$2(ctx) {
	let wmgPlayerJSTest_;
	let t_value = /*rootScope*/ ctx[0].labels.passwordError + "";
	let t;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t = text(t_value);
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_error-input-wrapper password-error-wrapper active");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t);
		},
		p(ctx, dirty) {
			if (dirty & /*rootScope*/ 1 && t_value !== (t_value = /*rootScope*/ ctx[0].labels.passwordError + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (223:4) {#if !rootScope.config.hideCaptcha}
function create_if_block$2(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let t0_value = /*rootScope*/ ctx[0].labels.captchaLbl + "";
	let t0;
	let t1;
	let captcha;
	let updating_captchaValid;
	let updating_showCaptchaError;
	let current;

	function captcha_captchaValid_binding(value) {
		/*captcha_captchaValid_binding*/ ctx[20](value);
	}

	function captcha_showCaptchaError_binding(value) {
		/*captcha_showCaptchaError_binding*/ ctx[21](value);
	}

	let captcha_props = {};

	if (/*validCaptcha*/ ctx[4] !== void 0) {
		captcha_props.captchaValid = /*validCaptcha*/ ctx[4];
	}

	if (/*showCapError*/ ctx[5] !== void 0) {
		captcha_props.showCaptchaError = /*showCapError*/ ctx[5];
	}

	captcha = new Captcha({ props: captcha_props });
	binding_callbacks.push(() => bind(captcha, 'captchaValid', captcha_captchaValid_binding));
	binding_callbacks.push(() => bind(captcha, 'showCaptchaError', captcha_showCaptchaError_binding));

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			create_component(captcha.$$.fragment);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_change-password-label");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_margin-tb-10");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, t0);
			append(wmgPlayerJSTest_1, t1);
			mount_component(captcha, wmgPlayerJSTest_1, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*rootScope*/ 1) && t0_value !== (t0_value = /*rootScope*/ ctx[0].labels.captchaLbl + "")) set_data(t0, t0_value);
			const captcha_changes = {};

			if (!updating_captchaValid && dirty & /*validCaptcha*/ 16) {
				updating_captchaValid = true;
				captcha_changes.captchaValid = /*validCaptcha*/ ctx[4];
				add_flush_callback(() => updating_captchaValid = false);
			}

			if (!updating_showCaptchaError && dirty & /*showCapError*/ 32) {
				updating_showCaptchaError = true;
				captcha_changes.showCaptchaError = /*showCapError*/ ctx[5];
				add_flush_callback(() => updating_showCaptchaError = false);
			}

			captcha.$set(captcha_changes);
		},
		i(local) {
			if (current) return;
			transition_in(captcha.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(captcha.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}

			destroy_component(captcha);
		}
	};
}

function create_fragment$2(ctx) {
	let header;
	let t0;
	let wmgPlayerJSTest_18;
	let wmgPlayerJSTest_5;
	let wmgPlayerJSTest_3;
	let wmgPlayerJSTest_0;
	let raw_value = /*rootScope*/ ctx[0].svgs.iconBack + "";
	let t1;
	let wmgPlayerJSTest_2;
	let wmgPlayerJSTest_1;
	let t2_value = /*rootScope*/ ctx[0].labels.back + "";
	let t2;
	let t3;
	let wmgPlayerJSTest_4;
	let t4_value = /*rootScope*/ ctx[0].labels.changePassword + "";
	let t4;
	let t5;
	let wmgPlayerJSTest_17;
	let form;
	let wmgPlayerJSTest_15;
	let wmgPlayerJSTest_12;
	let wmgPlayerJSTest_7;
	let wmgPlayerJSTest_6;
	let t6_value = /*rootScope*/ ctx[0].labels.placeholderCurrentPassword + "";
	let t6;
	let t7;
	let input0;
	let input0_placeholder_value;
	let t8;
	let show_if_2 = /*currentPwEmpty*/ ctx[6] || !/*currentPw*/ ctx[1].trim();
	let t9;
	let t10;
	let wmgPlayerJSTest_9;
	let wmgPlayerJSTest_8;
	let t11_value = /*rootScope*/ ctx[0].labels.placeholderNewPassword + "";
	let t11;
	let t12;
	let input1;
	let input1_placeholder_value;
	let t13;
	let show_if_1 = /*newPwEmpty*/ ctx[8] || !/*newPw*/ ctx[2].trim();
	let t14;
	let t15;
	let wmgPlayerJSTest_11;
	let wmgPlayerJSTest_10;
	let t16_value = /*rootScope*/ ctx[0].labels.placeholderPasswordC + "";
	let t16;
	let t17;
	let input2;
	let input2_placeholder_value;
	let t18;
	let show_if = /*confirmPwEmpty*/ ctx[10] || !/*confirmPw*/ ctx[3].trim();
	let t19;
	let t20;
	let t21;
	let wmgPlayerJSTest_13;
	let button0;
	let t22_value = /*rootScope*/ ctx[0].labels.change + "";
	let t22;
	let button0_aria_label_value;
	let t23;
	let button1;
	let t24_value = /*rootScope*/ ctx[0].labels.btnCancel + "";
	let t24;
	let button1_aria_label_value;
	let t25;
	let wmgPlayerJSTest_14;
	let t26;
	let wmgPlayerJSTest_16;
	let t27;
	let footer;
	let current;
	let mounted;
	let dispose;
	header = new Header({});
	let if_block0 = show_if_2 && create_if_block_6$1(ctx);
	let if_block1 = /*showCurrentPwError*/ ctx[7] && create_if_block_5$1(ctx);
	let if_block2 = show_if_1 && create_if_block_4$1(ctx);
	let if_block3 = /*showNewPwError*/ ctx[9] && create_if_block_3$2(ctx);
	let if_block4 = show_if && create_if_block_2$2(ctx);
	let if_block5 = /*showConfirmPwError*/ ctx[11] && create_if_block_1$2(ctx);
	let if_block6 = !/*rootScope*/ ctx[0].config.hideCaptcha && create_if_block$2(ctx);
	footer = new Footer({});

	return {
		c() {
			create_component(header.$$.fragment);
			t0 = space();
			wmgPlayerJSTest_18 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			t1 = space();
			wmgPlayerJSTest_2 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t2 = text(t2_value);
			t3 = space();
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			t4 = text(t4_value);
			t5 = space();
			wmgPlayerJSTest_17 = element("wmgPlayerJSTest_");
			form = element("form");
			wmgPlayerJSTest_15 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_12 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_6 = element("wmgPlayerJSTest_");
			t6 = text(t6_value);
			t7 = space();
			input0 = element("input");
			t8 = space();
			if (if_block0) if_block0.c();
			t9 = space();
			if (if_block1) if_block1.c();
			t10 = space();
			wmgPlayerJSTest_9 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			t11 = text(t11_value);
			t12 = space();
			input1 = element("input");
			t13 = space();
			if (if_block2) if_block2.c();
			t14 = space();
			if (if_block3) if_block3.c();
			t15 = space();
			wmgPlayerJSTest_11 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_10 = element("wmgPlayerJSTest_");
			t16 = text(t16_value);
			t17 = space();
			input2 = element("input");
			t18 = space();
			if (if_block4) if_block4.c();
			t19 = space();
			if (if_block5) if_block5.c();
			t20 = space();
			if (if_block6) if_block6.c();
			t21 = space();
			wmgPlayerJSTest_13 = element("wmgPlayerJSTest_");
			button0 = element("button");
			t22 = text(t22_value);
			t23 = space();
			button1 = element("button");
			t24 = text(t24_value);
			t25 = space();
			wmgPlayerJSTest_14 = element("wmgPlayerJSTest_");
			t26 = space();
			wmgPlayerJSTest_16 = element("wmgPlayerJSTest_");
			t27 = space();
			create_component(footer.$$.fragment);
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_ege-inline-block-vm");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_2, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-center");
			attr(wmgPlayerJSTest_3, "id", "mgPlayerJSTest_btn-back-change-pass");
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_ege-inline-block-vm mgPlayerJSTest_back-btn mgPlayerJSTest_icons-hover-effect mgPlayerJSTest_back-btn");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_header-text mgPlayerJSTest_margin-lr-10 mgPlayerJSTest_font-size-16 mgPlayerJSTest_text-color-white mgPlayerJSTest_text-overflow-ellipsis");
			attr(wmgPlayerJSTest_5, "class", "mgPlayerJSTest_header-title mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_padding-lr-15");
			attr(wmgPlayerJSTest_6, "id", "mgPlayerJSTest_current-password-label");
			attr(wmgPlayerJSTest_6, "class", "mgPlayerJSTest_change-password-label");
			attr(input0, "class", "mgPlayerJSTest_input-type-text mgPlayerJSTest_width-100 password-text-text mgPlayerJSTest_text-input mgPlayerJSTest_ege-inline-block-vm mgPlayerJSTest_font-size-16");
			attr(input0, "autocomplete", "off");
			attr(input0, "maxlength", "20");
			attr(input0, "spellcheck", "true");
			attr(input0, "type", "password");
			attr(input0, "placeholder", input0_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderCurrentPassword);
			attr(input0, "name", "currentPassword");
			input0.required = true;
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_current-password-wrapper");
			attr(wmgPlayerJSTest_8, "id", "mgPlayerJSTest_new-password-label");
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_change-password-label");
			attr(input1, "class", "mgPlayerJSTest_input-type-text mgPlayerJSTest_width-100 password-text-text mgPlayerJSTest_text-input mgPlayerJSTest_ege-inline-block-vm mgPlayerJSTest_font-size-16");
			attr(input1, "autocomplete", "off");
			attr(input1, "minlength", "8");
			attr(input1, "maxlength", "20");
			attr(input1, "spellcheck", "true");
			attr(input1, "type", "password");
			attr(input1, "placeholder", input1_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderNewPassword);
			attr(input1, "name", "newPassword");
			input1.required = true;
			attr(wmgPlayerJSTest_9, "class", "mgPlayerJSTest_new-password-wrapper");
			attr(wmgPlayerJSTest_10, "id", "mgPlayerJSTest_confirm-password-label");
			attr(wmgPlayerJSTest_10, "class", "mgPlayerJSTest_change-password-label");
			attr(input2, "class", "mgPlayerJSTest_input-type-text mgPlayerJSTest_width-100 password-text-text mgPlayerJSTest_text-input mgPlayerJSTest_ege-inline-block-vm mgPlayerJSTest_font-size-16");
			attr(input2, "autocomplete", "off");
			attr(input2, "minlength", "8");
			attr(input2, "maxlength", "20");
			attr(input2, "spellcheck", "true");
			attr(input2, "type", "password");
			attr(input2, "placeholder", input2_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderPasswordC);
			attr(input2, "name", "confirmPassword");
			input2.required = true;
			attr(wmgPlayerJSTest_11, "class", "mgPlayerJSTest_confirm-password-wrapper");
			attr(wmgPlayerJSTest_12, "class", "signin-form");
			attr(button0, "type", "button");
			attr(button0, "class", "mgPlayerJSTest_btn-default mgPlayerJSTest_btn-neutral");
			attr(button0, "aria-label", button0_aria_label_value = /*rootScope*/ ctx[0].labels.change);
			toggle_class(button0, "mgPlayerJSTest_disabled", !/*currentPw*/ ctx[1].trim() || /*currentPwEmpty*/ ctx[6] || /*showCurrentPwError*/ ctx[7] || !/*newPw*/ ctx[2].trim() || /*newPwEmpty*/ ctx[8] || /*showNewPwError*/ ctx[9] || !/*confirmPw*/ ctx[3].trim() || /*confirmPwEmpty*/ ctx[10] || /*showConfirmPwError*/ ctx[11] || /*showCapError*/ ctx[5]);
			attr(button1, "class", "mgPlayerJSTest_btn-default mgPlayerJSTest_btn-neutral");
			attr(button1, "aria-label", button1_aria_label_value = /*rootScope*/ ctx[0].labels.btnCancel);
			attr(wmgPlayerJSTest_13, "class", "mgPlayerJSTest_change-password-footer mgPlayerJSTest_text-align-center mgPlayerJSTest_margin-tb-15");
			attr(wmgPlayerJSTest_14, "class", "mgPlayerJSTest_ege-clear");
			attr(wmgPlayerJSTest_15, "class", "signin-form-container mgPlayerJSTest_no-border mgPlayerJSTest_no-border-all mgPlayerJSTest_no-padding mgPlayerJSTest_no-box-shadow");
			attr(wmgPlayerJSTest_16, "class", "mgPlayerJSTest_ege-clear");
			attr(form, "name", "cForm");
			attr(form, "autocomplete", "off");
			attr(form, "method", "post");
			attr(wmgPlayerJSTest_17, "class", "signin-page-wrapper mgPlayerJSTest_change-password-wrapper");
			attr(wmgPlayerJSTest_18, "class", "mgPlayerJSTest_ege-panel-main-container mgPlayerJSTest_signin-page-container");
		},
		m(target, anchor) {
			mount_component(header, target, anchor);
			insert(target, t0, anchor);
			insert(target, wmgPlayerJSTest_18, anchor);
			append(wmgPlayerJSTest_18, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_0);
			wmgPlayerJSTest_0.innerHTML = raw_value;
			append(wmgPlayerJSTest_3, t1);
			append(wmgPlayerJSTest_3, wmgPlayerJSTest_2);
			append(wmgPlayerJSTest_2, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_1, t2);
			append(wmgPlayerJSTest_5, t3);
			append(wmgPlayerJSTest_5, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, t4);
			append(wmgPlayerJSTest_18, t5);
			append(wmgPlayerJSTest_18, wmgPlayerJSTest_17);
			append(wmgPlayerJSTest_17, form);
			append(form, wmgPlayerJSTest_15);
			append(wmgPlayerJSTest_15, wmgPlayerJSTest_12);
			append(wmgPlayerJSTest_12, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_7, wmgPlayerJSTest_6);
			append(wmgPlayerJSTest_6, t6);
			append(wmgPlayerJSTest_7, t7);
			append(wmgPlayerJSTest_7, input0);
			set_input_value(input0, /*currentPw*/ ctx[1]);
			append(wmgPlayerJSTest_7, t8);
			if (if_block0) if_block0.m(wmgPlayerJSTest_7, null);
			append(wmgPlayerJSTest_7, t9);
			if (if_block1) if_block1.m(wmgPlayerJSTest_7, null);
			append(wmgPlayerJSTest_12, t10);
			append(wmgPlayerJSTest_12, wmgPlayerJSTest_9);
			append(wmgPlayerJSTest_9, wmgPlayerJSTest_8);
			append(wmgPlayerJSTest_8, t11);
			append(wmgPlayerJSTest_9, t12);
			append(wmgPlayerJSTest_9, input1);
			set_input_value(input1, /*newPw*/ ctx[2]);
			append(wmgPlayerJSTest_9, t13);
			if (if_block2) if_block2.m(wmgPlayerJSTest_9, null);
			append(wmgPlayerJSTest_9, t14);
			if (if_block3) if_block3.m(wmgPlayerJSTest_9, null);
			append(wmgPlayerJSTest_12, t15);
			append(wmgPlayerJSTest_12, wmgPlayerJSTest_11);
			append(wmgPlayerJSTest_11, wmgPlayerJSTest_10);
			append(wmgPlayerJSTest_10, t16);
			append(wmgPlayerJSTest_11, t17);
			append(wmgPlayerJSTest_11, input2);
			set_input_value(input2, /*confirmPw*/ ctx[3]);
			append(wmgPlayerJSTest_11, t18);
			if (if_block4) if_block4.m(wmgPlayerJSTest_11, null);
			append(wmgPlayerJSTest_11, t19);
			if (if_block5) if_block5.m(wmgPlayerJSTest_11, null);
			append(wmgPlayerJSTest_15, t20);
			if (if_block6) if_block6.m(wmgPlayerJSTest_15, null);
			append(wmgPlayerJSTest_15, t21);
			append(wmgPlayerJSTest_15, wmgPlayerJSTest_13);
			append(wmgPlayerJSTest_13, button0);
			append(button0, t22);
			append(wmgPlayerJSTest_13, t23);
			append(wmgPlayerJSTest_13, button1);
			append(button1, t24);
			append(wmgPlayerJSTest_15, t25);
			append(wmgPlayerJSTest_15, wmgPlayerJSTest_14);
			append(form, t26);
			append(form, wmgPlayerJSTest_16);
			insert(target, t27, anchor);
			mount_component(footer, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_3, "click", /*back*/ ctx[13]),
					listen(input0, "input", /*input0_input_handler*/ ctx[14]),
					listen(input0, "focus", /*focus_handler*/ ctx[15]),
					listen(input1, "input", /*input1_input_handler*/ ctx[16]),
					listen(input1, "focus", /*focus_handler_1*/ ctx[17]),
					listen(input2, "input", /*input2_input_handler*/ ctx[18]),
					listen(input2, "focus", /*focus_handler_2*/ ctx[19]),
					listen(button0, "click", /*click_handler*/ ctx[22]),
					listen(button1, "click", /*click_handler_1*/ ctx[23])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*rootScope*/ 1) && raw_value !== (raw_value = /*rootScope*/ ctx[0].svgs.iconBack + "")) wmgPlayerJSTest_0.innerHTML = raw_value;			if ((!current || dirty & /*rootScope*/ 1) && t2_value !== (t2_value = /*rootScope*/ ctx[0].labels.back + "")) set_data(t2, t2_value);
			if ((!current || dirty & /*rootScope*/ 1) && t4_value !== (t4_value = /*rootScope*/ ctx[0].labels.changePassword + "")) set_data(t4, t4_value);
			if ((!current || dirty & /*rootScope*/ 1) && t6_value !== (t6_value = /*rootScope*/ ctx[0].labels.placeholderCurrentPassword + "")) set_data(t6, t6_value);

			if (!current || dirty & /*rootScope*/ 1 && input0_placeholder_value !== (input0_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderCurrentPassword)) {
				attr(input0, "placeholder", input0_placeholder_value);
			}

			if (dirty & /*currentPw*/ 2 && input0.value !== /*currentPw*/ ctx[1]) {
				set_input_value(input0, /*currentPw*/ ctx[1]);
			}

			if (dirty & /*currentPwEmpty, currentPw*/ 66) show_if_2 = /*currentPwEmpty*/ ctx[6] || !/*currentPw*/ ctx[1].trim();

			if (show_if_2) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_6$1(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_7, t9);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*showCurrentPwError*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_5$1(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_7, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if ((!current || dirty & /*rootScope*/ 1) && t11_value !== (t11_value = /*rootScope*/ ctx[0].labels.placeholderNewPassword + "")) set_data(t11, t11_value);

			if (!current || dirty & /*rootScope*/ 1 && input1_placeholder_value !== (input1_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderNewPassword)) {
				attr(input1, "placeholder", input1_placeholder_value);
			}

			if (dirty & /*newPw*/ 4 && input1.value !== /*newPw*/ ctx[2]) {
				set_input_value(input1, /*newPw*/ ctx[2]);
			}

			if (dirty & /*newPwEmpty, newPw*/ 260) show_if_1 = /*newPwEmpty*/ ctx[8] || !/*newPw*/ ctx[2].trim();

			if (show_if_1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_4$1(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_9, t14);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*showNewPwError*/ ctx[9]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_3$2(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_9, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if ((!current || dirty & /*rootScope*/ 1) && t16_value !== (t16_value = /*rootScope*/ ctx[0].labels.placeholderPasswordC + "")) set_data(t16, t16_value);

			if (!current || dirty & /*rootScope*/ 1 && input2_placeholder_value !== (input2_placeholder_value = /*rootScope*/ ctx[0].labels.placeholderPasswordC)) {
				attr(input2, "placeholder", input2_placeholder_value);
			}

			if (dirty & /*confirmPw*/ 8 && input2.value !== /*confirmPw*/ ctx[3]) {
				set_input_value(input2, /*confirmPw*/ ctx[3]);
			}

			if (dirty & /*confirmPwEmpty, confirmPw*/ 1032) show_if = /*confirmPwEmpty*/ ctx[10] || !/*confirmPw*/ ctx[3].trim();

			if (show_if) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_2$2(ctx);
					if_block4.c();
					if_block4.m(wmgPlayerJSTest_11, t19);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (/*showConfirmPwError*/ ctx[11]) {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block_1$2(ctx);
					if_block5.c();
					if_block5.m(wmgPlayerJSTest_11, null);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (!/*rootScope*/ ctx[0].config.hideCaptcha) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty & /*rootScope*/ 1) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block$2(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(wmgPlayerJSTest_15, t21);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*rootScope*/ 1) && t22_value !== (t22_value = /*rootScope*/ ctx[0].labels.change + "")) set_data(t22, t22_value);

			if (!current || dirty & /*rootScope*/ 1 && button0_aria_label_value !== (button0_aria_label_value = /*rootScope*/ ctx[0].labels.change)) {
				attr(button0, "aria-label", button0_aria_label_value);
			}

			if (!current || dirty & /*currentPw, currentPwEmpty, showCurrentPwError, newPw, newPwEmpty, showNewPwError, confirmPw, confirmPwEmpty, showConfirmPwError, showCapError*/ 4078) {
				toggle_class(button0, "mgPlayerJSTest_disabled", !/*currentPw*/ ctx[1].trim() || /*currentPwEmpty*/ ctx[6] || /*showCurrentPwError*/ ctx[7] || !/*newPw*/ ctx[2].trim() || /*newPwEmpty*/ ctx[8] || /*showNewPwError*/ ctx[9] || !/*confirmPw*/ ctx[3].trim() || /*confirmPwEmpty*/ ctx[10] || /*showConfirmPwError*/ ctx[11] || /*showCapError*/ ctx[5]);
			}

			if ((!current || dirty & /*rootScope*/ 1) && t24_value !== (t24_value = /*rootScope*/ ctx[0].labels.btnCancel + "")) set_data(t24, t24_value);

			if (!current || dirty & /*rootScope*/ 1 && button1_aria_label_value !== (button1_aria_label_value = /*rootScope*/ ctx[0].labels.btnCancel)) {
				attr(button1, "aria-label", button1_aria_label_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(if_block6);
			transition_in(footer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(header.$$.fragment, local);
			transition_out(if_block6);
			transition_out(footer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(wmgPlayerJSTest_18);
				detach(t27);
			}

			destroy_component(header, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			destroy_component(footer, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	rootScope.currentView = 'change-password-view';
	let user = {};
	let currentPw = '';
	let newPw = '';
	let confirmPw = '';
	let validCaptcha = false;
	let showCapError = false;
	let currentPwEmpty = false;
	let showCurrentPwError = false;
	let newPwEmpty = false;
	let showNewPwError = false;
	let confirmPwEmpty = false;
	let showConfirmPwError = false;

	const submitChangePasswordForm = () => {
		if (GmCXt.isEmpty(currentPw)) {
			$$invalidate(6, currentPwEmpty = true);
		} else if (!GmCXt.isEmpty(currentPw) && currentPw.length < 8) {
			$$invalidate(7, showCurrentPwError = true);
		}

		if (GmCXt.isEmpty(newPw)) {
			$$invalidate(8, newPwEmpty = true);
		} else if (!GmCXt.isEmpty(newPw) && newPw.length < 8) {
			$$invalidate(9, showNewPwError = true);
		}

		if (GmCXt.isEmpty(confirmPw)) {
			$$invalidate(10, confirmPwEmpty = true);
		} else if (!GmCXt.isEmpty(confirmPw) && confirmPw.length < 8) {
			$$invalidate(11, showConfirmPwError = true);
		}

		if (!validCaptcha && !GmCXt.conf.hideCaptcha) {
			$$invalidate(5, showCapError = true);
			Gm.loading.set(false);
		}

		if (currentPwEmpty || showCurrentPwError || newPwEmpty || showNewPwError || confirmPwEmpty || showConfirmPwError || showCapError) {
			return;
		}

		if (newPw !== confirmPw) {
			rootScope.showPopup(rootScope.labels.msgConfirmNewPasswordError);
		} else {
			passwordChange();
		}
	};

	const passwordChange = () => {
		Gm.loading.set(true);

		function onSuccessCallback() {
			rootScope.logout('password_change');
		}

		function onSuccess(response) {
			Gm.loading.set(false);
			modal.open(rootScope.labels.msgPasswordChangedSuccess, 'success', onSuccessCallback, onSuccessCallback);
		}

		let data = {
			user_id: user.user_id,
			new_password: newPw,
			existing_password: currentPw
		};

		api.changePassword(data, onSuccess);
	};

	const back = () => {
		Gm.activeView.set('home');
	};

	user = rootScope.user;
	Gm.loading.set(false);

	onMount(() => {
		
	});

	function input0_input_handler() {
		currentPw = this.value;
		$$invalidate(1, currentPw);
	}

	const focus_handler = () => $$invalidate(7, showCurrentPwError = false);

	function input1_input_handler() {
		newPw = this.value;
		$$invalidate(2, newPw);
	}

	const focus_handler_1 = () => $$invalidate(9, showNewPwError = false);

	function input2_input_handler() {
		confirmPw = this.value;
		$$invalidate(3, confirmPw);
	}

	const focus_handler_2 = () => $$invalidate(11, showConfirmPwError = false);

	function captcha_captchaValid_binding(value) {
		validCaptcha = value;
		$$invalidate(4, validCaptcha);
	}

	function captcha_showCaptchaError_binding(value) {
		showCapError = value;
		$$invalidate(5, showCapError);
	}

	const click_handler = () => submitChangePasswordForm();
	const click_handler_1 = () => back();

	return [
		rootScope,
		currentPw,
		newPw,
		confirmPw,
		validCaptcha,
		showCapError,
		currentPwEmpty,
		showCurrentPwError,
		newPwEmpty,
		showNewPwError,
		confirmPwEmpty,
		showConfirmPwError,
		submitChangePasswordForm,
		back,
		input0_input_handler,
		focus_handler,
		input1_input_handler,
		focus_handler_1,
		input2_input_handler,
		focus_handler_2,
		captcha_captchaValid_binding,
		captcha_showCaptchaError_binding,
		click_handler,
		click_handler_1
	];
}

class ChangePassword extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});
	}
}

/* src/components/App.svelte generated by Svelte v4.2.20 */

function create_if_block_8(ctx) {
	let taskstatus;
	let current;
	taskstatus = new Empty({});

	return {
		c() {
			create_component(taskstatus.$$.fragment);
		},
		m(target, anchor) {
			mount_component(taskstatus, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(taskstatus.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(taskstatus.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(taskstatus, detaching);
		}
	};
}

// (74:38) 
function create_if_block_7(ctx) {
	let findreplace;
	let current;
	findreplace = new Empty({});

	return {
		c() {
			create_component(findreplace.$$.fragment);
		},
		m(target, anchor) {
			mount_component(findreplace, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(findreplace.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(findreplace.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(findreplace, detaching);
		}
	};
}

// (72:34) 
function create_if_block_6(ctx) {
	let changepassword;
	let current;
	changepassword = new ChangePassword({});

	return {
		c() {
			create_component(changepassword.$$.fragment);
		},
		m(target, anchor) {
			mount_component(changepassword, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(changepassword.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(changepassword.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(changepassword, detaching);
		}
	};
}

// (70:34) 
function create_if_block_5(ctx) {
	let tasklist;
	let current;
	tasklist = new TaskList({});

	return {
		c() {
			create_component(tasklist.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tasklist, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(tasklist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tasklist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tasklist, detaching);
		}
	};
}

// (68:33) 
function create_if_block_4(ctx) {
	let chatbot;
	let current;
	chatbot = new Bot({});

	return {
		c() {
			create_component(chatbot.$$.fragment);
		},
		m(target, anchor) {
			mount_component(chatbot, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(chatbot.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(chatbot.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(chatbot, detaching);
		}
	};
}

// (66:35) 
function create_if_block_3$1(ctx) {
	let forgotpwd;
	let current;
	forgotpwd = new ForgotPwd({});

	return {
		c() {
			create_component(forgotpwd.$$.fragment);
		},
		m(target, anchor) {
			mount_component(forgotpwd, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(forgotpwd.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(forgotpwd.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(forgotpwd, detaching);
		}
	};
}

// (64:30) 
function create_if_block_2$1(ctx) {
	let home;
	let current;
	home = new Home({});

	return {
		c() {
			create_component(home.$$.fragment);
		},
		m(target, anchor) {
			mount_component(home, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(home.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(home.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(home, detaching);
		}
	};
}

// (62:1) {#if loadComp == 'signin'}
function create_if_block_1$1(ctx) {
	let signin;
	let current;
	signin = new SignIn({});

	return {
		c() {
			create_component(signin.$$.fragment);
		},
		m(target, anchor) {
			mount_component(signin, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(signin.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(signin.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(signin, detaching);
		}
	};
}

// (80:1) {#if loading}
function create_if_block$1(ctx) {
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_0;
	let img;
	let img_src_value;

	return {
		c() {
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			img = element("img");
			attr(img, "class", "mgPlayerJSTest_loader-image");
			if (!src_url_equal(img.src, img_src_value = GmCXt.loader())) attr(img, "src", img_src_value);
			attr(img, "alt", "loader");
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_ege-loader-wrapper-spinner");
			attr(wmgPlayerJSTest_1, "id", "ege-spinner");
			attr(wmgPlayerJSTest_1, "class", "mgPlayerJSTest_ege-loader-wrapper");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_1, anchor);
			append(wmgPlayerJSTest_1, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_0, img);
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_1);
			}
		}
	};
}

// (61:0) {#key renderKey}
function create_key_block(ctx) {
	let current_block_type_index;
	let if_block0;
	let t0;
	let t1;
	let input;
	let current;

	const if_block_creators = [
		create_if_block_1$1,
		create_if_block_2$1,
		create_if_block_3$1,
		create_if_block_4,
		create_if_block_5,
		create_if_block_6,
		create_if_block_7,
		create_if_block_8
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*loadComp*/ ctx[0] == 'signin') return 0;
		if (/*loadComp*/ ctx[0] == 'home') return 1;
		if (/*loadComp*/ ctx[0] == 'forgotpwd') return 2;
		if (/*loadComp*/ ctx[0] == 'chatbot') return 3;
		if (/*loadComp*/ ctx[0] == 'taskList') return 4;
		if (/*loadComp*/ ctx[0] == 'changePw') return 5;
		if (/*loadComp*/ ctx[0] == 'findNReplace') return 6;
		if (/*loadComp*/ ctx[0] == 'taskStatus') return 7;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	let if_block1 = /*loading*/ ctx[1] && create_if_block$1();

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			input = element("input");
			attr(input, "class", "mgPlayerJSTest_display-none");
			attr(input, "spellcheck", "true");
			attr(input, "id", "mgPlayerJSTest_add-step-upload-file");
			attr(input, "type", "file");
			attr(input, "tabindex", "-1");
			attr(input, "accept", "image/png,image/jpeg");
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			insert(target, input, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block0) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					}

					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				} else {
					if_block0 = null;
				}
			}

			if (/*loading*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$1();
					if_block1.c();
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(input);
			}

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (if_block1) if_block1.d(detaching);
		}
	};
}

function create_fragment$1(ctx) {
	let previous_key = /*renderKey*/ ctx[2];
	let key_block_anchor;
	let current;
	let key_block = create_key_block(ctx);

	return {
		c() {
			key_block.c();
			key_block_anchor = empty();
		},
		m(target, anchor) {
			key_block.m(target, anchor);
			insert(target, key_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*renderKey*/ 4 && safe_not_equal(previous_key, previous_key = /*renderKey*/ ctx[2])) {
				group_outros();
				transition_out(key_block, 1, 1, noop);
				check_outros();
				key_block = create_key_block(ctx);
				key_block.c();
				transition_in(key_block, 1);
				key_block.m(key_block_anchor.parentNode, key_block_anchor);
			} else {
				key_block.p(ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(key_block);
			current = true;
		},
		o(local) {
			transition_out(key_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(key_block_anchor);
			}

			key_block.d(detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { loadComp = 'signin' } = $$props;
	let loading = false;
	GmCXt.refreshView = false;
	let renderKey = 0;

	// Function to trigger the re-render
	function resetRenderComponent() {
		$$invalidate(2, renderKey += 1); // Changing the key will force reinitialization
	}

	const loadActiveView = function () {
		$$invalidate(0, loadComp = get_store_value(Gm.activeView));
	};

	const activeViewSubscriber = Gm.activeView.subscribe(value => {
		let prevView = loadComp;

		if (value !== '' && prevView === value) {
			resetRenderComponent();
		}

		if (value !== '') {
			$$invalidate(0, loadComp = value);
			GmCXt.saveToStorage('activeView', value);
		}
	});

	Gm.loading.subscribe(value => {
		$$invalidate(1, loading = value);
	});

	const propsSubscriber = Gm.dialogBox.subscribe(value => {
	});

	onMount(() => {
		loadActiveView();
	});

	onDestroy(() => {
		propsSubscriber();
		activeViewSubscriber();
	});

	$$self.$$set = $$props => {
		if ('loadComp' in $$props) $$invalidate(0, loadComp = $$props.loadComp);
	};

	return [loadComp, loading, renderKey];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { loadComp: 0 });
	}
}

/**
 * @file Guideme Popup align module
 * @author Nilesh Pachpande
 */

/** @function
 * Sets up a popup alignment with respect to highlighted area, if an alignment (see below
 * for supported alignment types) is known. By default, it sets up alignment which fits
 * first in the order.
 * If none of the supported alignment is set then it aligns popup in the center.
 *
 * @param {object} options - having properties
 *  1. popup: popup jquery object (used to fetch properties (such as width and height) and
 *      to set up its css properties)
 *  2. highlightedArea: has properties, left, top, width and height
 *  3. alignment: any one of the supported alignment types namely left-top, left-bottom,
 *      right-top, right-bottom, top-left, top-right, bottom-left, bottom-right
 *  4. containerOffset: container offset in which popup should be aligned. for example
 *      image canvas for image type step
 *  5. hardApply: If input alignment should be applied. If not possible then, do nothing.
 *      By default, it is false, tries to set a default alignment if it is not possible
 *      to set the input alignment.
 */
//else add validation based import

/*global mg$*/

function alignPopup(options) {
    options = options || {};
    const pub = {};
    const self = {
        popup: mg$(options.popup),
        highlightedArea: options.elementBounds || {},
        containerOffset: options.containerOffest || {
            left: 0,
            top: 0,
        },
        alignment: options.alignment || '',
        hardApply: options.hardApply || false,
        doNotApplyArrow: options.doNotApplyArrow || false,
        arrowClass: '',
        left: null,
        top: null,
        isSet: false,
        arrowId: options.tooltipArrowId || '',
        arrowWidth: options.isBeacon ? 5 : 12, // true after alignment is set
        isGuidance: options.isGuidance,
        customPos: options.customPos,
        isBeacon: options.isBeacon,
        dimensions: options.dimensions,
        totalHeightMinusTop: 0,
        totalWidthMinusLeft: 0,
        totalHeightMinusBottom: 0,
        totalWidthMinusRight: 0,
        stepType: options.stepType,
        disableElementColor: options.disableElementColor,
        changeInHeight: options.changeInHeight,
        isExtension: options.isExtension,
        dynamicPopupHeight: options.dynamicPopupHeight
    };


    if (!self.arrowId) {
        self.doNotApplyArrow = true;
    }

    // This value gets set in tour player only
    // Hence assigning whenever it's not set
    // if (!self.highlightedArea.cy) {
    //     self.highlightedArea.cy = self.highlightedArea.cy;
    // }
    /**
     * Verify popup should be a valid jquery selector object
     */
    if (self.popup.length === 0) {
        // GM.log('self.popup.length - ', self.popup.length, 1);
        return;
    }

    if (self.arrowId && mg$(`#${self.arrowId}`).length) {
        mg$(`#${self.arrowId}`).remove();
    }

    if (
        self.isGuidance &&
        (self.alignment === 'top' || self.alignment === 'bottom')
    ) {
        self.arrowWidth = 8;
    }
    if (
        self.stepType == 'smartTip' ||
        self.stepType == 'tooltip' ||
        self.popup.outerWidth() != 0
    )
        self.popupWidth = self.popup.outerWidth();
    else self.popupWidth = 250;
    if (
        self.changeInHeight > 125 ||
        self.stepType == 'smartTip' ||
        self.stepType == 'tooltip' ||
        self.stepType == 'beacon' || 
        self.dynamicPopupHeight === true
    ) {
        self.popupHeight = self.popup.outerHeight();
    } else {
        self.popupHeight = 125;
    }

    self.highlightedArea.cw = self.highlightedArea.cw ?
        self.highlightedArea.cw :
        0;
    self.highlightedArea.ch = self.highlightedArea.ch ?
        self.highlightedArea.ch :
        0;
    self.highlightedArea.cx = self.highlightedArea.cx ?
        self.highlightedArea.cx :
        0;
    self.highlightedArea.cy = self.highlightedArea.cy ?
        self.highlightedArea.cy :
        0;

    // Available space surrounding highlighted area
    if (self.highlightedArea.cw > 0 && self.highlightedArea.ch > 0) {
        self.availableSpace = {
            top: self.highlightedArea.cy,
            left: self.highlightedArea.cx,
            right: self.dimensions.width -
                (self.highlightedArea.cx + self.highlightedArea.cw),
            bottom: self.dimensions.height -
                (self.highlightedArea.cy + self.highlightedArea.ch),
        };
    } else {
        self.availableSpace = {
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
        };
    }

    if (!self.highlightedArea.cx && !self.highlightedArea.cy) {
        self.availableSpace.top = self.availableSpace.top ?
            self.availableSpace.top :
            0;
        self.availableSpace.left = self.availableSpace.left ?
            self.availableSpace.left :
            0;
        self.availableSpace.right = self.availableSpace.right ?
            self.availableSpace.right :
            0;
        self.availableSpace.bottom = self.availableSpace.bottom ?
            self.availableSpace.bottom :
            0;
    }

    if (self.containerOffset !== undefined) {
        if (self.containerOffset.top < 0) {
            self.containerOffset.top = 0;
        }
        if (self.containerOffset.left < 0) {
            self.containerOffset.left = 0;
        }
        self.availableSpace.top += self.containerOffset.top;
        self.availableSpace.left += self.containerOffset.left;
        self.availableSpace.right -= self.containerOffset.left;
        self.availableSpace.bottom -= self.containerOffset.top;
    }

    if (options.playingTour) ;

    if (self.availableSpace.top >= 0) {
        self.totalHeightMinusTop = self.dimensions.height - self.availableSpace.top;
    }
    if (self.availableSpace.left >= 0) {
        self.totalWidthMinusLeft = self.dimensions.width - self.availableSpace.left;
    }
    if (self.availableSpace.bottom >= 0) {
        self.totalHeightMinusBottom =
            self.dimensions.height - self.availableSpace.bottom;
    }
    if (self.availableSpace.right >= 0) {
        self.totalWidthMinusRight =
            self.dimensions.width - self.availableSpace.right;
    }

    function checkLeftMiddle() {
        if (
            Math.abs(self.availableSpace.left) > self.popupWidth &&
            self.highlightedArea.ch / 2 < screen.height
        ) {
            if (
                Math.abs(self.availableSpace.top) + self.highlightedArea.ch / 2 >
                self.popupHeight / 2 &&
                Math.abs(self.availableSpace.bottom) + self.highlightedArea.ch / 2 >
                self.popupHeight / 2
            ) {
                return true;
            }
            return false;
        }
        return false;
    }

    function alignLeftMiddle() {
        if (checkLeftMiddle()) {
            if ((self.stepType === 'smartTip' && !self.isBeacon) || self.stepType === 'validation') {
                self.left = self.highlightedArea.cx;
                if (self.isGuidance && self.isExtension || self.stepType === 'validation') {
                    self.top = self.highlightedArea.cy;
                } else {
                    self.top =
                        self.highlightedArea.cy +
                        self.highlightedArea.ch / 2 -
                        self.popupHeight / 2;
                }
            } else if (self.stepType === 'beacon_tour' && self.isExtension) {
                self.left = self.highlightedArea.cx;
                self.top = self.highlightedArea.cy;
            } else if (self.stepType === 'inline' || self.stepType === 'message') {
                self.left = self.highlightedArea.cx - self.popupWidth - self.arrowWidth;
                self.top =
                    self.highlightedArea.cy +
                    self.highlightedArea.ch / 2 -
                    self.popupHeight / 2;
            } else {
                self.left = self.highlightedArea.cx - self.popupWidth - 5;
                self.top =
                    self.highlightedArea.cy +
                    self.highlightedArea.ch / 2 -
                    self.popupHeight / 2;
            }
            self.arrowClass = 'mgPlayerJSTest_arrow-right';
            self.arrowLeft = self.highlightedArea.cx - 12;
            self.arrowTop = self.top + self.popupHeight / 2 - 10;
            self.isSet = true;
            self.alignment = 'left-middle';
        }
    }

    function checkLeftTop() {
        if (
            Math.abs(self.availableSpace.left) > self.popupWidth &&
            self.totalHeightMinusTop > self.popupHeight
        ) {
            return true;
        }
        return false;
    }

    function alignLeftTop() {
        if (checkLeftTop()) {
            self.left = self.highlightedArea.cx - self.popupWidth - self.arrowWidth;
            self.top = self.highlightedArea.cy;
            self.arrowClass = 'mgPlayerJSTest_arrow-right';
            self.arrowLeft = self.highlightedArea.cx - 12;
            self.arrowTop = self.top + 7;
            self.isSet = true;
            self.alignment = 'left-top';
        }
    }

    function checkLeftBottom() {
        if (
            Math.abs(self.availableSpace.left) > self.popupWidth &&
            self.totalHeightMinusBottom > self.popupHeight
        ) {
            return true;
        }
        return false;
    }

    function alignLeftBottom() {
        if (checkLeftBottom()) {
            self.left = self.highlightedArea.cx - self.popupWidth - self.arrowWidth;
            self.top =
                self.highlightedArea.cy + self.highlightedArea.ch - self.popupHeight;
            self.arrowClass = 'mgPlayerJSTest_arrow-right';
            self.arrowLeft = self.highlightedArea.cx - 12;
            self.arrowTop = self.top + (self.popupHeight - 30);
            self.isSet = true;
            self.alignment = 'left-bottom';
        }
    }

    function checkRightMiddle() {
        if (
            self.availableSpace.right > self.popupWidth &&
            self.highlightedArea.ch / 2 < screen.height
        ) {
            if (
                Math.abs(self.availableSpace.top) + self.highlightedArea.ch / 2 >
                self.popupHeight / 2 &&
                Math.abs(self.availableSpace.bottom) + self.highlightedArea.ch / 2 >
                self.popupHeight / 2
            ) {
                return true;
            }
            return false;
        }
        return false;
    }

    function alignRightMiddle() {
        if (checkRightMiddle()) {
            if ((self.stepType === 'smartTip' && !self.isBeacon) || self.stepType === 'validation') {
                self.left = self.highlightedArea.cx;
                if (self.isGuidance && self.isExtension || self.stepType === 'validation') {
                    self.top = self.highlightedArea.cy;
                } else {
                    self.top =
                        self.highlightedArea.cy +
                        self.highlightedArea.ch / 2 -
                        self.popupHeight / 2;
                }
            } else if (self.stepType === 'beacon_tour' && self.isExtension) {
                self.left = self.highlightedArea.cx;
                self.top = self.highlightedArea.cy;
            } else if (self.stepType === 'inline' || self.stepType === 'message') {
                self.left =
                    self.highlightedArea.cx + self.highlightedArea.cw + self.arrowWidth;
                self.top =
                    self.highlightedArea.cy +
                    self.highlightedArea.ch / 2 -
                    self.popupHeight / 2;
            } else {
                self.left = self.highlightedArea.cx + self.highlightedArea.cw + 5;
                self.top =
                    self.highlightedArea.cy +
                    self.highlightedArea.ch / 2 -
                    self.popupHeight / 2;
            }
            self.arrowClass = 'mgPlayerJSTest_arrow-left';
            self.arrowLeft = self.left - 10;
            self.arrowTop = self.top + self.popupHeight / 2 - 10;
            self.isSet = true;
            self.alignment = 'right-middle';
        }
    }

    function checkRightTop() {
        if (
            self.availableSpace.right > self.popupWidth &&
            self.totalHeightMinusTop > self.popupHeight
        ) {
            return true;
        }
        return false;
    }

    function alignRightTop() {
        if (checkRightTop()) {
            self.left =
                self.highlightedArea.cx + self.highlightedArea.cw + self.arrowWidth;
            self.top = self.highlightedArea.cy;
            self.arrowClass = 'mgPlayerJSTest_arrow-left';
            self.arrowLeft = self.left - 10;
            self.arrowTop = self.top + 7;
            self.isSet = true;
            self.alignment = 'right-top';
        }
    }

    function checkRightBottom() {
        if (
            self.availableSpace.right > self.popupWidth &&
            self.totalHeightMinusBottom > self.popupHeight
        ) {
            return true;
        }
        return false;
    }

    function alignRightBottom() {
        if (checkRightBottom()) {
            self.left =
                self.highlightedArea.cx + self.highlightedArea.cw + self.arrowWidth;
            self.top =
                self.highlightedArea.cy + self.highlightedArea.ch - self.popupHeight;
            self.arrowClass = 'mgPlayerJSTest_arrow-left';
            self.arrowLeft = self.left - 10;
            self.arrowTop = self.top + (self.popupHeight - 30);
            self.isSet = true;
            self.alignment = 'right-bottom';
        }
    }

    function checkTopMiddle() {
        if (
            Math.abs(self.availableSpace.top) > self.popupHeight + 15 &&
            self.totalWidthMinusLeft > self.popupWidth / 2
        ) {
            if (
                Math.abs(self.availableSpace.left) + self.highlightedArea.cw / 2 >
                self.popupWidth / 2 &&
                self.availableSpace.right + self.highlightedArea.cw / 2 >
                self.popupWidth / 2
            ) {
                return true;
            }
            return false;
        }
        return false;
    }

    function alignTopMiddle() {
        if (self.stepType === 'message') {
            self.left = self.popupWidth / 2;
            self.top = self.highlightedArea.cy - self.popupHeight - self.arrowWidth;
        } else if (self.stepType === 'beacon_tour' && self.isExtension) {
            self.left = self.highlightedArea.cx;
            self.top = self.highlightedArea.cy;
        } else if (checkTopMiddle()) {
            self.left =
                self.highlightedArea.cx +
                self.highlightedArea.cw / 2 -
                self.popupWidth / 2;
            if (self.step == 'inline') {
                self.top = self.highlightedArea.cy - self.popupHeight - self.arrowWidth;
            } else {
                self.top = self.highlightedArea.cy - self.popupHeight - 10;
            }
        }
        self.arrowClass = 'mgPlayerJSTest_arrow-down';
        self.arrowLeft =
            self.highlightedArea.cx + self.highlightedArea.cw / 2 - 8;
        self.arrowTop = self.highlightedArea.cy - 12;
        self.isSet = true;
        self.alignment = 'top-middle';
    }

    function checkTopLeft() {
        if (
            Math.abs(self.availableSpace.top) > self.popupHeight + 15 &&
            self.totalWidthMinusLeft > self.popupWidth
        ) {
            return true;
        }
        return false;
    }

    function alignTopLeft() {
        if (self.stepType == 'message') {
            self.left = self.highlightedArea.cx;
            self.top = self.highlightedArea.cy - self.popupHeight - self.arrowWidth;
            self.arrowClass = 'mgPlayerJSTest_arrow-down';
            self.arrowLeft = self.highlightedArea.cx + 7;
            self.arrowTop = self.highlightedArea.cy - 12;
            self.isSet = true;
            self.alignment = 'top-left';
            return true;
        }
        if (checkTopLeft()) {
            self.left = self.highlightedArea.cx;
            self.top = self.highlightedArea.cy - self.popupHeight - self.arrowWidth;
            self.arrowClass = 'mgPlayerJSTest_arrow-down';
            self.arrowLeft = self.highlightedArea.cx + 7;
            self.arrowTop = self.highlightedArea.cy - 12;
            self.isSet = true;
            self.alignment = 'top-left';
        }
    }

    function checkTopRight() {
        if (
            Math.abs(self.availableSpace.top) > self.popupHeight + 15 &&
            self.totalWidthMinusRight > self.popupWidth
        ) {
            return true;
        }
        return false;
    }

    function alignTopRight() {
        if (self.stepType === 'message') {
            self.left =
                self.highlightedArea.cx + self.highlightedArea.cw - self.popupWidth;
            self.top = self.highlightedArea.cy - self.popupHeight - self.arrowWidth;
            self.arrowClass = 'mgPlayerJSTest_arrow-down';
            self.arrowLeft =
                self.highlightedArea.cx + self.highlightedArea.cw - (20 + 7); // 20 is arrow width
            self.arrowTop = self.highlightedArea.cy - 12;
            self.isSet = true;
            self.alignment = 'top-right';
        } else if (checkTopRight()) {
            self.left =
                self.highlightedArea.cx + self.highlightedArea.cw - self.popupWidth;
            self.top = self.highlightedArea.cy - self.popupHeight - self.arrowWidth;
            self.arrowClass = 'mgPlayerJSTest_arrow-down';
            self.arrowLeft =
                self.highlightedArea.cx + self.highlightedArea.cw - (20 + 7); // 20 is arrow width
            self.arrowTop = self.highlightedArea.cy - 12;
            self.isSet = true;
            self.alignment = 'top-right';
        }
    }

    function checkBottomMiddle() {
        if (
            Math.abs(self.availableSpace.bottom) > self.popupHeight &&
            self.totalWidthMinusLeft > self.popupWidth / 2
        ) {
            if (
                Math.abs(self.availableSpace.left) + self.highlightedArea.cw / 2 >
                self.popupWidth / 2 &&
                self.availableSpace.right + self.highlightedArea.cw / 2 >
                self.popupWidth / 2
            ) {
                return true;
            }
            return false;
        }
        return false;
    }

    function alignBottomMiddle() {
        if (checkBottomMiddle()) {
            if ((self.stepType === 'smartTip' && !self.isBeacon) || self.stepType === 'validation') {
                self.left = self.highlightedArea.cx;
                if (self.isGuidance && self.isExtension || self.stepType === 'validation') {
                    self.top = self.highlightedArea.cy;
                } else {
                    self.top =
                        self.highlightedArea.cy +
                        self.highlightedArea.ch / 2 -
                        self.popupHeight / 2;
                }
            } else if (self.stepType === 'beacon_tour' && self.isExtension) {
                self.left = self.highlightedArea.cx;
                self.top = self.highlightedArea.cy;
            } else if (self.stepType === 'inline' || self.stepType === 'message') {
                self.top =
                    self.highlightedArea.cy + self.highlightedArea.ch + self.arrowWidth;
                self.left =
                    self.highlightedArea.cx +
                    self.highlightedArea.cw / 2 -
                    self.popupWidth / 2;
            } else {
                self.left =
                    self.highlightedArea.cx +
                    self.highlightedArea.cw / 2 -
                    self.popupWidth / 2;
                self.top = self.highlightedArea.cy + self.highlightedArea.ch + 5; // reduced gap to 5 from 10 MG-18951
            }
            self.isSet = true;
            self.alignment = 'bottom-middle';
        }
    }

    function checkBottomLeft() {
        if (
            Math.abs(self.availableSpace.bottom) > self.popupHeight &&
            self.totalWidthMinusLeft > self.popupWidth
        ) {
            return true;
        }
        return false;
    }

    function alignBottomLeft() {
        if (checkBottomLeft()) {
            self.left = self.highlightedArea.cx;
            self.top =
                self.highlightedArea.cy + self.highlightedArea.ch + self.arrowWidth;
            self.arrowClass = 'mgPlayerJSTest_arrow-up';
            self.arrowLeft = self.highlightedArea.cx + 7;
            self.arrowTop = self.highlightedArea.cy + self.highlightedArea.ch + 2;
            self.isSet = true;
            self.alignment = 'bottom-left';
        }
    }

    function checkBottomRight() {
        if (
            Math.abs(self.availableSpace.bottom) > self.popupHeight &&
            self.totalWidthMinusRight > self.popupWidth
        ) {
            return true;
        }
        return false;
    }

    function alignBottomRight() {
        if (checkBottomRight()) {
            self.left =
                self.highlightedArea.cx + self.highlightedArea.cw - self.popupWidth;
            self.top =
                self.highlightedArea.cy + self.highlightedArea.ch + self.arrowWidth;
            self.arrowClass = 'mgPlayerJSTest_arrow-up';
            self.arrowLeft =
                self.highlightedArea.cx + self.highlightedArea.cw - (20 + 7); // 20 is arrow width
            self.arrowTop = self.highlightedArea.cy + self.highlightedArea.ch + 2;
            self.isSet = true;
            self.alignment = 'bottom-right';
        }
    }

    function alignCenter() {
        self.left = (self.dimensions.width - self.popupWidth) / 2;
        // self.left += $(window).scrollLeft();

        self.top = (self.dimensions.height - self.popupHeight) / 2;
        //	self.top += $(window).scrollTop();

        self.isSet = true;
        self.alignment = 'center';
    }

    function alignCustom() {
        self.left = self.highlightedArea.cx + self.customPos; // ? .left;

        self.top = self.highlightedArea.cy + self.customPos; //? .top;

        self.isSet = true;
        self.alignment = 'custom';
    }

    function checkLeftForTooltip() {
        if (self.highlightedArea.cx > self.dimensions.width / 5) {
            // we are taing 20% to chec the x vaL
            return true;
        } else {
            return false;
        }
    }

    function checkRightForTooltip(iconLeft, msgDivWidth) {
        if (self.dimensions.width - iconLeft < msgDivWidth + 30) {
            return false;
        } else {
            return true;
        }
    }

    function checkTopForTooltip(iconLeft) {
        if (
            self.highlightedArea.cy < 81 ||
            self.highlightedArea.cx < 50 ||
            self.dimensions.width - iconLeft < 50
        ) {
            return false;
        } else {
            return true;
        }
    }

    function checkBottomForTooltip(iconLeft, iconTop, msgDivHeight) {
        if (
            self.dimensions.height - iconTop < msgDivHeight + 16 ||
            self.highlightedArea.cx < 50 ||
            self.dimensions.width - iconLeft < 50
        ) {
            return false;
        } else {
            return true;
        }
    }

    pub.getAvailablePositions = function() {
        return {
            'left-middle': checkLeftMiddle(),
            'left-top': checkLeftTop(),
            'left-bottom': checkLeftBottom(),

            'right-middle': checkRightMiddle(),
            'right-top': checkRightTop(),
            'right-bottom': checkRightBottom(),

            'top-middle': checkTopMiddle(),
            'top-left': checkTopLeft(),
            'top-right': checkTopRight(),

            'bottom-middle': checkBottomMiddle(),
            'bottom-left': checkBottomLeft(),
            'bottom-right': checkBottomRight(),
        };
    };
    pub.getAvailablePositionsForTooltip = function() {
        let iconLeft = self.highlightedArea.cx + self.highlightedArea.cw + 15;
        let iconTop = self.highlightedArea.cy + self.highlightedArea.ch + 15;

        let msgDivHeight = 70;
        let msgDivWidth = 182;
        return {
            'left-middle': checkLeftForTooltip(),
            'right-middle': checkRightForTooltip(iconLeft, msgDivWidth),
            'top-middle': checkTopForTooltip(iconLeft),
            'bottom-middle': checkBottomForTooltip(iconLeft, iconTop, msgDivHeight),
        };
    };

    pub.start = function() {
      
        switch (self.alignment) {
        case 'left':
            alignLeftMiddle();
            if (!self.isSet) alignLeftTop();
            if (!self.isSet) alignLeftBottom();
            break;

        case 'left-middle':
            alignLeftMiddle();
            if (!self.isSet) alignLeftTop();
            if (!self.isSet) alignLeftBottom();
            break;

        case 'left-top':
            alignLeftTop();
            if (!self.isSet) alignLeftBottom();
            break;

        case 'left-bottom':
            alignLeftBottom();
            if (!self.isSet) alignLeftTop();
            break;

        case 'right':
            alignRightMiddle();
            if (!self.isSet) alignRightTop();
            if (!self.isSet) alignRightBottom();

            break;

        case 'right-middle':
            alignRightMiddle();
            if (!self.isSet) alignRightTop();
            if (!self.isSet) alignRightBottom();
            break;

        case 'right-top':
            alignRightTop();
            if (!self.isSet) alignRightBottom();
            break;

        case 'right-bottom':
            alignRightBottom();
            if (!self.isSet) alignRightTop();
            break;

        case 'top':
            alignTopMiddle();
            if (!self.isSet) alignTopLeft();
            if (!self.isSet) alignTopRight();
            break;

        case 'top-middle':
            alignTopMiddle();
            break;

        case 'top-left':
            alignTopLeft();
            break;

        case 'top-right':
            alignTopRight();
            break;

        case 'bottom':
            alignBottomMiddle();
            if (!self.isSet) alignBottomLeft();
            if (!self.isSet) alignBottomRight();
            break;

        case 'bottom-middle':
            alignBottomMiddle();
            break;

        case 'bottom-left':
            alignBottomLeft();
            break;

        case 'bottom-right':
            alignBottomRight();
            break;

        case 'center':
            alignCenter();
            break;

        case 'custom':
            alignCustom();
            break;
        }

        if (self.hardApply === false) {
            if (!self.isSet) alignRightMiddle();

            if (!self.isSet) alignRightTop();

            if (!self.isSet) alignRightBottom();

            if (!self.isSet) alignLeftMiddle();

            if (!self.isSet) alignLeftTop();

            if (!self.isSet) alignLeftBottom();

            if (!self.isSet) alignTopMiddle();

            if (!self.isSet) alignTopLeft();

            if (!self.isSet) alignTopRight();

            if (!self.isSet) alignBottomMiddle();

            if (!self.isSet) alignBottomLeft();

            if (!self.isSet) alignBottomRight();

            if (!self.isSet) alignCenter();
        }

        if (self.left !== null && self.top !== null) {
            if (self.top < 0) self.top = 10;

            const windowScrollLeft = mg$(window).scrollLeft();

            if (windowScrollLeft > 0) {
                self.left -= windowScrollLeft;
            }
            self.popup.css({
                left: self.left + self.containerOffset.left,
                top: self.top + self.containerOffset.top,
            });
          
         
        }

        if (self.arrowId) {
            self.arrowClass = `${self.arrowClass} mgPlayerJSTest_tooltip-arrow`;
        }

        if (!self.doNotApplyArrow) {
            mg$('html').append(
                `<wmgPlayerJSTest_ id= "${self.arrowId}" class="${self.arrowClass}" style="left:${self.arrowLeft}px;top:${self.arrowTop}px;"></wmgPlayerJSTest_>`,
            );
        }

        if (self.isSet){
          
            return {
                top: self.top + self.containerOffset.top,
                left: self.left + self.containerOffset.left,
                alignment: self.alignment,
            };
        } 
        return false;
    };

    pub.checkHeight = function() {
        const popupHeightNew = 80; // self.popup.outerHeight();

        if (self.popupHeight !== popupHeightNew) pub.redo();
    };

    pub.redo = function() {
        if (self.isGuidance) {
            self.arrowWidth = 8;
        }
        self.popupWidth = 307; // self.popup.outerWidth();
        if (self.changeInHeight > 125) {
            self.popupHeight = self.changeInHeight; // self.popup.outerHeight();
        } else {
            self.popupHeight = 125;
        } // self.popup.outerHeight();
        pub.start();
    };
    pub.clear = function() {
        // clear preview
        //	GmCXt.clearPreviewPopupAlignment(self.popup);
        mg$('.mgPlayerJSTest_arrow-down').not('.mgPlayerJSTest_tooltip-arrow').remove();
        mg$('.mgPlayerJSTest_arrow-up').not('.mgPlayerJSTest_tooltip-arrow').remove();
        mg$('.mgPlayerJSTest_arrow-left').not('.mgPlayerJSTest_tooltip-arrow').remove();
        mg$('.mgPlayerJSTest_arrow-right').not('.mgPlayerJSTest_tooltip-arrow').remove();

        self.popup.css({
            left: 0,
            top: 0,
        });
    };

    return pub;
}

/*global mg$,mg$container*/
function alignImageStepPreview(
    popup,
    diamension,
    alignment,
    addScroll,
    stepSettings,
) {
    // GmCXt.clearPreviewPopupAlignment(mg$popup);
    //  ;

    let mg$popup = mg$(popup);
    const popupWidth = mg$popup.width();
    const popupHeight = mg$popup.height();
    const windowWidth = diamension.width;
    const windowHeight = diamension.height;
    let left = (windowWidth - popupWidth) / 2;
    let top = 0;
    const element_top_data = stepSettings.elementTop;
    const element_left_data = stepSettings.elementLeft;

    if (!popupWidth || !popupHeight) {
        return;
    }

    switch (alignment) {
    case 'top':
        top = 20;
        left = (windowWidth - popupWidth) / 2;
        break;

    case 'center':
        top = (windowHeight - popupHeight) / 2;
        left = (windowWidth - popupWidth) / 2;
        break;

    case 'bottom':
        top = windowHeight - popupHeight - 40;
        left = (windowWidth - popupWidth) / 2;
        break;

    case 'left-top':
        top = 20;
        left = 20;
        break;

    case 'left-center':
        top = (windowHeight - popupHeight) / 2;
        left = 20;
        break;

    case 'left-bottom':
        top = windowHeight - popupHeight - 40;
        left = 20;
        break;

    case 'right-top':
        top = 20;
        left = windowWidth - popupWidth - 45;
        break;

    case 'right-center':
        top = (windowHeight - popupHeight) / 2;
        left = windowWidth - popupWidth - 45;
        break;

    case 'right-bottom':
        top = windowHeight - popupHeight - 40;
        left = windowWidth - popupWidth - 45;
        break;

    case 'custom':
        top = (element_top_data * windowHeight) / 100;
        left = (element_left_data * windowWidth) / 100;
        break;
    }

    // top += mg$container.offset().top;
    // left += mg$container.offset().left;

    mg$popup.css({
        left,
        top,
    });

    return {
        left,
        top
    };
}

/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2023 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */

/******/ // The require scope
/******/ var __webpack_require__ = {};
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop));
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = globalThis.pdfjsLib = {};

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AbortException: () => (/* reexport */ AbortException),
  AnnotationEditorLayer: () => (/* reexport */ AnnotationEditorLayer),
  AnnotationEditorParamsType: () => (/* reexport */ AnnotationEditorParamsType),
  AnnotationEditorType: () => (/* reexport */ AnnotationEditorType),
  AnnotationEditorUIManager: () => (/* reexport */ AnnotationEditorUIManager),
  AnnotationLayer: () => (/* reexport */ AnnotationLayer),
  AnnotationMode: () => (/* reexport */ AnnotationMode),
  CMapCompressionType: () => (/* reexport */ CMapCompressionType),
  ColorPicker: () => (/* reexport */ ColorPicker),
  DOMSVGFactory: () => (/* reexport */ DOMSVGFactory),
  DrawLayer: () => (/* reexport */ DrawLayer),
  FeatureTest: () => (/* reexport */ util_FeatureTest),
  GlobalWorkerOptions: () => (/* reexport */ GlobalWorkerOptions),
  ImageKind: () => (/* reexport */ util_ImageKind),
  InvalidPDFException: () => (/* reexport */ InvalidPDFException),
  MissingPDFException: () => (/* reexport */ MissingPDFException),
  OPS: () => (/* reexport */ OPS),
  Outliner: () => (/* reexport */ Outliner),
  PDFDataRangeTransport: () => (/* reexport */ PDFDataRangeTransport),
  PDFDateString: () => (/* reexport */ PDFDateString),
  PDFWorker: () => (/* reexport */ PDFWorker),
  PasswordResponses: () => (/* reexport */ PasswordResponses),
  PermissionFlag: () => (/* reexport */ PermissionFlag),
  PixelsPerInch: () => (/* reexport */ PixelsPerInch),
  RenderingCancelledException: () => (/* reexport */ RenderingCancelledException),
  TextLayer: () => (/* reexport */ TextLayer),
  UnexpectedResponseException: () => (/* reexport */ UnexpectedResponseException),
  Util: () => (/* reexport */ Util),
  VerbosityLevel: () => (/* reexport */ VerbosityLevel),
  XfaLayer: () => (/* reexport */ XfaLayer),
  build: () => (/* reexport */ build),
  createValidAbsoluteUrl: () => (/* reexport */ createValidAbsoluteUrl),
  fetchData: () => (/* reexport */ fetchData),
  getDocument: () => (/* reexport */ getDocument),
  getFilenameFromUrl: () => (/* reexport */ getFilenameFromUrl),
  getPdfFilenameFromUrl: () => (/* reexport */ getPdfFilenameFromUrl),
  getXfaPageViewport: () => (/* reexport */ getXfaPageViewport),
  isDataScheme: () => (/* reexport */ isDataScheme),
  isPdfFile: () => (/* reexport */ isPdfFile),
  noContextMenu: () => (/* reexport */ noContextMenu),
  normalizeUnicode: () => (/* reexport */ normalizeUnicode),
  renderTextLayer: () => (/* reexport */ renderTextLayer),
  setLayerDimensions: () => (/* reexport */ setLayerDimensions),
  shadow: () => (/* reexport */ shadow),
  updateTextLayer: () => (/* reexport */ updateTextLayer),
  version: () => (/* reexport */ version)
});
const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
const MAX_IMAGE_SIZE_TO_CACHE = 10e6;
const LINE_FACTOR = 1.35;
const RenderingIntentFlag = {
  ANY: 0x01,
  DISPLAY: 0x02,
  PRINT: 0x04,
  ANNOTATIONS_FORMS: 0x10,
  ANNOTATIONS_STORAGE: 0x20,
  ANNOTATIONS_DISABLE: 0x40,
  OPLIST: 0x100
};
const AnnotationMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
};
const AnnotationEditorPrefix = "pdfjs_internal_editor_";
const AnnotationEditorType = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15
};
const AnnotationEditorParamsType = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23,
  HIGHLIGHT_COLOR: 31,
  HIGHLIGHT_DEFAULT_COLOR: 32,
  HIGHLIGHT_THICKNESS: 33,
  HIGHLIGHT_FREE: 34,
  HIGHLIGHT_SHOW_ALL: 35
};
const PermissionFlag = {
  PRINT: 0x04,
  MODIFY_CONTENTS: 0x08,
  COPY: 0x10,
  MODIFY_ANNOTATIONS: 0x20,
  FILL_INTERACTIVE_FORMS: 0x100,
  COPY_FOR_ACCESSIBILITY: 0x200,
  ASSEMBLE: 0x400,
  PRINT_HIGH_QUALITY: 0x800
};
const TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
const util_ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
const AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  WIDGET: 20};
const AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
const VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
const CMapCompressionType = {
  NONE: 0,
  BINARY: 1
};
const OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
const PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
let verbosity = VerbosityLevel.WARNINGS;
function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}
function getVerbosityLevel() {
  return verbosity;
}
function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.log(`Info: ${msg}`);
  }
}
function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.log(`Warning: ${msg}`);
  }
}
function unreachable(msg) {
  throw new Error(msg);
}
function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}
function _isValidProtocol(url) {
  switch (url?.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;
    default:
      return false;
  }
}
function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
  if (!url) {
    return null;
  }
  try {
    if (options && typeof url === "string") {
      if (options.addDefaultProtocol && url.startsWith("www.")) {
        const dots = url.match(/\./g);
        if (dots?.length >= 2) {
          url = `http://${url}`;
        }
      }
      if (options.tryConvertEncoding) {
        try {
          url = stringToUTF8String(url);
        } catch {}
      }
    }
    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
    if (_isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch {}
  return null;
}
function shadow(obj, prop, value, nonSerializable = false) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: !nonSerializable,
    configurable: true,
    writable: false
  });
  return value;
}
const BaseException = function BaseExceptionClosure() {
  function BaseException(message, name) {
    if (this.constructor === BaseException) {
      unreachable("Cannot initialize BaseException.");
    }
    this.message = message;
    this.name = name;
  }
  BaseException.prototype = new Error();
  BaseException.constructor = BaseException;
  return BaseException;
}();
class PasswordException extends BaseException {
  constructor(msg, code) {
    super(msg, "PasswordException");
    this.code = code;
  }
}
class UnknownErrorException extends BaseException {
  constructor(msg, details) {
    super(msg, "UnknownErrorException");
    this.details = details;
  }
}
class InvalidPDFException extends BaseException {
  constructor(msg) {
    super(msg, "InvalidPDFException");
  }
}
class MissingPDFException extends BaseException {
  constructor(msg) {
    super(msg, "MissingPDFException");
  }
}
class UnexpectedResponseException extends BaseException {
  constructor(msg, status) {
    super(msg, "UnexpectedResponseException");
    this.status = status;
  }
}
class FormatError extends BaseException {
  constructor(msg) {
    super(msg, "FormatError");
  }
}
class AbortException extends BaseException {
  constructor(msg) {
    super(msg, "AbortException");
  }
}
function bytesToString(bytes) {
  if (typeof bytes !== "object" || bytes?.length === undefined) {
    unreachable("Invalid argument for bytesToString");
  }
  const length = bytes.length;
  const MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  const strBuf = [];
  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    const chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join("");
}
function stringToBytes(str) {
  if (typeof str !== "string") {
    unreachable("Invalid argument for stringToBytes");
  }
  const length = str.length;
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xff;
  }
  return bytes;
}
function string32(value) {
  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}
function objectFromMap(map) {
  const obj = Object.create(null);
  for (const [key, value] of map) {
    obj[key] = value;
  }
  return obj;
}
function isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}
function isEvalSupported() {
  try {
    new Function("");
    return true;
  } catch {
    return false;
  }
}
class util_FeatureTest {
  static get isLittleEndian() {
    return shadow(this, "isLittleEndian", isLittleEndian());
  }
  static get isEvalSupported() {
    return shadow(this, "isEvalSupported", isEvalSupported());
  }
  static get isOffscreenCanvasSupported() {
    return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
  }
  static get platform() {
    if (typeof navigator !== "undefined" && typeof navigator?.platform === "string") {
      return shadow(this, "platform", {
        isMac: navigator.platform.includes("Mac")
      });
    }
    return shadow(this, "platform", {
      isMac: false
    });
  }
  static get isCSSRoundSupported() {
    return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
  }
}
const hexNumbers = Array.from(Array(256).keys(), n => n.toString(16).padStart(2, "0"));
class Util {
  static makeHexColor(r, g, b) {
    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
  }
  static scaleMinMax(transform, minMax) {
    let temp;
    if (transform[0]) {
      if (transform[0] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[2];
        minMax[2] = temp;
      }
      minMax[0] *= transform[0];
      minMax[2] *= transform[0];
      if (transform[3] < 0) {
        temp = minMax[1];
        minMax[1] = minMax[3];
        minMax[3] = temp;
      }
      minMax[1] *= transform[3];
      minMax[3] *= transform[3];
    } else {
      temp = minMax[0];
      minMax[0] = minMax[1];
      minMax[1] = temp;
      temp = minMax[2];
      minMax[2] = minMax[3];
      minMax[3] = temp;
      if (transform[1] < 0) {
        temp = minMax[1];
        minMax[1] = minMax[3];
        minMax[3] = temp;
      }
      minMax[1] *= transform[1];
      minMax[3] *= transform[1];
      if (transform[2] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[2];
        minMax[2] = temp;
      }
      minMax[0] *= transform[2];
      minMax[2] *= transform[2];
    }
    minMax[0] += transform[4];
    minMax[1] += transform[5];
    minMax[2] += transform[4];
    minMax[3] += transform[5];
  }
  static transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  }
  static applyTransform(p, m) {
    const xt = p[0] * m[0] + p[1] * m[2] + m[4];
    const yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  }
  static applyInverseTransform(p, m) {
    const d = m[0] * m[3] - m[1] * m[2];
    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  }
  static getAxialAlignedBoundingBox(r, m) {
    const p1 = this.applyTransform(r, m);
    const p2 = this.applyTransform(r.slice(2, 4), m);
    const p3 = this.applyTransform([r[0], r[3]], m);
    const p4 = this.applyTransform([r[2], r[1]], m);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  }
  static inverseTransform(m) {
    const d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  }
  static singularValueDecompose2dScale(m) {
    const transpose = [m[0], m[2], m[1], m[3]];
    const a = m[0] * transpose[0] + m[1] * transpose[2];
    const b = m[0] * transpose[1] + m[1] * transpose[3];
    const c = m[2] * transpose[0] + m[3] * transpose[2];
    const d = m[2] * transpose[1] + m[3] * transpose[3];
    const first = (a + d) / 2;
    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
    const sx = first + second || 1;
    const sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  }
  static normalizeRect(rect) {
    const r = rect.slice(0);
    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }
    return r;
  }
  static intersect(rect1, rect2) {
    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
    if (xLow > xHigh) {
      return null;
    }
    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
    if (yLow > yHigh) {
      return null;
    }
    return [xLow, yLow, xHigh, yHigh];
  }
  static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {
    if (t <= 0 || t >= 1) {
      return;
    }
    const mt = 1 - t;
    const tt = t * t;
    const ttt = tt * t;
    const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;
    const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;
    minMax[0] = Math.min(minMax[0], x);
    minMax[1] = Math.min(minMax[1], y);
    minMax[2] = Math.max(minMax[2], x);
    minMax[3] = Math.max(minMax[3], y);
  }
  static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {
    if (Math.abs(a) < 1e-12) {
      if (Math.abs(b) >= 1e-12) {
        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);
      }
      return;
    }
    const delta = b ** 2 - 4 * c * a;
    if (delta < 0) {
      return;
    }
    const sqrtDelta = Math.sqrt(delta);
    const a2 = 2 * a;
    this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);
    this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);
  }
  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
    if (minMax) {
      minMax[0] = Math.min(minMax[0], x0, x3);
      minMax[1] = Math.min(minMax[1], y0, y3);
      minMax[2] = Math.max(minMax[2], x0, x3);
      minMax[3] = Math.max(minMax[3], y0, y3);
    } else {
      minMax = [Math.min(x0, x3), Math.min(y0, y3), Math.max(x0, x3), Math.max(y0, y3)];
    }
    this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);
    this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);
    return minMax;
  }
}
function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}
let NormalizeRegex = null;
let NormalizationMap = null;
function normalizeUnicode(str) {
  if (!NormalizeRegex) {
    NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
    NormalizationMap = new Map([["ﬅ", "ſt"]]);
  }
  return str.replaceAll(NormalizeRegex, (_, p1, p2) => p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2));
}
function getUuid() {
  if (typeof crypto !== "undefined" && typeof crypto?.randomUUID === "function") {
    return crypto.randomUUID();
  }
  const buf = new Uint8Array(32);
  if (typeof crypto !== "undefined" && typeof crypto?.getRandomValues === "function") {
    crypto.getRandomValues(buf);
  } else {
    for (let i = 0; i < 32; i++) {
      buf[i] = Math.floor(Math.random() * 255);
    }
  }
  return bytesToString(buf);
}
const AnnotationPrefix = "pdfjs_internal_id_";
const FontRenderOps = {
  BEZIER_CURVE_TO: 0,
  MOVE_TO: 1,
  LINE_TO: 2,
  QUADRATIC_CURVE_TO: 3,
  RESTORE: 4,
  SAVE: 5,
  SCALE: 6,
  TRANSFORM: 7,
  TRANSLATE: 8
};

class BaseFilterFactory {
  constructor() {
    if (this.constructor === BaseFilterFactory) {
      unreachable("Cannot initialize BaseFilterFactory.");
    }
  }
  addFilter(maps) {
    return "none";
  }
  addHCMFilter(fgColor, bgColor) {
    return "none";
  }
  addAlphaFilter(map) {
    return "none";
  }
  addLuminosityFilter(map) {
    return "none";
  }
  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
    return "none";
  }
  destroy(keepHCM = false) {}
}
class BaseCanvasFactory {
  #enableHWA = false;
  constructor({
    enableHWA = false
  } = {}) {
    if (this.constructor === BaseCanvasFactory) {
      unreachable("Cannot initialize BaseCanvasFactory.");
    }
    this.#enableHWA = enableHWA;
  }
  create(width, height) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }
    const canvas = this._createCanvas(width, height);
    return {
      canvas,
      context: canvas.getContext("2d", {
        willReadFrequently: !this.#enableHWA
      })
    };
  }
  reset(canvasAndContext, width, height) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }
    canvasAndContext.canvas.width = width;
    canvasAndContext.canvas.height = height;
  }
  destroy(canvasAndContext) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }
    canvasAndContext.canvas.width = 0;
    canvasAndContext.canvas.height = 0;
    canvasAndContext.canvas = null;
    canvasAndContext.context = null;
  }
  _createCanvas(width, height) {
    unreachable("Abstract method `_createCanvas` called.");
  }
}
class BaseCMapReaderFactory {
  constructor({
    baseUrl = null,
    isCompressed = true
  }) {
    if (this.constructor === BaseCMapReaderFactory) {
      unreachable("Cannot initialize BaseCMapReaderFactory.");
    }
    this.baseUrl = baseUrl;
    this.isCompressed = isCompressed;
  }
  async fetch({
    name
  }) {
    if (!this.baseUrl) {
      throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');
    }
    if (!name) {
      throw new Error("CMap name must be specified.");
    }
    const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
    const compressionType = this.isCompressed ? CMapCompressionType.BINARY : CMapCompressionType.NONE;
    return this._fetchData(url, compressionType).catch(reason => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
    });
  }
  _fetchData(url, compressionType) {
    unreachable("Abstract method `_fetchData` called.");
  }
}
class BaseStandardFontDataFactory {
  constructor({
    baseUrl = null
  }) {
    if (this.constructor === BaseStandardFontDataFactory) {
      unreachable("Cannot initialize BaseStandardFontDataFactory.");
    }
    this.baseUrl = baseUrl;
  }
  async fetch({
    filename
  }) {
    if (!this.baseUrl) {
      throw new Error('The standard font "baseUrl" parameter must be specified, ensure that ' + 'the "standardFontDataUrl" API parameter is provided.');
    }
    if (!filename) {
      throw new Error("Font filename must be specified.");
    }
    const url = `${this.baseUrl}${filename}`;
    return this._fetchData(url).catch(reason => {
      throw new Error(`Unable to load font data at: ${url}`);
    });
  }
  _fetchData(url) {
    unreachable("Abstract method `_fetchData` called.");
  }
}
class BaseSVGFactory {
  constructor() {
    if (this.constructor === BaseSVGFactory) {
      unreachable("Cannot initialize BaseSVGFactory.");
    }
  }
  create(width, height, skipDimensions = false) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid SVG dimensions");
    }
    const svg = this._createSVG("svg:svg");
    svg.setAttribute("version", "1.1");
    if (!skipDimensions) {
      svg.setAttribute("width", `${width}px`);
      svg.setAttribute("height", `${height}px`);
    }
    svg.setAttribute("preserveAspectRatio", "none");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    return svg;
  }
  createElement(type) {
    if (typeof type !== "string") {
      throw new Error("Invalid SVG element type");
    }
    return this._createSVG(type);
  }
  _createSVG(type) {
    unreachable("Abstract method `_createSVG` called.");
  }
}


const SVG_NS = "http://www.w3.org/2000/svg";
class PixelsPerInch {
  static CSS = 96.0;
  static PDF = 72.0;
  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
}
class DOMFilterFactory extends BaseFilterFactory {
  #_cache;
  #_defs;
  #docId;
  #document;
  #_hcmCache;
  #id = 0;
  constructor({
    docId,
    ownerDocument = globalThis.document
  } = {}) {
    super();
    this.#docId = docId;
    this.#document = ownerDocument;
  }
  get #cache() {
    return this.#_cache ||= new Map();
  }
  get #hcmCache() {
    return this.#_hcmCache ||= new Map();
  }
  get #defs() {
    if (!this.#_defs) {
      const div = this.#document.createElement("div");
      const {
        style
      } = div;
      style.visibility = "hidden";
      style.contain = "strict";
      style.width = style.height = 0;
      style.position = "absolute";
      style.top = style.left = 0;
      style.zIndex = -1;
      const svg = this.#document.createElementNS(SVG_NS, "svg");
      svg.setAttribute("width", 0);
      svg.setAttribute("height", 0);
      this.#_defs = this.#document.createElementNS(SVG_NS, "defs");
      div.append(svg);
      svg.append(this.#_defs);
      this.#document.body.append(div);
    }
    return this.#_defs;
  }
  #createTables(maps) {
    if (maps.length === 1) {
      const mapR = maps[0];
      const buffer = new Array(256);
      for (let i = 0; i < 256; i++) {
        buffer[i] = mapR[i] / 255;
      }
      const table = buffer.join(",");
      return [table, table, table];
    }
    const [mapR, mapG, mapB] = maps;
    const bufferR = new Array(256);
    const bufferG = new Array(256);
    const bufferB = new Array(256);
    for (let i = 0; i < 256; i++) {
      bufferR[i] = mapR[i] / 255;
      bufferG[i] = mapG[i] / 255;
      bufferB[i] = mapB[i] / 255;
    }
    return [bufferR.join(","), bufferG.join(","), bufferB.join(",")];
  }
  addFilter(maps) {
    if (!maps) {
      return "none";
    }
    let value = this.#cache.get(maps);
    if (value) {
      return value;
    }
    const [tableR, tableG, tableB] = this.#createTables(maps);
    const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;
    value = this.#cache.get(key);
    if (value) {
      this.#cache.set(maps, value);
      return value;
    }
    const id = `g_${this.#docId}_transfer_map_${this.#id++}`;
    const url = `url(#${id})`;
    this.#cache.set(maps, url);
    this.#cache.set(key, url);
    const filter = this.#createFilter(id);
    this.#addTransferMapConversion(tableR, tableG, tableB, filter);
    return url;
  }
  addHCMFilter(fgColor, bgColor) {
    const key = `${fgColor}-${bgColor}`;
    const filterName = "base";
    let info = this.#hcmCache.get(filterName);
    if (info?.key === key) {
      return info.url;
    }
    if (info) {
      info.filter?.remove();
      info.key = key;
      info.url = "none";
      info.filter = null;
    } else {
      info = {
        key,
        url: "none",
        filter: null
      };
      this.#hcmCache.set(filterName, info);
    }
    if (!fgColor || !bgColor) {
      return info.url;
    }
    const fgRGB = this.#getRGB(fgColor);
    fgColor = Util.makeHexColor(...fgRGB);
    const bgRGB = this.#getRGB(bgColor);
    bgColor = Util.makeHexColor(...bgRGB);
    this.#defs.style.color = "";
    if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) {
      return info.url;
    }
    const map = new Array(256);
    for (let i = 0; i <= 255; i++) {
      const x = i / 255;
      map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
    }
    const table = map.join(",");
    const id = `g_${this.#docId}_hcm_filter`;
    const filter = info.filter = this.#createFilter(id);
    this.#addTransferMapConversion(table, table, table, filter);
    this.#addGrayConversion(filter);
    const getSteps = (c, n) => {
      const start = fgRGB[c] / 255;
      const end = bgRGB[c] / 255;
      const arr = new Array(n + 1);
      for (let i = 0; i <= n; i++) {
        arr[i] = start + i / n * (end - start);
      }
      return arr.join(",");
    };
    this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);
    info.url = `url(#${id})`;
    return info.url;
  }
  addAlphaFilter(map) {
    let value = this.#cache.get(map);
    if (value) {
      return value;
    }
    const [tableA] = this.#createTables([map]);
    const key = `alpha_${tableA}`;
    value = this.#cache.get(key);
    if (value) {
      this.#cache.set(map, value);
      return value;
    }
    const id = `g_${this.#docId}_alpha_map_${this.#id++}`;
    const url = `url(#${id})`;
    this.#cache.set(map, url);
    this.#cache.set(key, url);
    const filter = this.#createFilter(id);
    this.#addTransferMapAlphaConversion(tableA, filter);
    return url;
  }
  addLuminosityFilter(map) {
    let value = this.#cache.get(map || "luminosity");
    if (value) {
      return value;
    }
    let tableA, key;
    if (map) {
      [tableA] = this.#createTables([map]);
      key = `luminosity_${tableA}`;
    } else {
      key = "luminosity";
    }
    value = this.#cache.get(key);
    if (value) {
      this.#cache.set(map, value);
      return value;
    }
    const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;
    const url = `url(#${id})`;
    this.#cache.set(map, url);
    this.#cache.set(key, url);
    const filter = this.#createFilter(id);
    this.#addLuminosityConversion(filter);
    if (map) {
      this.#addTransferMapAlphaConversion(tableA, filter);
    }
    return url;
  }
  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
    const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;
    let info = this.#hcmCache.get(filterName);
    if (info?.key === key) {
      return info.url;
    }
    if (info) {
      info.filter?.remove();
      info.key = key;
      info.url = "none";
      info.filter = null;
    } else {
      info = {
        key,
        url: "none",
        filter: null
      };
      this.#hcmCache.set(filterName, info);
    }
    if (!fgColor || !bgColor) {
      return info.url;
    }
    const [fgRGB, bgRGB] = [fgColor, bgColor].map(this.#getRGB.bind(this));
    let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
    let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
    let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(this.#getRGB.bind(this));
    if (bgGray < fgGray) {
      [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];
    }
    this.#defs.style.color = "";
    const getSteps = (fg, bg, n) => {
      const arr = new Array(256);
      const step = (bgGray - fgGray) / n;
      const newStart = fg / 255;
      const newStep = (bg - fg) / (255 * n);
      let prev = 0;
      for (let i = 0; i <= n; i++) {
        const k = Math.round(fgGray + i * step);
        const value = newStart + i * newStep;
        for (let j = prev; j <= k; j++) {
          arr[j] = value;
        }
        prev = k + 1;
      }
      for (let i = prev; i < 256; i++) {
        arr[i] = arr[prev - 1];
      }
      return arr.join(",");
    };
    const id = `g_${this.#docId}_hcm_${filterName}_filter`;
    const filter = info.filter = this.#createFilter(id);
    this.#addGrayConversion(filter);
    this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);
    info.url = `url(#${id})`;
    return info.url;
  }
  destroy(keepHCM = false) {
    if (keepHCM && this.#hcmCache.size !== 0) {
      return;
    }
    if (this.#_defs) {
      this.#_defs.parentNode.parentNode.remove();
      this.#_defs = null;
    }
    if (this.#_cache) {
      this.#_cache.clear();
      this.#_cache = null;
    }
    this.#id = 0;
  }
  #addLuminosityConversion(filter) {
    const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
    feColorMatrix.setAttribute("type", "matrix");
    feColorMatrix.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0");
    filter.append(feColorMatrix);
  }
  #addGrayConversion(filter) {
    const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
    feColorMatrix.setAttribute("type", "matrix");
    feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
    filter.append(feColorMatrix);
  }
  #createFilter(id) {
    const filter = this.#document.createElementNS(SVG_NS, "filter");
    filter.setAttribute("color-interpolation-filters", "sRGB");
    filter.setAttribute("id", id);
    this.#defs.append(filter);
    return filter;
  }
  #appendFeFunc(feComponentTransfer, func, table) {
    const feFunc = this.#document.createElementNS(SVG_NS, func);
    feFunc.setAttribute("type", "discrete");
    feFunc.setAttribute("tableValues", table);
    feComponentTransfer.append(feFunc);
  }
  #addTransferMapConversion(rTable, gTable, bTable, filter) {
    const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
    filter.append(feComponentTransfer);
    this.#appendFeFunc(feComponentTransfer, "feFuncR", rTable);
    this.#appendFeFunc(feComponentTransfer, "feFuncG", gTable);
    this.#appendFeFunc(feComponentTransfer, "feFuncB", bTable);
  }
  #addTransferMapAlphaConversion(aTable, filter) {
    const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
    filter.append(feComponentTransfer);
    this.#appendFeFunc(feComponentTransfer, "feFuncA", aTable);
  }
  #getRGB(color) {
    this.#defs.style.color = color;
    return getRGB(getComputedStyle(this.#defs).getPropertyValue("color"));
  }
}
class DOMCanvasFactory extends BaseCanvasFactory {
  constructor({
    ownerDocument = globalThis.document,
    enableHWA = false
  } = {}) {
    super({
      enableHWA
    });
    this._document = ownerDocument;
  }
  _createCanvas(width, height) {
    const canvas = this._document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }
}
async function fetchData(url, type = "text") {
  if (isValidFetchUrl(url, document.baseURI)) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(response.statusText);
    }
    switch (type) {
      case "arraybuffer":
        return response.arrayBuffer();
      case "blob":
        return response.blob();
      case "json":
        return response.json();
    }
    return response.text();
  }
  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.open("GET", url, true);
    request.responseType = type;
    request.onreadystatechange = () => {
      if (request.readyState !== XMLHttpRequest.DONE) {
        return;
      }
      if (request.status === 200 || request.status === 0) {
        switch (type) {
          case "arraybuffer":
          case "blob":
          case "json":
            resolve(request.response);
            return;
        }
        resolve(request.responseText);
        return;
      }
      reject(new Error(request.statusText));
    };
    request.send(null);
  });
}
class DOMCMapReaderFactory extends BaseCMapReaderFactory {
  _fetchData(url, compressionType) {
    return fetchData(url, this.isCompressed ? "arraybuffer" : "text").then(data => ({
      cMapData: data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data),
      compressionType
    }));
  }
}
class DOMStandardFontDataFactory extends BaseStandardFontDataFactory {
  _fetchData(url) {
    return fetchData(url, "arraybuffer").then(data => new Uint8Array(data));
  }
}
class DOMSVGFactory extends BaseSVGFactory {
  _createSVG(type) {
    return document.createElementNS(SVG_NS, type);
  }
}
class PageViewport {
  constructor({
    viewBox,
    scale,
    rotation,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  }) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    const centerX = (viewBox[2] + viewBox[0]) / 2;
    const centerY = (viewBox[3] + viewBox[1]) / 2;
    let rotateA, rotateB, rotateC, rotateD;
    rotation %= 360;
    if (rotation < 0) {
      rotation += 360;
    }
    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;
      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;
      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;
      case 0:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }
    let offsetCanvasX, offsetCanvasY;
    let width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = (viewBox[3] - viewBox[1]) * scale;
      height = (viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = (viewBox[2] - viewBox[0]) * scale;
      height = (viewBox[3] - viewBox[1]) * scale;
    }
    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
  }
  get rawDims() {
    const {
      viewBox
    } = this;
    return shadow(this, "rawDims", {
      pageWidth: viewBox[2] - viewBox[0],
      pageHeight: viewBox[3] - viewBox[1],
      pageX: viewBox[0],
      pageY: viewBox[1]
    });
  }
  clone({
    scale = this.scale,
    rotation = this.rotation,
    offsetX = this.offsetX,
    offsetY = this.offsetY,
    dontFlip = false
  } = {}) {
    return new PageViewport({
      viewBox: this.viewBox.slice(),
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }
  convertToViewportPoint(x, y) {
    return Util.applyTransform([x, y], this.transform);
  }
  convertToViewportRectangle(rect) {
    const topLeft = Util.applyTransform([rect[0], rect[1]], this.transform);
    const bottomRight = Util.applyTransform([rect[2], rect[3]], this.transform);
    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
  }
  convertToPdfPoint(x, y) {
    return Util.applyInverseTransform([x, y], this.transform);
  }
}
class RenderingCancelledException extends BaseException {
  constructor(msg, extraDelay = 0) {
    super(msg, "RenderingCancelledException");
    this.extraDelay = extraDelay;
  }
}
function isDataScheme(url) {
  const ii = url.length;
  let i = 0;
  while (i < ii && url[i].trim() === "") {
    i++;
  }
  return url.substring(i, i + 5).toLowerCase() === "data:";
}
function isPdfFile(filename) {
  return typeof filename === "string" && /\.pdf$/i.test(filename);
}
function getFilenameFromUrl(url) {
  [url] = url.split(/[#?]/, 1);
  return url.substring(url.lastIndexOf("/") + 1);
}
function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
  if (typeof url !== "string") {
    return defaultFilename;
  }
  if (isDataScheme(url)) {
    warn('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
    return defaultFilename;
  }
  const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
  const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
  const splitURI = reURI.exec(url);
  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
  if (suggestedFilename) {
    suggestedFilename = suggestedFilename[0];
    if (suggestedFilename.includes("%")) {
      try {
        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
      } catch {}
    }
  }
  return suggestedFilename || defaultFilename;
}
class StatTimer {
  started = Object.create(null);
  times = [];
  time(name) {
    if (name in this.started) {
      warn(`Timer is already running for ${name}`);
    }
    this.started[name] = Date.now();
  }
  timeEnd(name) {
    if (!(name in this.started)) {
      warn(`Timer has not been started for ${name}`);
    }
    this.times.push({
      name,
      start: this.started[name],
      end: Date.now()
    });
    delete this.started[name];
  }
  toString() {
    const outBuf = [];
    let longest = 0;
    for (const {
      name
    } of this.times) {
      longest = Math.max(name.length, longest);
    }
    for (const {
      name,
      start,
      end
    } of this.times) {
      outBuf.push(`${name.padEnd(longest)} ${end - start}ms\n`);
    }
    return outBuf.join("");
  }
}
function isValidFetchUrl(url, baseUrl) {
  try {
    const {
      protocol
    } = baseUrl ? new URL(url, baseUrl) : new URL(url);
    return protocol === "http:" || protocol === "https:";
  } catch {
    return false;
  }
}
function noContextMenu(e) {
  e.preventDefault();
}
function deprecated(details) {
  console.log("Deprecated API usage: " + details);
}
let pdfDateStringRegex;
class PDFDateString {
  static toDateObject(input) {
    if (!input || typeof input !== "string") {
      return null;
    }
    pdfDateStringRegex ||= new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
    const matches = pdfDateStringRegex.exec(input);
    if (!matches) {
      return null;
    }
    const year = parseInt(matches[1], 10);
    let month = parseInt(matches[2], 10);
    month = month >= 1 && month <= 12 ? month - 1 : 0;
    let day = parseInt(matches[3], 10);
    day = day >= 1 && day <= 31 ? day : 1;
    let hour = parseInt(matches[4], 10);
    hour = hour >= 0 && hour <= 23 ? hour : 0;
    let minute = parseInt(matches[5], 10);
    minute = minute >= 0 && minute <= 59 ? minute : 0;
    let second = parseInt(matches[6], 10);
    second = second >= 0 && second <= 59 ? second : 0;
    const universalTimeRelation = matches[7] || "Z";
    let offsetHour = parseInt(matches[8], 10);
    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
    let offsetMinute = parseInt(matches[9], 10) || 0;
    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
    if (universalTimeRelation === "-") {
      hour += offsetHour;
      minute += offsetMinute;
    } else if (universalTimeRelation === "+") {
      hour -= offsetHour;
      minute -= offsetMinute;
    }
    return new Date(Date.UTC(year, month, day, hour, minute, second));
  }
}
function getXfaPageViewport(xfaPage, {
  scale = 1,
  rotation = 0
}) {
  const {
    width,
    height
  } = xfaPage.attributes.style;
  const viewBox = [0, 0, parseInt(width), parseInt(height)];
  return new PageViewport({
    viewBox,
    scale,
    rotation
  });
}
function getRGB(color) {
  if (color.startsWith("#")) {
    const colorRGB = parseInt(color.slice(1), 16);
    return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];
  }
  if (color.startsWith("rgb(")) {
    return color.slice(4, -1).split(",").map(x => parseInt(x));
  }
  if (color.startsWith("rgba(")) {
    return color.slice(5, -1).split(",").map(x => parseInt(x)).slice(0, 3);
  }
  warn(`Not a valid color format: "${color}"`);
  return [0, 0, 0];
}
function getColorValues(colors) {
  const span = document.createElement("span");
  span.style.visibility = "hidden";
  document.body.append(span);
  for (const name of colors.keys()) {
    span.style.color = name;
    const computedColor = window.getComputedStyle(span).color;
    colors.set(name, getRGB(computedColor));
  }
  span.remove();
}
function getCurrentTransform(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform();
  return [a, b, c, d, e, f];
}
function getCurrentTransformInverse(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform().invertSelf();
  return [a, b, c, d, e, f];
}
function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {
  if (viewport instanceof PageViewport) {
    const {
      pageWidth,
      pageHeight
    } = viewport.rawDims;
    const {
      style
    } = div;
    const useRound = util_FeatureTest.isCSSRoundSupported;
    const w = `var(--scale-factor) * ${pageWidth}px`,
      h = `var(--scale-factor) * ${pageHeight}px`;
    const widthStr = useRound ? `round(${w}, 1px)` : `calc(${w})`,
      heightStr = useRound ? `round(${h}, 1px)` : `calc(${h})`;
    if (!mustFlip || viewport.rotation % 180 === 0) {
      style.width = widthStr;
      style.height = heightStr;
    } else {
      style.width = heightStr;
      style.height = widthStr;
    }
  }
  if (mustRotate) {
    div.setAttribute("data-main-rotation", viewport.rotation);
  }
}

class EditorToolbar {
  #toolbar = null;
  #colorPicker = null;
  #editor;
  #buttons = null;
  constructor(editor) {
    this.#editor = editor;
  }
  render() {
    const editToolbar = this.#toolbar = document.createElement("div");
    editToolbar.className = "editToolbar";
    editToolbar.setAttribute("role", "toolbar");
    const signal = this.#editor._uiManager._signal;
    editToolbar.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    editToolbar.addEventListener("pointerdown", EditorToolbar.#pointerDown, {
      signal
    });
    const buttons = this.#buttons = document.createElement("div");
    buttons.className = "buttons";
    editToolbar.append(buttons);
    const position = this.#editor.toolbarPosition;
    if (position) {
      const {
        style
      } = editToolbar;
      const x = this.#editor._uiManager.direction === "ltr" ? 1 - position[0] : position[0];
      style.insetInlineEnd = `${100 * x}%`;
      style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    this.#addDeleteButton();
    return editToolbar;
  }
  static #pointerDown(e) {
    e.stopPropagation();
  }
  #focusIn(e) {
    this.#editor._focusEventsAllowed = false;
    e.preventDefault();
    e.stopPropagation();
  }
  #focusOut(e) {
    this.#editor._focusEventsAllowed = true;
    e.preventDefault();
    e.stopPropagation();
  }
  #addListenersToElement(element) {
    const signal = this.#editor._uiManager._signal;
    element.addEventListener("focusin", this.#focusIn.bind(this), {
      capture: true,
      signal
    });
    element.addEventListener("focusout", this.#focusOut.bind(this), {
      capture: true,
      signal
    });
    element.addEventListener("contextmenu", noContextMenu, {
      signal
    });
  }
  hide() {
    this.#toolbar.classList.add("hidden");
    this.#colorPicker?.hideDropdown();
  }
  show() {
    this.#toolbar.classList.remove("hidden");
  }
  #addDeleteButton() {
    const button = document.createElement("button");
    button.className = "delete";
    button.tabIndex = 0;
    button.setAttribute("data-l10n-id", `pdfjs-editor-remove-${this.#editor.editorType}-button`);
    this.#addListenersToElement(button);
    button.addEventListener("click", e => {
      this.#editor._uiManager.delete();
    }, {
      signal: this.#editor._uiManager._signal
    });
    this.#buttons.append(button);
  }
  get #divider() {
    const divider = document.createElement("div");
    divider.className = "divider";
    return divider;
  }
  addAltTextButton(button) {
    this.#addListenersToElement(button);
    this.#buttons.prepend(button, this.#divider);
  }
  addColorPicker(colorPicker) {
    this.#colorPicker = colorPicker;
    const button = colorPicker.renderButton();
    this.#addListenersToElement(button);
    this.#buttons.prepend(button, this.#divider);
  }
  remove() {
    this.#toolbar.remove();
    this.#colorPicker?.destroy();
    this.#colorPicker = null;
  }
}
class HighlightToolbar {
  #buttons = null;
  #toolbar = null;
  #uiManager;
  constructor(uiManager) {
    this.#uiManager = uiManager;
  }
  #render() {
    const editToolbar = this.#toolbar = document.createElement("div");
    editToolbar.className = "editToolbar";
    editToolbar.setAttribute("role", "toolbar");
    editToolbar.addEventListener("contextmenu", noContextMenu, {
      signal: this.#uiManager._signal
    });
    const buttons = this.#buttons = document.createElement("div");
    buttons.className = "buttons";
    editToolbar.append(buttons);
    this.#addHighlightButton();
    return editToolbar;
  }
  #getLastPoint(boxes, isLTR) {
    let lastY = 0;
    let lastX = 0;
    for (const box of boxes) {
      const y = box.y + box.height;
      if (y < lastY) {
        continue;
      }
      const x = box.x + (isLTR ? box.width : 0);
      if (y > lastY) {
        lastX = x;
        lastY = y;
        continue;
      }
      if (isLTR) {
        if (x > lastX) {
          lastX = x;
        }
      } else if (x < lastX) {
        lastX = x;
      }
    }
    return [isLTR ? 1 - lastX : lastX, lastY];
  }
  show(parent, boxes, isLTR) {
    const [x, y] = this.#getLastPoint(boxes, isLTR);
    const {
      style
    } = this.#toolbar ||= this.#render();
    parent.append(this.#toolbar);
    style.insetInlineEnd = `${100 * x}%`;
    style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    this.#toolbar.remove();
  }
  #addHighlightButton() {
    const button = document.createElement("button");
    button.className = "highlightButton";
    button.tabIndex = 0;
    button.setAttribute("data-l10n-id", `pdfjs-highlight-floating-button1`);
    const span = document.createElement("span");
    button.append(span);
    span.className = "visuallyHidden";
    span.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
    const signal = this.#uiManager._signal;
    button.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    button.addEventListener("click", () => {
      this.#uiManager.highlightSelection("floating_button");
    }, {
      signal
    });
    this.#buttons.append(button);
  }
}



function bindEvents(obj, element, names) {
  for (const name of names) {
    element.addEventListener(name, obj[name].bind(obj));
  }
}
function opacityToHex(opacity) {
  return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, "0");
}
class IdManager {
  #id = 0;
  get id() {
    return `${AnnotationEditorPrefix}${this.#id++}`;
  }
}
class ImageManager {
  #baseId = getUuid();
  #id = 0;
  #cache = null;
  static get _isSVGFittingCanvas() {
    const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
    const canvas = new OffscreenCanvas(1, 3);
    const ctx = canvas.getContext("2d", {
      willReadFrequently: true
    });
    const image = new Image();
    image.src = svg;
    const promise = image.decode().then(() => {
      ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
      return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
    });
    return shadow(this, "_isSVGFittingCanvas", promise);
  }
  async #get(key, rawData) {
    this.#cache ||= new Map();
    let data = this.#cache.get(key);
    if (data === null) {
      return null;
    }
    if (data?.bitmap) {
      data.refCounter += 1;
      return data;
    }
    try {
      data ||= {
        bitmap: null,
        id: `image_${this.#baseId}_${this.#id++}`,
        refCounter: 0,
        isSvg: false
      };
      let image;
      if (typeof rawData === "string") {
        data.url = rawData;
        image = await fetchData(rawData, "blob");
      } else {
        image = data.file = rawData;
      }
      if (image.type === "image/svg+xml") {
        const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;
        const fileReader = new FileReader();
        const imageElement = new Image();
        const imagePromise = new Promise((resolve, reject) => {
          imageElement.onload = () => {
            data.bitmap = imageElement;
            data.isSvg = true;
            resolve();
          };
          fileReader.onload = async () => {
            const url = data.svgUrl = fileReader.result;
            imageElement.src = (await mustRemoveAspectRatioPromise) ? `${url}#svgView(preserveAspectRatio(none))` : url;
          };
          imageElement.onerror = fileReader.onerror = reject;
        });
        fileReader.readAsDataURL(image);
        await imagePromise;
      } else {
        data.bitmap = await createImageBitmap(image);
      }
      data.refCounter = 1;
    } catch (e) {
      console.error(e);
      data = null;
    }
    this.#cache.set(key, data);
    if (data) {
      this.#cache.set(data.id, data);
    }
    return data;
  }
  async getFromFile(file) {
    const {
      lastModified,
      name,
      size,
      type
    } = file;
    return this.#get(`${lastModified}_${name}_${size}_${type}`, file);
  }
  async getFromUrl(url) {
    return this.#get(url, url);
  }
  async getFromId(id) {
    this.#cache ||= new Map();
    const data = this.#cache.get(id);
    if (!data) {
      return null;
    }
    if (data.bitmap) {
      data.refCounter += 1;
      return data;
    }
    if (data.file) {
      return this.getFromFile(data.file);
    }
    return this.getFromUrl(data.url);
  }
  getSvgUrl(id) {
    const data = this.#cache.get(id);
    if (!data?.isSvg) {
      return null;
    }
    return data.svgUrl;
  }
  deleteId(id) {
    this.#cache ||= new Map();
    const data = this.#cache.get(id);
    if (!data) {
      return;
    }
    data.refCounter -= 1;
    if (data.refCounter !== 0) {
      return;
    }
    data.bitmap = null;
  }
  isValidId(id) {
    return id.startsWith(`image_${this.#baseId}_`);
  }
}
class CommandManager {
  #commands = [];
  #locked = false;
  #maxSize;
  #position = -1;
  constructor(maxSize = 128) {
    this.#maxSize = maxSize;
  }
  add({
    cmd,
    undo,
    post,
    mustExec,
    type = NaN,
    overwriteIfSameType = false,
    keepUndo = false
  }) {
    if (mustExec) {
      cmd();
    }
    if (this.#locked) {
      return;
    }
    const save = {
      cmd,
      undo,
      post,
      type
    };
    if (this.#position === -1) {
      if (this.#commands.length > 0) {
        this.#commands.length = 0;
      }
      this.#position = 0;
      this.#commands.push(save);
      return;
    }
    if (overwriteIfSameType && this.#commands[this.#position].type === type) {
      if (keepUndo) {
        save.undo = this.#commands[this.#position].undo;
      }
      this.#commands[this.#position] = save;
      return;
    }
    const next = this.#position + 1;
    if (next === this.#maxSize) {
      this.#commands.splice(0, 1);
    } else {
      this.#position = next;
      if (next < this.#commands.length) {
        this.#commands.splice(next);
      }
    }
    this.#commands.push(save);
  }
  undo() {
    if (this.#position === -1) {
      return;
    }
    this.#locked = true;
    const {
      undo,
      post
    } = this.#commands[this.#position];
    undo();
    post?.();
    this.#locked = false;
    this.#position -= 1;
  }
  redo() {
    if (this.#position < this.#commands.length - 1) {
      this.#position += 1;
      this.#locked = true;
      const {
        cmd,
        post
      } = this.#commands[this.#position];
      cmd();
      post?.();
      this.#locked = false;
    }
  }
  hasSomethingToUndo() {
    return this.#position !== -1;
  }
  hasSomethingToRedo() {
    return this.#position < this.#commands.length - 1;
  }
  destroy() {
    this.#commands = null;
  }
}
class KeyboardManager {
  constructor(callbacks) {
    this.buffer = [];
    this.callbacks = new Map();
    this.allKeys = new Set();
    const {
      isMac
    } = util_FeatureTest.platform;
    for (const [keys, callback, options = {}] of callbacks) {
      for (const key of keys) {
        const isMacKey = key.startsWith("mac+");
        if (isMac && isMacKey) {
          this.callbacks.set(key.slice(4), {
            callback,
            options
          });
          this.allKeys.add(key.split("+").at(-1));
        } else if (!isMac && !isMacKey) {
          this.callbacks.set(key, {
            callback,
            options
          });
          this.allKeys.add(key.split("+").at(-1));
        }
      }
    }
  }
  #serialize(event) {
    if (event.altKey) {
      this.buffer.push("alt");
    }
    if (event.ctrlKey) {
      this.buffer.push("ctrl");
    }
    if (event.metaKey) {
      this.buffer.push("meta");
    }
    if (event.shiftKey) {
      this.buffer.push("shift");
    }
    this.buffer.push(event.key);
    const str = this.buffer.join("+");
    this.buffer.length = 0;
    return str;
  }
  exec(self, event) {
    if (!this.allKeys.has(event.key)) {
      return;
    }
    const info = this.callbacks.get(this.#serialize(event));
    if (!info) {
      return;
    }
    const {
      callback,
      options: {
        bubbles = false,
        args = [],
        checker = null
      }
    } = info;
    if (checker && !checker(self, event)) {
      return;
    }
    callback.bind(self, ...args, event)();
    if (!bubbles) {
      event.stopPropagation();
      event.preventDefault();
    }
  }
}
class ColorManager {
  static _colorsMapping = new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]);
  get _colors() {
    const colors = new Map([["CanvasText", null], ["Canvas", null]]);
    getColorValues(colors);
    return shadow(this, "_colors", colors);
  }
  convert(color) {
    const rgb = getRGB(color);
    if (!window.matchMedia("(forced-colors: active)").matches) {
      return rgb;
    }
    for (const [name, RGB] of this._colors) {
      if (RGB.every((x, i) => x === rgb[i])) {
        return ColorManager._colorsMapping.get(name);
      }
    }
    return rgb;
  }
  getHexCode(name) {
    const rgb = this._colors.get(name);
    if (!rgb) {
      return name;
    }
    return Util.makeHexColor(...rgb);
  }
}
class AnnotationEditorUIManager {
  #abortController = new AbortController();
  #activeEditor = null;
  #allEditors = new Map();
  #allLayers = new Map();
  #altTextManager = null;
  #annotationStorage = null;
  #changedExistingAnnotations = null;
  #commandManager = new CommandManager();
  #currentPageIndex = 0;
  #deletedAnnotationsElementIds = new Set();
  #draggingEditors = null;
  #editorTypes = null;
  #editorsToRescale = new Set();
  #enableHighlightFloatingButton = false;
  #filterFactory = null;
  #focusMainContainerTimeoutId = null;
  #highlightColors = null;
  #highlightWhenShiftUp = false;
  #highlightToolbar = null;
  #idManager = new IdManager();
  #isEnabled = false;
  #isWaiting = false;
  #lastActiveElement = null;
  #mainHighlightColorPicker = null;
  #mlManager = null;
  #mode = AnnotationEditorType.NONE;
  #selectedEditors = new Set();
  #selectedTextNode = null;
  #pageColors = null;
  #showAllStates = null;
  #boundBlur = this.blur.bind(this);
  #boundFocus = this.focus.bind(this);
  #boundCopy = this.copy.bind(this);
  #boundCut = this.cut.bind(this);
  #boundPaste = this.paste.bind(this);
  #boundKeydown = this.keydown.bind(this);
  #boundKeyup = this.keyup.bind(this);
  #boundOnEditingAction = this.onEditingAction.bind(this);
  #boundOnPageChanging = this.onPageChanging.bind(this);
  #boundOnScaleChanging = this.onScaleChanging.bind(this);
  #boundOnRotationChanging = this.onRotationChanging.bind(this);
  #previousStates = {
    isEditing: false,
    isEmpty: true,
    hasSomethingToUndo: false,
    hasSomethingToRedo: false,
    hasSelectedEditor: false,
    hasSelectedText: false
  };
  #translation = [0, 0];
  #translationTimeoutId = null;
  #container = null;
  #viewer = null;
  static TRANSLATE_SMALL = 1;
  static TRANSLATE_BIG = 10;
  static get _keyboardManager() {
    const proto = AnnotationEditorUIManager.prototype;
    const arrowChecker = self => self.#container.contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && self.hasSomethingToControl();
    const textInputChecker = (_self, {
      target: el
    }) => {
      if (el instanceof HTMLInputElement) {
        const {
          type
        } = el;
        return type !== "text" && type !== "number";
      }
      return true;
    };
    const small = this.TRANSLATE_SMALL;
    const big = this.TRANSLATE_BIG;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], proto.selectAll, {
      checker: textInputChecker
    }], [["ctrl+z", "mac+meta+z"], proto.undo, {
      checker: textInputChecker
    }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], proto.redo, {
      checker: textInputChecker
    }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], proto.delete, {
      checker: textInputChecker
    }], [["Enter", "mac+Enter"], proto.addNewEditorFromKeyboard, {
      checker: (self, {
        target: el
      }) => !(el instanceof HTMLButtonElement) && self.#container.contains(el) && !self.isEnterHandled
    }], [[" ", "mac+ "], proto.addNewEditorFromKeyboard, {
      checker: (self, {
        target: el
      }) => !(el instanceof HTMLButtonElement) && self.#container.contains(document.activeElement)
    }], [["Escape", "mac+Escape"], proto.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], proto.translateSelectedEditors, {
      args: [-small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto.translateSelectedEditors, {
      args: [-big, 0],
      checker: arrowChecker
    }], [["ArrowRight", "mac+ArrowRight"], proto.translateSelectedEditors, {
      args: [small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto.translateSelectedEditors, {
      args: [big, 0],
      checker: arrowChecker
    }], [["ArrowUp", "mac+ArrowUp"], proto.translateSelectedEditors, {
      args: [0, -small],
      checker: arrowChecker
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto.translateSelectedEditors, {
      args: [0, -big],
      checker: arrowChecker
    }], [["ArrowDown", "mac+ArrowDown"], proto.translateSelectedEditors, {
      args: [0, small],
      checker: arrowChecker
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto.translateSelectedEditors, {
      args: [0, big],
      checker: arrowChecker
    }]]));
  }
  constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, mlManager) {
    this._signal = this.#abortController.signal;
    this.#container = container;
    this.#viewer = viewer;
    this.#altTextManager = altTextManager;
    this._eventBus = eventBus;
    this._eventBus._on("editingaction", this.#boundOnEditingAction);
    this._eventBus._on("pagechanging", this.#boundOnPageChanging);
    this._eventBus._on("scalechanging", this.#boundOnScaleChanging);
    this._eventBus._on("rotationchanging", this.#boundOnRotationChanging);
    this.#addSelectionListener();
    this.#addDragAndDropListeners();
    this.#addKeyboardManager();
    this.#annotationStorage = pdfDocument.annotationStorage;
    this.#filterFactory = pdfDocument.filterFactory;
    this.#pageColors = pageColors;
    this.#highlightColors = highlightColors || null;
    this.#enableHighlightFloatingButton = enableHighlightFloatingButton;
    this.#mlManager = mlManager || null;
    this.viewParameters = {
      realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
      rotation: 0
    };
    this.isShiftKeyDown = false;
  }
  destroy() {
    this.#abortController?.abort();
    this.#abortController = null;
    this._signal = null;
    this._eventBus._off("editingaction", this.#boundOnEditingAction);
    this._eventBus._off("pagechanging", this.#boundOnPageChanging);
    this._eventBus._off("scalechanging", this.#boundOnScaleChanging);
    this._eventBus._off("rotationchanging", this.#boundOnRotationChanging);
    for (const layer of this.#allLayers.values()) {
      layer.destroy();
    }
    this.#allLayers.clear();
    this.#allEditors.clear();
    this.#editorsToRescale.clear();
    this.#activeEditor = null;
    this.#selectedEditors.clear();
    this.#commandManager.destroy();
    this.#altTextManager?.destroy();
    this.#highlightToolbar?.hide();
    this.#highlightToolbar = null;
    if (this.#focusMainContainerTimeoutId) {
      clearTimeout(this.#focusMainContainerTimeoutId);
      this.#focusMainContainerTimeoutId = null;
    }
    if (this.#translationTimeoutId) {
      clearTimeout(this.#translationTimeoutId);
      this.#translationTimeoutId = null;
    }
  }
  async mlGuess(data) {
    return this.#mlManager?.guess(data) || null;
  }
  get hasMLManager() {
    return !!this.#mlManager;
  }
  get hcmFilter() {
    return shadow(this, "hcmFilter", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : "none");
  }
  get direction() {
    return shadow(this, "direction", getComputedStyle(this.#container).direction);
  }
  get highlightColors() {
    return shadow(this, "highlightColors", this.#highlightColors ? new Map(this.#highlightColors.split(",").map(pair => pair.split("=").map(x => x.trim()))) : null);
  }
  get highlightColorNames() {
    return shadow(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, e => e.reverse())) : null);
  }
  setMainHighlightColorPicker(colorPicker) {
    this.#mainHighlightColorPicker = colorPicker;
  }
  editAltText(editor) {
    this.#altTextManager?.editAltText(this, editor);
  }
  onPageChanging({
    pageNumber
  }) {
    this.#currentPageIndex = pageNumber - 1;
  }
  focusMainContainer() {
    this.#container.focus();
  }
  findParent(x, y) {
    for (const layer of this.#allLayers.values()) {
      const {
        x: layerX,
        y: layerY,
        width,
        height
      } = layer.div.getBoundingClientRect();
      if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {
        return layer;
      }
    }
    return null;
  }
  disableUserSelect(value = false) {
    this.#viewer.classList.toggle("noUserSelect", value);
  }
  addShouldRescale(editor) {
    this.#editorsToRescale.add(editor);
  }
  removeShouldRescale(editor) {
    this.#editorsToRescale.delete(editor);
  }
  onScaleChanging({
    scale
  }) {
    this.commitOrRemove();
    this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
    for (const editor of this.#editorsToRescale) {
      editor.onScaleChanging();
    }
  }
  onRotationChanging({
    pagesRotation
  }) {
    this.commitOrRemove();
    this.viewParameters.rotation = pagesRotation;
  }
  #getAnchorElementForSelection({
    anchorNode
  }) {
    return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;
  }
  highlightSelection(methodOfCreation = "") {
    const selection = document.getSelection();
    if (!selection || selection.isCollapsed) {
      return;
    }
    const {
      anchorNode,
      anchorOffset,
      focusNode,
      focusOffset
    } = selection;
    const text = selection.toString();
    const anchorElement = this.#getAnchorElementForSelection(selection);
    const textLayer = anchorElement.closest(".textLayer");
    const boxes = this.getSelectionBoxes(textLayer);
    if (!boxes) {
      return;
    }
    selection.empty();
    if (this.#mode === AnnotationEditorType.NONE) {
      this._eventBus.dispatch("showannotationeditorui", {
        source: this,
        mode: AnnotationEditorType.HIGHLIGHT
      });
      this.showAllEditors("highlight", true, true);
    }
    for (const layer of this.#allLayers.values()) {
      if (layer.hasTextLayer(textLayer)) {
        layer.createAndAddNewEditor({
          x: 0,
          y: 0
        }, false, {
          methodOfCreation,
          boxes,
          anchorNode,
          anchorOffset,
          focusNode,
          focusOffset,
          text
        });
        break;
      }
    }
  }
  #displayHighlightToolbar() {
    const selection = document.getSelection();
    if (!selection || selection.isCollapsed) {
      return;
    }
    const anchorElement = this.#getAnchorElementForSelection(selection);
    const textLayer = anchorElement.closest(".textLayer");
    const boxes = this.getSelectionBoxes(textLayer);
    if (!boxes) {
      return;
    }
    this.#highlightToolbar ||= new HighlightToolbar(this);
    this.#highlightToolbar.show(textLayer, boxes, this.direction === "ltr");
  }
  addToAnnotationStorage(editor) {
    if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {
      this.#annotationStorage.setValue(editor.id, editor);
    }
  }
  #selectionChange() {
    const selection = document.getSelection();
    if (!selection || selection.isCollapsed) {
      if (this.#selectedTextNode) {
        this.#highlightToolbar?.hide();
        this.#selectedTextNode = null;
        this.#dispatchUpdateStates({
          hasSelectedText: false
        });
      }
      return;
    }
    const {
      anchorNode
    } = selection;
    if (anchorNode === this.#selectedTextNode) {
      return;
    }
    const anchorElement = this.#getAnchorElementForSelection(selection);
    const textLayer = anchorElement.closest(".textLayer");
    if (!textLayer) {
      if (this.#selectedTextNode) {
        this.#highlightToolbar?.hide();
        this.#selectedTextNode = null;
        this.#dispatchUpdateStates({
          hasSelectedText: false
        });
      }
      return;
    }
    this.#highlightToolbar?.hide();
    this.#selectedTextNode = anchorNode;
    this.#dispatchUpdateStates({
      hasSelectedText: true
    });
    if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {
      return;
    }
    if (this.#mode === AnnotationEditorType.HIGHLIGHT) {
      this.showAllEditors("highlight", true, true);
    }
    this.#highlightWhenShiftUp = this.isShiftKeyDown;
    if (!this.isShiftKeyDown) {
      const signal = this._signal;
      const pointerup = e => {
        if (e.type === "pointerup" && e.button !== 0) {
          return;
        }
        window.removeEventListener("pointerup", pointerup);
        window.removeEventListener("blur", pointerup);
        if (e.type === "pointerup") {
          this.#onSelectEnd("main_toolbar");
        }
      };
      window.addEventListener("pointerup", pointerup, {
        signal
      });
      window.addEventListener("blur", pointerup, {
        signal
      });
    }
  }
  #onSelectEnd(methodOfCreation = "") {
    if (this.#mode === AnnotationEditorType.HIGHLIGHT) {
      this.highlightSelection(methodOfCreation);
    } else if (this.#enableHighlightFloatingButton) {
      this.#displayHighlightToolbar();
    }
  }
  #addSelectionListener() {
    document.addEventListener("selectionchange", this.#selectionChange.bind(this), {
      signal: this._signal
    });
  }
  #addFocusManager() {
    const signal = this._signal;
    window.addEventListener("focus", this.#boundFocus, {
      signal
    });
    window.addEventListener("blur", this.#boundBlur, {
      signal
    });
  }
  #removeFocusManager() {
    window.removeEventListener("focus", this.#boundFocus);
    window.removeEventListener("blur", this.#boundBlur);
  }
  blur() {
    this.isShiftKeyDown = false;
    if (this.#highlightWhenShiftUp) {
      this.#highlightWhenShiftUp = false;
      this.#onSelectEnd("main_toolbar");
    }
    if (!this.hasSelection) {
      return;
    }
    const {
      activeElement
    } = document;
    for (const editor of this.#selectedEditors) {
      if (editor.div.contains(activeElement)) {
        this.#lastActiveElement = [editor, activeElement];
        editor._focusEventsAllowed = false;
        break;
      }
    }
  }
  focus() {
    if (!this.#lastActiveElement) {
      return;
    }
    const [lastEditor, lastActiveElement] = this.#lastActiveElement;
    this.#lastActiveElement = null;
    lastActiveElement.addEventListener("focusin", () => {
      lastEditor._focusEventsAllowed = true;
    }, {
      once: true,
      signal: this._signal
    });
    lastActiveElement.focus();
  }
  #addKeyboardManager() {
    const signal = this._signal;
    window.addEventListener("keydown", this.#boundKeydown, {
      signal
    });
    window.addEventListener("keyup", this.#boundKeyup, {
      signal
    });
  }
  #removeKeyboardManager() {
    window.removeEventListener("keydown", this.#boundKeydown);
    window.removeEventListener("keyup", this.#boundKeyup);
  }
  #addCopyPasteListeners() {
    const signal = this._signal;
    document.addEventListener("copy", this.#boundCopy, {
      signal
    });
    document.addEventListener("cut", this.#boundCut, {
      signal
    });
    document.addEventListener("paste", this.#boundPaste, {
      signal
    });
  }
  #removeCopyPasteListeners() {
    document.removeEventListener("copy", this.#boundCopy);
    document.removeEventListener("cut", this.#boundCut);
    document.removeEventListener("paste", this.#boundPaste);
  }
  #addDragAndDropListeners() {
    const signal = this._signal;
    document.addEventListener("dragover", this.dragOver.bind(this), {
      signal
    });
    document.addEventListener("drop", this.drop.bind(this), {
      signal
    });
  }
  addEditListeners() {
    this.#addKeyboardManager();
    this.#addCopyPasteListeners();
  }
  removeEditListeners() {
    this.#removeKeyboardManager();
    this.#removeCopyPasteListeners();
  }
  dragOver(event) {
    for (const {
      type
    } of event.dataTransfer.items) {
      for (const editorType of this.#editorTypes) {
        if (editorType.isHandlingMimeForPasting(type)) {
          event.dataTransfer.dropEffect = "copy";
          event.preventDefault();
          return;
        }
      }
    }
  }
  drop(event) {
    for (const item of event.dataTransfer.items) {
      for (const editorType of this.#editorTypes) {
        if (editorType.isHandlingMimeForPasting(item.type)) {
          editorType.paste(item, this.currentLayer);
          event.preventDefault();
          return;
        }
      }
    }
  }
  copy(event) {
    event.preventDefault();
    this.#activeEditor?.commitOrRemove();
    if (!this.hasSelection) {
      return;
    }
    const editors = [];
    for (const editor of this.#selectedEditors) {
      const serialized = editor.serialize(true);
      if (serialized) {
        editors.push(serialized);
      }
    }
    if (editors.length === 0) {
      return;
    }
    event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
  }
  cut(event) {
    this.copy(event);
    this.delete();
  }
  paste(event) {
    event.preventDefault();
    const {
      clipboardData
    } = event;
    for (const item of clipboardData.items) {
      for (const editorType of this.#editorTypes) {
        if (editorType.isHandlingMimeForPasting(item.type)) {
          editorType.paste(item, this.currentLayer);
          return;
        }
      }
    }
    let data = clipboardData.getData("application/pdfjs");
    if (!data) {
      return;
    }
    try {
      data = JSON.parse(data);
    } catch (ex) {
      warn(`paste: "${ex.message}".`);
      return;
    }
    if (!Array.isArray(data)) {
      return;
    }
    this.unselectAll();
    const layer = this.currentLayer;
    try {
      const newEditors = [];
      for (const editor of data) {
        const deserializedEditor = layer.deserialize(editor);
        if (!deserializedEditor) {
          return;
        }
        newEditors.push(deserializedEditor);
      }
      const cmd = () => {
        for (const editor of newEditors) {
          this.#addEditorToLayer(editor);
        }
        this.#selectEditors(newEditors);
      };
      const undo = () => {
        for (const editor of newEditors) {
          editor.remove();
        }
      };
      this.addCommands({
        cmd,
        undo,
        mustExec: true
      });
    } catch (ex) {
      warn(`paste: "${ex.message}".`);
    }
  }
  keydown(event) {
    if (!this.isShiftKeyDown && event.key === "Shift") {
      this.isShiftKeyDown = true;
    }
    if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {
      AnnotationEditorUIManager._keyboardManager.exec(this, event);
    }
  }
  keyup(event) {
    if (this.isShiftKeyDown && event.key === "Shift") {
      this.isShiftKeyDown = false;
      if (this.#highlightWhenShiftUp) {
        this.#highlightWhenShiftUp = false;
        this.#onSelectEnd("main_toolbar");
      }
    }
  }
  onEditingAction({
    name
  }) {
    switch (name) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[name]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
        break;
    }
  }
  #dispatchUpdateStates(details) {
    const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);
    if (hasChanged) {
      this._eventBus.dispatch("annotationeditorstateschanged", {
        source: this,
        details: Object.assign(this.#previousStates, details)
      });
      if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {
        this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_FREE, true]]);
      }
    }
  }
  #dispatchUpdateUI(details) {
    this._eventBus.dispatch("annotationeditorparamschanged", {
      source: this,
      details
    });
  }
  setEditingState(isEditing) {
    if (isEditing) {
      this.#addFocusManager();
      this.#addCopyPasteListeners();
      this.#dispatchUpdateStates({
        isEditing: this.#mode !== AnnotationEditorType.NONE,
        isEmpty: this.#isEmpty(),
        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
        hasSelectedEditor: false
      });
    } else {
      this.#removeFocusManager();
      this.#removeCopyPasteListeners();
      this.#dispatchUpdateStates({
        isEditing: false
      });
      this.disableUserSelect(false);
    }
  }
  registerEditorTypes(types) {
    if (this.#editorTypes) {
      return;
    }
    this.#editorTypes = types;
    for (const editorType of this.#editorTypes) {
      this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return this.#idManager.id;
  }
  get currentLayer() {
    return this.#allLayers.get(this.#currentPageIndex);
  }
  getLayer(pageIndex) {
    return this.#allLayers.get(pageIndex);
  }
  get currentPageIndex() {
    return this.#currentPageIndex;
  }
  addLayer(layer) {
    this.#allLayers.set(layer.pageIndex, layer);
    if (this.#isEnabled) {
      layer.enable();
    } else {
      layer.disable();
    }
  }
  removeLayer(layer) {
    this.#allLayers.delete(layer.pageIndex);
  }
  updateMode(mode, editId = null, isFromKeyboard = false) {
    if (this.#mode === mode) {
      return;
    }
    this.#mode = mode;
    if (mode === AnnotationEditorType.NONE) {
      this.setEditingState(false);
      this.#disableAll();
      return;
    }
    this.setEditingState(true);
    this.#enableAll();
    this.unselectAll();
    for (const layer of this.#allLayers.values()) {
      layer.updateMode(mode);
    }
    if (!editId && isFromKeyboard) {
      this.addNewEditorFromKeyboard();
      return;
    }
    if (!editId) {
      return;
    }
    for (const editor of this.#allEditors.values()) {
      if (editor.annotationElementId === editId) {
        this.setSelected(editor);
        editor.enterInEditMode();
        break;
      }
    }
  }
  addNewEditorFromKeyboard() {
    if (this.currentLayer.canCreateNewEmptyEditor()) {
      this.currentLayer.addNewEditor();
    }
  }
  updateToolbar(mode) {
    if (mode === this.#mode) {
      return;
    }
    this._eventBus.dispatch("switchannotationeditormode", {
      source: this,
      mode
    });
  }
  updateParams(type, value) {
    if (!this.#editorTypes) {
      return;
    }
    switch (type) {
      case AnnotationEditorParamsType.CREATE:
        this.currentLayer.addNewEditor();
        return;
      case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:
        this.#mainHighlightColorPicker?.updateColor(value);
        break;
      case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:
        this._eventBus.dispatch("reporttelemetry", {
          source: this,
          details: {
            type: "editing",
            data: {
              type: "highlight",
              action: "toggle_visibility"
            }
          }
        });
        (this.#showAllStates ||= new Map()).set(type, value);
        this.showAllEditors("highlight", value);
        break;
    }
    for (const editor of this.#selectedEditors) {
      editor.updateParams(type, value);
    }
    for (const editorType of this.#editorTypes) {
      editorType.updateDefaultParams(type, value);
    }
  }
  showAllEditors(type, visible, updateButton = false) {
    for (const editor of this.#allEditors.values()) {
      if (editor.editorType === type) {
        editor.show(visible);
      }
    }
    const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;
    if (state !== visible) {
      this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, visible]]);
    }
  }
  enableWaiting(mustWait = false) {
    if (this.#isWaiting === mustWait) {
      return;
    }
    this.#isWaiting = mustWait;
    for (const layer of this.#allLayers.values()) {
      if (mustWait) {
        layer.disableClick();
      } else {
        layer.enableClick();
      }
      layer.div.classList.toggle("waiting", mustWait);
    }
  }
  #enableAll() {
    if (!this.#isEnabled) {
      this.#isEnabled = true;
      for (const layer of this.#allLayers.values()) {
        layer.enable();
      }
      for (const editor of this.#allEditors.values()) {
        editor.enable();
      }
    }
  }
  #disableAll() {
    this.unselectAll();
    if (this.#isEnabled) {
      this.#isEnabled = false;
      for (const layer of this.#allLayers.values()) {
        layer.disable();
      }
      for (const editor of this.#allEditors.values()) {
        editor.disable();
      }
    }
  }
  getEditors(pageIndex) {
    const editors = [];
    for (const editor of this.#allEditors.values()) {
      if (editor.pageIndex === pageIndex) {
        editors.push(editor);
      }
    }
    return editors;
  }
  getEditor(id) {
    return this.#allEditors.get(id);
  }
  addEditor(editor) {
    this.#allEditors.set(editor.id, editor);
  }
  removeEditor(editor) {
    if (editor.div.contains(document.activeElement)) {
      if (this.#focusMainContainerTimeoutId) {
        clearTimeout(this.#focusMainContainerTimeoutId);
      }
      this.#focusMainContainerTimeoutId = setTimeout(() => {
        this.focusMainContainer();
        this.#focusMainContainerTimeoutId = null;
      }, 0);
    }
    this.#allEditors.delete(editor.id);
    this.unselect(editor);
    if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {
      this.#annotationStorage?.remove(editor.id);
    }
  }
  addDeletedAnnotationElement(editor) {
    this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
    this.addChangedExistingAnnotation(editor);
    editor.deleted = true;
  }
  isDeletedAnnotationElement(annotationElementId) {
    return this.#deletedAnnotationsElementIds.has(annotationElementId);
  }
  removeDeletedAnnotationElement(editor) {
    this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
    this.removeChangedExistingAnnotation(editor);
    editor.deleted = false;
  }
  #addEditorToLayer(editor) {
    const layer = this.#allLayers.get(editor.pageIndex);
    if (layer) {
      layer.addOrRebuild(editor);
    } else {
      this.addEditor(editor);
      this.addToAnnotationStorage(editor);
    }
  }
  setActiveEditor(editor) {
    if (this.#activeEditor === editor) {
      return;
    }
    this.#activeEditor = editor;
    if (editor) {
      this.#dispatchUpdateUI(editor.propertiesToUpdate);
    }
  }
  get #lastSelectedEditor() {
    let ed = null;
    for (ed of this.#selectedEditors) {}
    return ed;
  }
  updateUI(editor) {
    if (this.#lastSelectedEditor === editor) {
      this.#dispatchUpdateUI(editor.propertiesToUpdate);
    }
  }
  toggleSelected(editor) {
    if (this.#selectedEditors.has(editor)) {
      this.#selectedEditors.delete(editor);
      editor.unselect();
      this.#dispatchUpdateStates({
        hasSelectedEditor: this.hasSelection
      });
      return;
    }
    this.#selectedEditors.add(editor);
    editor.select();
    this.#dispatchUpdateUI(editor.propertiesToUpdate);
    this.#dispatchUpdateStates({
      hasSelectedEditor: true
    });
  }
  setSelected(editor) {
    for (const ed of this.#selectedEditors) {
      if (ed !== editor) {
        ed.unselect();
      }
    }
    this.#selectedEditors.clear();
    this.#selectedEditors.add(editor);
    editor.select();
    this.#dispatchUpdateUI(editor.propertiesToUpdate);
    this.#dispatchUpdateStates({
      hasSelectedEditor: true
    });
  }
  isSelected(editor) {
    return this.#selectedEditors.has(editor);
  }
  get firstSelectedEditor() {
    return this.#selectedEditors.values().next().value;
  }
  unselect(editor) {
    editor.unselect();
    this.#selectedEditors.delete(editor);
    this.#dispatchUpdateStates({
      hasSelectedEditor: this.hasSelection
    });
  }
  get hasSelection() {
    return this.#selectedEditors.size !== 0;
  }
  get isEnterHandled() {
    return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    this.#commandManager.undo();
    this.#dispatchUpdateStates({
      hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
      hasSomethingToRedo: true,
      isEmpty: this.#isEmpty()
    });
  }
  redo() {
    this.#commandManager.redo();
    this.#dispatchUpdateStates({
      hasSomethingToUndo: true,
      hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
      isEmpty: this.#isEmpty()
    });
  }
  addCommands(params) {
    this.#commandManager.add(params);
    this.#dispatchUpdateStates({
      hasSomethingToUndo: true,
      hasSomethingToRedo: false,
      isEmpty: this.#isEmpty()
    });
  }
  #isEmpty() {
    if (this.#allEditors.size === 0) {
      return true;
    }
    if (this.#allEditors.size === 1) {
      for (const editor of this.#allEditors.values()) {
        return editor.isEmpty();
      }
    }
    return false;
  }
  delete() {
    this.commitOrRemove();
    if (!this.hasSelection) {
      return;
    }
    const editors = [...this.#selectedEditors];
    const cmd = () => {
      for (const editor of editors) {
        editor.remove();
      }
    };
    const undo = () => {
      for (const editor of editors) {
        this.#addEditorToLayer(editor);
      }
    };
    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }
  commitOrRemove() {
    this.#activeEditor?.commitOrRemove();
  }
  hasSomethingToControl() {
    return this.#activeEditor || this.hasSelection;
  }
  #selectEditors(editors) {
    for (const editor of this.#selectedEditors) {
      editor.unselect();
    }
    this.#selectedEditors.clear();
    for (const editor of editors) {
      if (editor.isEmpty()) {
        continue;
      }
      this.#selectedEditors.add(editor);
      editor.select();
    }
    this.#dispatchUpdateStates({
      hasSelectedEditor: this.hasSelection
    });
  }
  selectAll() {
    for (const editor of this.#selectedEditors) {
      editor.commit();
    }
    this.#selectEditors(this.#allEditors.values());
  }
  unselectAll() {
    if (this.#activeEditor) {
      this.#activeEditor.commitOrRemove();
      if (this.#mode !== AnnotationEditorType.NONE) {
        return;
      }
    }
    if (!this.hasSelection) {
      return;
    }
    for (const editor of this.#selectedEditors) {
      editor.unselect();
    }
    this.#selectedEditors.clear();
    this.#dispatchUpdateStates({
      hasSelectedEditor: false
    });
  }
  translateSelectedEditors(x, y, noCommit = false) {
    if (!noCommit) {
      this.commitOrRemove();
    }
    if (!this.hasSelection) {
      return;
    }
    this.#translation[0] += x;
    this.#translation[1] += y;
    const [totalX, totalY] = this.#translation;
    const editors = [...this.#selectedEditors];
    const TIME_TO_WAIT = 1000;
    if (this.#translationTimeoutId) {
      clearTimeout(this.#translationTimeoutId);
    }
    this.#translationTimeoutId = setTimeout(() => {
      this.#translationTimeoutId = null;
      this.#translation[0] = this.#translation[1] = 0;
      this.addCommands({
        cmd: () => {
          for (const editor of editors) {
            if (this.#allEditors.has(editor.id)) {
              editor.translateInPage(totalX, totalY);
            }
          }
        },
        undo: () => {
          for (const editor of editors) {
            if (this.#allEditors.has(editor.id)) {
              editor.translateInPage(-totalX, -totalY);
            }
          }
        },
        mustExec: false
      });
    }, TIME_TO_WAIT);
    for (const editor of editors) {
      editor.translateInPage(x, y);
    }
  }
  setUpDragSession() {
    if (!this.hasSelection) {
      return;
    }
    this.disableUserSelect(true);
    this.#draggingEditors = new Map();
    for (const editor of this.#selectedEditors) {
      this.#draggingEditors.set(editor, {
        savedX: editor.x,
        savedY: editor.y,
        savedPageIndex: editor.pageIndex,
        newX: 0,
        newY: 0,
        newPageIndex: -1
      });
    }
  }
  endDragSession() {
    if (!this.#draggingEditors) {
      return false;
    }
    this.disableUserSelect(false);
    const map = this.#draggingEditors;
    this.#draggingEditors = null;
    let mustBeAddedInUndoStack = false;
    for (const [{
      x,
      y,
      pageIndex
    }, value] of map) {
      value.newX = x;
      value.newY = y;
      value.newPageIndex = pageIndex;
      mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;
    }
    if (!mustBeAddedInUndoStack) {
      return false;
    }
    const move = (editor, x, y, pageIndex) => {
      if (this.#allEditors.has(editor.id)) {
        const parent = this.#allLayers.get(pageIndex);
        if (parent) {
          editor._setParentAndPosition(parent, x, y);
        } else {
          editor.pageIndex = pageIndex;
          editor.x = x;
          editor.y = y;
        }
      }
    };
    this.addCommands({
      cmd: () => {
        for (const [editor, {
          newX,
          newY,
          newPageIndex
        }] of map) {
          move(editor, newX, newY, newPageIndex);
        }
      },
      undo: () => {
        for (const [editor, {
          savedX,
          savedY,
          savedPageIndex
        }] of map) {
          move(editor, savedX, savedY, savedPageIndex);
        }
      },
      mustExec: true
    });
    return true;
  }
  dragSelectedEditors(tx, ty) {
    if (!this.#draggingEditors) {
      return;
    }
    for (const editor of this.#draggingEditors.keys()) {
      editor.drag(tx, ty);
    }
  }
  rebuild(editor) {
    if (editor.parent === null) {
      const parent = this.getLayer(editor.pageIndex);
      if (parent) {
        parent.changeParent(editor);
        parent.addOrRebuild(editor);
      } else {
        this.addEditor(editor);
        this.addToAnnotationStorage(editor);
        editor.rebuild();
      }
    } else {
      editor.parent.addOrRebuild(editor);
    }
  }
  get isEditorHandlingKeyboard() {
    return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(editor) {
    return this.#activeEditor === editor;
  }
  getActive() {
    return this.#activeEditor;
  }
  getMode() {
    return this.#mode;
  }
  get imageManager() {
    return shadow(this, "imageManager", new ImageManager());
  }
  getSelectionBoxes(textLayer) {
    if (!textLayer) {
      return null;
    }
    const selection = document.getSelection();
    for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
      if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {
        return null;
      }
    }
    const {
      x: layerX,
      y: layerY,
      width: parentWidth,
      height: parentHeight
    } = textLayer.getBoundingClientRect();
    let rotator;
    switch (textLayer.getAttribute("data-main-rotation")) {
      case "90":
        rotator = (x, y, w, h) => ({
          x: (y - layerY) / parentHeight,
          y: 1 - (x + w - layerX) / parentWidth,
          width: h / parentHeight,
          height: w / parentWidth
        });
        break;
      case "180":
        rotator = (x, y, w, h) => ({
          x: 1 - (x + w - layerX) / parentWidth,
          y: 1 - (y + h - layerY) / parentHeight,
          width: w / parentWidth,
          height: h / parentHeight
        });
        break;
      case "270":
        rotator = (x, y, w, h) => ({
          x: 1 - (y + h - layerY) / parentHeight,
          y: (x - layerX) / parentWidth,
          width: h / parentHeight,
          height: w / parentWidth
        });
        break;
      default:
        rotator = (x, y, w, h) => ({
          x: (x - layerX) / parentWidth,
          y: (y - layerY) / parentHeight,
          width: w / parentWidth,
          height: h / parentHeight
        });
        break;
    }
    const boxes = [];
    for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
      const range = selection.getRangeAt(i);
      if (range.collapsed) {
        continue;
      }
      for (const {
        x,
        y,
        width,
        height
      } of range.getClientRects()) {
        if (width === 0 || height === 0) {
          continue;
        }
        boxes.push(rotator(x, y, width, height));
      }
    }
    return boxes.length === 0 ? null : boxes;
  }
  addChangedExistingAnnotation({
    annotationElementId,
    id
  }) {
    (this.#changedExistingAnnotations ||= new Map()).set(annotationElementId, id);
  }
  removeChangedExistingAnnotation({
    annotationElementId
  }) {
    this.#changedExistingAnnotations?.delete(annotationElementId);
  }
  renderAnnotationElement(annotation) {
    const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);
    if (!editorId) {
      return;
    }
    const editor = this.#annotationStorage.getRawValue(editorId);
    if (!editor) {
      return;
    }
    if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {
      return;
    }
    editor.renderAnnotationElement(annotation);
  }
}

class AltText {
  #altText = "";
  #altTextDecorative = false;
  #altTextButton = null;
  #altTextTooltip = null;
  #altTextTooltipTimeout = null;
  #altTextWasFromKeyBoard = false;
  #editor = null;
  static _l10nPromise = null;
  constructor(editor) {
    this.#editor = editor;
  }
  static initialize(l10nPromise) {
    AltText._l10nPromise ||= l10nPromise;
  }
  async render() {
    const altText = this.#altTextButton = document.createElement("button");
    altText.className = "altText";
    const msg = await AltText._l10nPromise.get("pdfjs-editor-alt-text-button-label");
    altText.textContent = msg;
    altText.setAttribute("aria-label", msg);
    altText.tabIndex = "0";
    const signal = this.#editor._uiManager._signal;
    altText.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    altText.addEventListener("pointerdown", event => event.stopPropagation(), {
      signal
    });
    const onClick = event => {
      event.preventDefault();
      this.#editor._uiManager.editAltText(this.#editor);
    };
    altText.addEventListener("click", onClick, {
      capture: true,
      signal
    });
    altText.addEventListener("keydown", event => {
      if (event.target === altText && event.key === "Enter") {
        this.#altTextWasFromKeyBoard = true;
        onClick(event);
      }
    }, {
      signal
    });
    await this.#setState();
    return altText;
  }
  finish() {
    if (!this.#altTextButton) {
      return;
    }
    this.#altTextButton.focus({
      focusVisible: this.#altTextWasFromKeyBoard
    });
    this.#altTextWasFromKeyBoard = false;
  }
  isEmpty() {
    return !this.#altText && !this.#altTextDecorative;
  }
  get data() {
    return {
      altText: this.#altText,
      decorative: this.#altTextDecorative
    };
  }
  set data({
    altText,
    decorative
  }) {
    if (this.#altText === altText && this.#altTextDecorative === decorative) {
      return;
    }
    this.#altText = altText;
    this.#altTextDecorative = decorative;
    this.#setState();
  }
  toggle(enabled = false) {
    if (!this.#altTextButton) {
      return;
    }
    if (!enabled && this.#altTextTooltipTimeout) {
      clearTimeout(this.#altTextTooltipTimeout);
      this.#altTextTooltipTimeout = null;
    }
    this.#altTextButton.disabled = !enabled;
  }
  destroy() {
    this.#altTextButton?.remove();
    this.#altTextButton = null;
    this.#altTextTooltip = null;
  }
  async #setState() {
    const button = this.#altTextButton;
    if (!button) {
      return;
    }
    if (!this.#altText && !this.#altTextDecorative) {
      button.classList.remove("done");
      this.#altTextTooltip?.remove();
      return;
    }
    button.classList.add("done");
    AltText._l10nPromise.get("pdfjs-editor-alt-text-edit-button-label").then(msg => {
      button.setAttribute("aria-label", msg);
    });
    let tooltip = this.#altTextTooltip;
    if (!tooltip) {
      this.#altTextTooltip = tooltip = document.createElement("span");
      tooltip.className = "tooltip";
      tooltip.setAttribute("role", "tooltip");
      const id = tooltip.id = `alt-text-tooltip-${this.#editor.id}`;
      button.setAttribute("aria-describedby", id);
      const DELAY_TO_SHOW_TOOLTIP = 100;
      const signal = this.#editor._uiManager._signal;
      signal.addEventListener("abort", () => {
        clearTimeout(this.#altTextTooltipTimeout);
        this.#altTextTooltipTimeout = null;
      }, {
        once: true
      });
      button.addEventListener("mouseenter", () => {
        this.#altTextTooltipTimeout = setTimeout(() => {
          this.#altTextTooltipTimeout = null;
          this.#altTextTooltip.classList.add("show");
          this.#editor._reportTelemetry({
            action: "alt_text_tooltip"
          });
        }, DELAY_TO_SHOW_TOOLTIP);
      }, {
        signal
      });
      button.addEventListener("mouseleave", () => {
        if (this.#altTextTooltipTimeout) {
          clearTimeout(this.#altTextTooltipTimeout);
          this.#altTextTooltipTimeout = null;
        }
        this.#altTextTooltip?.classList.remove("show");
      }, {
        signal
      });
    }
    tooltip.innerText = this.#altTextDecorative ? await AltText._l10nPromise.get("pdfjs-editor-alt-text-decorative-tooltip") : this.#altText;
    if (!tooltip.parentNode) {
      button.append(tooltip);
    }
    const element = this.#editor.getImageForAltText();
    element?.setAttribute("aria-describedby", tooltip.id);
  }
}





class AnnotationEditor {
  #accessibilityData = null;
  #allResizerDivs = null;
  #altText = null;
  #disabled = false;
  #keepAspectRatio = false;
  #resizersDiv = null;
  #savedDimensions = null;
  #boundFocusin = this.focusin.bind(this);
  #boundFocusout = this.focusout.bind(this);
  #editToolbar = null;
  #focusedResizerName = "";
  #hasBeenClicked = false;
  #initialPosition = null;
  #isEditing = false;
  #isInEditMode = false;
  #isResizerEnabledForKeyboard = false;
  #moveInDOMTimeout = null;
  #prevDragX = 0;
  #prevDragY = 0;
  #telemetryTimeouts = null;
  _initialOptions = Object.create(null);
  _isVisible = true;
  _uiManager = null;
  _focusEventsAllowed = true;
  _l10nPromise = null;
  #isDraggable = false;
  #zIndex = AnnotationEditor._zIndex++;
  static _borderLineWidth = -1;
  static _colorManager = new ColorManager();
  static _zIndex = 1;
  static _telemetryTimeout = 1000;
  static get _resizerKeyboardManager() {
    const resize = AnnotationEditor.prototype._resizeWithKeyboard;
    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
    const big = AnnotationEditorUIManager.TRANSLATE_BIG;
    return shadow(this, "_resizerKeyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], resize, {
      args: [-small, 0]
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], resize, {
      args: [-big, 0]
    }], [["ArrowRight", "mac+ArrowRight"], resize, {
      args: [small, 0]
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], resize, {
      args: [big, 0]
    }], [["ArrowUp", "mac+ArrowUp"], resize, {
      args: [0, -small]
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], resize, {
      args: [0, -big]
    }], [["ArrowDown", "mac+ArrowDown"], resize, {
      args: [0, small]
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], resize, {
      args: [0, big]
    }], [["Escape", "mac+Escape"], AnnotationEditor.prototype._stopResizingWithKeyboard]]));
  }
  constructor(parameters) {
    if (this.constructor === AnnotationEditor) {
      unreachable("Cannot initialize AnnotationEditor.");
    }
    this.parent = parameters.parent;
    this.id = parameters.id;
    this.width = this.height = null;
    this.pageIndex = parameters.parent.pageIndex;
    this.name = parameters.name;
    this.div = null;
    this._uiManager = parameters.uiManager;
    this.annotationElementId = null;
    this._willKeepAspectRatio = false;
    this._initialOptions.isCentered = parameters.isCentered;
    this._structTreeParentId = null;
    const {
      rotation,
      rawDims: {
        pageWidth,
        pageHeight,
        pageX,
        pageY
      }
    } = this.parent.viewport;
    this.rotation = rotation;
    this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
    this.pageDimensions = [pageWidth, pageHeight];
    this.pageTranslation = [pageX, pageY];
    const [width, height] = this.parentDimensions;
    this.x = parameters.x / width;
    this.y = parameters.y / height;
    this.isAttachedToDOM = false;
    this.deleted = false;
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  static get _defaultLineColor() {
    return shadow(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(editor) {
    const fakeEditor = new FakeEditor({
      id: editor.parent.getNextId(),
      parent: editor.parent,
      uiManager: editor._uiManager
    });
    fakeEditor.annotationElementId = editor.annotationElementId;
    fakeEditor.deleted = true;
    fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
  }
  static initialize(l10n, _uiManager, options) {
    AnnotationEditor._l10nPromise ||= new Map(["pdfjs-editor-alt-text-button-label", "pdfjs-editor-alt-text-edit-button-label", "pdfjs-editor-alt-text-decorative-tooltip", "pdfjs-editor-resizer-label-topLeft", "pdfjs-editor-resizer-label-topMiddle", "pdfjs-editor-resizer-label-topRight", "pdfjs-editor-resizer-label-middleRight", "pdfjs-editor-resizer-label-bottomRight", "pdfjs-editor-resizer-label-bottomMiddle", "pdfjs-editor-resizer-label-bottomLeft", "pdfjs-editor-resizer-label-middleLeft"].map(str => [str, l10n.get(str.replaceAll(/([A-Z])/g, c => `-${c.toLowerCase()}`))]));
    if (options?.strings) {
      for (const str of options.strings) {
        AnnotationEditor._l10nPromise.set(str, l10n.get(str));
      }
    }
    if (AnnotationEditor._borderLineWidth !== -1) {
      return;
    }
    const style = getComputedStyle(document.documentElement);
    AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(_type, _value) {}
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(mime) {
    return false;
  }
  static paste(item, parent) {
    unreachable("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return this.#isDraggable;
  }
  set _isDraggable(value) {
    this.#isDraggable = value;
    this.div?.classList.toggle("draggable", value);
  }
  get isEnterHandled() {
    return true;
  }
  center() {
    const [pageWidth, pageHeight] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * pageHeight / (pageWidth * 2);
        this.y += this.width * pageWidth / (pageHeight * 2);
        break;
      case 180:
        this.x += this.width / 2;
        this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * pageHeight / (pageWidth * 2);
        this.y -= this.width * pageWidth / (pageHeight * 2);
        break;
      default:
        this.x -= this.width / 2;
        this.y -= this.height / 2;
        break;
    }
    this.fixAndSetPosition();
  }
  addCommands(params) {
    this._uiManager.addCommands(params);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = this.#zIndex;
  }
  setParent(parent) {
    if (parent !== null) {
      this.pageIndex = parent.pageIndex;
      this.pageDimensions = parent.pageDimensions;
    } else {
      this.#stopResizing();
    }
    this.parent = parent;
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    if (!this.#hasBeenClicked) {
      this.parent.setSelected(this);
    } else {
      this.#hasBeenClicked = false;
    }
  }
  focusout(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    if (!this.isAttachedToDOM) {
      return;
    }
    const target = event.relatedTarget;
    if (target?.closest(`#${this.id}`)) {
      return;
    }
    event.preventDefault();
    if (!this.parent?.isMultipleSelection) {
      this.commitOrRemove();
    }
  }
  commitOrRemove() {
    if (this.isEmpty()) {
      this.remove();
    } else {
      this.commit();
    }
  }
  commit() {
    this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(x, y, tx, ty) {
    const [width, height] = this.parentDimensions;
    [tx, ty] = this.screenToPageTranslation(tx, ty);
    this.x = (x + tx) / width;
    this.y = (y + ty) / height;
    this.fixAndSetPosition();
  }
  #translate([width, height], x, y) {
    [x, y] = this.screenToPageTranslation(x, y);
    this.x += x / width;
    this.y += y / height;
    this.fixAndSetPosition();
  }
  translate(x, y) {
    this.#translate(this.parentDimensions, x, y);
  }
  translateInPage(x, y) {
    this.#initialPosition ||= [this.x, this.y];
    this.#translate(this.pageDimensions, x, y);
    this.div.scrollIntoView({
      block: "nearest"
    });
  }
  drag(tx, ty) {
    this.#initialPosition ||= [this.x, this.y];
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.x += tx / parentWidth;
    this.y += ty / parentHeight;
    if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const {
        x,
        y
      } = this.div.getBoundingClientRect();
      if (this.parent.findNewParent(this, x, y)) {
        this.x -= Math.floor(this.x);
        this.y -= Math.floor(this.y);
      }
    }
    let {
      x,
      y
    } = this;
    const [bx, by] = this.getBaseTranslation();
    x += bx;
    y += by;
    this.div.style.left = `${(100 * x).toFixed(2)}%`;
    this.div.style.top = `${(100 * y).toFixed(2)}%`;
    this.div.scrollIntoView({
      block: "nearest"
    });
  }
  get _hasBeenMoved() {
    return !!this.#initialPosition && (this.#initialPosition[0] !== this.x || this.#initialPosition[1] !== this.y);
  }
  getBaseTranslation() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const {
      _borderLineWidth
    } = AnnotationEditor;
    const x = _borderLineWidth / parentWidth;
    const y = _borderLineWidth / parentHeight;
    switch (this.rotation) {
      case 90:
        return [-x, y];
      case 180:
        return [x, y];
      case 270:
        return [x, -y];
      default:
        return [-x, -y];
    }
  }
  get _mustFixPosition() {
    return true;
  }
  fixAndSetPosition(rotation = this.rotation) {
    const [pageWidth, pageHeight] = this.pageDimensions;
    let {
      x,
      y,
      width,
      height
    } = this;
    width *= pageWidth;
    height *= pageHeight;
    x *= pageWidth;
    y *= pageHeight;
    if (this._mustFixPosition) {
      switch (rotation) {
        case 0:
          x = Math.max(0, Math.min(pageWidth - width, x));
          y = Math.max(0, Math.min(pageHeight - height, y));
          break;
        case 90:
          x = Math.max(0, Math.min(pageWidth - height, x));
          y = Math.min(pageHeight, Math.max(width, y));
          break;
        case 180:
          x = Math.min(pageWidth, Math.max(width, x));
          y = Math.min(pageHeight, Math.max(height, y));
          break;
        case 270:
          x = Math.min(pageWidth, Math.max(height, x));
          y = Math.max(0, Math.min(pageHeight - width, y));
          break;
      }
    }
    this.x = x /= pageWidth;
    this.y = y /= pageHeight;
    const [bx, by] = this.getBaseTranslation();
    x += bx;
    y += by;
    const {
      style
    } = this.div;
    style.left = `${(100 * x).toFixed(2)}%`;
    style.top = `${(100 * y).toFixed(2)}%`;
    this.moveInDOM();
  }
  static #rotatePoint(x, y, angle) {
    switch (angle) {
      case 90:
        return [y, -x];
      case 180:
        return [-x, -y];
      case 270:
        return [-y, x];
      default:
        return [x, y];
    }
  }
  screenToPageTranslation(x, y) {
    return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);
  }
  pageTranslationToScreen(x, y) {
    return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);
  }
  #getRotationMatrix(rotation) {
    switch (rotation) {
      case 90:
        {
          const [pageWidth, pageHeight] = this.pageDimensions;
          return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
        }
      case 180:
        return [-1, 0, 0, -1];
      case 270:
        {
          const [pageWidth, pageHeight] = this.pageDimensions;
          return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];
        }
      default:
        return [1, 0, 0, 1];
    }
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const {
      parentScale,
      pageDimensions: [pageWidth, pageHeight]
    } = this;
    const scaledWidth = pageWidth * parentScale;
    const scaledHeight = pageHeight * parentScale;
    return util_FeatureTest.isCSSRoundSupported ? [Math.round(scaledWidth), Math.round(scaledHeight)] : [scaledWidth, scaledHeight];
  }
  setDims(width, height) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.div.style.width = `${(100 * width / parentWidth).toFixed(2)}%`;
    if (!this.#keepAspectRatio) {
      this.div.style.height = `${(100 * height / parentHeight).toFixed(2)}%`;
    }
  }
  fixDims() {
    const {
      style
    } = this.div;
    const {
      height,
      width
    } = style;
    const widthPercent = width.endsWith("%");
    const heightPercent = !this.#keepAspectRatio && height.endsWith("%");
    if (widthPercent && heightPercent) {
      return;
    }
    const [parentWidth, parentHeight] = this.parentDimensions;
    if (!widthPercent) {
      style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;
    }
    if (!this.#keepAspectRatio && !heightPercent) {
      style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;
    }
  }
  getInitialTranslation() {
    return [0, 0];
  }
  #createResizers() {
    if (this.#resizersDiv) {
      return;
    }
    this.#resizersDiv = document.createElement("div");
    this.#resizersDiv.classList.add("resizers");
    const classes = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"];
    const signal = this._uiManager._signal;
    for (const name of classes) {
      const div = document.createElement("div");
      this.#resizersDiv.append(div);
      div.classList.add("resizer", name);
      div.setAttribute("data-resizer-name", name);
      div.addEventListener("pointerdown", this.#resizerPointerdown.bind(this, name), {
        signal
      });
      div.addEventListener("contextmenu", noContextMenu, {
        signal
      });
      div.tabIndex = -1;
    }
    this.div.prepend(this.#resizersDiv);
  }
  #resizerPointerdown(name, event) {
    event.preventDefault();
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    this.#altText?.toggle(false);
    const boundResizerPointermove = this.#resizerPointermove.bind(this, name);
    const savedDraggable = this._isDraggable;
    this._isDraggable = false;
    const signal = this._uiManager._signal;
    const pointerMoveOptions = {
      passive: true,
      capture: true,
      signal
    };
    this.parent.togglePointerEvents(false);
    window.addEventListener("pointermove", boundResizerPointermove, pointerMoveOptions);
    window.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    const savedX = this.x;
    const savedY = this.y;
    const savedWidth = this.width;
    const savedHeight = this.height;
    const savedParentCursor = this.parent.div.style.cursor;
    const savedCursor = this.div.style.cursor;
    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;
    const pointerUpCallback = () => {
      this.parent.togglePointerEvents(true);
      this.#altText?.toggle(true);
      this._isDraggable = savedDraggable;
      window.removeEventListener("pointerup", pointerUpCallback);
      window.removeEventListener("blur", pointerUpCallback);
      window.removeEventListener("pointermove", boundResizerPointermove, pointerMoveOptions);
      window.removeEventListener("contextmenu", noContextMenu);
      this.parent.div.style.cursor = savedParentCursor;
      this.div.style.cursor = savedCursor;
      this.#addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight);
    };
    window.addEventListener("pointerup", pointerUpCallback, {
      signal
    });
    window.addEventListener("blur", pointerUpCallback, {
      signal
    });
  }
  #addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight) {
    const newX = this.x;
    const newY = this.y;
    const newWidth = this.width;
    const newHeight = this.height;
    if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {
      return;
    }
    this.addCommands({
      cmd: () => {
        this.width = newWidth;
        this.height = newHeight;
        this.x = newX;
        this.y = newY;
        const [parentWidth, parentHeight] = this.parentDimensions;
        this.setDims(parentWidth * newWidth, parentHeight * newHeight);
        this.fixAndSetPosition();
      },
      undo: () => {
        this.width = savedWidth;
        this.height = savedHeight;
        this.x = savedX;
        this.y = savedY;
        const [parentWidth, parentHeight] = this.parentDimensions;
        this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);
        this.fixAndSetPosition();
      },
      mustExec: true
    });
  }
  #resizerPointermove(name, event) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const savedX = this.x;
    const savedY = this.y;
    const savedWidth = this.width;
    const savedHeight = this.height;
    const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;
    const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;
    const round = x => Math.round(x * 10000) / 10000;
    const rotationMatrix = this.#getRotationMatrix(this.rotation);
    const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];
    const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);
    const invTransf = (x, y) => [invRotationMatrix[0] * x + invRotationMatrix[2] * y, invRotationMatrix[1] * x + invRotationMatrix[3] * y];
    let getPoint;
    let getOpposite;
    let isDiagonal = false;
    let isHorizontal = false;
    switch (name) {
      case "topLeft":
        isDiagonal = true;
        getPoint = (w, h) => [0, 0];
        getOpposite = (w, h) => [w, h];
        break;
      case "topMiddle":
        getPoint = (w, h) => [w / 2, 0];
        getOpposite = (w, h) => [w / 2, h];
        break;
      case "topRight":
        isDiagonal = true;
        getPoint = (w, h) => [w, 0];
        getOpposite = (w, h) => [0, h];
        break;
      case "middleRight":
        isHorizontal = true;
        getPoint = (w, h) => [w, h / 2];
        getOpposite = (w, h) => [0, h / 2];
        break;
      case "bottomRight":
        isDiagonal = true;
        getPoint = (w, h) => [w, h];
        getOpposite = (w, h) => [0, 0];
        break;
      case "bottomMiddle":
        getPoint = (w, h) => [w / 2, h];
        getOpposite = (w, h) => [w / 2, 0];
        break;
      case "bottomLeft":
        isDiagonal = true;
        getPoint = (w, h) => [0, h];
        getOpposite = (w, h) => [w, 0];
        break;
      case "middleLeft":
        isHorizontal = true;
        getPoint = (w, h) => [0, h / 2];
        getOpposite = (w, h) => [w, h / 2];
        break;
    }
    const point = getPoint(savedWidth, savedHeight);
    const oppositePoint = getOpposite(savedWidth, savedHeight);
    let transfOppositePoint = transf(...oppositePoint);
    const oppositeX = round(savedX + transfOppositePoint[0]);
    const oppositeY = round(savedY + transfOppositePoint[1]);
    let ratioX = 1;
    let ratioY = 1;
    let [deltaX, deltaY] = this.screenToPageTranslation(event.movementX, event.movementY);
    [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
    if (isDiagonal) {
      const oldDiag = Math.hypot(savedWidth, savedHeight);
      ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
    } else if (isHorizontal) {
      ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;
    } else {
      ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;
    }
    const newWidth = round(savedWidth * ratioX);
    const newHeight = round(savedHeight * ratioY);
    transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
    const newX = oppositeX - transfOppositePoint[0];
    const newY = oppositeY - transfOppositePoint[1];
    this.width = newWidth;
    this.height = newHeight;
    this.x = newX;
    this.y = newY;
    this.setDims(parentWidth * newWidth, parentHeight * newHeight);
    this.fixAndSetPosition();
  }
  altTextFinish() {
    this.#altText?.finish();
  }
  async addEditToolbar() {
    if (this.#editToolbar || this.#isInEditMode) {
      return this.#editToolbar;
    }
    this.#editToolbar = new EditorToolbar(this);
    this.div.append(this.#editToolbar.render());
    if (this.#altText) {
      this.#editToolbar.addAltTextButton(await this.#altText.render());
    }
    return this.#editToolbar;
  }
  removeEditToolbar() {
    if (!this.#editToolbar) {
      return;
    }
    this.#editToolbar.remove();
    this.#editToolbar = null;
    this.#altText?.destroy();
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  async addAltTextButton() {
    if (this.#altText) {
      return;
    }
    AltText.initialize(AnnotationEditor._l10nPromise);
    this.#altText = new AltText(this);
    if (this.#accessibilityData) {
      this.#altText.data = this.#accessibilityData;
      this.#accessibilityData = null;
    }
    await this.addEditToolbar();
  }
  get altTextData() {
    return this.#altText?.data;
  }
  set altTextData(data) {
    if (!this.#altText) {
      return;
    }
    this.#altText.data = data;
  }
  hasAltText() {
    return !this.#altText?.isEmpty();
  }
  render() {
    this.div = document.createElement("div");
    this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
    this.div.className = this.name;
    this.div.setAttribute("id", this.id);
    this.div.tabIndex = this.#disabled ? -1 : 0;
    if (!this._isVisible) {
      this.div.classList.add("hidden");
    }
    this.setInForeground();
    const signal = this._uiManager._signal;
    this.div.addEventListener("focusin", this.#boundFocusin, {
      signal
    });
    this.div.addEventListener("focusout", this.#boundFocusout, {
      signal
    });
    const [parentWidth, parentHeight] = this.parentDimensions;
    if (this.parentRotation % 180 !== 0) {
      this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;
      this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;
    }
    const [tx, ty] = this.getInitialTranslation();
    this.translate(tx, ty);
    bindEvents(this, this.div, ["pointerdown"]);
    return this.div;
  }
  pointerdown(event) {
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      event.preventDefault();
      return;
    }
    this.#hasBeenClicked = true;
    if (this._isDraggable) {
      this.#setUpDragSession(event);
      return;
    }
    this.#selectOnPointerEvent(event);
  }
  #selectOnPointerEvent(event) {
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
      this.parent.toggleSelected(this);
    } else {
      this.parent.setSelected(this);
    }
  }
  #setUpDragSession(event) {
    const isSelected = this._uiManager.isSelected(this);
    this._uiManager.setUpDragSession();
    let pointerMoveOptions, pointerMoveCallback;
    const signal = this._uiManager._signal;
    if (isSelected) {
      this.div.classList.add("moving");
      pointerMoveOptions = {
        passive: true,
        capture: true,
        signal
      };
      this.#prevDragX = event.clientX;
      this.#prevDragY = event.clientY;
      pointerMoveCallback = e => {
        const {
          clientX: x,
          clientY: y
        } = e;
        const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);
        this.#prevDragX = x;
        this.#prevDragY = y;
        this._uiManager.dragSelectedEditors(tx, ty);
      };
      window.addEventListener("pointermove", pointerMoveCallback, pointerMoveOptions);
    }
    const pointerUpCallback = () => {
      window.removeEventListener("pointerup", pointerUpCallback);
      window.removeEventListener("blur", pointerUpCallback);
      if (isSelected) {
        this.div.classList.remove("moving");
        window.removeEventListener("pointermove", pointerMoveCallback, pointerMoveOptions);
      }
      this.#hasBeenClicked = false;
      if (!this._uiManager.endDragSession()) {
        this.#selectOnPointerEvent(event);
      }
    };
    window.addEventListener("pointerup", pointerUpCallback, {
      signal
    });
    window.addEventListener("blur", pointerUpCallback, {
      signal
    });
  }
  moveInDOM() {
    if (this.#moveInDOMTimeout) {
      clearTimeout(this.#moveInDOMTimeout);
    }
    this.#moveInDOMTimeout = setTimeout(() => {
      this.#moveInDOMTimeout = null;
      this.parent?.moveEditorInDOM(this);
    }, 0);
  }
  _setParentAndPosition(parent, x, y) {
    parent.changeParent(this);
    this.x = x;
    this.y = y;
    this.fixAndSetPosition();
  }
  getRect(tx, ty, rotation = this.rotation) {
    const scale = this.parentScale;
    const [pageWidth, pageHeight] = this.pageDimensions;
    const [pageX, pageY] = this.pageTranslation;
    const shiftX = tx / scale;
    const shiftY = ty / scale;
    const x = this.x * pageWidth;
    const y = this.y * pageHeight;
    const width = this.width * pageWidth;
    const height = this.height * pageHeight;
    switch (rotation) {
      case 0:
        return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];
      case 90:
        return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];
      case 180:
        return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];
      case 270:
        return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(rect, pageHeight) {
    const [x1, y1, x2, y2] = rect;
    const width = x2 - x1;
    const height = y2 - y1;
    switch (this.rotation) {
      case 0:
        return [x1, pageHeight - y2, width, height];
      case 90:
        return [x1, pageHeight - y1, height, width];
      case 180:
        return [x2, pageHeight - y1, width, height];
      case 270:
        return [x2, pageHeight - y2, height, width];
      default:
        throw new Error("Invalid rotation");
    }
  }
  onceAdded() {}
  isEmpty() {
    return false;
  }
  enableEditMode() {
    this.#isInEditMode = true;
  }
  disableEditMode() {
    this.#isInEditMode = false;
  }
  isInEditMode() {
    return this.#isInEditMode;
  }
  shouldGetKeyboardEvents() {
    return this.#isResizerEnabledForKeyboard;
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  rebuild() {
    const signal = this._uiManager._signal;
    this.div?.addEventListener("focusin", this.#boundFocusin, {
      signal
    });
    this.div?.addEventListener("focusout", this.#boundFocusout, {
      signal
    });
  }
  rotate(_angle) {}
  serialize(isForCopying = false, context = null) {
    unreachable("An editor must be serializable");
  }
  static deserialize(data, parent, uiManager) {
    const editor = new this.prototype.constructor({
      parent,
      id: parent.getNextId(),
      uiManager
    });
    editor.rotation = data.rotation;
    editor.#accessibilityData = data.accessibilityData;
    const [pageWidth, pageHeight] = editor.pageDimensions;
    const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
    editor.x = x / pageWidth;
    editor.y = y / pageHeight;
    editor.width = width / pageWidth;
    editor.height = height / pageHeight;
    return editor;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
  }
  remove() {
    this.div.removeEventListener("focusin", this.#boundFocusin);
    this.div.removeEventListener("focusout", this.#boundFocusout);
    if (!this.isEmpty()) {
      this.commit();
    }
    if (this.parent) {
      this.parent.remove(this);
    } else {
      this._uiManager.removeEditor(this);
    }
    if (this.#moveInDOMTimeout) {
      clearTimeout(this.#moveInDOMTimeout);
      this.#moveInDOMTimeout = null;
    }
    this.#stopResizing();
    this.removeEditToolbar();
    if (this.#telemetryTimeouts) {
      for (const timeout of this.#telemetryTimeouts.values()) {
        clearTimeout(timeout);
      }
      this.#telemetryTimeouts = null;
    }
    this.parent = null;
  }
  get isResizable() {
    return false;
  }
  makeResizable() {
    if (this.isResizable) {
      this.#createResizers();
      this.#resizersDiv.classList.remove("hidden");
      bindEvents(this, this.div, ["keydown"]);
    }
  }
  get toolbarPosition() {
    return null;
  }
  keydown(event) {
    if (!this.isResizable || event.target !== this.div || event.key !== "Enter") {
      return;
    }
    this._uiManager.setSelected(this);
    this.#savedDimensions = {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    };
    const children = this.#resizersDiv.children;
    if (!this.#allResizerDivs) {
      this.#allResizerDivs = Array.from(children);
      const boundResizerKeydown = this.#resizerKeydown.bind(this);
      const boundResizerBlur = this.#resizerBlur.bind(this);
      const signal = this._uiManager._signal;
      for (const div of this.#allResizerDivs) {
        const name = div.getAttribute("data-resizer-name");
        div.setAttribute("role", "spinbutton");
        div.addEventListener("keydown", boundResizerKeydown, {
          signal
        });
        div.addEventListener("blur", boundResizerBlur, {
          signal
        });
        div.addEventListener("focus", this.#resizerFocus.bind(this, name), {
          signal
        });
        AnnotationEditor._l10nPromise.get(`pdfjs-editor-resizer-label-${name}`).then(msg => div.setAttribute("aria-label", msg));
      }
    }
    const first = this.#allResizerDivs[0];
    let firstPosition = 0;
    for (const div of children) {
      if (div === first) {
        break;
      }
      firstPosition++;
    }
    const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);
    if (nextFirstPosition !== firstPosition) {
      if (nextFirstPosition < firstPosition) {
        for (let i = 0; i < firstPosition - nextFirstPosition; i++) {
          this.#resizersDiv.append(this.#resizersDiv.firstChild);
        }
      } else if (nextFirstPosition > firstPosition) {
        for (let i = 0; i < nextFirstPosition - firstPosition; i++) {
          this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);
        }
      }
      let i = 0;
      for (const child of children) {
        const div = this.#allResizerDivs[i++];
        const name = div.getAttribute("data-resizer-name");
        AnnotationEditor._l10nPromise.get(`pdfjs-editor-resizer-label-${name}`).then(msg => child.setAttribute("aria-label", msg));
      }
    }
    this.#setResizerTabIndex(0);
    this.#isResizerEnabledForKeyboard = true;
    this.#resizersDiv.firstChild.focus({
      focusVisible: true
    });
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  #resizerKeydown(event) {
    AnnotationEditor._resizerKeyboardManager.exec(this, event);
  }
  #resizerBlur(event) {
    if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {
      this.#stopResizing();
    }
  }
  #resizerFocus(name) {
    this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : "";
  }
  #setResizerTabIndex(value) {
    if (!this.#allResizerDivs) {
      return;
    }
    for (const div of this.#allResizerDivs) {
      div.tabIndex = value;
    }
  }
  _resizeWithKeyboard(x, y) {
    if (!this.#isResizerEnabledForKeyboard) {
      return;
    }
    this.#resizerPointermove(this.#focusedResizerName, {
      movementX: x,
      movementY: y
    });
  }
  #stopResizing() {
    this.#isResizerEnabledForKeyboard = false;
    this.#setResizerTabIndex(-1);
    if (this.#savedDimensions) {
      const {
        savedX,
        savedY,
        savedWidth,
        savedHeight
      } = this.#savedDimensions;
      this.#addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight);
      this.#savedDimensions = null;
    }
  }
  _stopResizingWithKeyboard() {
    this.#stopResizing();
    this.div.focus();
  }
  select() {
    this.makeResizable();
    this.div?.classList.add("selectedEditor");
    if (!this.#editToolbar) {
      this.addEditToolbar().then(() => {
        if (this.div?.classList.contains("selectedEditor")) {
          this.#editToolbar?.show();
        }
      });
      return;
    }
    this.#editToolbar?.show();
  }
  unselect() {
    this.#resizersDiv?.classList.add("hidden");
    this.div?.classList.remove("selectedEditor");
    if (this.div?.contains(document.activeElement)) {
      this._uiManager.currentLayer.div.focus({
        preventScroll: true
      });
    }
    this.#editToolbar?.hide();
  }
  updateParams(type, value) {}
  disableEditing() {}
  enableEditing() {}
  enterInEditMode() {}
  getImageForAltText() {
    return null;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return this.#isEditing;
  }
  set isEditing(value) {
    this.#isEditing = value;
    if (!this.parent) {
      return;
    }
    if (value) {
      this.parent.setSelected(this);
      this.parent.setActiveEditor(this);
    } else {
      this.parent.setActiveEditor(null);
    }
  }
  setAspectRatio(width, height) {
    this.#keepAspectRatio = true;
    const aspectRatio = width / height;
    const {
      style
    } = this.div;
    style.aspectRatio = aspectRatio;
    style.height = "auto";
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return true;
  }
  get telemetryInitialData() {
    return {
      action: "added"
    };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(data, mustWait = false) {
    if (mustWait) {
      this.#telemetryTimeouts ||= new Map();
      const {
        action
      } = data;
      let timeout = this.#telemetryTimeouts.get(action);
      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        this._reportTelemetry(data);
        this.#telemetryTimeouts.delete(action);
        if (this.#telemetryTimeouts.size === 0) {
          this.#telemetryTimeouts = null;
        }
      }, AnnotationEditor._telemetryTimeout);
      this.#telemetryTimeouts.set(action, timeout);
      return;
    }
    data.type ||= this.editorType;
    this._uiManager._eventBus.dispatch("reporttelemetry", {
      source: this,
      details: {
        type: "editing",
        data
      }
    });
  }
  show(visible = this._isVisible) {
    this.div.classList.toggle("hidden", !visible);
    this._isVisible = visible;
  }
  enable() {
    if (this.div) {
      this.div.tabIndex = 0;
    }
    this.#disabled = false;
  }
  disable() {
    if (this.div) {
      this.div.tabIndex = -1;
    }
    this.#disabled = true;
  }
  renderAnnotationElement(annotation) {
    let content = annotation.container.querySelector(".annotationContent");
    if (!content) {
      content = document.createElement("div");
      content.classList.add("annotationContent", this.editorType);
      annotation.container.prepend(content);
    } else if (content.nodeName === "CANVAS") {
      const canvas = content;
      content = document.createElement("div");
      content.classList.add("annotationContent", this.editorType);
      canvas.before(content);
    }
    return content;
  }
  resetAnnotationElement(annotation) {
    const {
      firstChild
    } = annotation.container;
    if (firstChild.nodeName === "DIV" && firstChild.classList.contains("annotationContent")) {
      firstChild.remove();
    }
  }
}
class FakeEditor extends AnnotationEditor {
  constructor(params) {
    super(params);
    this.annotationElementId = params.annotationElementId;
    this.deleted = true;
  }
  serialize() {
    return {
      id: this.annotationElementId,
      deleted: true,
      pageIndex: this.pageIndex
    };
  }
}
const SEED = 0xc3d2e1f0;
const MASK_HIGH = 0xffff0000;
const MASK_LOW = 0xffff;
class MurmurHash3_64 {
  constructor(seed) {
    this.h1 = seed ? seed & 0xffffffff : SEED;
    this.h2 = seed ? seed & 0xffffffff : SEED;
  }
  update(input) {
    let data, length;
    if (typeof input === "string") {
      data = new Uint8Array(input.length * 2);
      length = 0;
      for (let i = 0, ii = input.length; i < ii; i++) {
        const code = input.charCodeAt(i);
        if (code <= 0xff) {
          data[length++] = code;
        } else {
          data[length++] = code >>> 8;
          data[length++] = code & 0xff;
        }
      }
    } else if (ArrayBuffer.isView(input)) {
      data = input.slice();
      length = data.byteLength;
    } else {
      throw new Error("Invalid data format, must be a string or TypedArray.");
    }
    const blockCounts = length >> 2;
    const tailLength = length - blockCounts * 4;
    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
    let k1 = 0,
      k2 = 0;
    let h1 = this.h1,
      h2 = this.h2;
    const C1 = 0xcc9e2d51,
      C2 = 0x1b873593;
    const C1_LOW = C1 & MASK_LOW,
      C2_LOW = C2 & MASK_LOW;
    for (let i = 0; i < blockCounts; i++) {
      if (i & 1) {
        k1 = dataUint32[i];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = h1 * 5 + 0xe6546b64;
      } else {
        k2 = dataUint32[i];
        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
        k2 = k2 << 15 | k2 >>> 17;
        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
        h2 ^= k2;
        h2 = h2 << 13 | h2 >>> 19;
        h2 = h2 * 5 + 0xe6546b64;
      }
    }
    k1 = 0;
    switch (tailLength) {
      case 3:
        k1 ^= data[blockCounts * 4 + 2] << 16;
      case 2:
        k1 ^= data[blockCounts * 4 + 1] << 8;
      case 1:
        k1 ^= data[blockCounts * 4];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        if (blockCounts & 1) {
          h1 ^= k1;
        } else {
          h2 ^= k1;
        }
    }
    this.h1 = h1;
    this.h2 = h2;
  }
  hexdigest() {
    let h1 = this.h1,
      h2 = this.h2;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
  }
}



const SerializableEmpty = Object.freeze({
  map: null,
  hash: "",
  transfer: undefined
});
class AnnotationStorage {
  #modified = false;
  #storage = new Map();
  constructor() {
    this.onSetModified = null;
    this.onResetModified = null;
    this.onAnnotationEditor = null;
  }
  getValue(key, defaultValue) {
    const value = this.#storage.get(key);
    if (value === undefined) {
      return defaultValue;
    }
    return Object.assign(defaultValue, value);
  }
  getRawValue(key) {
    return this.#storage.get(key);
  }
  remove(key) {
    this.#storage.delete(key);
    if (this.#storage.size === 0) {
      this.resetModified();
    }
    if (typeof this.onAnnotationEditor === "function") {
      for (const value of this.#storage.values()) {
        if (value instanceof AnnotationEditor) {
          return;
        }
      }
      this.onAnnotationEditor(null);
    }
  }
  setValue(key, value) {
    const obj = this.#storage.get(key);
    let modified = false;
    if (obj !== undefined) {
      for (const [entry, val] of Object.entries(value)) {
        if (obj[entry] !== val) {
          modified = true;
          obj[entry] = val;
        }
      }
    } else {
      modified = true;
      this.#storage.set(key, value);
    }
    if (modified) {
      this.#setModified();
    }
    if (value instanceof AnnotationEditor && typeof this.onAnnotationEditor === "function") {
      this.onAnnotationEditor(value.constructor._type);
    }
  }
  has(key) {
    return this.#storage.has(key);
  }
  getAll() {
    return this.#storage.size > 0 ? objectFromMap(this.#storage) : null;
  }
  setAll(obj) {
    for (const [key, val] of Object.entries(obj)) {
      this.setValue(key, val);
    }
  }
  get size() {
    return this.#storage.size;
  }
  #setModified() {
    if (!this.#modified) {
      this.#modified = true;
      if (typeof this.onSetModified === "function") {
        this.onSetModified();
      }
    }
  }
  resetModified() {
    if (this.#modified) {
      this.#modified = false;
      if (typeof this.onResetModified === "function") {
        this.onResetModified();
      }
    }
  }
  get print() {
    return new PrintAnnotationStorage(this);
  }
  get serializable() {
    if (this.#storage.size === 0) {
      return SerializableEmpty;
    }
    const map = new Map(),
      hash = new MurmurHash3_64(),
      transfer = [];
    const context = Object.create(null);
    let hasBitmap = false;
    for (const [key, val] of this.#storage) {
      const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;
      if (serialized) {
        map.set(key, serialized);
        hash.update(`${key}:${JSON.stringify(serialized)}`);
        hasBitmap ||= !!serialized.bitmap;
      }
    }
    if (hasBitmap) {
      for (const value of map.values()) {
        if (value.bitmap) {
          transfer.push(value.bitmap);
        }
      }
    }
    return map.size > 0 ? {
      map,
      hash: hash.hexdigest(),
      transfer
    } : SerializableEmpty;
  }
  get editorStats() {
    let stats = null;
    const typeToEditor = new Map();
    for (const value of this.#storage.values()) {
      if (!(value instanceof AnnotationEditor)) {
        continue;
      }
      const editorStats = value.telemetryFinalData;
      if (!editorStats) {
        continue;
      }
      const {
        type
      } = editorStats;
      if (!typeToEditor.has(type)) {
        typeToEditor.set(type, Object.getPrototypeOf(value).constructor);
      }
      stats ||= Object.create(null);
      const map = stats[type] ||= new Map();
      for (const [key, val] of Object.entries(editorStats)) {
        if (key === "type") {
          continue;
        }
        let counters = map.get(key);
        if (!counters) {
          counters = new Map();
          map.set(key, counters);
        }
        const count = counters.get(val) ?? 0;
        counters.set(val, count + 1);
      }
    }
    for (const [type, editor] of typeToEditor) {
      stats[type] = editor.computeTelemetryFinalData(stats[type]);
    }
    return stats;
  }
}
class PrintAnnotationStorage extends AnnotationStorage {
  #serializable;
  constructor(parent) {
    super();
    const {
      map,
      hash,
      transfer
    } = parent.serializable;
    const clone = structuredClone(map, transfer ? {
      transfer
    } : null);
    this.#serializable = {
      map: clone,
      hash,
      transfer
    };
  }
  get print() {
    unreachable("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return this.#serializable;
  }
}

class FontLoader {
  #systemFonts = new Set();
  constructor({
    ownerDocument = globalThis.document,
    styleElement = null
  }) {
    this._document = ownerDocument;
    this.nativeFontFaces = new Set();
    this.styleElement = null;
    this.loadingRequests = [];
    this.loadTestFontId = 0;
  }
  addNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.add(nativeFontFace);
    this._document.fonts.add(nativeFontFace);
  }
  removeNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.delete(nativeFontFace);
    this._document.fonts.delete(nativeFontFace);
  }
  insertRule(rule) {
    if (!this.styleElement) {
      this.styleElement = this._document.createElement("style");
      this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
    }
    const styleSheet = this.styleElement.sheet;
    styleSheet.insertRule(rule, styleSheet.cssRules.length);
  }
  clear() {
    for (const nativeFontFace of this.nativeFontFaces) {
      this._document.fonts.delete(nativeFontFace);
    }
    this.nativeFontFaces.clear();
    this.#systemFonts.clear();
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }
  async loadSystemFont({
    systemFontInfo: info,
    _inspectFont
  }) {
    if (!info || this.#systemFonts.has(info.loadedName)) {
      return;
    }
    assert(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
    if (this.isFontLoadingAPISupported) {
      const {
        loadedName,
        src,
        style
      } = info;
      const fontFace = new FontFace(loadedName, src, style);
      this.addNativeFontFace(fontFace);
      try {
        await fontFace.load();
        this.#systemFonts.add(loadedName);
        _inspectFont?.(info);
      } catch {
        warn(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);
        this.removeNativeFontFace(fontFace);
      }
      return;
    }
    unreachable("Not implemented: loadSystemFont without the Font Loading API.");
  }
  async bind(font) {
    if (font.attached || font.missingFile && !font.systemFontInfo) {
      return;
    }
    font.attached = true;
    if (font.systemFontInfo) {
      await this.loadSystemFont(font);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const nativeFontFace = font.createNativeFontFace();
      if (nativeFontFace) {
        this.addNativeFontFace(nativeFontFace);
        try {
          await nativeFontFace.loaded;
        } catch (ex) {
          warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
          font.disableFontFace = true;
          throw ex;
        }
      }
      return;
    }
    const rule = font.createFontFaceRule();
    if (rule) {
      this.insertRule(rule);
      if (this.isSyncFontLoadingSupported) {
        return;
      }
      await new Promise(resolve => {
        const request = this._queueLoadingCallback(resolve);
        this._prepareFontLoadEvent(font, request);
      });
    }
  }
  get isFontLoadingAPISupported() {
    const hasFonts = !!this._document?.fonts;
    return shadow(this, "isFontLoadingAPISupported", hasFonts);
  }
  get isSyncFontLoadingSupported() {
    let supported = false;
    if (isNodeJS) {
      supported = true;
    } else if (typeof navigator !== "undefined" && typeof navigator?.userAgent === "string" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) {
      supported = true;
    }
    return shadow(this, "isSyncFontLoadingSupported", supported);
  }
  _queueLoadingCallback(callback) {
    function completeRequest() {
      assert(!request.done, "completeRequest() cannot be called twice.");
      request.done = true;
      while (loadingRequests.length > 0 && loadingRequests[0].done) {
        const otherRequest = loadingRequests.shift();
        setTimeout(otherRequest.callback, 0);
      }
    }
    const {
      loadingRequests
    } = this;
    const request = {
      done: false,
      complete: completeRequest,
      callback
    };
    loadingRequests.push(request);
    return request;
  }
  get _loadTestFont() {
    const testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
    return shadow(this, "_loadTestFont", testFont);
  }
  _prepareFontLoadEvent(font, request) {
    function int32(data, offset) {
      return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
    }
    function spliceString(s, offset, remove, insert) {
      const chunk1 = s.substring(0, offset);
      const chunk2 = s.substring(offset + remove);
      return chunk1 + insert + chunk2;
    }
    let i, ii;
    const canvas = this._document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext("2d");
    let called = 0;
    function isFontReady(name, callback) {
      if (++called > 30) {
        warn("Load test font never loaded.");
        callback();
        return;
      }
      ctx.font = "30px " + name;
      ctx.fillText(".", 0, 20);
      const imageData = ctx.getImageData(0, 0, 1, 1);
      if (imageData.data[3] > 0) {
        callback();
        return;
      }
      setTimeout(isFontReady.bind(null, name, callback));
    }
    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
    let data = this._loadTestFont;
    const COMMENT_OFFSET = 976;
    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
    const CFF_CHECKSUM_OFFSET = 16;
    const XXXX_VALUE = 0x58585858;
    let checksum = int32(data, CFF_CHECKSUM_OFFSET);
    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
    }
    if (i < loadTestFontId.length) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
    }
    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));
    const url = `url(data:font/opentype;base64,${btoa(data)});`;
    const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
    this.insertRule(rule);
    const div = this._document.createElement("div");
    div.style.visibility = "hidden";
    div.style.width = div.style.height = "10px";
    div.style.position = "absolute";
    div.style.top = div.style.left = "0px";
    for (const name of [font.loadedName, loadTestFontId]) {
      const span = this._document.createElement("span");
      span.textContent = "Hi";
      span.style.fontFamily = name;
      div.append(span);
    }
    this._document.body.append(div);
    isFontReady(loadTestFontId, () => {
      div.remove();
      request.complete();
    });
  }
}
class FontFaceObject {
  constructor(translatedData, {
    disableFontFace = false,
    inspectFont = null
  }) {
    this.compiledGlyphs = Object.create(null);
    for (const i in translatedData) {
      this[i] = translatedData[i];
    }
    this.disableFontFace = disableFontFace === true;
    this._inspectFont = inspectFont;
  }
  createNativeFontFace() {
    if (!this.data || this.disableFontFace) {
      return null;
    }
    let nativeFontFace;
    if (!this.cssFontInfo) {
      nativeFontFace = new FontFace(this.loadedName, this.data, {});
    } else {
      const css = {
        weight: this.cssFontInfo.fontWeight
      };
      if (this.cssFontInfo.italicAngle) {
        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
      }
      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
    }
    this._inspectFont?.(this);
    return nativeFontFace;
  }
  createFontFaceRule() {
    if (!this.data || this.disableFontFace) {
      return null;
    }
    const data = bytesToString(this.data);
    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
    let rule;
    if (!this.cssFontInfo) {
      rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
    } else {
      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
      if (this.cssFontInfo.italicAngle) {
        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
      }
      rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
    }
    this._inspectFont?.(this, url);
    return rule;
  }
  getPathGenerator(objs, character) {
    if (this.compiledGlyphs[character] !== undefined) {
      return this.compiledGlyphs[character];
    }
    let cmds;
    try {
      cmds = objs.get(this.loadedName + "_path_" + character);
    } catch (ex) {
      warn(`getPathGenerator - ignoring character: "${ex}".`);
    }
    if (!Array.isArray(cmds) || cmds.length === 0) {
      return this.compiledGlyphs[character] = function (c, size) {};
    }
    const commands = [];
    for (let i = 0, ii = cmds.length; i < ii;) {
      switch (cmds[i++]) {
        case FontRenderOps.BEZIER_CURVE_TO:
          {
            const [a, b, c, d, e, f] = cmds.slice(i, i + 6);
            commands.push(ctx => ctx.bezierCurveTo(a, b, c, d, e, f));
            i += 6;
          }
          break;
        case FontRenderOps.MOVE_TO:
          {
            const [a, b] = cmds.slice(i, i + 2);
            commands.push(ctx => ctx.moveTo(a, b));
            i += 2;
          }
          break;
        case FontRenderOps.LINE_TO:
          {
            const [a, b] = cmds.slice(i, i + 2);
            commands.push(ctx => ctx.lineTo(a, b));
            i += 2;
          }
          break;
        case FontRenderOps.QUADRATIC_CURVE_TO:
          {
            const [a, b, c, d] = cmds.slice(i, i + 4);
            commands.push(ctx => ctx.quadraticCurveTo(a, b, c, d));
            i += 4;
          }
          break;
        case FontRenderOps.RESTORE:
          commands.push(ctx => ctx.restore());
          break;
        case FontRenderOps.SAVE:
          commands.push(ctx => ctx.save());
          break;
        case FontRenderOps.SCALE:
          assert(commands.length === 2, "Scale command is only valid at the third position.");
          break;
        case FontRenderOps.TRANSFORM:
          {
            const [a, b, c, d, e, f] = cmds.slice(i, i + 6);
            commands.push(ctx => ctx.transform(a, b, c, d, e, f));
            i += 6;
          }
          break;
        case FontRenderOps.TRANSLATE:
          {
            const [a, b] = cmds.slice(i, i + 2);
            commands.push(ctx => ctx.translate(a, b));
            i += 2;
          }
          break;
      }
    }
    return this.compiledGlyphs[character] = function glyphDrawer(ctx, size) {
      commands[0](ctx);
      commands[1](ctx);
      ctx.scale(size, -size);
      for (let i = 2, ii = commands.length; i < ii; i++) {
        commands[i](ctx);
      }
    };
  }
}


if (isNodeJS) {
  var packageCapability = Promise.withResolvers();
  var packageMap = null;
  const loadPackages = async () => {
    const fs = await import( /*webpackIgnore: true*/'./_node-resolve_empty-CDDt4GJF.js'),
      http = await import( /*webpackIgnore: true*/'./_node-resolve_empty-CDDt4GJF.js'),
      https = await import( /*webpackIgnore: true*/'./_node-resolve_empty-CDDt4GJF.js'),
      url = await import( /*webpackIgnore: true*/'./_node-resolve_empty-CDDt4GJF.js');
    let canvas, path2d;
    return new Map(Object.entries({
      fs,
      http,
      https,
      url,
      canvas,
      path2d
    }));
  };
  loadPackages().then(map => {
    packageMap = map;
    packageCapability.resolve();
  }, reason => {
    warn(`loadPackages: ${reason}`);
    packageMap = new Map();
    packageCapability.resolve();
  });
}
class NodePackages {
  static get promise() {
    return packageCapability.promise;
  }
  static get(name) {
    return packageMap?.get(name);
  }
}
const node_utils_fetchData = function (url) {
  const fs = NodePackages.get("fs");
  return fs.promises.readFile(url).then(data => new Uint8Array(data));
};
class NodeFilterFactory extends BaseFilterFactory {}
class NodeCanvasFactory extends BaseCanvasFactory {
  _createCanvas(width, height) {
    const canvas = NodePackages.get("canvas");
    return canvas.createCanvas(width, height);
  }
}
class NodeCMapReaderFactory extends BaseCMapReaderFactory {
  _fetchData(url, compressionType) {
    return node_utils_fetchData(url).then(data => ({
      cMapData: data,
      compressionType
    }));
  }
}
class NodeStandardFontDataFactory extends BaseStandardFontDataFactory {
  _fetchData(url) {
    return node_utils_fetchData(url);
  }
}


const PathType = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
function applyBoundingBox(ctx, bbox) {
  if (!bbox) {
    return;
  }
  const width = bbox[2] - bbox[0];
  const height = bbox[3] - bbox[1];
  const region = new Path2D();
  region.rect(bbox[0], bbox[1], width, height);
  ctx.clip(region);
}
class BaseShadingPattern {
  constructor() {
    if (this.constructor === BaseShadingPattern) {
      unreachable("Cannot initialize BaseShadingPattern.");
    }
  }
  getPattern() {
    unreachable("Abstract method `getPattern` called.");
  }
}
class RadialAxialShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._type = IR[1];
    this._bbox = IR[2];
    this._colorStops = IR[3];
    this._p0 = IR[4];
    this._p1 = IR[5];
    this._r0 = IR[6];
    this._r1 = IR[7];
    this.matrix = null;
  }
  _createGradient(ctx) {
    let grad;
    if (this._type === "axial") {
      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
    } else if (this._type === "radial") {
      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
    }
    for (const colorStop of this._colorStops) {
      grad.addColorStop(colorStop[0], colorStop[1]);
    }
    return grad;
  }
  getPattern(ctx, owner, inverse, pathType) {
    let pattern;
    if (pathType === PathType.STROKE || pathType === PathType.FILL) {
      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [0, 0, 0, 0];
      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
      const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
      const tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.beginPath();
      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
      inverse = Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
      tmpCtx.transform(...owner.baseTransform);
      if (this.matrix) {
        tmpCtx.transform(...this.matrix);
      }
      applyBoundingBox(tmpCtx, this._bbox);
      tmpCtx.fillStyle = this._createGradient(tmpCtx);
      tmpCtx.fill();
      pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
      const domMatrix = new DOMMatrix(inverse);
      pattern.setTransform(domMatrix);
    } else {
      applyBoundingBox(ctx, this._bbox);
      pattern = this._createGradient(ctx);
    }
    return pattern;
  }
}
function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
  const coords = context.coords,
    colors = context.colors;
  const bytes = data.data,
    rowSize = data.width * 4;
  let tmp;
  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }
  if (coords[p2 + 1] > coords[p3 + 1]) {
    tmp = p2;
    p2 = p3;
    p3 = tmp;
    tmp = c2;
    c2 = c3;
    c3 = tmp;
  }
  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }
  const x1 = (coords[p1] + context.offsetX) * context.scaleX;
  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
  const x2 = (coords[p2] + context.offsetX) * context.scaleX;
  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
  const x3 = (coords[p3] + context.offsetX) * context.scaleX;
  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
  if (y1 >= y3) {
    return;
  }
  const c1r = colors[c1],
    c1g = colors[c1 + 1],
    c1b = colors[c1 + 2];
  const c2r = colors[c2],
    c2g = colors[c2 + 1],
    c2b = colors[c2 + 2];
  const c3r = colors[c3],
    c3g = colors[c3 + 1],
    c3b = colors[c3 + 2];
  const minY = Math.round(y1),
    maxY = Math.round(y3);
  let xa, car, cag, cab;
  let xb, cbr, cbg, cbb;
  for (let y = minY; y <= maxY; y++) {
    if (y < y2) {
      const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);
      xa = x1 - (x1 - x2) * k;
      car = c1r - (c1r - c2r) * k;
      cag = c1g - (c1g - c2g) * k;
      cab = c1b - (c1b - c2b) * k;
    } else {
      let k;
      if (y > y3) {
        k = 1;
      } else if (y2 === y3) {
        k = 0;
      } else {
        k = (y2 - y) / (y2 - y3);
      }
      xa = x2 - (x2 - x3) * k;
      car = c2r - (c2r - c3r) * k;
      cag = c2g - (c2g - c3g) * k;
      cab = c2b - (c2b - c3b) * k;
    }
    let k;
    if (y < y1) {
      k = 0;
    } else if (y > y3) {
      k = 1;
    } else {
      k = (y1 - y) / (y1 - y3);
    }
    xb = x1 - (x1 - x3) * k;
    cbr = c1r - (c1r - c3r) * k;
    cbg = c1g - (c1g - c3g) * k;
    cbb = c1b - (c1b - c3b) * k;
    const x1_ = Math.round(Math.min(xa, xb));
    const x2_ = Math.round(Math.max(xa, xb));
    let j = rowSize * y + x1_ * 4;
    for (let x = x1_; x <= x2_; x++) {
      k = (xa - x) / (xa - xb);
      if (k < 0) {
        k = 0;
      } else if (k > 1) {
        k = 1;
      }
      bytes[j++] = car - (car - cbr) * k | 0;
      bytes[j++] = cag - (cag - cbg) * k | 0;
      bytes[j++] = cab - (cab - cbb) * k | 0;
      bytes[j++] = 255;
    }
  }
}
function drawFigure(data, figure, context) {
  const ps = figure.coords;
  const cs = figure.colors;
  let i, ii;
  switch (figure.type) {
    case "lattice":
      const verticesPerRow = figure.verticesPerRow;
      const rows = Math.floor(ps.length / verticesPerRow) - 1;
      const cols = verticesPerRow - 1;
      for (i = 0; i < rows; i++) {
        let q = i * verticesPerRow;
        for (let j = 0; j < cols; j++, q++) {
          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
        }
      }
      break;
    case "triangles":
      for (i = 0, ii = ps.length; i < ii; i += 3) {
        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
      }
      break;
    default:
      throw new Error("illegal figure");
  }
}
class MeshShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._coords = IR[2];
    this._colors = IR[3];
    this._figures = IR[4];
    this._bounds = IR[5];
    this._bbox = IR[7];
    this._background = IR[8];
    this.matrix = null;
  }
  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
    const EXPECTED_SCALE = 1.1;
    const MAX_PATTERN_SIZE = 3000;
    const BORDER_SIZE = 2;
    const offsetX = Math.floor(this._bounds[0]);
    const offsetY = Math.floor(this._bounds[1]);
    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const scaleX = boundsWidth / width;
    const scaleY = boundsHeight / height;
    const context = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -offsetX,
      offsetY: -offsetY,
      scaleX: 1 / scaleX,
      scaleY: 1 / scaleY
    };
    const paddedWidth = width + BORDER_SIZE * 2;
    const paddedHeight = height + BORDER_SIZE * 2;
    const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
    const tmpCtx = tmpCanvas.context;
    const data = tmpCtx.createImageData(width, height);
    if (backgroundColor) {
      const bytes = data.data;
      for (let i = 0, ii = bytes.length; i < ii; i += 4) {
        bytes[i] = backgroundColor[0];
        bytes[i + 1] = backgroundColor[1];
        bytes[i + 2] = backgroundColor[2];
        bytes[i + 3] = 255;
      }
    }
    for (const figure of this._figures) {
      drawFigure(data, figure, context);
    }
    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
    const canvas = tmpCanvas.canvas;
    return {
      canvas,
      offsetX: offsetX - BORDER_SIZE * scaleX,
      offsetY: offsetY - BORDER_SIZE * scaleY,
      scaleX,
      scaleY
    };
  }
  getPattern(ctx, owner, inverse, pathType) {
    applyBoundingBox(ctx, this._bbox);
    let scale;
    if (pathType === PathType.SHADING) {
      scale = Util.singularValueDecompose2dScale(getCurrentTransform(ctx));
    } else {
      scale = Util.singularValueDecompose2dScale(owner.baseTransform);
      if (this.matrix) {
        const matrixScale = Util.singularValueDecompose2dScale(this.matrix);
        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
      }
    }
    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
    if (pathType !== PathType.SHADING) {
      ctx.setTransform(...owner.baseTransform);
      if (this.matrix) {
        ctx.transform(...this.matrix);
      }
    }
    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
  }
}
class DummyShadingPattern extends BaseShadingPattern {
  getPattern() {
    return "hotpink";
  }
}
function getShadingPattern(IR) {
  switch (IR[0]) {
    case "RadialAxial":
      return new RadialAxialShadingPattern(IR);
    case "Mesh":
      return new MeshShadingPattern(IR);
    case "Dummy":
      return new DummyShadingPattern();
  }
  throw new Error(`Unknown IR type: ${IR[0]}`);
}
const PaintType = {
  COLORED: 1,
  UNCOLORED: 2
};
class TilingPattern {
  static MAX_PATTERN_SIZE = 3000;
  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
    this.operatorList = IR[2];
    this.matrix = IR[3];
    this.bbox = IR[4];
    this.xstep = IR[5];
    this.ystep = IR[6];
    this.paintType = IR[7];
    this.tilingType = IR[8];
    this.color = color;
    this.ctx = ctx;
    this.canvasGraphicsFactory = canvasGraphicsFactory;
    this.baseTransform = baseTransform;
  }
  createPatternCanvas(owner) {
    const operatorList = this.operatorList;
    const bbox = this.bbox;
    const xstep = this.xstep;
    const ystep = this.ystep;
    const paintType = this.paintType;
    const tilingType = this.tilingType;
    const color = this.color;
    const canvasGraphicsFactory = this.canvasGraphicsFactory;
    info("TilingType: " + tilingType);
    const x0 = bbox[0],
      y0 = bbox[1],
      x1 = bbox[2],
      y1 = bbox[3];
    const matrixScale = Util.singularValueDecompose2dScale(this.matrix);
    const curMatrixScale = Util.singularValueDecompose2dScale(this.baseTransform);
    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
    const tmpCtx = tmpCanvas.context;
    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
    graphics.groupLevel = owner.groupLevel;
    this.setFillAndStrokeStyleToContext(graphics, paintType, color);
    let adjustedX0 = x0;
    let adjustedY0 = y0;
    let adjustedX1 = x1;
    let adjustedY1 = y1;
    if (x0 < 0) {
      adjustedX0 = 0;
      adjustedX1 += Math.abs(x0);
    }
    if (y0 < 0) {
      adjustedY0 = 0;
      adjustedY1 += Math.abs(y0);
    }
    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
    tmpCtx.save();
    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
    graphics.baseTransform = getCurrentTransform(graphics.ctx);
    graphics.executeOperatorList(operatorList);
    graphics.endDrawing();
    return {
      canvas: tmpCanvas.canvas,
      scaleX: dimx.scale,
      scaleY: dimy.scale,
      offsetX: adjustedX0,
      offsetY: adjustedY0
    };
  }
  getSizeAndScale(step, realOutputSize, scale) {
    step = Math.abs(step);
    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
    let size = Math.ceil(step * scale);
    if (size >= maxSize) {
      size = maxSize;
    } else {
      scale = size / step;
    }
    return {
      scale,
      size
    };
  }
  clipBbox(graphics, x0, y0, x1, y1) {
    const bboxWidth = x1 - x0;
    const bboxHeight = y1 - y0;
    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
    graphics.current.updateRectMinMax(getCurrentTransform(graphics.ctx), [x0, y0, x1, y1]);
    graphics.clip();
    graphics.endPath();
  }
  setFillAndStrokeStyleToContext(graphics, paintType, color) {
    const context = graphics.ctx,
      current = graphics.current;
    switch (paintType) {
      case PaintType.COLORED:
        const ctx = this.ctx;
        context.fillStyle = ctx.fillStyle;
        context.strokeStyle = ctx.strokeStyle;
        current.fillColor = ctx.fillStyle;
        current.strokeColor = ctx.strokeStyle;
        break;
      case PaintType.UNCOLORED:
        const cssColor = Util.makeHexColor(color[0], color[1], color[2]);
        context.fillStyle = cssColor;
        context.strokeStyle = cssColor;
        current.fillColor = cssColor;
        current.strokeColor = cssColor;
        break;
      default:
        throw new FormatError(`Unsupported paint type: ${paintType}`);
    }
  }
  getPattern(ctx, owner, inverse, pathType) {
    let matrix = inverse;
    if (pathType !== PathType.SHADING) {
      matrix = Util.transform(matrix, owner.baseTransform);
      if (this.matrix) {
        matrix = Util.transform(matrix, this.matrix);
      }
    }
    const temporaryPatternCanvas = this.createPatternCanvas(owner);
    let domMatrix = new DOMMatrix(matrix);
    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
    pattern.setTransform(domMatrix);
    return pattern;
  }
}
function convertBlackAndWhiteToRGBA({
  src,
  srcPos = 0,
  dest,
  width,
  height,
  nonBlackColor = 0xffffffff,
  inverseDecode = false
}) {
  const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
  const widthInSource = width >> 3;
  const widthRemainder = width & 7;
  const srcLength = src.length;
  dest = new Uint32Array(dest.buffer);
  let destPos = 0;
  for (let i = 0; i < height; i++) {
    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
      const elem = srcPos < srcLength ? src[srcPos] : 255;
      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;
    }
    if (widthRemainder === 0) {
      continue;
    }
    const elem = srcPos < srcLength ? src[srcPos++] : 255;
    for (let j = 0; j < widthRemainder; j++) {
      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
    }
  }
  return {
    srcPos,
    destPos
  };
}




const MIN_FONT_SIZE = 16;
const MAX_FONT_SIZE = 100;
const EXECUTION_TIME = 15;
const EXECUTION_STEPS = 10;
const MAX_SIZE_TO_COMPILE = 1000;
const FULL_CHUNK_HEIGHT = 16;
function mirrorContextOperations(ctx, destCtx) {
  if (ctx._removeMirroring) {
    throw new Error("Context is already forwarding operations.");
  }
  ctx.__originalSave = ctx.save;
  ctx.__originalRestore = ctx.restore;
  ctx.__originalRotate = ctx.rotate;
  ctx.__originalScale = ctx.scale;
  ctx.__originalTranslate = ctx.translate;
  ctx.__originalTransform = ctx.transform;
  ctx.__originalSetTransform = ctx.setTransform;
  ctx.__originalResetTransform = ctx.resetTransform;
  ctx.__originalClip = ctx.clip;
  ctx.__originalMoveTo = ctx.moveTo;
  ctx.__originalLineTo = ctx.lineTo;
  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
  ctx.__originalRect = ctx.rect;
  ctx.__originalClosePath = ctx.closePath;
  ctx.__originalBeginPath = ctx.beginPath;
  ctx._removeMirroring = () => {
    ctx.save = ctx.__originalSave;
    ctx.restore = ctx.__originalRestore;
    ctx.rotate = ctx.__originalRotate;
    ctx.scale = ctx.__originalScale;
    ctx.translate = ctx.__originalTranslate;
    ctx.transform = ctx.__originalTransform;
    ctx.setTransform = ctx.__originalSetTransform;
    ctx.resetTransform = ctx.__originalResetTransform;
    ctx.clip = ctx.__originalClip;
    ctx.moveTo = ctx.__originalMoveTo;
    ctx.lineTo = ctx.__originalLineTo;
    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
    ctx.rect = ctx.__originalRect;
    ctx.closePath = ctx.__originalClosePath;
    ctx.beginPath = ctx.__originalBeginPath;
    delete ctx._removeMirroring;
  };
  ctx.save = function ctxSave() {
    destCtx.save();
    this.__originalSave();
  };
  ctx.restore = function ctxRestore() {
    destCtx.restore();
    this.__originalRestore();
  };
  ctx.translate = function ctxTranslate(x, y) {
    destCtx.translate(x, y);
    this.__originalTranslate(x, y);
  };
  ctx.scale = function ctxScale(x, y) {
    destCtx.scale(x, y);
    this.__originalScale(x, y);
  };
  ctx.transform = function ctxTransform(a, b, c, d, e, f) {
    destCtx.transform(a, b, c, d, e, f);
    this.__originalTransform(a, b, c, d, e, f);
  };
  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
    destCtx.setTransform(a, b, c, d, e, f);
    this.__originalSetTransform(a, b, c, d, e, f);
  };
  ctx.resetTransform = function ctxResetTransform() {
    destCtx.resetTransform();
    this.__originalResetTransform();
  };
  ctx.rotate = function ctxRotate(angle) {
    destCtx.rotate(angle);
    this.__originalRotate(angle);
  };
  ctx.clip = function ctxRotate(rule) {
    destCtx.clip(rule);
    this.__originalClip(rule);
  };
  ctx.moveTo = function (x, y) {
    destCtx.moveTo(x, y);
    this.__originalMoveTo(x, y);
  };
  ctx.lineTo = function (x, y) {
    destCtx.lineTo(x, y);
    this.__originalLineTo(x, y);
  };
  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  };
  ctx.rect = function (x, y, width, height) {
    destCtx.rect(x, y, width, height);
    this.__originalRect(x, y, width, height);
  };
  ctx.closePath = function () {
    destCtx.closePath();
    this.__originalClosePath();
  };
  ctx.beginPath = function () {
    destCtx.beginPath();
    this.__originalBeginPath();
  };
}
class CachedCanvases {
  constructor(canvasFactory) {
    this.canvasFactory = canvasFactory;
    this.cache = Object.create(null);
  }
  getCanvas(id, width, height) {
    let canvasEntry;
    if (this.cache[id] !== undefined) {
      canvasEntry = this.cache[id];
      this.canvasFactory.reset(canvasEntry, width, height);
    } else {
      canvasEntry = this.canvasFactory.create(width, height);
      this.cache[id] = canvasEntry;
    }
    return canvasEntry;
  }
  delete(id) {
    delete this.cache[id];
  }
  clear() {
    for (const id in this.cache) {
      const canvasEntry = this.cache[id];
      this.canvasFactory.destroy(canvasEntry);
      delete this.cache[id];
    }
  }
}
function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
  const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
  if (b === 0 && c === 0) {
    const tlX = destX * a + tx;
    const rTlX = Math.round(tlX);
    const tlY = destY * d + ty;
    const rTlY = Math.round(tlY);
    const brX = (destX + destW) * a + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destY + destH) * d + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rWidth, rHeight];
  }
  if (a === 0 && d === 0) {
    const tlX = destY * c + tx;
    const rTlX = Math.round(tlX);
    const tlY = destX * b + ty;
    const rTlY = Math.round(tlY);
    const brX = (destY + destH) * c + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destX + destW) * b + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rHeight, rWidth];
  }
  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
  const scaleX = Math.hypot(a, b);
  const scaleY = Math.hypot(c, d);
  return [scaleX * destW, scaleY * destH];
}
function compileType3Glyph(imgData) {
  const {
    width,
    height
  } = imgData;
  if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
    return null;
  }
  const POINT_TO_PROCESS_LIMIT = 1000;
  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
  const width1 = width + 1;
  let points = new Uint8Array(width1 * (height + 1));
  let i, j, j0;
  const lineSize = width + 7 & -8;
  let data = new Uint8Array(lineSize * height),
    pos = 0;
  for (const elem of imgData.data) {
    let mask = 128;
    while (mask > 0) {
      data[pos++] = elem & mask ? 0 : 255;
      mask >>= 1;
    }
  }
  let count = 0;
  pos = 0;
  if (data[pos] !== 0) {
    points[0] = 1;
    ++count;
  }
  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j] = data[pos] ? 2 : 1;
      ++count;
    }
    pos++;
  }
  if (data[pos] !== 0) {
    points[j] = 2;
    ++count;
  }
  for (i = 1; i < height; i++) {
    pos = i * lineSize;
    j0 = i * width1;
    if (data[pos - lineSize] !== data[pos]) {
      points[j0] = data[pos] ? 1 : 8;
      ++count;
    }
    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
    for (j = 1; j < width; j++) {
      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
      if (POINT_TYPES[sum]) {
        points[j0 + j] = POINT_TYPES[sum];
        ++count;
      }
      pos++;
    }
    if (data[pos - lineSize] !== data[pos]) {
      points[j0 + j] = data[pos] ? 2 : 4;
      ++count;
    }
    if (count > POINT_TO_PROCESS_LIMIT) {
      return null;
    }
  }
  pos = lineSize * (height - 1);
  j0 = i * width1;
  if (data[pos] !== 0) {
    points[j0] = 8;
    ++count;
  }
  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j0 + j] = data[pos] ? 4 : 8;
      ++count;
    }
    pos++;
  }
  if (data[pos] !== 0) {
    points[j0 + j] = 4;
    ++count;
  }
  if (count > POINT_TO_PROCESS_LIMIT) {
    return null;
  }
  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
  const path = new Path2D();
  for (i = 0; count && i <= height; i++) {
    let p = i * width1;
    const end = p + width;
    while (p < end && !points[p]) {
      p++;
    }
    if (p === end) {
      continue;
    }
    path.moveTo(p % width1, i);
    const p0 = p;
    let type = points[p];
    do {
      const step = steps[type];
      do {
        p += step;
      } while (!points[p]);
      const pp = points[p];
      if (pp !== 5 && pp !== 10) {
        type = pp;
        points[p] = 0;
      } else {
        type = pp & 0x33 * type >> 4;
        points[p] &= type >> 2 | type << 2;
      }
      path.lineTo(p % width1, p / width1 | 0);
      if (!points[p]) {
        --count;
      }
    } while (p0 !== p);
    --i;
  }
  data = null;
  points = null;
  const drawOutline = function (c) {
    c.save();
    c.scale(1 / width, -1 / height);
    c.translate(0, -height);
    c.fill(path);
    c.beginPath();
    c.restore();
  };
  return drawOutline;
}
class CanvasExtraState {
  constructor(width, height) {
    this.alphaIsShape = false;
    this.fontSize = 0;
    this.fontSizeScale = 1;
    this.textMatrix = IDENTITY_MATRIX;
    this.textMatrixScale = 1;
    this.fontMatrix = FONT_IDENTITY_MATRIX;
    this.leading = 0;
    this.x = 0;
    this.y = 0;
    this.lineX = 0;
    this.lineY = 0;
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.textHScale = 1;
    this.textRenderingMode = TextRenderingMode.FILL;
    this.textRise = 0;
    this.fillColor = "#000000";
    this.strokeColor = "#000000";
    this.patternFill = false;
    this.fillAlpha = 1;
    this.strokeAlpha = 1;
    this.lineWidth = 1;
    this.activeSMask = null;
    this.transferMaps = "none";
    this.startNewPathAndClipBox([0, 0, width, height]);
  }
  clone() {
    const clone = Object.create(this);
    clone.clipBox = this.clipBox.slice();
    return clone;
  }
  setCurrentPoint(x, y) {
    this.x = x;
    this.y = y;
  }
  updatePathMinMax(transform, x, y) {
    [x, y] = Util.applyTransform([x, y], transform);
    this.minX = Math.min(this.minX, x);
    this.minY = Math.min(this.minY, y);
    this.maxX = Math.max(this.maxX, x);
    this.maxY = Math.max(this.maxY, y);
  }
  updateRectMinMax(transform, rect) {
    const p1 = Util.applyTransform(rect, transform);
    const p2 = Util.applyTransform(rect.slice(2), transform);
    const p3 = Util.applyTransform([rect[0], rect[3]], transform);
    const p4 = Util.applyTransform([rect[2], rect[1]], transform);
    this.minX = Math.min(this.minX, p1[0], p2[0], p3[0], p4[0]);
    this.minY = Math.min(this.minY, p1[1], p2[1], p3[1], p4[1]);
    this.maxX = Math.max(this.maxX, p1[0], p2[0], p3[0], p4[0]);
    this.maxY = Math.max(this.maxY, p1[1], p2[1], p3[1], p4[1]);
  }
  updateScalingPathMinMax(transform, minMax) {
    Util.scaleMinMax(transform, minMax);
    this.minX = Math.min(this.minX, minMax[0]);
    this.minY = Math.min(this.minY, minMax[1]);
    this.maxX = Math.max(this.maxX, minMax[2]);
    this.maxY = Math.max(this.maxY, minMax[3]);
  }
  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
    const box = Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax);
    if (minMax) {
      return;
    }
    this.updateRectMinMax(transform, box);
  }
  getPathBoundingBox(pathType = PathType.FILL, transform = null) {
    const box = [this.minX, this.minY, this.maxX, this.maxY];
    if (pathType === PathType.STROKE) {
      if (!transform) {
        unreachable("Stroke bounding box must include transform.");
      }
      const scale = Util.singularValueDecompose2dScale(transform);
      const xStrokePad = scale[0] * this.lineWidth / 2;
      const yStrokePad = scale[1] * this.lineWidth / 2;
      box[0] -= xStrokePad;
      box[1] -= yStrokePad;
      box[2] += xStrokePad;
      box[3] += yStrokePad;
    }
    return box;
  }
  updateClipFromPath() {
    const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minX === Infinity;
  }
  startNewPathAndClipBox(box) {
    this.clipBox = box;
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = 0;
    this.maxY = 0;
  }
  getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
    return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
  }
}
function putBinaryImageData(ctx, imgData) {
  if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
    ctx.putImageData(imgData, 0, 0);
    return;
  }
  const height = imgData.height,
    width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0,
    destPos;
  const src = imgData.data;
  const dest = chunkImgData.data;
  let i, j, thisChunkHeight, elemsInThisChunk;
  if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {
    const srcLength = src.byteLength;
    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
    const dest32DataLength = dest32.length;
    const fullSrcDiff = width + 7 >> 3;
    const white = 0xffffffff;
    const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
    for (i = 0; i < totalChunks; i++) {
      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      destPos = 0;
      for (j = 0; j < thisChunkHeight; j++) {
        const srcDiff = srcLength - srcPos;
        let k = 0;
        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
        const kEndUnrolled = kEnd & -8;
        let mask = 0;
        let srcByte = 0;
        for (; k < kEndUnrolled; k += 8) {
          srcByte = src[srcPos++];
          dest32[destPos++] = srcByte & 128 ? white : black;
          dest32[destPos++] = srcByte & 64 ? white : black;
          dest32[destPos++] = srcByte & 32 ? white : black;
          dest32[destPos++] = srcByte & 16 ? white : black;
          dest32[destPos++] = srcByte & 8 ? white : black;
          dest32[destPos++] = srcByte & 4 ? white : black;
          dest32[destPos++] = srcByte & 2 ? white : black;
          dest32[destPos++] = srcByte & 1 ? white : black;
        }
        for (; k < kEnd; k++) {
          if (mask === 0) {
            srcByte = src[srcPos++];
            mask = 128;
          }
          dest32[destPos++] = srcByte & mask ? white : black;
          mask >>= 1;
        }
      }
      while (destPos < dest32DataLength) {
        dest32[destPos++] = 0;
      }
      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {
    j = 0;
    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
    for (i = 0; i < fullChunks; i++) {
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      srcPos += elemsInThisChunk;
      ctx.putImageData(chunkImgData, 0, j);
      j += FULL_CHUNK_HEIGHT;
    }
    if (i < totalChunks) {
      elemsInThisChunk = width * partialChunkHeight * 4;
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      ctx.putImageData(chunkImgData, 0, j);
    }
  } else if (imgData.kind === util_ImageKind.RGB_24BPP) {
    thisChunkHeight = FULL_CHUNK_HEIGHT;
    elemsInThisChunk = width * thisChunkHeight;
    for (i = 0; i < totalChunks; i++) {
      if (i >= fullChunks) {
        thisChunkHeight = partialChunkHeight;
        elemsInThisChunk = width * thisChunkHeight;
      }
      destPos = 0;
      for (j = elemsInThisChunk; j--;) {
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = 255;
      }
      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else {
    throw new Error(`bad image kind: ${imgData.kind}`);
  }
}
function putBinaryImageMask(ctx, imgData) {
  if (imgData.bitmap) {
    ctx.drawImage(imgData.bitmap, 0, 0);
    return;
  }
  const height = imgData.height,
    width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0;
  const src = imgData.data;
  const dest = chunkImgData.data;
  for (let i = 0; i < totalChunks; i++) {
    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
    ({
      srcPos
    } = convertBlackAndWhiteToRGBA({
      src,
      srcPos,
      dest,
      width,
      height: thisChunkHeight,
      nonBlackColor: 0
    }));
    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
  }
}
function copyCtxState(sourceCtx, destCtx) {
  const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const property of properties) {
    if (sourceCtx[property] !== undefined) {
      destCtx[property] = sourceCtx[property];
    }
  }
  if (sourceCtx.setLineDash !== undefined) {
    destCtx.setLineDash(sourceCtx.getLineDash());
    destCtx.lineDashOffset = sourceCtx.lineDashOffset;
  }
}
function resetCtxToDefault(ctx) {
  ctx.strokeStyle = ctx.fillStyle = "#000000";
  ctx.fillRule = "nonzero";
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.lineCap = "butt";
  ctx.lineJoin = "miter";
  ctx.miterLimit = 10;
  ctx.globalCompositeOperation = "source-over";
  ctx.font = "10px sans-serif";
  if (ctx.setLineDash !== undefined) {
    ctx.setLineDash([]);
    ctx.lineDashOffset = 0;
  }
  if (!isNodeJS) {
    const {
      filter
    } = ctx;
    if (filter !== "none" && filter !== "") {
      ctx.filter = "none";
    }
  }
}
function getImageSmoothingEnabled(transform, interpolate) {
  if (interpolate) {
    return true;
  }
  const scale = Util.singularValueDecompose2dScale(transform);
  scale[0] = Math.fround(scale[0]);
  scale[1] = Math.fround(scale[1]);
  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS);
  return scale[0] <= actualScale && scale[1] <= actualScale;
}
const LINE_CAP_STYLES = ["butt", "round", "square"];
const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
const NORMAL_CLIP = {};
const EO_CLIP = {};
class CanvasGraphics {
  constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {
    optionalContentConfig,
    markedContentStack = null
  }, annotationCanvasMap, pageColors) {
    this.ctx = canvasCtx;
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.stateStack = [];
    this.pendingClip = null;
    this.pendingEOFill = false;
    this.res = null;
    this.xobjs = null;
    this.commonObjs = commonObjs;
    this.objs = objs;
    this.canvasFactory = canvasFactory;
    this.filterFactory = filterFactory;
    this.groupStack = [];
    this.processingType3 = null;
    this.baseTransform = null;
    this.baseTransformStack = [];
    this.groupLevel = 0;
    this.smaskStack = [];
    this.smaskCounter = 0;
    this.tempSMask = null;
    this.suspendedCtx = null;
    this.contentVisible = true;
    this.markedContentStack = markedContentStack || [];
    this.optionalContentConfig = optionalContentConfig;
    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
    this.cachedPatterns = new Map();
    this.annotationCanvasMap = annotationCanvasMap;
    this.viewportScale = 1;
    this.outputScaleX = 1;
    this.outputScaleY = 1;
    this.pageColors = pageColors;
    this._cachedScaleForStroking = [-1, 0];
    this._cachedGetSinglePixelWidth = null;
    this._cachedBitmapsMap = new Map();
  }
  getObject(data, fallback = null) {
    if (typeof data === "string") {
      return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
    }
    return fallback;
  }
  beginDrawing({
    transform,
    viewport,
    transparency = false,
    background = null
  }) {
    const width = this.ctx.canvas.width;
    const height = this.ctx.canvas.height;
    const savedFillStyle = this.ctx.fillStyle;
    this.ctx.fillStyle = background || "#ffffff";
    this.ctx.fillRect(0, 0, width, height);
    this.ctx.fillStyle = savedFillStyle;
    if (transparency) {
      const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
      this.compositeCtx = this.ctx;
      this.transparentCanvas = transparentCanvas.canvas;
      this.ctx = transparentCanvas.context;
      this.ctx.save();
      this.ctx.transform(...getCurrentTransform(this.compositeCtx));
    }
    this.ctx.save();
    resetCtxToDefault(this.ctx);
    if (transform) {
      this.ctx.transform(...transform);
      this.outputScaleX = transform[0];
      this.outputScaleY = transform[0];
    }
    this.ctx.transform(...viewport.transform);
    this.viewportScale = viewport.scale;
    this.baseTransform = getCurrentTransform(this.ctx);
  }
  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
    const argsArray = operatorList.argsArray;
    const fnArray = operatorList.fnArray;
    let i = executionStartIdx || 0;
    const argsArrayLen = argsArray.length;
    if (argsArrayLen === i) {
      return i;
    }
    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
    let steps = 0;
    const commonObjs = this.commonObjs;
    const objs = this.objs;
    let fnId;
    while (true) {
      if (stepper !== undefined && i === stepper.nextBreakPoint) {
        stepper.breakIt(i, continueCallback);
        return i;
      }
      fnId = fnArray[i];
      if (fnId !== OPS.dependency) {
        this[fnId].apply(this, argsArray[i]);
      } else {
        for (const depObjId of argsArray[i]) {
          const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
          if (!objsPool.has(depObjId)) {
            objsPool.get(depObjId, continueCallback);
            return i;
          }
        }
      }
      i++;
      if (i === argsArrayLen) {
        return i;
      }
      if (chunkOperations && ++steps > EXECUTION_STEPS) {
        if (Date.now() > endTime) {
          continueCallback();
          return i;
        }
        steps = 0;
      }
    }
  }
  #restoreInitialState() {
    while (this.stateStack.length || this.inSMaskMode) {
      this.restore();
    }
    this.ctx.restore();
    if (this.transparentCanvas) {
      this.ctx = this.compositeCtx;
      this.ctx.save();
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.drawImage(this.transparentCanvas, 0, 0);
      this.ctx.restore();
      this.transparentCanvas = null;
    }
  }
  endDrawing() {
    this.#restoreInitialState();
    this.cachedCanvases.clear();
    this.cachedPatterns.clear();
    for (const cache of this._cachedBitmapsMap.values()) {
      for (const canvas of cache.values()) {
        if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
          canvas.width = canvas.height = 0;
        }
      }
      cache.clear();
    }
    this._cachedBitmapsMap.clear();
    this.#drawFilter();
  }
  #drawFilter() {
    if (this.pageColors) {
      const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
      if (hcmFilterId !== "none") {
        const savedFilter = this.ctx.filter;
        this.ctx.filter = hcmFilterId;
        this.ctx.drawImage(this.ctx.canvas, 0, 0);
        this.ctx.filter = savedFilter;
      }
    }
  }
  _scaleImage(img, inverseTransform) {
    const width = img.width;
    const height = img.height;
    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
    let paintWidth = width,
      paintHeight = height;
    let tmpCanvasId = "prescale1";
    let tmpCanvas, tmpCtx;
    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
      let newWidth = paintWidth,
        newHeight = paintHeight;
      if (widthScale > 2 && paintWidth > 1) {
        newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
        widthScale /= paintWidth / newWidth;
      }
      if (heightScale > 2 && paintHeight > 1) {
        newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
        heightScale /= paintHeight / newHeight;
      }
      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
      tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, newWidth, newHeight);
      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
      img = tmpCanvas.canvas;
      paintWidth = newWidth;
      paintHeight = newHeight;
      tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
    }
    return {
      img,
      paintWidth,
      paintHeight
    };
  }
  _createMaskCanvas(img) {
    const ctx = this.ctx;
    const {
      width,
      height
    } = img;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    const currentTransform = getCurrentTransform(ctx);
    let cache, cacheKey, scaled, maskCanvas;
    if ((img.bitmap || img.data) && img.count > 1) {
      const mainKey = img.bitmap || img.data.buffer;
      cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);
      cache = this._cachedBitmapsMap.get(mainKey);
      if (!cache) {
        cache = new Map();
        this._cachedBitmapsMap.set(mainKey, cache);
      }
      const cachedImage = cache.get(cacheKey);
      if (cachedImage && !isPatternFill) {
        const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
        const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
        return {
          canvas: cachedImage,
          offsetX,
          offsetY
        };
      }
      scaled = cachedImage;
    }
    if (!scaled) {
      maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      putBinaryImageMask(maskCanvas.context, img);
    }
    let maskToCanvas = Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
    maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
    const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox([0, 0, width, height], maskToCanvas);
    const drawnWidth = Math.round(maxX - minX) || 1;
    const drawnHeight = Math.round(maxY - minY) || 1;
    const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
    const fillCtx = fillCanvas.context;
    const offsetX = minX;
    const offsetY = minY;
    fillCtx.translate(-offsetX, -offsetY);
    fillCtx.transform(...maskToCanvas);
    if (!scaled) {
      scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));
      scaled = scaled.img;
      if (cache && isPatternFill) {
        cache.set(cacheKey, scaled);
      }
    }
    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);
    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
    fillCtx.globalCompositeOperation = "source-in";
    const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL) : fillColor;
    fillCtx.fillRect(0, 0, width, height);
    if (cache && !isPatternFill) {
      this.cachedCanvases.delete("fillCanvas");
      cache.set(cacheKey, fillCanvas.canvas);
    }
    return {
      canvas: fillCanvas.canvas,
      offsetX: Math.round(offsetX),
      offsetY: Math.round(offsetY)
    };
  }
  setLineWidth(width) {
    if (width !== this.current.lineWidth) {
      this._cachedScaleForStroking[0] = -1;
    }
    this.current.lineWidth = width;
    this.ctx.lineWidth = width;
  }
  setLineCap(style) {
    this.ctx.lineCap = LINE_CAP_STYLES[style];
  }
  setLineJoin(style) {
    this.ctx.lineJoin = LINE_JOIN_STYLES[style];
  }
  setMiterLimit(limit) {
    this.ctx.miterLimit = limit;
  }
  setDash(dashArray, dashPhase) {
    const ctx = this.ctx;
    if (ctx.setLineDash !== undefined) {
      ctx.setLineDash(dashArray);
      ctx.lineDashOffset = dashPhase;
    }
  }
  setRenderingIntent(intent) {}
  setFlatness(flatness) {}
  setGState(states) {
    for (const [key, value] of states) {
      switch (key) {
        case "LW":
          this.setLineWidth(value);
          break;
        case "LC":
          this.setLineCap(value);
          break;
        case "LJ":
          this.setLineJoin(value);
          break;
        case "ML":
          this.setMiterLimit(value);
          break;
        case "D":
          this.setDash(value[0], value[1]);
          break;
        case "RI":
          this.setRenderingIntent(value);
          break;
        case "FL":
          this.setFlatness(value);
          break;
        case "Font":
          this.setFont(value[0], value[1]);
          break;
        case "CA":
          this.current.strokeAlpha = value;
          break;
        case "ca":
          this.current.fillAlpha = value;
          this.ctx.globalAlpha = value;
          break;
        case "BM":
          this.ctx.globalCompositeOperation = value;
          break;
        case "SMask":
          this.current.activeSMask = value ? this.tempSMask : null;
          this.tempSMask = null;
          this.checkSMaskState();
          break;
        case "TR":
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
          break;
      }
    }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const inSMaskMode = this.inSMaskMode;
    if (this.current.activeSMask && !inSMaskMode) {
      this.beginSMaskMode();
    } else if (!this.current.activeSMask && inSMaskMode) {
      this.endSMaskMode();
    }
  }
  beginSMaskMode() {
    if (this.inSMaskMode) {
      throw new Error("beginSMaskMode called while already in smask mode");
    }
    const drawnWidth = this.ctx.canvas.width;
    const drawnHeight = this.ctx.canvas.height;
    const cacheId = "smaskGroupAt" + this.groupLevel;
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    this.suspendedCtx = this.ctx;
    this.ctx = scratchCanvas.context;
    const ctx = this.ctx;
    ctx.setTransform(...getCurrentTransform(this.suspendedCtx));
    copyCtxState(this.suspendedCtx, ctx);
    mirrorContextOperations(ctx, this.suspendedCtx);
    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode) {
      throw new Error("endSMaskMode called while not in smask mode");
    }
    this.ctx._removeMirroring();
    copyCtxState(this.ctx, this.suspendedCtx);
    this.ctx = this.suspendedCtx;
    this.suspendedCtx = null;
  }
  compose(dirtyBox) {
    if (!this.current.activeSMask) {
      return;
    }
    if (!dirtyBox) {
      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    } else {
      dirtyBox[0] = Math.floor(dirtyBox[0]);
      dirtyBox[1] = Math.floor(dirtyBox[1]);
      dirtyBox[2] = Math.ceil(dirtyBox[2]);
      dirtyBox[3] = Math.ceil(dirtyBox[3]);
    }
    const smask = this.current.activeSMask;
    const suspendedCtx = this.suspendedCtx;
    this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.ctx.restore();
  }
  composeSMask(ctx, smask, layerCtx, layerBox) {
    const layerOffsetX = layerBox[0];
    const layerOffsetY = layerBox[1];
    const layerWidth = layerBox[2] - layerOffsetX;
    const layerHeight = layerBox[3] - layerOffsetY;
    if (layerWidth === 0 || layerHeight === 0) {
      return;
    }
    this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(layerCtx.canvas, 0, 0);
    ctx.restore();
  }
  genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
    let maskCanvas = maskCtx.canvas;
    let maskX = layerOffsetX - maskOffsetX;
    let maskY = layerOffsetY - maskOffsetY;
    if (backdrop) {
      if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {
        const canvas = this.cachedCanvases.getCanvas("maskExtension", width, height);
        const ctx = canvas.context;
        ctx.drawImage(maskCanvas, -maskX, -maskY);
        if (backdrop.some(c => c !== 0)) {
          ctx.globalCompositeOperation = "destination-atop";
          ctx.fillStyle = Util.makeHexColor(...backdrop);
          ctx.fillRect(0, 0, width, height);
          ctx.globalCompositeOperation = "source-over";
        }
        maskCanvas = canvas.canvas;
        maskX = maskY = 0;
      } else if (backdrop.some(c => c !== 0)) {
        maskCtx.save();
        maskCtx.globalAlpha = 1;
        maskCtx.setTransform(1, 0, 0, 1, 0, 0);
        const clip = new Path2D();
        clip.rect(maskX, maskY, width, height);
        maskCtx.clip(clip);
        maskCtx.globalCompositeOperation = "destination-atop";
        maskCtx.fillStyle = Util.makeHexColor(...backdrop);
        maskCtx.fillRect(maskX, maskY, width, height);
        maskCtx.restore();
      }
    }
    layerCtx.save();
    layerCtx.globalAlpha = 1;
    layerCtx.setTransform(1, 0, 0, 1, 0, 0);
    if (subtype === "Alpha" && transferMap) {
      layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
    } else if (subtype === "Luminosity") {
      layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
    }
    const clip = new Path2D();
    clip.rect(layerOffsetX, layerOffsetY, width, height);
    layerCtx.clip(clip);
    layerCtx.globalCompositeOperation = "destination-in";
    layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);
    layerCtx.restore();
  }
  save() {
    if (this.inSMaskMode) {
      copyCtxState(this.ctx, this.suspendedCtx);
      this.suspendedCtx.save();
    } else {
      this.ctx.save();
    }
    const old = this.current;
    this.stateStack.push(old);
    this.current = old.clone();
  }
  restore() {
    if (this.stateStack.length === 0 && this.inSMaskMode) {
      this.endSMaskMode();
    }
    if (this.stateStack.length !== 0) {
      this.current = this.stateStack.pop();
      if (this.inSMaskMode) {
        this.suspendedCtx.restore();
        copyCtxState(this.suspendedCtx, this.ctx);
      } else {
        this.ctx.restore();
      }
      this.checkSMaskState();
      this.pendingClip = null;
      this._cachedScaleForStroking[0] = -1;
      this._cachedGetSinglePixelWidth = null;
    }
  }
  transform(a, b, c, d, e, f) {
    this.ctx.transform(a, b, c, d, e, f);
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
  }
  constructPath(ops, args, minMax) {
    const ctx = this.ctx;
    const current = this.current;
    let x = current.x,
      y = current.y;
    let startX, startY;
    const currentTransform = getCurrentTransform(ctx);
    const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
    const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
      switch (ops[i] | 0) {
        case OPS.rectangle:
          x = args[j++];
          y = args[j++];
          const width = args[j++];
          const height = args[j++];
          const xw = x + width;
          const yh = y + height;
          ctx.moveTo(x, y);
          if (width === 0 || height === 0) {
            ctx.lineTo(xw, yh);
          } else {
            ctx.lineTo(xw, y);
            ctx.lineTo(xw, yh);
            ctx.lineTo(x, yh);
          }
          if (!isScalingMatrix) {
            current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
          }
          ctx.closePath();
          break;
        case OPS.moveTo:
          x = args[j++];
          y = args[j++];
          ctx.moveTo(x, y);
          if (!isScalingMatrix) {
            current.updatePathMinMax(currentTransform, x, y);
          }
          break;
        case OPS.lineTo:
          x = args[j++];
          y = args[j++];
          ctx.lineTo(x, y);
          if (!isScalingMatrix) {
            current.updatePathMinMax(currentTransform, x, y);
          }
          break;
        case OPS.curveTo:
          startX = x;
          startY = y;
          x = args[j + 4];
          y = args[j + 5];
          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
          j += 6;
          break;
        case OPS.curveTo2:
          startX = x;
          startY = y;
          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
          current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
          x = args[j + 2];
          y = args[j + 3];
          j += 4;
          break;
        case OPS.curveTo3:
          startX = x;
          startY = y;
          x = args[j + 2];
          y = args[j + 3];
          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
          j += 4;
          break;
        case OPS.closePath:
          ctx.closePath();
          break;
      }
    }
    if (isScalingMatrix) {
      current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
    }
    current.setCurrentPoint(x, y);
  }
  closePath() {
    this.ctx.closePath();
  }
  stroke(consumePath = true) {
    const ctx = this.ctx;
    const strokeColor = this.current.strokeColor;
    ctx.globalAlpha = this.current.strokeAlpha;
    if (this.contentVisible) {
      if (typeof strokeColor === "object" && strokeColor?.getPattern) {
        ctx.save();
        ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);
        this.rescaleAndStroke(false);
        ctx.restore();
      } else {
        this.rescaleAndStroke(true);
      }
    }
    if (consumePath) {
      this.consumePath(this.current.getClippedPathBoundingBox());
    }
    ctx.globalAlpha = this.current.fillAlpha;
  }
  closeStroke() {
    this.closePath();
    this.stroke();
  }
  fill(consumePath = true) {
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    let needRestore = false;
    if (isPatternFill) {
      ctx.save();
      ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);
      needRestore = true;
    }
    const intersect = this.current.getClippedPathBoundingBox();
    if (this.contentVisible && intersect !== null) {
      if (this.pendingEOFill) {
        ctx.fill("evenodd");
        this.pendingEOFill = false;
      } else {
        ctx.fill();
      }
    }
    if (needRestore) {
      ctx.restore();
    }
    if (consumePath) {
      this.consumePath(intersect);
    }
  }
  eoFill() {
    this.pendingEOFill = true;
    this.fill();
  }
  fillStroke() {
    this.fill(false);
    this.stroke(false);
    this.consumePath();
  }
  eoFillStroke() {
    this.pendingEOFill = true;
    this.fillStroke();
  }
  closeFillStroke() {
    this.closePath();
    this.fillStroke();
  }
  closeEOFillStroke() {
    this.pendingEOFill = true;
    this.closePath();
    this.fillStroke();
  }
  endPath() {
    this.consumePath();
  }
  clip() {
    this.pendingClip = NORMAL_CLIP;
  }
  eoClip() {
    this.pendingClip = EO_CLIP;
  }
  beginText() {
    this.current.textMatrix = IDENTITY_MATRIX;
    this.current.textMatrixScale = 1;
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
  }
  endText() {
    const paths = this.pendingTextPaths;
    const ctx = this.ctx;
    if (paths === undefined) {
      ctx.beginPath();
      return;
    }
    ctx.save();
    ctx.beginPath();
    for (const path of paths) {
      ctx.setTransform(...path.transform);
      ctx.translate(path.x, path.y);
      path.addToPath(ctx, path.fontSize);
    }
    ctx.restore();
    ctx.clip();
    ctx.beginPath();
    delete this.pendingTextPaths;
  }
  setCharSpacing(spacing) {
    this.current.charSpacing = spacing;
  }
  setWordSpacing(spacing) {
    this.current.wordSpacing = spacing;
  }
  setHScale(scale) {
    this.current.textHScale = scale / 100;
  }
  setLeading(leading) {
    this.current.leading = -leading;
  }
  setFont(fontRefName, size) {
    const fontObj = this.commonObjs.get(fontRefName);
    const current = this.current;
    if (!fontObj) {
      throw new Error(`Can't find font for ${fontRefName}`);
    }
    current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
      warn("Invalid font matrix for font " + fontRefName);
    }
    if (size < 0) {
      size = -size;
      current.fontDirection = -1;
    } else {
      current.fontDirection = 1;
    }
    this.current.font = fontObj;
    this.current.fontSize = size;
    if (fontObj.isType3Font) {
      return;
    }
    const name = fontObj.loadedName || "sans-serif";
    const typeface = fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
    let bold = "normal";
    if (fontObj.black) {
      bold = "900";
    } else if (fontObj.bold) {
      bold = "bold";
    }
    const italic = fontObj.italic ? "italic" : "normal";
    let browserFontSize = size;
    if (size < MIN_FONT_SIZE) {
      browserFontSize = MIN_FONT_SIZE;
    } else if (size > MAX_FONT_SIZE) {
      browserFontSize = MAX_FONT_SIZE;
    }
    this.current.fontSizeScale = size / browserFontSize;
    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
  }
  setTextRenderingMode(mode) {
    this.current.textRenderingMode = mode;
  }
  setTextRise(rise) {
    this.current.textRise = rise;
  }
  moveText(x, y) {
    this.current.x = this.current.lineX += x;
    this.current.y = this.current.lineY += y;
  }
  setLeadingMoveText(x, y) {
    this.setLeading(-y);
    this.moveText(x, y);
  }
  setTextMatrix(a, b, c, d, e, f) {
    this.current.textMatrix = [a, b, c, d, e, f];
    this.current.textMatrixScale = Math.hypot(a, b);
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
  }
  nextLine() {
    this.moveText(0, this.current.leading);
  }
  paintChar(character, x, y, patternTransform) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const textRenderingMode = current.textRenderingMode;
    const fontSize = current.fontSize / current.fontSizeScale;
    const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
    const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);
    const patternFill = current.patternFill && !font.missingFile;
    let addToPath;
    if (font.disableFontFace || isAddToPathSet || patternFill) {
      addToPath = font.getPathGenerator(this.commonObjs, character);
    }
    if (font.disableFontFace || patternFill) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      addToPath(ctx, fontSize);
      if (patternTransform) {
        ctx.setTransform(...patternTransform);
      }
      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        ctx.fill();
      }
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        ctx.stroke();
      }
      ctx.restore();
    } else {
      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        ctx.fillText(character, x, y);
      }
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        ctx.strokeText(character, x, y);
      }
    }
    if (isAddToPathSet) {
      const paths = this.pendingTextPaths ||= [];
      paths.push({
        transform: getCurrentTransform(ctx),
        x,
        y,
        fontSize,
        addToPath
      });
    }
  }
  get isFontSubpixelAAEnabled() {
    const {
      context: ctx
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    ctx.scale(1.5, 1);
    ctx.fillText("I", 0, 10);
    const data = ctx.getImageData(0, 0, 10, 10).data;
    let enabled = false;
    for (let i = 3; i < data.length; i += 4) {
      if (data[i] > 0 && data[i] < 255) {
        enabled = true;
        break;
      }
    }
    return shadow(this, "isFontSubpixelAAEnabled", enabled);
  }
  showText(glyphs) {
    const current = this.current;
    const font = current.font;
    if (font.isType3Font) {
      return this.showType3Text(glyphs);
    }
    const fontSize = current.fontSize;
    if (fontSize === 0) {
      return undefined;
    }
    const ctx = this.ctx;
    const fontSizeScale = current.fontSizeScale;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const fontDirection = current.fontDirection;
    const textHScale = current.textHScale * fontDirection;
    const glyphsLength = glyphs.length;
    const vertical = font.vertical;
    const spacingDir = vertical ? 1 : -1;
    const defaultVMetrics = font.defaultVMetrics;
    const widthAdvanceScale = fontSize * current.fontMatrix[0];
    const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
    ctx.save();
    ctx.transform(...current.textMatrix);
    ctx.translate(current.x, current.y + current.textRise);
    if (fontDirection > 0) {
      ctx.scale(textHScale, -1);
    } else {
      ctx.scale(textHScale, 1);
    }
    let patternTransform;
    if (current.patternFill) {
      ctx.save();
      const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);
      patternTransform = getCurrentTransform(ctx);
      ctx.restore();
      ctx.fillStyle = pattern;
    }
    let lineWidth = current.lineWidth;
    const scale = current.textMatrixScale;
    if (scale === 0 || lineWidth === 0) {
      const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        lineWidth = this.getSinglePixelWidth();
      }
    } else {
      lineWidth /= scale;
    }
    if (fontSizeScale !== 1.0) {
      ctx.scale(fontSizeScale, fontSizeScale);
      lineWidth /= fontSizeScale;
    }
    ctx.lineWidth = lineWidth;
    if (font.isInvalidPDFjsFont) {
      const chars = [];
      let width = 0;
      for (const glyph of glyphs) {
        chars.push(glyph.unicode);
        width += glyph.width;
      }
      ctx.fillText(chars.join(""), 0, 0);
      current.x += width * widthAdvanceScale * textHScale;
      ctx.restore();
      this.compose();
      return undefined;
    }
    let x = 0,
      i;
    for (i = 0; i < glyphsLength; ++i) {
      const glyph = glyphs[i];
      if (typeof glyph === "number") {
        x += spacingDir * glyph * fontSize / 1000;
        continue;
      }
      let restoreNeeded = false;
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const character = glyph.fontChar;
      const accent = glyph.accent;
      let scaledX, scaledY;
      let width = glyph.width;
      if (vertical) {
        const vmetric = glyph.vmetric || defaultVMetrics;
        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
        const vy = vmetric[2] * widthAdvanceScale;
        width = vmetric ? -vmetric[0] : width;
        scaledX = vx / fontSizeScale;
        scaledY = (x + vy) / fontSizeScale;
      } else {
        scaledX = x / fontSizeScale;
        scaledY = 0;
      }
      if (font.remeasure && width > 0) {
        const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;
        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
          const characterScaleX = width / measuredWidth;
          restoreNeeded = true;
          ctx.save();
          ctx.scale(characterScaleX, 1);
          scaledX /= characterScaleX;
        } else if (width !== measuredWidth) {
          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
        }
      }
      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
        if (simpleFillText && !accent) {
          ctx.fillText(character, scaledX, scaledY);
        } else {
          this.paintChar(character, scaledX, scaledY, patternTransform);
          if (accent) {
            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
          }
        }
      }
      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
      x += charWidth;
      if (restoreNeeded) {
        ctx.restore();
      }
    }
    if (vertical) {
      current.y -= x;
    } else {
      current.x += x * textHScale;
    }
    ctx.restore();
    this.compose();
    return undefined;
  }
  showType3Text(glyphs) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const fontSize = current.fontSize;
    const fontDirection = current.fontDirection;
    const spacingDir = font.vertical ? 1 : -1;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const textHScale = current.textHScale * fontDirection;
    const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
    const glyphsLength = glyphs.length;
    const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;
    let i, glyph, width, spacingLength;
    if (isTextInvisible || fontSize === 0) {
      return;
    }
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
    ctx.save();
    ctx.transform(...current.textMatrix);
    ctx.translate(current.x, current.y);
    ctx.scale(textHScale, fontDirection);
    for (i = 0; i < glyphsLength; ++i) {
      glyph = glyphs[i];
      if (typeof glyph === "number") {
        spacingLength = spacingDir * glyph * fontSize / 1000;
        this.ctx.translate(spacingLength, 0);
        current.x += spacingLength * textHScale;
        continue;
      }
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const operatorList = font.charProcOperatorList[glyph.operatorListId];
      if (!operatorList) {
        warn(`Type3 character "${glyph.operatorListId}" is not available.`);
        continue;
      }
      if (this.contentVisible) {
        this.processingType3 = glyph;
        this.save();
        ctx.scale(fontSize, fontSize);
        ctx.transform(...fontMatrix);
        this.executeOperatorList(operatorList);
        this.restore();
      }
      const transformed = Util.applyTransform([glyph.width, 0], fontMatrix);
      width = transformed[0] * fontSize + spacing;
      ctx.translate(width, 0);
      current.x += width * textHScale;
    }
    ctx.restore();
    this.processingType3 = null;
  }
  setCharWidth(xWidth, yWidth) {}
  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
    this.ctx.rect(llx, lly, urx - llx, ury - lly);
    this.ctx.clip();
    this.endPath();
  }
  getColorN_Pattern(IR) {
    let pattern;
    if (IR[0] === "TilingPattern") {
      const color = IR[1];
      const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
      const canvasGraphicsFactory = {
        createCanvasGraphics: ctx => new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
          optionalContentConfig: this.optionalContentConfig,
          markedContentStack: this.markedContentStack
        })
      };
      pattern = new TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
    } else {
      pattern = this._getPattern(IR[1], IR[2]);
    }
    return pattern;
  }
  setStrokeColorN() {
    this.current.strokeColor = this.getColorN_Pattern(arguments);
  }
  setFillColorN() {
    this.current.fillColor = this.getColorN_Pattern(arguments);
    this.current.patternFill = true;
  }
  setStrokeRGBColor(r, g, b) {
    const color = Util.makeHexColor(r, g, b);
    this.ctx.strokeStyle = color;
    this.current.strokeColor = color;
  }
  setFillRGBColor(r, g, b) {
    const color = Util.makeHexColor(r, g, b);
    this.ctx.fillStyle = color;
    this.current.fillColor = color;
    this.current.patternFill = false;
  }
  _getPattern(objId, matrix = null) {
    let pattern;
    if (this.cachedPatterns.has(objId)) {
      pattern = this.cachedPatterns.get(objId);
    } else {
      pattern = getShadingPattern(this.getObject(objId));
      this.cachedPatterns.set(objId, pattern);
    }
    if (matrix) {
      pattern.matrix = matrix;
    }
    return pattern;
  }
  shadingFill(objId) {
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    this.save();
    const pattern = this._getPattern(objId);
    ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING);
    const inv = getCurrentTransformInverse(ctx);
    if (inv) {
      const {
        width,
        height
      } = ctx.canvas;
      const [x0, y0, x1, y1] = Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);
      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
    } else {
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    }
    this.compose(this.current.getClippedPathBoundingBox());
    this.restore();
  }
  beginInlineImage() {
    unreachable("Should not call beginInlineImage");
  }
  beginImageData() {
    unreachable("Should not call beginImageData");
  }
  paintFormXObjectBegin(matrix, bbox) {
    if (!this.contentVisible) {
      return;
    }
    this.save();
    this.baseTransformStack.push(this.baseTransform);
    if (matrix) {
      this.transform(...matrix);
    }
    this.baseTransform = getCurrentTransform(this.ctx);
    if (bbox) {
      const width = bbox[2] - bbox[0];
      const height = bbox[3] - bbox[1];
      this.ctx.rect(bbox[0], bbox[1], width, height);
      this.current.updateRectMinMax(getCurrentTransform(this.ctx), bbox);
      this.clip();
      this.endPath();
    }
  }
  paintFormXObjectEnd() {
    if (!this.contentVisible) {
      return;
    }
    this.restore();
    this.baseTransform = this.baseTransformStack.pop();
  }
  beginGroup(group) {
    if (!this.contentVisible) {
      return;
    }
    this.save();
    if (this.inSMaskMode) {
      this.endSMaskMode();
      this.current.activeSMask = null;
    }
    const currentCtx = this.ctx;
    if (!group.isolated) {
      info("TODO: Support non-isolated groups.");
    }
    if (group.knockout) {
      warn("Knockout groups not supported.");
    }
    const currentTransform = getCurrentTransform(currentCtx);
    if (group.matrix) {
      currentCtx.transform(...group.matrix);
    }
    if (!group.bbox) {
      throw new Error("Bounding box is required.");
    }
    let bounds = Util.getAxialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx));
    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
    bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
    const offsetX = Math.floor(bounds[0]);
    const offsetY = Math.floor(bounds[1]);
    const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
    const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
    let cacheId = "groupAt" + this.groupLevel;
    if (group.smask) {
      cacheId += "_smask_" + this.smaskCounter++ % 2;
    }
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    const groupCtx = scratchCanvas.context;
    groupCtx.translate(-offsetX, -offsetY);
    groupCtx.transform(...currentTransform);
    if (group.smask) {
      this.smaskStack.push({
        canvas: scratchCanvas.canvas,
        context: groupCtx,
        offsetX,
        offsetY,
        subtype: group.smask.subtype,
        backdrop: group.smask.backdrop,
        transferMap: group.smask.transferMap || null,
        startTransformInverse: null
      });
    } else {
      currentCtx.setTransform(1, 0, 0, 1, 0, 0);
      currentCtx.translate(offsetX, offsetY);
      currentCtx.save();
    }
    copyCtxState(currentCtx, groupCtx);
    this.ctx = groupCtx;
    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
    this.groupStack.push(currentCtx);
    this.groupLevel++;
  }
  endGroup(group) {
    if (!this.contentVisible) {
      return;
    }
    this.groupLevel--;
    const groupCtx = this.ctx;
    const ctx = this.groupStack.pop();
    this.ctx = ctx;
    this.ctx.imageSmoothingEnabled = false;
    if (group.smask) {
      this.tempSMask = this.smaskStack.pop();
      this.restore();
    } else {
      this.ctx.restore();
      const currentMtx = getCurrentTransform(this.ctx);
      this.restore();
      this.ctx.save();
      this.ctx.setTransform(...currentMtx);
      const dirtyBox = Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
      this.ctx.drawImage(groupCtx.canvas, 0, 0);
      this.ctx.restore();
      this.compose(dirtyBox);
    }
  }
  beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
    this.#restoreInitialState();
    resetCtxToDefault(this.ctx);
    this.ctx.save();
    this.save();
    if (this.baseTransform) {
      this.ctx.setTransform(...this.baseTransform);
    }
    if (rect) {
      const width = rect[2] - rect[0];
      const height = rect[3] - rect[1];
      if (hasOwnCanvas && this.annotationCanvasMap) {
        transform = transform.slice();
        transform[4] -= rect[0];
        transform[5] -= rect[1];
        rect = rect.slice();
        rect[0] = rect[1] = 0;
        rect[2] = width;
        rect[3] = height;
        const [scaleX, scaleY] = Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx));
        const {
          viewportScale
        } = this;
        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
        const {
          canvas,
          context
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(id, canvas);
        this.annotationCanvas.savedCtx = this.ctx;
        this.ctx = context;
        this.ctx.save();
        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
        resetCtxToDefault(this.ctx);
      } else {
        resetCtxToDefault(this.ctx);
        this.ctx.rect(rect[0], rect[1], width, height);
        this.ctx.clip();
        this.endPath();
      }
    }
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.transform(...transform);
    this.transform(...matrix);
  }
  endAnnotation() {
    if (this.annotationCanvas) {
      this.ctx.restore();
      this.#drawFilter();
      this.ctx = this.annotationCanvas.savedCtx;
      delete this.annotationCanvas.savedCtx;
      delete this.annotationCanvas;
    }
  }
  paintImageMaskXObject(img) {
    if (!this.contentVisible) {
      return;
    }
    const count = img.count;
    img = this.getObject(img.data, img);
    img.count = count;
    const ctx = this.ctx;
    const glyph = this.processingType3;
    if (glyph) {
      if (glyph.compiled === undefined) {
        glyph.compiled = compileType3Glyph(img);
      }
      if (glyph.compiled) {
        glyph.compiled(ctx);
        return;
      }
    }
    const mask = this._createMaskCanvas(img);
    const maskCanvas = mask.canvas;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
    ctx.restore();
    this.compose();
  }
  paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }
    img = this.getObject(img.data, img);
    const ctx = this.ctx;
    ctx.save();
    const currentTransform = getCurrentTransform(ctx);
    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
    const mask = this._createMaskCanvas(img);
    ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      const trans = Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
      const [x, y] = Util.applyTransform([0, 0], trans);
      ctx.drawImage(mask.canvas, x, y);
    }
    ctx.restore();
    this.compose();
  }
  paintImageMaskXObjectGroup(images) {
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    for (const image of images) {
      const {
        data,
        width,
        height,
        transform
      } = image;
      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      const maskCtx = maskCanvas.context;
      maskCtx.save();
      const img = this.getObject(data, image);
      putBinaryImageMask(maskCtx, img);
      maskCtx.globalCompositeOperation = "source-in";
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      ctx.save();
      ctx.transform(...transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
      ctx.restore();
    }
    this.compose();
  }
  paintImageXObject(objId) {
    if (!this.contentVisible) {
      return;
    }
    const imgData = this.getObject(objId);
    if (!imgData) {
      warn("Dependent image isn't ready yet");
      return;
    }
    this.paintInlineImageXObject(imgData);
  }
  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }
    const imgData = this.getObject(objId);
    if (!imgData) {
      warn("Dependent image isn't ready yet");
      return;
    }
    const width = imgData.width;
    const height = imgData.height;
    const map = [];
    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      map.push({
        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
        x: 0,
        y: 0,
        w: width,
        h: height
      });
    }
    this.paintInlineImageXObjectGroup(imgData, map);
  }
  applyTransferMapsToCanvas(ctx) {
    if (this.current.transferMaps !== "none") {
      ctx.filter = this.current.transferMaps;
      ctx.drawImage(ctx.canvas, 0, 0);
      ctx.filter = "none";
    }
    return ctx.canvas;
  }
  applyTransferMapsToBitmap(imgData) {
    if (this.current.transferMaps === "none") {
      return imgData.bitmap;
    }
    const {
      bitmap,
      width,
      height
    } = imgData;
    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
    const tmpCtx = tmpCanvas.context;
    tmpCtx.filter = this.current.transferMaps;
    tmpCtx.drawImage(bitmap, 0, 0);
    tmpCtx.filter = "none";
    return tmpCanvas.canvas;
  }
  paintInlineImageXObject(imgData) {
    if (!this.contentVisible) {
      return;
    }
    const width = imgData.width;
    const height = imgData.height;
    const ctx = this.ctx;
    this.save();
    if (!isNodeJS) {
      const {
        filter
      } = ctx;
      if (filter !== "none" && filter !== "") {
        ctx.filter = "none";
      }
    }
    ctx.scale(1 / width, -1 / height);
    let imgToPaint;
    if (imgData.bitmap) {
      imgToPaint = this.applyTransferMapsToBitmap(imgData);
    } else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
      imgToPaint = imgData;
    } else {
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);
      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
    }
    const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));
    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);
    drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
    this.compose();
    this.restore();
  }
  paintInlineImageXObjectGroup(imgData, map) {
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    let imgToPaint;
    if (imgData.bitmap) {
      imgToPaint = imgData.bitmap;
    } else {
      const w = imgData.width;
      const h = imgData.height;
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);
      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
    }
    for (const entry of map) {
      ctx.save();
      ctx.transform(...entry.transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
      ctx.restore();
    }
    this.compose();
  }
  paintSolidColorImageMask() {
    if (!this.contentVisible) {
      return;
    }
    this.ctx.fillRect(0, 0, 1, 1);
    this.compose();
  }
  markPoint(tag) {}
  markPointProps(tag, properties) {}
  beginMarkedContent(tag) {
    this.markedContentStack.push({
      visible: true
    });
  }
  beginMarkedContentProps(tag, properties) {
    if (tag === "OC") {
      this.markedContentStack.push({
        visible: this.optionalContentConfig.isVisible(properties)
      });
    } else {
      this.markedContentStack.push({
        visible: true
      });
    }
    this.contentVisible = this.isContentVisible();
  }
  endMarkedContent() {
    this.markedContentStack.pop();
    this.contentVisible = this.isContentVisible();
  }
  beginCompat() {}
  endCompat() {}
  consumePath(clipBox) {
    const isEmpty = this.current.isEmptyClip();
    if (this.pendingClip) {
      this.current.updateClipFromPath();
    }
    if (!this.pendingClip) {
      this.compose(clipBox);
    }
    const ctx = this.ctx;
    if (this.pendingClip) {
      if (!isEmpty) {
        if (this.pendingClip === EO_CLIP) {
          ctx.clip("evenodd");
        } else {
          ctx.clip();
        }
      }
      this.pendingClip = null;
    }
    this.current.startNewPathAndClipBox(this.current.clipBox);
    ctx.beginPath();
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const m = getCurrentTransform(this.ctx);
      if (m[1] === 0 && m[2] === 0) {
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
      } else {
        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
        const normX = Math.hypot(m[0], m[2]);
        const normY = Math.hypot(m[1], m[3]);
        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (this._cachedScaleForStroking[0] === -1) {
      const {
        lineWidth
      } = this.current;
      const {
        a,
        b,
        c,
        d
      } = this.ctx.getTransform();
      let scaleX, scaleY;
      if (b === 0 && c === 0) {
        const normX = Math.abs(a);
        const normY = Math.abs(d);
        if (normX === normY) {
          if (lineWidth === 0) {
            scaleX = scaleY = 1 / normX;
          } else {
            const scaledLineWidth = normX * lineWidth;
            scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
          }
        } else if (lineWidth === 0) {
          scaleX = 1 / normX;
          scaleY = 1 / normY;
        } else {
          const scaledXLineWidth = normX * lineWidth;
          const scaledYLineWidth = normY * lineWidth;
          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
        }
      } else {
        const absDet = Math.abs(a * d - b * c);
        const normX = Math.hypot(a, b);
        const normY = Math.hypot(c, d);
        if (lineWidth === 0) {
          scaleX = normY / absDet;
          scaleY = normX / absDet;
        } else {
          const baseArea = lineWidth * absDet;
          scaleX = normY > baseArea ? normY / baseArea : 1;
          scaleY = normX > baseArea ? normX / baseArea : 1;
        }
      }
      this._cachedScaleForStroking[0] = scaleX;
      this._cachedScaleForStroking[1] = scaleY;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(saveRestore) {
    const {
      ctx
    } = this;
    const {
      lineWidth
    } = this.current;
    const [scaleX, scaleY] = this.getScaleForStroking();
    ctx.lineWidth = lineWidth || 1;
    if (scaleX === 1 && scaleY === 1) {
      ctx.stroke();
      return;
    }
    const dashes = ctx.getLineDash();
    if (saveRestore) {
      ctx.save();
    }
    ctx.scale(scaleX, scaleY);
    if (dashes.length > 0) {
      const scale = Math.max(scaleX, scaleY);
      ctx.setLineDash(dashes.map(x => x / scale));
      ctx.lineDashOffset /= scale;
    }
    ctx.stroke();
    if (saveRestore) {
      ctx.restore();
    }
  }
  isContentVisible() {
    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
      if (!this.markedContentStack[i].visible) {
        return false;
      }
    }
    return true;
  }
}
for (const op in OPS) {
  if (CanvasGraphics.prototype[op] !== undefined) {
    CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
  }
}
class GlobalWorkerOptions {
  static #port = null;
  static #src = "";
  static get workerPort() {
    return this.#port;
  }
  static set workerPort(val) {
    if (!(typeof Worker !== "undefined" && val instanceof Worker) && val !== null) {
      throw new Error("Invalid `workerPort` type.");
    }
    this.#port = val;
  }
  static get workerSrc() {
    return this.#src;
  }
  static set workerSrc(val) {
    if (typeof val !== "string") {
      throw new Error("Invalid `workerSrc` type.");
    }
    this.#src = val;
  }
}

const CallbackKind = {
  DATA: 1,
  ERROR: 2
};
const StreamKind = {
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function wrapReason(reason) {
  if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
    unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  }
  switch (reason.name) {
    case "AbortException":
      return new AbortException(reason.message);
    case "MissingPDFException":
      return new MissingPDFException(reason.message);
    case "PasswordException":
      return new PasswordException(reason.message, reason.code);
    case "UnexpectedResponseException":
      return new UnexpectedResponseException(reason.message, reason.status);
    case "UnknownErrorException":
      return new UnknownErrorException(reason.message, reason.details);
    default:
      return new UnknownErrorException(reason.message, reason.toString());
  }
}
class MessageHandler {
  constructor(sourceName, targetName, comObj) {
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = Object.create(null);
    this.streamControllers = Object.create(null);
    this.callbackCapabilities = Object.create(null);
    this.actionHandler = Object.create(null);
    this._onComObjOnMessage = event => {
      const data = event.data;
      if (data.targetName !== this.sourceName) {
        return;
      }
      if (data.stream) {
        this.#processStreamMessage(data);
        return;
      }
      if (data.callback) {
        const callbackId = data.callbackId;
        const capability = this.callbackCapabilities[callbackId];
        if (!capability) {
          throw new Error(`Cannot resolve callback ${callbackId}`);
        }
        delete this.callbackCapabilities[callbackId];
        if (data.callback === CallbackKind.DATA) {
          capability.resolve(data.data);
        } else if (data.callback === CallbackKind.ERROR) {
          capability.reject(wrapReason(data.reason));
        } else {
          throw new Error("Unexpected callback case");
        }
        return;
      }
      const action = this.actionHandler[data.action];
      if (!action) {
        throw new Error(`Unknown action from worker: ${data.action}`);
      }
      if (data.callbackId) {
        const cbSourceName = this.sourceName;
        const cbTargetName = data.sourceName;
        new Promise(function (resolve) {
          resolve(action(data.data));
        }).then(function (result) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.DATA,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.ERROR,
            callbackId: data.callbackId,
            reason: wrapReason(reason)
          });
        });
        return;
      }
      if (data.streamId) {
        this.#createStreamSink(data);
        return;
      }
      action(data.data);
    };
    comObj.addEventListener("message", this._onComObjOnMessage);
  }
  on(actionName, handler) {
    const ah = this.actionHandler;
    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }
    ah[actionName] = handler;
  }
  send(actionName, data, transfers) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data
    }, transfers);
  }
  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = Promise.withResolvers();
    this.callbackCapabilities[callbackId] = capability;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }
    return capability.promise;
  }
  sendWithStream(actionName, data, queueingStrategy, transfers) {
    const streamId = this.streamId++,
      sourceName = this.sourceName,
      targetName = this.targetName,
      comObj = this.comObj;
    return new ReadableStream({
      start: controller => {
        const startCapability = Promise.withResolvers();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };
        comObj.postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data,
          desiredSize: controller.desiredSize
        }, transfers);
        return startCapability.promise;
      },
      pull: controller => {
        const pullCapability = Promise.withResolvers();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: reason => {
        assert(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = Promise.withResolvers();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  }
  #createStreamSink(data) {
    const streamId = data.streamId,
      sourceName = this.sourceName,
      targetName = data.sourceName,
      comObj = this.comObj;
    const self = this,
      action = this.actionHandler[data.action];
    const streamSink = {
      enqueue(chunk, size = 1, transfers) {
        if (this.isCancelled) {
          return;
        }
        const lastDesiredSize = this.desiredSize;
        this.desiredSize -= size;
        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = Promise.withResolvers();
          this.ready = this.sinkCapability.promise;
        }
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ENQUEUE,
          streamId,
          chunk
        }, transfers);
      },
      close() {
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CLOSE,
          streamId
        });
        delete self.streamSinks[streamId];
      },
      error(reason) {
        assert(reason instanceof Error, "error must have a valid reason");
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ERROR,
          streamId,
          reason: wrapReason(reason)
        });
      },
      sinkCapability: Promise.withResolvers(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: data.desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    new Promise(function (resolve) {
      resolve(action(data.data, streamSink));
    }).then(function () {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        success: true
      });
    }, function (reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        reason: wrapReason(reason)
      });
    });
  }
  #processStreamMessage(data) {
    const streamId = data.streamId,
      sourceName = this.sourceName,
      targetName = data.sourceName,
      comObj = this.comObj;
    const streamController = this.streamControllers[streamId],
      streamSink = this.streamSinks[streamId];
    switch (data.stream) {
      case StreamKind.START_COMPLETE:
        if (data.success) {
          streamController.startCall.resolve();
        } else {
          streamController.startCall.reject(wrapReason(data.reason));
        }
        break;
      case StreamKind.PULL_COMPLETE:
        if (data.success) {
          streamController.pullCall.resolve();
        } else {
          streamController.pullCall.reject(wrapReason(data.reason));
        }
        break;
      case StreamKind.PULL:
        if (!streamSink) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
          break;
        }
        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
          streamSink.sinkCapability.resolve();
        }
        streamSink.desiredSize = data.desiredSize;
        new Promise(function (resolve) {
          resolve(streamSink.onPull?.());
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        break;
      case StreamKind.ENQUEUE:
        assert(streamController, "enqueue should have stream controller");
        if (streamController.isClosed) {
          break;
        }
        streamController.controller.enqueue(data.chunk);
        break;
      case StreamKind.CLOSE:
        assert(streamController, "close should have stream controller");
        if (streamController.isClosed) {
          break;
        }
        streamController.isClosed = true;
        streamController.controller.close();
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.ERROR:
        assert(streamController, "error should have stream controller");
        streamController.controller.error(wrapReason(data.reason));
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.CANCEL_COMPLETE:
        if (data.success) {
          streamController.cancelCall.resolve();
        } else {
          streamController.cancelCall.reject(wrapReason(data.reason));
        }
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.CANCEL:
        if (!streamSink) {
          break;
        }
        new Promise(function (resolve) {
          resolve(streamSink.onCancel?.(wrapReason(data.reason)));
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        streamSink.sinkCapability.reject(wrapReason(data.reason));
        streamSink.isCancelled = true;
        delete this.streamSinks[streamId];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }
  async #deleteStreamController(streamController, streamId) {
    await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);
    delete this.streamControllers[streamId];
  }
  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }
}

class Metadata {
  #metadataMap;
  #data;
  constructor({
    parsedData,
    rawData
  }) {
    this.#metadataMap = parsedData;
    this.#data = rawData;
  }
  getRaw() {
    return this.#data;
  }
  get(name) {
    return this.#metadataMap.get(name) ?? null;
  }
  getAll() {
    return objectFromMap(this.#metadataMap);
  }
  has(name) {
    return this.#metadataMap.has(name);
  }
}


const INTERNAL = Symbol("INTERNAL");
class OptionalContentGroup {
  #isDisplay = false;
  #isPrint = false;
  #userSet = false;
  #visible = true;
  constructor(renderingIntent, {
    name,
    intent,
    usage
  }) {
    this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);
    this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
    this.name = name;
    this.intent = intent;
    this.usage = usage;
  }
  get visible() {
    if (this.#userSet) {
      return this.#visible;
    }
    if (!this.#visible) {
      return false;
    }
    const {
      print,
      view
    } = this.usage;
    if (this.#isDisplay) {
      return view?.viewState !== "OFF";
    } else if (this.#isPrint) {
      return print?.printState !== "OFF";
    }
    return true;
  }
  _setVisible(internal, visible, userSet = false) {
    if (internal !== INTERNAL) {
      unreachable("Internal method `_setVisible` called.");
    }
    this.#userSet = userSet;
    this.#visible = visible;
  }
}
class OptionalContentConfig {
  #cachedGetHash = null;
  #groups = new Map();
  #initialHash = null;
  #order = null;
  constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY) {
    this.renderingIntent = renderingIntent;
    this.name = null;
    this.creator = null;
    if (data === null) {
      return;
    }
    this.name = data.name;
    this.creator = data.creator;
    this.#order = data.order;
    for (const group of data.groups) {
      this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));
    }
    if (data.baseState === "OFF") {
      for (const group of this.#groups.values()) {
        group._setVisible(INTERNAL, false);
      }
    }
    for (const on of data.on) {
      this.#groups.get(on)._setVisible(INTERNAL, true);
    }
    for (const off of data.off) {
      this.#groups.get(off)._setVisible(INTERNAL, false);
    }
    this.#initialHash = this.getHash();
  }
  #evaluateVisibilityExpression(array) {
    const length = array.length;
    if (length < 2) {
      return true;
    }
    const operator = array[0];
    for (let i = 1; i < length; i++) {
      const element = array[i];
      let state;
      if (Array.isArray(element)) {
        state = this.#evaluateVisibilityExpression(element);
      } else if (this.#groups.has(element)) {
        state = this.#groups.get(element).visible;
      } else {
        warn(`Optional content group not found: ${element}`);
        return true;
      }
      switch (operator) {
        case "And":
          if (!state) {
            return false;
          }
          break;
        case "Or":
          if (state) {
            return true;
          }
          break;
        case "Not":
          return !state;
        default:
          return true;
      }
    }
    return operator === "And";
  }
  isVisible(group) {
    if (this.#groups.size === 0) {
      return true;
    }
    if (!group) {
      info("Optional content group not defined.");
      return true;
    }
    if (group.type === "OCG") {
      if (!this.#groups.has(group.id)) {
        warn(`Optional content group not found: ${group.id}`);
        return true;
      }
      return this.#groups.get(group.id).visible;
    } else if (group.type === "OCMD") {
      if (group.expression) {
        return this.#evaluateVisibilityExpression(group.expression);
      }
      if (!group.policy || group.policy === "AnyOn") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (this.#groups.get(id).visible) {
            return true;
          }
        }
        return false;
      } else if (group.policy === "AllOn") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (!this.#groups.get(id).visible) {
            return false;
          }
        }
        return true;
      } else if (group.policy === "AnyOff") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (!this.#groups.get(id).visible) {
            return true;
          }
        }
        return false;
      } else if (group.policy === "AllOff") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (this.#groups.get(id).visible) {
            return false;
          }
        }
        return true;
      }
      warn(`Unknown optional content policy ${group.policy}.`);
      return true;
    }
    warn(`Unknown group type ${group.type}.`);
    return true;
  }
  setVisibility(id, visible = true) {
    const group = this.#groups.get(id);
    if (!group) {
      warn(`Optional content group not found: ${id}`);
      return;
    }
    group._setVisible(INTERNAL, !!visible, true);
    this.#cachedGetHash = null;
  }
  setOCGState({
    state,
    preserveRB
  }) {
    let operator;
    for (const elem of state) {
      switch (elem) {
        case "ON":
        case "OFF":
        case "Toggle":
          operator = elem;
          continue;
      }
      const group = this.#groups.get(elem);
      if (!group) {
        continue;
      }
      switch (operator) {
        case "ON":
          group._setVisible(INTERNAL, true);
          break;
        case "OFF":
          group._setVisible(INTERNAL, false);
          break;
        case "Toggle":
          group._setVisible(INTERNAL, !group.visible);
          break;
      }
    }
    this.#cachedGetHash = null;
  }
  get hasInitialVisibility() {
    return this.#initialHash === null || this.getHash() === this.#initialHash;
  }
  getOrder() {
    if (!this.#groups.size) {
      return null;
    }
    if (this.#order) {
      return this.#order.slice();
    }
    return [...this.#groups.keys()];
  }
  getGroups() {
    return this.#groups.size > 0 ? objectFromMap(this.#groups) : null;
  }
  getGroup(id) {
    return this.#groups.get(id) || null;
  }
  getHash() {
    if (this.#cachedGetHash !== null) {
      return this.#cachedGetHash;
    }
    const hash = new MurmurHash3_64();
    for (const [id, group] of this.#groups) {
      hash.update(`${id}:${group.visible}`);
    }
    return this.#cachedGetHash = hash.hexdigest();
  }
}


class PDFDataTransportStream {
  constructor(pdfDataRangeTransport, {
    disableRange = false,
    disableStream = false
  }) {
    assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const {
      length,
      initialData,
      progressiveDone,
      contentDispositionFilename
    } = pdfDataRangeTransport;
    this._queuedChunks = [];
    this._progressiveDone = progressiveDone;
    this._contentDispositionFilename = contentDispositionFilename;
    if (initialData?.length > 0) {
      const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
      this._queuedChunks.push(buffer);
    }
    this._pdfDataRangeTransport = pdfDataRangeTransport;
    this._isStreamingSupported = !disableStream;
    this._isRangeSupported = !disableRange;
    this._contentLength = length;
    this._fullRequestReader = null;
    this._rangeReaders = [];
    pdfDataRangeTransport.addRangeListener((begin, chunk) => {
      this._onReceiveData({
        begin,
        chunk
      });
    });
    pdfDataRangeTransport.addProgressListener((loaded, total) => {
      this._onProgress({
        loaded,
        total
      });
    });
    pdfDataRangeTransport.addProgressiveReadListener(chunk => {
      this._onReceiveData({
        chunk
      });
    });
    pdfDataRangeTransport.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    });
    pdfDataRangeTransport.transportReady();
  }
  _onReceiveData({
    begin,
    chunk
  }) {
    const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;
    if (begin === undefined) {
      if (this._fullRequestReader) {
        this._fullRequestReader._enqueue(buffer);
      } else {
        this._queuedChunks.push(buffer);
      }
    } else {
      const found = this._rangeReaders.some(function (rangeReader) {
        if (rangeReader._begin !== begin) {
          return false;
        }
        rangeReader._enqueue(buffer);
        return true;
      });
      assert(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  _onProgress(evt) {
    if (evt.total === undefined) {
      this._rangeReaders[0]?.onProgress?.({
        loaded: evt.loaded
      });
    } else {
      this._fullRequestReader?.onProgress?.({
        loaded: evt.loaded,
        total: evt.total
      });
    }
  }
  _onProgressiveDone() {
    this._fullRequestReader?.progressiveDone();
    this._progressiveDone = true;
  }
  _removeRangeReader(reader) {
    const i = this._rangeReaders.indexOf(reader);
    if (i >= 0) {
      this._rangeReaders.splice(i, 1);
    }
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const queuedChunks = this._queuedChunks;
    this._queuedChunks = null;
    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
    this._pdfDataRangeTransport.requestDataRange(begin, end);
    this._rangeReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeReaders.slice(0)) {
      reader.cancel(reason);
    }
    this._pdfDataRangeTransport.abort();
  }
}
class PDFDataTransportStreamReader {
  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
    this._stream = stream;
    this._done = progressiveDone || false;
    this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;
    this._queuedChunks = queuedChunks || [];
    this._loaded = 0;
    for (const chunk of this._queuedChunks) {
      this._loaded += chunk.byteLength;
    }
    this._requests = [];
    this._headersReady = Promise.resolve();
    stream._fullRequestReader = this;
    this.onProgress = null;
  }
  _enqueue(chunk) {
    if (this._done) {
      return;
    }
    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunks.push(chunk);
    }
    this._loaded += chunk.byteLength;
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0) {
      const chunk = this._queuedChunks.shift();
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }
    this._requests.length = 0;
  }
  progressiveDone() {
    if (this._done) {
      return;
    }
    this._done = true;
  }
}
class PDFDataTransportStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._begin = begin;
    this._end = end;
    this._queuedChunk = null;
    this._requests = [];
    this._done = false;
    this.onProgress = null;
  }
  _enqueue(chunk) {
    if (this._done) {
      return;
    }
    if (this._requests.length === 0) {
      this._queuedChunk = chunk;
    } else {
      const requestsCapability = this._requests.shift();
      requestsCapability.resolve({
        value: chunk,
        done: false
      });
      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      }
      this._requests.length = 0;
    }
    this._done = true;
    this._stream._removeRangeReader(this);
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._queuedChunk) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }
    this._requests.length = 0;
    this._stream._removeRangeReader(this);
  }
}

function getFilenameFromContentDispositionHeader(contentDisposition) {
  let needsEncodingFixup = true;
  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = unescape(filename);
    filename = rfc5987decode(filename);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  tmp = rfc2231getparam(contentDisposition);
  if (tmp) {
    const filename = rfc2047decode(tmp);
    return fixupEncoding(filename);
  }
  tmp = toParamRegExp("filename", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  function toParamRegExp(attributePattern, flags) {
    return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
  }
  function textdecode(encoding, value) {
    if (encoding) {
      if (!/^[\x00-\xFF]+$/.test(value)) {
        return value;
      }
      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = stringToBytes(value);
        value = decoder.decode(buffer);
        needsEncodingFixup = false;
      } catch {}
    }
    return value;
  }
  function fixupEncoding(value) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
      value = textdecode("utf-8", value);
      if (needsEncodingFixup) {
        value = textdecode("iso-8859-1", value);
      }
    }
    return value;
  }
  function rfc2231getparam(contentDispositionStr) {
    const matches = [];
    let match;
    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    while ((match = iter.exec(contentDispositionStr)) !== null) {
      let [, n, quot, part] = match;
      n = parseInt(n, 10);
      if (n in matches) {
        if (n === 0) {
          break;
        }
        continue;
      }
      matches[n] = [quot, part];
    }
    const parts = [];
    for (let n = 0; n < matches.length; ++n) {
      if (!(n in matches)) {
        break;
      }
      let [quot, part] = matches[n];
      part = rfc2616unquote(part);
      if (quot) {
        part = unescape(part);
        if (n === 0) {
          part = rfc5987decode(part);
        }
      }
      parts.push(part);
    }
    return parts.join("");
  }
  function rfc2616unquote(value) {
    if (value.startsWith('"')) {
      const parts = value.slice(1).split('\\"');
      for (let i = 0; i < parts.length; ++i) {
        const quotindex = parts[i].indexOf('"');
        if (quotindex !== -1) {
          parts[i] = parts[i].slice(0, quotindex);
          parts.length = i + 1;
        }
        parts[i] = parts[i].replaceAll(/\\(.)/g, "$1");
      }
      value = parts.join('"');
    }
    return value;
  }
  function rfc5987decode(extvalue) {
    const encodingend = extvalue.indexOf("'");
    if (encodingend === -1) {
      return extvalue;
    }
    const encoding = extvalue.slice(0, encodingend);
    const langvalue = extvalue.slice(encodingend + 1);
    const value = langvalue.replace(/^[^']*'/, "");
    return textdecode(encoding, value);
  }
  function rfc2047decode(value) {
    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
      return value;
    }
    return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
      if (encoding === "q" || encoding === "Q") {
        text = text.replaceAll("_", " ");
        text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function (match, hex) {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return textdecode(charset, text);
      }
      try {
        text = atob(text);
      } catch {}
      return textdecode(charset, text);
    });
  }
  return "";
}



function validateRangeRequestCapabilities({
  getResponseHeader,
  isHttp,
  rangeChunkSize,
  disableRange
}) {
  const returnValues = {
    allowRangeRequests: false,
    suggestedLength: undefined
  };
  const length = parseInt(getResponseHeader("Content-Length"), 10);
  if (!Number.isInteger(length)) {
    return returnValues;
  }
  returnValues.suggestedLength = length;
  if (length <= 2 * rangeChunkSize) {
    return returnValues;
  }
  if (disableRange || !isHttp) {
    return returnValues;
  }
  if (getResponseHeader("Accept-Ranges") !== "bytes") {
    return returnValues;
  }
  const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
  if (contentEncoding !== "identity") {
    return returnValues;
  }
  returnValues.allowRangeRequests = true;
  return returnValues;
}
function extractFilenameFromHeader(getResponseHeader) {
  const contentDisposition = getResponseHeader("Content-Disposition");
  if (contentDisposition) {
    let filename = getFilenameFromContentDispositionHeader(contentDisposition);
    if (filename.includes("%")) {
      try {
        filename = decodeURIComponent(filename);
      } catch {}
    }
    if (isPdfFile(filename)) {
      return filename;
    }
  }
  return null;
}
function createResponseStatusError(status, url) {
  if (status === 404 || status === 0 && url.startsWith("file:")) {
    return new MissingPDFException('Missing PDF "' + url + '".');
  }
  return new UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
}
function validateResponseStatus(status) {
  return status === 200 || status === 206;
}


function createFetchOptions(headers, withCredentials, abortController) {
  return {
    method: "GET",
    headers,
    signal: abortController.signal,
    mode: "cors",
    credentials: withCredentials ? "include" : "same-origin",
    redirect: "follow"
  };
}
function createHeaders(httpHeaders) {
  const headers = new Headers();
  for (const property in httpHeaders) {
    const value = httpHeaders[property];
    if (value === undefined) {
      continue;
    }
    headers.append(property, value);
  }
  return headers;
}
function getArrayBuffer(val) {
  if (val instanceof Uint8Array) {
    return val.buffer;
  }
  if (val instanceof ArrayBuffer) {
    return val;
  }
  warn(`getArrayBuffer - unexpected data format: ${val}`);
  return new Uint8Array(val).buffer;
}
class PDFFetchStream {
  constructor(source) {
    this.source = source;
    this.isHttp = /^https?:/i.test(source.url);
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFFetchStreamReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const reader = new PDFFetchStreamRangeReader(this, begin, end);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
}
class PDFFetchStreamReader {
  constructor(stream) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    this._filename = null;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._contentLength = source.length;
    this._headersCapability = Promise.withResolvers();
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._abortController = new AbortController();
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._headers = createHeaders(this._stream.httpHeaders);
    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
      if (!validateResponseStatus(response.status)) {
        throw createResponseStatusError(response.status, url);
      }
      this._reader = response.body.getReader();
      this._headersCapability.resolve();
      const getResponseHeader = name => response.headers.get(name);
      const {
        allowRangeRequests,
        suggestedLength
      } = validateRangeRequestCapabilities({
        getResponseHeader,
        isHttp: this._stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = extractFilenameFromHeader(getResponseHeader);
      if (!this._isStreamingSupported && this._isRangeSupported) {
        this.cancel(new AbortException("Streaming is disabled."));
      }
    }).catch(this._headersCapability.reject);
    this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._headersCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value,
        done
      };
    }
    this._loaded += value.byteLength;
    this.onProgress?.({
      loaded: this._loaded,
      total: this._contentLength
    });
    return {
      value: getArrayBuffer(value),
      done: false
    };
  }
  cancel(reason) {
    this._reader?.cancel(reason);
    this._abortController.abort();
  }
}
class PDFFetchStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._readCapability = Promise.withResolvers();
    this._isStreamingSupported = !source.disableStream;
    this._abortController = new AbortController();
    this._headers = createHeaders(this._stream.httpHeaders);
    this._headers.append("Range", `bytes=${begin}-${end - 1}`);
    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
      if (!validateResponseStatus(response.status)) {
        throw createResponseStatusError(response.status, url);
      }
      this._readCapability.resolve();
      this._reader = response.body.getReader();
    }).catch(this._readCapability.reject);
    this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value,
        done
      };
    }
    this._loaded += value.byteLength;
    this.onProgress?.({
      loaded: this._loaded
    });
    return {
      value: getArrayBuffer(value),
      done: false
    };
  }
  cancel(reason) {
    this._reader?.cancel(reason);
    this._abortController.abort();
  }
}


const OK_RESPONSE = 200;
const PARTIAL_CONTENT_RESPONSE = 206;
function network_getArrayBuffer(xhr) {
  const data = xhr.response;
  if (typeof data !== "string") {
    return data;
  }
  return stringToBytes(data).buffer;
}
class NetworkManager {
  constructor(url, args = {}) {
    this.url = url;
    this.isHttp = /^https?:/i.test(url);
    this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);
    this.withCredentials = args.withCredentials || false;
    this.currXhrId = 0;
    this.pendingRequests = Object.create(null);
  }
  requestRange(begin, end, listeners) {
    const args = {
      begin,
      end
    };
    for (const prop in listeners) {
      args[prop] = listeners[prop];
    }
    return this.request(args);
  }
  requestFull(listeners) {
    return this.request(listeners);
  }
  request(args) {
    const xhr = new XMLHttpRequest();
    const xhrId = this.currXhrId++;
    const pendingRequest = this.pendingRequests[xhrId] = {
      xhr
    };
    xhr.open("GET", this.url);
    xhr.withCredentials = this.withCredentials;
    for (const property in this.httpHeaders) {
      const value = this.httpHeaders[property];
      if (value === undefined) {
        continue;
      }
      xhr.setRequestHeader(property, value);
    }
    if (this.isHttp && "begin" in args && "end" in args) {
      xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
    } else {
      pendingRequest.expectedStatus = OK_RESPONSE;
    }
    xhr.responseType = "arraybuffer";
    if (args.onError) {
      xhr.onerror = function (evt) {
        args.onError(xhr.status);
      };
    }
    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
    xhr.onprogress = this.onProgress.bind(this, xhrId);
    pendingRequest.onHeadersReceived = args.onHeadersReceived;
    pendingRequest.onDone = args.onDone;
    pendingRequest.onError = args.onError;
    pendingRequest.onProgress = args.onProgress;
    xhr.send(null);
    return xhrId;
  }
  onProgress(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    pendingRequest.onProgress?.(evt);
  }
  onStateChange(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    const xhr = pendingRequest.xhr;
    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
      pendingRequest.onHeadersReceived();
      delete pendingRequest.onHeadersReceived;
    }
    if (xhr.readyState !== 4) {
      return;
    }
    if (!(xhrId in this.pendingRequests)) {
      return;
    }
    delete this.pendingRequests[xhrId];
    if (xhr.status === 0 && this.isHttp) {
      pendingRequest.onError?.(xhr.status);
      return;
    }
    const xhrStatus = xhr.status || OK_RESPONSE;
    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
      pendingRequest.onError?.(xhr.status);
      return;
    }
    const chunk = network_getArrayBuffer(xhr);
    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
      const rangeHeader = xhr.getResponseHeader("Content-Range");
      const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
      pendingRequest.onDone({
        begin: parseInt(matches[1], 10),
        chunk
      });
    } else if (chunk) {
      pendingRequest.onDone({
        begin: 0,
        chunk
      });
    } else {
      pendingRequest.onError?.(xhr.status);
    }
  }
  getRequestXhr(xhrId) {
    return this.pendingRequests[xhrId].xhr;
  }
  isPendingRequest(xhrId) {
    return xhrId in this.pendingRequests;
  }
  abortRequest(xhrId) {
    const xhr = this.pendingRequests[xhrId].xhr;
    delete this.pendingRequests[xhrId];
    xhr.abort();
  }
}
class PDFNetworkStream {
  constructor(source) {
    this._source = source;
    this._manager = new NetworkManager(source.url, {
      httpHeaders: source.httpHeaders,
      withCredentials: source.withCredentials
    });
    this._rangeChunkSize = source.rangeChunkSize;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(reader) {
    const i = this._rangeRequestReaders.indexOf(reader);
    if (i >= 0) {
      this._rangeRequestReaders.splice(i, 1);
    }
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
}
class PDFNetworkStreamFullRequestReader {
  constructor(manager, source) {
    this._manager = manager;
    const args = {
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = source.url;
    this._fullRequestId = manager.requestFull(args);
    this._headersReceivedCapability = Promise.withResolvers();
    this._disableRange = source.disableRange || false;
    this._contentLength = source.length;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._isStreamingSupported = false;
    this._isRangeSupported = false;
    this._cachedChunks = [];
    this._requests = [];
    this._done = false;
    this._storedError = undefined;
    this._filename = null;
    this.onProgress = null;
  }
  _onHeadersReceived() {
    const fullRequestXhrId = this._fullRequestId;
    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
    const getResponseHeader = name => fullRequestXhr.getResponseHeader(name);
    const {
      allowRangeRequests,
      suggestedLength
    } = validateRangeRequestCapabilities({
      getResponseHeader,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });
    if (allowRangeRequests) {
      this._isRangeSupported = true;
    }
    this._contentLength = suggestedLength || this._contentLength;
    this._filename = extractFilenameFromHeader(getResponseHeader);
    if (this._isRangeSupported) {
      this._manager.abortRequest(fullRequestXhrId);
    }
    this._headersReceivedCapability.resolve();
  }
  _onDone(data) {
    if (data) {
      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();
        requestCapability.resolve({
          value: data.chunk,
          done: false
        });
      } else {
        this._cachedChunks.push(data.chunk);
      }
    }
    this._done = true;
    if (this._cachedChunks.length > 0) {
      return;
    }
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }
    this._requests.length = 0;
  }
  _onError(status) {
    this._storedError = createResponseStatusError(status, this._url);
    this._headersReceivedCapability.reject(this._storedError);
    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }
    this._requests.length = 0;
    this._cachedChunks.length = 0;
  }
  _onProgress(evt) {
    this.onProgress?.({
      loaded: evt.loaded,
      total: evt.lengthComputable ? evt.total : this._contentLength
    });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersReceivedCapability.promise;
  }
  async read() {
    if (this._storedError) {
      throw this._storedError;
    }
    if (this._cachedChunks.length > 0) {
      const chunk = this._cachedChunks.shift();
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    this._headersReceivedCapability.reject(reason);
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }
    this._requests.length = 0;
    if (this._manager.isPendingRequest(this._fullRequestId)) {
      this._manager.abortRequest(this._fullRequestId);
    }
    this._fullRequestReader = null;
  }
}
class PDFNetworkStreamRangeRequestReader {
  constructor(manager, begin, end) {
    this._manager = manager;
    const args = {
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = manager.url;
    this._requestId = manager.requestRange(begin, end, args);
    this._requests = [];
    this._queuedChunk = null;
    this._done = false;
    this._storedError = undefined;
    this.onProgress = null;
    this.onClosed = null;
  }
  _close() {
    this.onClosed?.(this);
  }
  _onDone(data) {
    const chunk = data.chunk;
    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunk = chunk;
    }
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }
    this._requests.length = 0;
    this._close();
  }
  _onError(status) {
    this._storedError = createResponseStatusError(status, this._url);
    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }
    this._requests.length = 0;
    this._queuedChunk = null;
  }
  _onProgress(evt) {
    if (!this.isStreamingSupported) {
      this.onProgress?.({
        loaded: evt.loaded
      });
    }
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._storedError) {
      throw this._storedError;
    }
    if (this._queuedChunk !== null) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }
    this._requests.length = 0;
    if (this._manager.isPendingRequest(this._requestId)) {
      this._manager.abortRequest(this._requestId);
    }
    this._close();
  }
}



const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
function parseUrl(sourceUrl) {
  const url = NodePackages.get("url");
  const parsedUrl = url.parse(sourceUrl);
  if (parsedUrl.protocol === "file:" || parsedUrl.host) {
    return parsedUrl;
  }
  if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
    return url.parse(`file:///${sourceUrl}`);
  }
  if (!parsedUrl.host) {
    parsedUrl.protocol = "file:";
  }
  return parsedUrl;
}
class PDFNodeStream {
  constructor(source) {
    this.source = source;
    this.url = parseUrl(source.url);
    this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
    this.isFsUrl = this.url.protocol === "file:";
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(start, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
    this._rangeRequestReaders.push(rangeReader);
    return rangeReader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
}
class BaseFullReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    const source = stream.source;
    this._contentLength = source.length;
    this._loaded = 0;
    this._filename = null;
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._readableStream = null;
    this._readCapability = Promise.withResolvers();
    this._headersCapability = Promise.withResolvers();
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }
    if (this._storedError) {
      throw this._storedError;
    }
    const chunk = this._readableStream.read();
    if (chunk === null) {
      this._readCapability = Promise.withResolvers();
      return this.read();
    }
    this._loaded += chunk.length;
    this.onProgress?.({
      loaded: this._loaded,
      total: this._contentLength
    });
    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }
  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);
      return;
    }
    this._readableStream.destroy(reason);
  }
  _error(reason) {
    this._storedError = reason;
    this._readCapability.resolve();
  }
  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    readableStream.on("error", reason => {
      this._error(reason);
    });
    if (!this._isStreamingSupported && this._isRangeSupported) {
      this._error(new AbortException("streaming is disabled"));
    }
    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }
}
class BaseRangeReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    this._loaded = 0;
    this._readableStream = null;
    this._readCapability = Promise.withResolvers();
    const source = stream.source;
    this._isStreamingSupported = !source.disableStream;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }
    if (this._storedError) {
      throw this._storedError;
    }
    const chunk = this._readableStream.read();
    if (chunk === null) {
      this._readCapability = Promise.withResolvers();
      return this.read();
    }
    this._loaded += chunk.length;
    this.onProgress?.({
      loaded: this._loaded
    });
    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }
  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);
      return;
    }
    this._readableStream.destroy(reason);
  }
  _error(reason) {
    this._storedError = reason;
    this._readCapability.resolve();
  }
  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    readableStream.on("error", reason => {
      this._error(reason);
    });
    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }
}
function createRequestOptions(parsedUrl, headers) {
  return {
    protocol: parsedUrl.protocol,
    auth: parsedUrl.auth,
    host: parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.path,
    method: "GET",
    headers
  };
}
class PDFNodeStreamFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);
    const handleResponse = response => {
      if (response.statusCode === 404) {
        const error = new MissingPDFException(`Missing PDF "${this._url}".`);
        this._storedError = error;
        this._headersCapability.reject(error);
        return;
      }
      this._headersCapability.resolve();
      this._setReadableStream(response);
      const getResponseHeader = name => this._readableStream.headers[name.toLowerCase()];
      const {
        allowRangeRequests,
        suggestedLength
      } = validateRangeRequestCapabilities({
        getResponseHeader,
        isHttp: stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = extractFilenameFromHeader(getResponseHeader);
    };
    this._request = null;
    if (this._url.protocol === "http:") {
      const http = NodePackages.get("http");
      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    } else {
      const https = NodePackages.get("https");
      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    }
    this._request.on("error", reason => {
      this._storedError = reason;
      this._headersCapability.reject(reason);
    });
    this._request.end();
  }
}
class PDFNodeStreamRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    this._httpHeaders = {};
    for (const property in stream.httpHeaders) {
      const value = stream.httpHeaders[property];
      if (value === undefined) {
        continue;
      }
      this._httpHeaders[property] = value;
    }
    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;
    const handleResponse = response => {
      if (response.statusCode === 404) {
        const error = new MissingPDFException(`Missing PDF "${this._url}".`);
        this._storedError = error;
        return;
      }
      this._setReadableStream(response);
    };
    this._request = null;
    if (this._url.protocol === "http:") {
      const http = NodePackages.get("http");
      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    } else {
      const https = NodePackages.get("https");
      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    }
    this._request.on("error", reason => {
      this._storedError = reason;
    });
    this._request.end();
  }
}
class PDFNodeStreamFsFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);
    let path = decodeURIComponent(this._url.path);
    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }
    const fs = NodePackages.get("fs");
    fs.promises.lstat(path).then(stat => {
      this._contentLength = stat.size;
      this._setReadableStream(fs.createReadStream(path));
      this._headersCapability.resolve();
    }, error => {
      if (error.code === "ENOENT") {
        error = new MissingPDFException(`Missing PDF "${path}".`);
      }
      this._storedError = error;
      this._headersCapability.reject(error);
    });
  }
}
class PDFNodeStreamFsRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    let path = decodeURIComponent(this._url.path);
    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }
    const fs = NodePackages.get("fs");
    this._setReadableStream(fs.createReadStream(path, {
      start,
      end: end - 1
    }));
  }
}


const MAX_TEXT_DIVS_TO_RENDER = 100000;
const DEFAULT_FONT_SIZE = 30;
const DEFAULT_FONT_ASCENT = 0.8;
class TextLayer {
  #capability = Promise.withResolvers();
  #container = null;
  #disableProcessItems = false;
  #fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
  #lang = null;
  #layoutTextParams = null;
  #pageHeight = 0;
  #pageWidth = 0;
  #reader = null;
  #rootContainer = null;
  #rotation = 0;
  #scale = 0;
  #styleCache = Object.create(null);
  #textContentItemsStr = [];
  #textContentSource = null;
  #textDivs = [];
  #textDivProperties = new WeakMap();
  #transform = null;
  static #ascentCache = new Map();
  static #canvasContexts = new Map();
  static #minFontSize = null;
  static #pendingTextLayers = new Set();
  constructor({
    textContentSource,
    container,
    viewport
  }) {
    if (textContentSource instanceof ReadableStream) {
      this.#textContentSource = textContentSource;
    } else if (typeof textContentSource === "object") {
      this.#textContentSource = new ReadableStream({
        start(controller) {
          controller.enqueue(textContentSource);
          controller.close();
        }
      });
    } else {
      throw new Error('No "textContentSource" parameter specified.');
    }
    this.#container = this.#rootContainer = container;
    this.#scale = viewport.scale * (globalThis.devicePixelRatio || 1);
    this.#rotation = viewport.rotation;
    this.#layoutTextParams = {
      prevFontSize: null,
      prevFontFamily: null,
      div: null,
      properties: null,
      ctx: null
    };
    const {
      pageWidth,
      pageHeight,
      pageX,
      pageY
    } = viewport.rawDims;
    this.#transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];
    this.#pageWidth = pageWidth;
    this.#pageHeight = pageHeight;
    TextLayer.#ensureMinFontSizeComputed();
    setLayerDimensions(container, viewport);
    this.#capability.promise.catch(() => {}).then(() => {
      TextLayer.#pendingTextLayers.delete(this);
      this.#layoutTextParams = null;
      this.#styleCache = null;
    });
  }
  render() {
    const pump = () => {
      this.#reader.read().then(({
        value,
        done
      }) => {
        if (done) {
          this.#capability.resolve();
          return;
        }
        this.#lang ??= value.lang;
        Object.assign(this.#styleCache, value.styles);
        this.#processItems(value.items);
        pump();
      }, this.#capability.reject);
    };
    this.#reader = this.#textContentSource.getReader();
    TextLayer.#pendingTextLayers.add(this);
    pump();
    return this.#capability.promise;
  }
  update({
    viewport,
    onBefore = null
  }) {
    const scale = viewport.scale * (globalThis.devicePixelRatio || 1);
    const rotation = viewport.rotation;
    if (rotation !== this.#rotation) {
      onBefore?.();
      this.#rotation = rotation;
      setLayerDimensions(this.#rootContainer, {
        rotation
      });
    }
    if (scale !== this.#scale) {
      onBefore?.();
      this.#scale = scale;
      const params = {
        prevFontSize: null,
        prevFontFamily: null,
        div: null,
        properties: null,
        ctx: TextLayer.#getCtx(this.#lang)
      };
      for (const div of this.#textDivs) {
        params.properties = this.#textDivProperties.get(div);
        params.div = div;
        this.#layout(params);
      }
    }
  }
  cancel() {
    const abortEx = new AbortException("TextLayer task cancelled.");
    this.#reader?.cancel(abortEx).catch(() => {});
    this.#reader = null;
    this.#capability.reject(abortEx);
  }
  get textDivs() {
    return this.#textDivs;
  }
  get textContentItemsStr() {
    return this.#textContentItemsStr;
  }
  #processItems(items) {
    if (this.#disableProcessItems) {
      return;
    }
    this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);
    const textDivs = this.#textDivs,
      textContentItemsStr = this.#textContentItemsStr;
    for (const item of items) {
      if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {
        warn("Ignoring additional textDivs for performance reasons.");
        this.#disableProcessItems = true;
        return;
      }
      if (item.str === undefined) {
        if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
          const parent = this.#container;
          this.#container = document.createElement("span");
          this.#container.classList.add("markedContent");
          if (item.id !== null) {
            this.#container.setAttribute("id", `${item.id}`);
          }
          parent.append(this.#container);
        } else if (item.type === "endMarkedContent") {
          this.#container = this.#container.parentNode;
        }
        continue;
      }
      textContentItemsStr.push(item.str);
      this.#appendText(item);
    }
  }
  #appendText(geom) {
    const textDiv = document.createElement("span");
    const textDivProperties = {
      angle: 0,
      canvasWidth: 0,
      hasText: geom.str !== "",
      hasEOL: geom.hasEOL,
      fontSize: 0
    };
    this.#textDivs.push(textDiv);
    const tx = Util.transform(this.#transform, geom.transform);
    let angle = Math.atan2(tx[1], tx[0]);
    const style = this.#styleCache[geom.fontName];
    if (style.vertical) {
      angle += Math.PI / 2;
    }
    const fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;
    const fontHeight = Math.hypot(tx[2], tx[3]);
    const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, this.#lang);
    let left, top;
    if (angle === 0) {
      left = tx[4];
      top = tx[5] - fontAscent;
    } else {
      left = tx[4] + fontAscent * Math.sin(angle);
      top = tx[5] - fontAscent * Math.cos(angle);
    }
    const scaleFactorStr = "calc(var(--scale-factor)*";
    const divStyle = textDiv.style;
    if (this.#container === this.#rootContainer) {
      divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;
      divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;
    } else {
      divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;
      divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;
    }
    divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;
    divStyle.fontFamily = fontFamily;
    textDivProperties.fontSize = fontHeight;
    textDiv.setAttribute("role", "presentation");
    textDiv.textContent = geom.str;
    textDiv.dir = geom.dir;
    if (this.#fontInspectorEnabled) {
      textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;
    }
    if (angle !== 0) {
      textDivProperties.angle = angle * (180 / Math.PI);
    }
    let shouldScaleText = false;
    if (geom.str.length > 1) {
      shouldScaleText = true;
    } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
      const absScaleX = Math.abs(geom.transform[0]),
        absScaleY = Math.abs(geom.transform[3]);
      if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
        shouldScaleText = true;
      }
    }
    if (shouldScaleText) {
      textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;
    }
    this.#textDivProperties.set(textDiv, textDivProperties);
    this.#layoutTextParams.div = textDiv;
    this.#layoutTextParams.properties = textDivProperties;
    this.#layout(this.#layoutTextParams);
    if (textDivProperties.hasText) {
      this.#container.append(textDiv);
    }
    if (textDivProperties.hasEOL) {
      const br = document.createElement("br");
      br.setAttribute("role", "presentation");
      this.#container.append(br);
    }
  }
  #layout(params) {
    const {
      div,
      properties,
      ctx,
      prevFontSize,
      prevFontFamily
    } = params;
    const {
      style
    } = div;
    let transform = "";
    if (TextLayer.#minFontSize > 1) {
      transform = `scale(${1 / TextLayer.#minFontSize})`;
    }
    if (properties.canvasWidth !== 0 && properties.hasText) {
      const {
        fontFamily
      } = style;
      const {
        canvasWidth,
        fontSize
      } = properties;
      if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) {
        ctx.font = `${fontSize * this.#scale}px ${fontFamily}`;
        params.prevFontSize = fontSize;
        params.prevFontFamily = fontFamily;
      }
      const {
        width
      } = ctx.measureText(div.textContent);
      if (width > 0) {
        transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;
      }
    }
    if (properties.angle !== 0) {
      transform = `rotate(${properties.angle}deg) ${transform}`;
    }
    if (transform.length > 0) {
      style.transform = transform;
    }
  }
  static cleanup() {
    if (this.#pendingTextLayers.size > 0) {
      return;
    }
    this.#ascentCache.clear();
    for (const {
      canvas
    } of this.#canvasContexts.values()) {
      canvas.remove();
    }
    this.#canvasContexts.clear();
  }
  static #getCtx(lang = null) {
    let canvasContext = this.#canvasContexts.get(lang ||= "");
    if (!canvasContext) {
      const canvas = document.createElement("canvas");
      canvas.className = "hiddenCanvasElement";
      canvas.lang = lang;
      document.body.append(canvas);
      canvasContext = canvas.getContext("2d", {
        alpha: false,
        willReadFrequently: true
      });
      this.#canvasContexts.set(lang, canvasContext);
    }
    return canvasContext;
  }
  static #ensureMinFontSizeComputed() {
    if (this.#minFontSize !== null) {
      return;
    }
    const div = document.createElement("div");
    div.style.opacity = 0;
    div.style.lineHeight = 1;
    div.style.fontSize = "1px";
    div.textContent = "X";
    document.body.append(div);
    this.#minFontSize = div.getBoundingClientRect().height;
    div.remove();
  }
  static #getAscent(fontFamily, lang) {
    const cachedAscent = this.#ascentCache.get(fontFamily);
    if (cachedAscent) {
      return cachedAscent;
    }
    const ctx = this.#getCtx(lang);
    const savedFont = ctx.font;
    ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;
    ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
    const metrics = ctx.measureText("");
    let ascent = metrics.fontBoundingBoxAscent;
    let descent = Math.abs(metrics.fontBoundingBoxDescent);
    if (ascent) {
      const ratio = ascent / (ascent + descent);
      this.#ascentCache.set(fontFamily, ratio);
      ctx.canvas.width = ctx.canvas.height = 0;
      ctx.font = savedFont;
      return ratio;
    }
    ctx.strokeStyle = "red";
    ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
    ctx.strokeText("g", 0, 0);
    let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
    descent = 0;
    for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
      if (pixels[i] > 0) {
        descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
        break;
      }
    }
    ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
    ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
    pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
    ascent = 0;
    for (let i = 0, ii = pixels.length; i < ii; i += 4) {
      if (pixels[i] > 0) {
        ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
        break;
      }
    }
    ctx.canvas.width = ctx.canvas.height = 0;
    ctx.font = savedFont;
    const ratio = ascent ? ascent / (ascent + descent) : DEFAULT_FONT_ASCENT;
    this.#ascentCache.set(fontFamily, ratio);
    return ratio;
  }
}
function renderTextLayer() {
  deprecated("`renderTextLayer`, please use `TextLayer` instead.");
  const {
    textContentSource,
    container,
    viewport,
    ...rest
  } = arguments[0];
  const restKeys = Object.keys(rest);
  if (restKeys.length > 0) {
    warn("Ignoring `renderTextLayer` parameters: " + restKeys.join(", "));
  }
  const textLayer = new TextLayer({
    textContentSource,
    container,
    viewport
  });
  const {
    textDivs,
    textContentItemsStr
  } = textLayer;
  const promise = textLayer.render();
  return {
    promise,
    textDivs,
    textContentItemsStr
  };
}
function updateTextLayer() {
  deprecated("`updateTextLayer`, please use `TextLayer` instead.");
}
class XfaText {
  static textContent(xfa) {
    const items = [];
    const output = {
      items,
      styles: Object.create(null)
    };
    function walk(node) {
      if (!node) {
        return;
      }
      let str = null;
      const name = node.name;
      if (name === "#text") {
        str = node.value;
      } else if (!XfaText.shouldBuildText(name)) {
        return;
      } else if (node?.attributes?.textContent) {
        str = node.attributes.textContent;
      } else if (node.value) {
        str = node.value;
      }
      if (str !== null) {
        items.push({
          str
        });
      }
      if (!node.children) {
        return;
      }
      for (const child of node.children) {
        walk(child);
      }
    }
    walk(xfa);
    return output;
  }
  static shouldBuildText(name) {
    return !(name === "textarea" || name === "input" || name === "option" || name === "select");
  }
}
















const DEFAULT_RANGE_CHUNK_SIZE = 65536;
const RENDERING_CANCELLED_TIMEOUT = 100;
const DELAYED_CLEANUP_TIMEOUT = 5000;
const DefaultCanvasFactory = isNodeJS ? NodeCanvasFactory : DOMCanvasFactory;
const DefaultCMapReaderFactory = isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory;
const DefaultFilterFactory = isNodeJS ? NodeFilterFactory : DOMFilterFactory;
const DefaultStandardFontDataFactory = isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory;
function getDocument(src = {}) {
  if (typeof src === "string" || src instanceof URL) {
    src = {
      url: src
    };
  } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {
    src = {
      data: src
    };
  }
  const task = new PDFDocumentLoadingTask();
  const {
    docId
  } = task;
  const url = src.url ? getUrlProp(src.url) : null;
  const data = src.data ? getDataProp(src.data) : null;
  const httpHeaders = src.httpHeaders || null;
  const withCredentials = src.withCredentials === true;
  const password = src.password ?? null;
  const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;
  const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
  let worker = src.worker instanceof PDFWorker ? src.worker : null;
  const verbosity = src.verbosity;
  const docBaseUrl = typeof src.docBaseUrl === "string" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;
  const cMapUrl = typeof src.cMapUrl === "string" ? src.cMapUrl : null;
  const cMapPacked = src.cMapPacked !== false;
  const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;
  const standardFontDataUrl = typeof src.standardFontDataUrl === "string" ? src.standardFontDataUrl : null;
  const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;
  const ignoreErrors = src.stopAtErrors !== true;
  const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
  const isEvalSupported = src.isEvalSupported !== false;
  const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !isNodeJS;
  const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
  const disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : isNodeJS;
  const fontExtraProperties = src.fontExtraProperties === true;
  const enableXfa = src.enableXfa === true;
  const ownerDocument = src.ownerDocument || globalThis.document;
  const disableRange = src.disableRange === true;
  const disableStream = src.disableStream === true;
  const disableAutoFetch = src.disableAutoFetch === true;
  const pdfBug = src.pdfBug === true;
  const enableHWA = src.enableHWA === true;
  const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;
  const useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !isNodeJS && !disableFontFace;
  const useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI);
  const canvasFactory = src.canvasFactory || new DefaultCanvasFactory({
    ownerDocument,
    enableHWA
  });
  const filterFactory = src.filterFactory || new DefaultFilterFactory({
    docId,
    ownerDocument
  });
  const styleElement = null;
  setVerbosityLevel(verbosity);
  const transportFactory = {
    canvasFactory,
    filterFactory
  };
  if (!useWorkerFetch) {
    transportFactory.cMapReaderFactory = new CMapReaderFactory({
      baseUrl: cMapUrl,
      isCompressed: cMapPacked
    });
    transportFactory.standardFontDataFactory = new StandardFontDataFactory({
      baseUrl: standardFontDataUrl
    });
  }
  if (!worker) {
    const workerParams = {
      verbosity,
      port: GlobalWorkerOptions.workerPort
    };
    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
    task._worker = worker;
  }
  const docParams = {
    docId,
    apiVersion: "4.4.168",
    data,
    password,
    disableAutoFetch,
    rangeChunkSize,
    length,
    docBaseUrl,
    enableXfa,
    evaluatorOptions: {
      maxImageSize,
      disableFontFace,
      ignoreErrors,
      isEvalSupported,
      isOffscreenCanvasSupported,
      canvasMaxAreaInBytes,
      fontExtraProperties,
      useSystemFonts,
      cMapUrl: useWorkerFetch ? cMapUrl : null,
      standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null
    }
  };
  const transportParams = {
    disableFontFace,
    fontExtraProperties,
    ownerDocument,
    pdfBug,
    styleElement,
    loadingParams: {
      disableAutoFetch,
      enableXfa
    }
  };
  worker.promise.then(function () {
    if (task.destroyed) {
      throw new Error("Loading aborted");
    }
    if (worker.destroyed) {
      throw new Error("Worker was destroyed");
    }
    const workerIdPromise = worker.messageHandler.sendWithPromise("GetDocRequest", docParams, data ? [data.buffer] : null);
    let networkStream;
    if (rangeTransport) {
      networkStream = new PDFDataTransportStream(rangeTransport, {
        disableRange,
        disableStream
      });
    } else if (!data) {
      if (!url) {
        throw new Error("getDocument - no `url` parameter provided.");
      }
      const createPDFNetworkStream = params => {
        if (isNodeJS) {
          const isFetchSupported = function () {
            return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype;
          };
          return isFetchSupported() && isValidFetchUrl(params.url) ? new PDFFetchStream(params) : new PDFNodeStream(params);
        }
        return isValidFetchUrl(params.url) ? new PDFFetchStream(params) : new PDFNetworkStream(params);
      };
      networkStream = createPDFNetworkStream({
        url,
        length,
        httpHeaders,
        withCredentials,
        rangeChunkSize,
        disableRange,
        disableStream
      });
    }
    return workerIdPromise.then(workerId => {
      if (task.destroyed) {
        throw new Error("Loading aborted");
      }
      if (worker.destroyed) {
        throw new Error("Worker was destroyed");
      }
      const messageHandler = new MessageHandler(docId, workerId, worker.port);
      const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);
      task._transport = transport;
      messageHandler.send("Ready", null);
    });
  }).catch(task._capability.reject);
  return task;
}
function getUrlProp(val) {
  if (val instanceof URL) {
    return val.href;
  }
  try {
    return new URL(val, window.location).href;
  } catch {
    if (isNodeJS && typeof val === "string") {
      return val;
    }
  }
  throw new Error("Invalid PDF url data: " + "either string or URL-object is expected in the url property.");
}
function getDataProp(val) {
  if (isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) {
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  }
  if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
    return val;
  }
  if (typeof val === "string") {
    return stringToBytes(val);
  }
  if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === "object" && !isNaN(val?.length)) {
    return new Uint8Array(val);
  }
  throw new Error("Invalid PDF binary data: either TypedArray, " + "string, or array-like object is expected in the data property.");
}
function isRefProxy(ref) {
  return typeof ref === "object" && Number.isInteger(ref?.num) && ref.num >= 0 && Number.isInteger(ref?.gen) && ref.gen >= 0;
}
class PDFDocumentLoadingTask {
  static #docId = 0;
  constructor() {
    this._capability = Promise.withResolvers();
    this._transport = null;
    this._worker = null;
    this.docId = `d${PDFDocumentLoadingTask.#docId++}`;
    this.destroyed = false;
    this.onPassword = null;
    this.onProgress = null;
  }
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    this.destroyed = true;
    try {
      if (this._worker?.port) {
        this._worker._pendingDestroy = true;
      }
      await this._transport?.destroy();
    } catch (ex) {
      if (this._worker?.port) {
        delete this._worker._pendingDestroy;
      }
      throw ex;
    }
    this._transport = null;
    if (this._worker) {
      this._worker.destroy();
      this._worker = null;
    }
  }
}
class PDFDataRangeTransport {
  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
    this.length = length;
    this.initialData = initialData;
    this.progressiveDone = progressiveDone;
    this.contentDispositionFilename = contentDispositionFilename;
    this._rangeListeners = [];
    this._progressListeners = [];
    this._progressiveReadListeners = [];
    this._progressiveDoneListeners = [];
    this._readyCapability = Promise.withResolvers();
  }
  addRangeListener(listener) {
    this._rangeListeners.push(listener);
  }
  addProgressListener(listener) {
    this._progressListeners.push(listener);
  }
  addProgressiveReadListener(listener) {
    this._progressiveReadListeners.push(listener);
  }
  addProgressiveDoneListener(listener) {
    this._progressiveDoneListeners.push(listener);
  }
  onDataRange(begin, chunk) {
    for (const listener of this._rangeListeners) {
      listener(begin, chunk);
    }
  }
  onDataProgress(loaded, total) {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressListeners) {
        listener(loaded, total);
      }
    });
  }
  onDataProgressiveRead(chunk) {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressiveReadListeners) {
        listener(chunk);
      }
    });
  }
  onDataProgressiveDone() {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressiveDoneListeners) {
        listener();
      }
    });
  }
  transportReady() {
    this._readyCapability.resolve();
  }
  requestDataRange(begin, end) {
    unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {}
}
class PDFDocumentProxy {
  constructor(pdfInfo, transport) {
    this._pdfInfo = pdfInfo;
    this._transport = transport;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(pageNumber) {
    return this._transport.getPage(pageNumber);
  }
  getPageIndex(ref) {
    return this._transport.getPageIndex(ref);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(id) {
    return this._transport.getDestination(id);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({
    intent = "display"
  } = {}) {
    const {
      renderingIntent
    } = this._transport.getRenderingIntent(intent);
    return this._transport.getOptionalContentConfig(renderingIntent);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(keepLoadedFonts = false) {
    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(ref) {
    return this._transport.cachedPageNumber(ref);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
}
class PDFPageProxy {
  #delayedCleanupTimeout = null;
  #pendingCleanup = false;
  constructor(pageIndex, pageInfo, transport, pdfBug = false) {
    this._pageIndex = pageIndex;
    this._pageInfo = pageInfo;
    this._transport = transport;
    this._stats = pdfBug ? new StatTimer() : null;
    this._pdfBug = pdfBug;
    this.commonObjs = transport.commonObjs;
    this.objs = new PDFObjects();
    this._maybeCleanupAfterRender = false;
    this._intentStates = new Map();
    this.destroyed = false;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({
    scale,
    rotation = this.rotate,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  } = {}) {
    return new PageViewport({
      viewBox: this.view,
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }
  getAnnotations({
    intent = "display"
  } = {}) {
    const {
      renderingIntent
    } = this._transport.getRenderingIntent(intent);
    return this._transport.getAnnotations(this._pageIndex, renderingIntent);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    return this._transport._htmlForXfa?.children[this._pageIndex] || null;
  }
  render({
    canvasContext,
    viewport,
    intent = "display",
    annotationMode = AnnotationMode.ENABLE,
    transform = null,
    background = null,
    optionalContentConfigPromise = null,
    annotationCanvasMap = null,
    pageColors = null,
    printAnnotationStorage = null
  }) {
    this._stats?.time("Overall");
    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);
    const {
      renderingIntent,
      cacheKey
    } = intentArgs;
    this.#pendingCleanup = false;
    this.#abortDelayedCleanup();
    optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);
    let intentState = this._intentStates.get(cacheKey);
    if (!intentState) {
      intentState = Object.create(null);
      this._intentStates.set(cacheKey, intentState);
    }
    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }
    const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
    if (!intentState.displayReadyCapability) {
      intentState.displayReadyCapability = Promise.withResolvers();
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };
      this._stats?.time("Page Request");
      this._pumpOperatorList(intentArgs);
    }
    const complete = error => {
      intentState.renderTasks.delete(internalRenderTask);
      if (this._maybeCleanupAfterRender || intentPrint) {
        this.#pendingCleanup = true;
      }
      this.#tryCleanup(!intentPrint);
      if (error) {
        internalRenderTask.capability.reject(error);
        this._abortOperatorList({
          intentState,
          reason: error instanceof Error ? error : new Error(error)
        });
      } else {
        internalRenderTask.capability.resolve();
      }
      if (this._stats) {
        this._stats.timeEnd("Rendering");
        this._stats.timeEnd("Overall");
        if (globalThis.Stats?.enabled) {
          globalThis.Stats.add(this.pageNumber, this._stats);
        }
      }
    };
    const internalRenderTask = new InternalRenderTask({
      callback: complete,
      params: {
        canvasContext,
        viewport,
        transform,
        background
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap,
      operatorList: intentState.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: this._transport.canvasFactory,
      filterFactory: this._transport.filterFactory,
      useRequestAnimationFrame: !intentPrint,
      pdfBug: this._pdfBug,
      pageColors
    });
    (intentState.renderTasks ||= new Set()).add(internalRenderTask);
    const renderTask = internalRenderTask.task;
    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
      if (this.destroyed) {
        complete();
        return;
      }
      this._stats?.time("Rendering");
      if (!(optionalContentConfig.renderingIntent & renderingIntent)) {
        throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` " + "and `PDFDocumentProxy.getOptionalContentConfig` methods.");
      }
      internalRenderTask.initializeGraphics({
        transparency,
        optionalContentConfig
      });
      internalRenderTask.operatorListChanged();
    }).catch(complete);
    return renderTask;
  }
  getOperatorList({
    intent = "display",
    annotationMode = AnnotationMode.ENABLE,
    printAnnotationStorage = null
  } = {}) {
    function operatorListChanged() {
      if (intentState.operatorList.lastChunk) {
        intentState.opListReadCapability.resolve(intentState.operatorList);
        intentState.renderTasks.delete(opListTask);
      }
    }
    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);
    let intentState = this._intentStates.get(intentArgs.cacheKey);
    if (!intentState) {
      intentState = Object.create(null);
      this._intentStates.set(intentArgs.cacheKey, intentState);
    }
    let opListTask;
    if (!intentState.opListReadCapability) {
      opListTask = Object.create(null);
      opListTask.operatorListChanged = operatorListChanged;
      intentState.opListReadCapability = Promise.withResolvers();
      (intentState.renderTasks ||= new Set()).add(opListTask);
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };
      this._stats?.time("Page Request");
      this._pumpOperatorList(intentArgs);
    }
    return intentState.opListReadCapability.promise;
  }
  streamTextContent({
    includeMarkedContent = false,
    disableNormalization = false
  } = {}) {
    const TEXT_CONTENT_CHUNK_SIZE = 100;
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      includeMarkedContent: includeMarkedContent === true,
      disableNormalization: disableNormalization === true
    }, {
      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
      size(textContent) {
        return textContent.items.length;
      }
    });
  }
  getTextContent(params = {}) {
    if (this._transport._htmlForXfa) {
      return this.getXfa().then(xfa => XfaText.textContent(xfa));
    }
    const readableStream = this.streamTextContent(params);
    return new Promise(function (resolve, reject) {
      function pump() {
        reader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            resolve(textContent);
            return;
          }
          textContent.lang ??= value.lang;
          Object.assign(textContent.styles, value.styles);
          textContent.items.push(...value.items);
          pump();
        }, reject);
      }
      const reader = readableStream.getReader();
      const textContent = {
        items: [],
        styles: Object.create(null),
        lang: null
      };
      pump();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = true;
    const waitOn = [];
    for (const intentState of this._intentStates.values()) {
      this._abortOperatorList({
        intentState,
        reason: new Error("Page was destroyed."),
        force: true
      });
      if (intentState.opListReadCapability) {
        continue;
      }
      for (const internalRenderTask of intentState.renderTasks) {
        waitOn.push(internalRenderTask.completed);
        internalRenderTask.cancel();
      }
    }
    this.objs.clear();
    this.#pendingCleanup = false;
    this.#abortDelayedCleanup();
    return Promise.all(waitOn);
  }
  cleanup(resetStats = false) {
    this.#pendingCleanup = true;
    const success = this.#tryCleanup(false);
    if (resetStats && success) {
      this._stats &&= new StatTimer();
    }
    return success;
  }
  #tryCleanup(delayed = false) {
    this.#abortDelayedCleanup();
    if (!this.#pendingCleanup || this.destroyed) {
      return false;
    }
    if (delayed) {
      this.#delayedCleanupTimeout = setTimeout(() => {
        this.#delayedCleanupTimeout = null;
        this.#tryCleanup(false);
      }, DELAYED_CLEANUP_TIMEOUT);
      return false;
    }
    for (const {
      renderTasks,
      operatorList
    } of this._intentStates.values()) {
      if (renderTasks.size > 0 || !operatorList.lastChunk) {
        return false;
      }
    }
    this._intentStates.clear();
    this.objs.clear();
    this.#pendingCleanup = false;
    return true;
  }
  #abortDelayedCleanup() {
    if (this.#delayedCleanupTimeout) {
      clearTimeout(this.#delayedCleanupTimeout);
      this.#delayedCleanupTimeout = null;
    }
  }
  _startRenderPage(transparency, cacheKey) {
    const intentState = this._intentStates.get(cacheKey);
    if (!intentState) {
      return;
    }
    this._stats?.timeEnd("Page Request");
    intentState.displayReadyCapability?.resolve(transparency);
  }
  _renderPageChunk(operatorListChunk, intentState) {
    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
    }
    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
    for (const internalRenderTask of intentState.renderTasks) {
      internalRenderTask.operatorListChanged();
    }
    if (operatorListChunk.lastChunk) {
      this.#tryCleanup(true);
    }
  }
  _pumpOperatorList({
    renderingIntent,
    cacheKey,
    annotationStorageSerializable
  }) {
    const {
      map,
      transfer
    } = annotationStorageSerializable;
    const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: renderingIntent,
      cacheKey,
      annotationStorage: map
    }, transfer);
    const reader = readableStream.getReader();
    const intentState = this._intentStates.get(cacheKey);
    intentState.streamReader = reader;
    const pump = () => {
      reader.read().then(({
        value,
        done
      }) => {
        if (done) {
          intentState.streamReader = null;
          return;
        }
        if (this._transport.destroyed) {
          return;
        }
        this._renderPageChunk(value, intentState);
        pump();
      }, reason => {
        intentState.streamReader = null;
        if (this._transport.destroyed) {
          return;
        }
        if (intentState.operatorList) {
          intentState.operatorList.lastChunk = true;
          for (const internalRenderTask of intentState.renderTasks) {
            internalRenderTask.operatorListChanged();
          }
          this.#tryCleanup(true);
        }
        if (intentState.displayReadyCapability) {
          intentState.displayReadyCapability.reject(reason);
        } else if (intentState.opListReadCapability) {
          intentState.opListReadCapability.reject(reason);
        } else {
          throw reason;
        }
      });
    };
    pump();
  }
  _abortOperatorList({
    intentState,
    reason,
    force = false
  }) {
    if (!intentState.streamReader) {
      return;
    }
    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }
    if (!force) {
      if (intentState.renderTasks.size > 0) {
        return;
      }
      if (reason instanceof RenderingCancelledException) {
        let delay = RENDERING_CANCELLED_TIMEOUT;
        if (reason.extraDelay > 0 && reason.extraDelay < 1000) {
          delay += reason.extraDelay;
        }
        intentState.streamReaderCancelTimeout = setTimeout(() => {
          intentState.streamReaderCancelTimeout = null;
          this._abortOperatorList({
            intentState,
            reason,
            force: true
          });
        }, delay);
        return;
      }
    }
    intentState.streamReader.cancel(new AbortException(reason.message)).catch(() => {});
    intentState.streamReader = null;
    if (this._transport.destroyed) {
      return;
    }
    for (const [curCacheKey, curIntentState] of this._intentStates) {
      if (curIntentState === intentState) {
        this._intentStates.delete(curCacheKey);
        break;
      }
    }
    this.cleanup();
  }
  get stats() {
    return this._stats;
  }
}
class LoopbackPort {
  #listeners = new Set();
  #deferred = Promise.resolve();
  postMessage(obj, transfer) {
    const event = {
      data: structuredClone(obj, transfer ? {
        transfer
      } : null)
    };
    this.#deferred.then(() => {
      for (const listener of this.#listeners) {
        listener.call(this, event);
      }
    });
  }
  addEventListener(name, listener) {
    this.#listeners.add(listener);
  }
  removeEventListener(name, listener) {
    this.#listeners.delete(listener);
  }
  terminate() {
    this.#listeners.clear();
  }
}
const PDFWorkerUtil = {
  isWorkerDisabled: false,
  fakeWorkerId: 0
};
{
  if (isNodeJS) {
    PDFWorkerUtil.isWorkerDisabled = true;
    GlobalWorkerOptions.workerSrc ||= "./pdf.worker.mjs";
  }
  PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) {
    let base;
    try {
      base = new URL(baseUrl);
      if (!base.origin || base.origin === "null") {
        return false;
      }
    } catch {
      return false;
    }
    const other = new URL(otherUrl, base);
    return base.origin === other.origin;
  };
  PDFWorkerUtil.createCDNWrapper = function (url) {
    const wrapper = `await import("${url}");`;
    return URL.createObjectURL(new Blob([wrapper], {
      type: "text/javascript"
    }));
  };
}
class PDFWorker {
  static #workerPorts;
  constructor({
    name = null,
    port = null,
    verbosity = getVerbosityLevel()
  } = {}) {
    this.name = name;
    this.destroyed = false;
    this.verbosity = verbosity;
    this._readyCapability = Promise.withResolvers();
    this._port = null;
    this._webWorker = null;
    this._messageHandler = null;
    if (port) {
      if (PDFWorker.#workerPorts?.has(port)) {
        throw new Error("Cannot use more than one PDFWorker per port.");
      }
      (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);
      this._initializeFromPort(port);
      return;
    }
    this._initialize();
  }
  get promise() {
    if (isNodeJS) {
      return Promise.all([NodePackages.promise, this._readyCapability.promise]);
    }
    return this._readyCapability.promise;
  }
  #resolve() {
    this._readyCapability.resolve();
    this._messageHandler.send("configure", {
      verbosity: this.verbosity
    });
  }
  get port() {
    return this._port;
  }
  get messageHandler() {
    return this._messageHandler;
  }
  _initializeFromPort(port) {
    this._port = port;
    this._messageHandler = new MessageHandler("main", "worker", port);
    this._messageHandler.on("ready", function () {});
    this.#resolve();
  }
  _initialize() {
    if (PDFWorkerUtil.isWorkerDisabled || PDFWorker.#mainThreadWorkerMessageHandler) {
      this._setupFakeWorker();
      return;
    }
    let {
      workerSrc
    } = PDFWorker;
    try {
      if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
        workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
      }
      const worker = new Worker(workerSrc, {
        type: "module"
      });
      const messageHandler = new MessageHandler("main", "worker", worker);
      const terminateEarly = () => {
        ac.abort();
        messageHandler.destroy();
        worker.terminate();
        if (this.destroyed) {
          this._readyCapability.reject(new Error("Worker was destroyed"));
        } else {
          this._setupFakeWorker();
        }
      };
      const ac = new AbortController();
      worker.addEventListener("error", () => {
        if (!this._webWorker) {
          terminateEarly();
        }
      }, {
        signal: ac.signal
      });
      messageHandler.on("test", data => {
        ac.abort();
        if (this.destroyed || !data) {
          terminateEarly();
          return;
        }
        this._messageHandler = messageHandler;
        this._port = worker;
        this._webWorker = worker;
        this.#resolve();
      });
      messageHandler.on("ready", data => {
        ac.abort();
        if (this.destroyed) {
          terminateEarly();
          return;
        }
        try {
          sendTest();
        } catch {
          this._setupFakeWorker();
        }
      });
      const sendTest = () => {
        const testObj = new Uint8Array();
        messageHandler.send("test", testObj, [testObj.buffer]);
      };
      sendTest();
      return;
    } catch {
      info("The worker has been disabled.");
    }
    this._setupFakeWorker();
  }
  _setupFakeWorker() {
    if (!PDFWorkerUtil.isWorkerDisabled) {
      warn("Setting up fake worker.");
      PDFWorkerUtil.isWorkerDisabled = true;
    }
    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {
      if (this.destroyed) {
        this._readyCapability.reject(new Error("Worker was destroyed"));
        return;
      }
      const port = new LoopbackPort();
      this._port = port;
      const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;
      const workerHandler = new MessageHandler(id + "_worker", id, port);
      WorkerMessageHandler.setup(workerHandler, port);
      this._messageHandler = new MessageHandler(id, id + "_worker", port);
      this.#resolve();
    }).catch(reason => {
      this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
    });
  }
  destroy() {
    this.destroyed = true;
    if (this._webWorker) {
      this._webWorker.terminate();
      this._webWorker = null;
    }
    PDFWorker.#workerPorts?.delete(this._port);
    this._port = null;
    if (this._messageHandler) {
      this._messageHandler.destroy();
      this._messageHandler = null;
    }
  }
  static fromPort(params) {
    if (!params?.port) {
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    }
    const cachedPort = this.#workerPorts?.get(params.port);
    if (cachedPort) {
      if (cachedPort._pendingDestroy) {
        throw new Error("PDFWorker.fromPort - the worker is being destroyed.\n" + "Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      }
      return cachedPort;
    }
    return new PDFWorker(params);
  }
  static get workerSrc() {
    if (GlobalWorkerOptions.workerSrc) {
      return GlobalWorkerOptions.workerSrc;
    }
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get #mainThreadWorkerMessageHandler() {
    try {
      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
    } catch {
      return null;
    }
  }
  static get _setupFakeWorkerGlobal() {
    const loader = async () => {
      if (this.#mainThreadWorkerMessageHandler) {
        return this.#mainThreadWorkerMessageHandler;
      }
      const worker = await import( /*webpackIgnore: true*/this.workerSrc);
      return worker.WorkerMessageHandler;
    };
    return shadow(this, "_setupFakeWorkerGlobal", loader());
  }
}
class WorkerTransport {
  #methodPromises = new Map();
  #pageCache = new Map();
  #pagePromises = new Map();
  #pageRefCache = new Map();
  #passwordCapability = null;
  constructor(messageHandler, loadingTask, networkStream, params, factory) {
    this.messageHandler = messageHandler;
    this.loadingTask = loadingTask;
    this.commonObjs = new PDFObjects();
    this.fontLoader = new FontLoader({
      ownerDocument: params.ownerDocument,
      styleElement: params.styleElement
    });
    this.loadingParams = params.loadingParams;
    this._params = params;
    this.canvasFactory = factory.canvasFactory;
    this.filterFactory = factory.filterFactory;
    this.cMapReaderFactory = factory.cMapReaderFactory;
    this.standardFontDataFactory = factory.standardFontDataFactory;
    this.destroyed = false;
    this.destroyCapability = null;
    this._networkStream = networkStream;
    this._fullReader = null;
    this._lastProgress = null;
    this.downloadInfoCapability = Promise.withResolvers();
    this.setupMessageHandler();
  }
  #cacheSimpleMethod(name, data = null) {
    const cachedPromise = this.#methodPromises.get(name);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise(name, data);
    this.#methodPromises.set(name, promise);
    return promise;
  }
  get annotationStorage() {
    return shadow(this, "annotationStorage", new AnnotationStorage());
  }
  getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {
    let renderingIntent = RenderingIntentFlag.DISPLAY;
    let annotationStorageSerializable = SerializableEmpty;
    switch (intent) {
      case "any":
        renderingIntent = RenderingIntentFlag.ANY;
        break;
      case "display":
        break;
      case "print":
        renderingIntent = RenderingIntentFlag.PRINT;
        break;
      default:
        warn(`getRenderingIntent - invalid intent: ${intent}`);
    }
    switch (annotationMode) {
      case AnnotationMode.DISABLE:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;
        break;
      case AnnotationMode.ENABLE:
        break;
      case AnnotationMode.ENABLE_FORMS:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;
        break;
      case AnnotationMode.ENABLE_STORAGE:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;
        const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
        annotationStorageSerializable = annotationStorage.serializable;
        break;
      default:
        warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
    }
    if (isOpList) {
      renderingIntent += RenderingIntentFlag.OPLIST;
    }
    return {
      renderingIntent,
      cacheKey: `${renderingIntent}_${annotationStorageSerializable.hash}`,
      annotationStorageSerializable
    };
  }
  destroy() {
    if (this.destroyCapability) {
      return this.destroyCapability.promise;
    }
    this.destroyed = true;
    this.destroyCapability = Promise.withResolvers();
    this.#passwordCapability?.reject(new Error("Worker was destroyed during onPassword callback"));
    const waitOn = [];
    for (const page of this.#pageCache.values()) {
      waitOn.push(page._destroy());
    }
    this.#pageCache.clear();
    this.#pagePromises.clear();
    this.#pageRefCache.clear();
    if (this.hasOwnProperty("annotationStorage")) {
      this.annotationStorage.resetModified();
    }
    const terminated = this.messageHandler.sendWithPromise("Terminate", null);
    waitOn.push(terminated);
    Promise.all(waitOn).then(() => {
      this.commonObjs.clear();
      this.fontLoader.clear();
      this.#methodPromises.clear();
      this.filterFactory.destroy();
      TextLayer.cleanup();
      this._networkStream?.cancelAllRequests(new AbortException("Worker was terminated."));
      if (this.messageHandler) {
        this.messageHandler.destroy();
        this.messageHandler = null;
      }
      this.destroyCapability.resolve();
    }, this.destroyCapability.reject);
    return this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const {
      messageHandler,
      loadingTask
    } = this;
    messageHandler.on("GetReader", (data, sink) => {
      assert(this._networkStream, "GetReader - no `IPDFStream` instance available.");
      this._fullReader = this._networkStream.getFullReader();
      this._fullReader.onProgress = evt => {
        this._lastProgress = {
          loaded: evt.loaded,
          total: evt.total
        };
      };
      sink.onPull = () => {
        this._fullReader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }
          assert(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch(reason => {
          sink.error(reason);
        });
      };
      sink.onCancel = reason => {
        this._fullReader.cancel(reason);
        sink.ready.catch(readyReason => {
          if (this.destroyed) {
            return;
          }
          throw readyReason;
        });
      };
    });
    messageHandler.on("ReaderHeadersReady", data => {
      const headersCapability = Promise.withResolvers();
      const fullReader = this._fullReader;
      fullReader.headersReady.then(() => {
        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
          if (this._lastProgress) {
            loadingTask.onProgress?.(this._lastProgress);
          }
          fullReader.onProgress = evt => {
            loadingTask.onProgress?.({
              loaded: evt.loaded,
              total: evt.total
            });
          };
        }
        headersCapability.resolve({
          isStreamingSupported: fullReader.isStreamingSupported,
          isRangeSupported: fullReader.isRangeSupported,
          contentLength: fullReader.contentLength
        });
      }, headersCapability.reject);
      return headersCapability.promise;
    });
    messageHandler.on("GetRangeReader", (data, sink) => {
      assert(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
      if (!rangeReader) {
        sink.close();
        return;
      }
      sink.onPull = () => {
        rangeReader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }
          assert(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch(reason => {
          sink.error(reason);
        });
      };
      sink.onCancel = reason => {
        rangeReader.cancel(reason);
        sink.ready.catch(readyReason => {
          if (this.destroyed) {
            return;
          }
          throw readyReason;
        });
      };
    });
    messageHandler.on("GetDoc", ({
      pdfInfo
    }) => {
      this._numPages = pdfInfo.numPages;
      this._htmlForXfa = pdfInfo.htmlForXfa;
      delete pdfInfo.htmlForXfa;
      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
    });
    messageHandler.on("DocException", function (ex) {
      let reason;
      switch (ex.name) {
        case "PasswordException":
          reason = new PasswordException(ex.message, ex.code);
          break;
        case "InvalidPDFException":
          reason = new InvalidPDFException(ex.message);
          break;
        case "MissingPDFException":
          reason = new MissingPDFException(ex.message);
          break;
        case "UnexpectedResponseException":
          reason = new UnexpectedResponseException(ex.message, ex.status);
          break;
        case "UnknownErrorException":
          reason = new UnknownErrorException(ex.message, ex.details);
          break;
        default:
          unreachable("DocException - expected a valid Error.");
      }
      loadingTask._capability.reject(reason);
    });
    messageHandler.on("PasswordRequest", exception => {
      this.#passwordCapability = Promise.withResolvers();
      if (loadingTask.onPassword) {
        const updatePassword = password => {
          if (password instanceof Error) {
            this.#passwordCapability.reject(password);
          } else {
            this.#passwordCapability.resolve({
              password
            });
          }
        };
        try {
          loadingTask.onPassword(updatePassword, exception.code);
        } catch (ex) {
          this.#passwordCapability.reject(ex);
        }
      } else {
        this.#passwordCapability.reject(new PasswordException(exception.message, exception.code));
      }
      return this.#passwordCapability.promise;
    });
    messageHandler.on("DataLoaded", data => {
      loadingTask.onProgress?.({
        loaded: data.length,
        total: data.length
      });
      this.downloadInfoCapability.resolve(data);
    });
    messageHandler.on("StartRenderPage", data => {
      if (this.destroyed) {
        return;
      }
      const page = this.#pageCache.get(data.pageIndex);
      page._startRenderPage(data.transparency, data.cacheKey);
    });
    messageHandler.on("commonobj", ([id, type, exportedData]) => {
      if (this.destroyed) {
        return null;
      }
      if (this.commonObjs.has(id)) {
        return null;
      }
      switch (type) {
        case "Font":
          const {
            disableFontFace,
            fontExtraProperties,
            pdfBug
          } = this._params;
          if ("error" in exportedData) {
            const exportedError = exportedData.error;
            warn(`Error during font loading: ${exportedError}`);
            this.commonObjs.resolve(id, exportedError);
            break;
          }
          const inspectFont = pdfBug && globalThis.FontInspector?.enabled ? (font, url) => globalThis.FontInspector.fontAdded(font, url) : null;
          const font = new FontFaceObject(exportedData, {
            disableFontFace,
            inspectFont
          });
          this.fontLoader.bind(font).catch(() => messageHandler.sendWithPromise("FontFallback", {
            id
          })).finally(() => {
            if (!fontExtraProperties && font.data) {
              font.data = null;
            }
            this.commonObjs.resolve(id, font);
          });
          break;
        case "CopyLocalImage":
          const {
            imageRef
          } = exportedData;
          assert(imageRef, "The imageRef must be defined.");
          for (const pageProxy of this.#pageCache.values()) {
            for (const [, data] of pageProxy.objs) {
              if (data?.ref !== imageRef) {
                continue;
              }
              if (!data.dataLen) {
                return null;
              }
              this.commonObjs.resolve(id, structuredClone(data));
              return data.dataLen;
            }
          }
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(id, exportedData);
          break;
        default:
          throw new Error(`Got unknown common object type ${type}`);
      }
      return null;
    });
    messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
      if (this.destroyed) {
        return;
      }
      const pageProxy = this.#pageCache.get(pageIndex);
      if (pageProxy.objs.has(id)) {
        return;
      }
      if (pageProxy._intentStates.size === 0) {
        imageData?.bitmap?.close();
        return;
      }
      switch (type) {
        case "Image":
          pageProxy.objs.resolve(id, imageData);
          if (imageData?.dataLen > MAX_IMAGE_SIZE_TO_CACHE) {
            pageProxy._maybeCleanupAfterRender = true;
          }
          break;
        case "Pattern":
          pageProxy.objs.resolve(id, imageData);
          break;
        default:
          throw new Error(`Got unknown object type ${type}`);
      }
    });
    messageHandler.on("DocProgress", data => {
      if (this.destroyed) {
        return;
      }
      loadingTask.onProgress?.({
        loaded: data.loaded,
        total: data.total
      });
    });
    messageHandler.on("FetchBuiltInCMap", data => {
      if (this.destroyed) {
        return Promise.reject(new Error("Worker was destroyed."));
      }
      if (!this.cMapReaderFactory) {
        return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
      }
      return this.cMapReaderFactory.fetch(data);
    });
    messageHandler.on("FetchStandardFontData", data => {
      if (this.destroyed) {
        return Promise.reject(new Error("Worker was destroyed."));
      }
      if (!this.standardFontDataFactory) {
        return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
      }
      return this.standardFontDataFactory.fetch(data);
    });
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    if (this.annotationStorage.size <= 0) {
      warn("saveDocument called while `annotationStorage` is empty, " + "please use the getData-method instead.");
    }
    const {
      map,
      transfer
    } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: map,
      filename: this._fullReader?.filename ?? null
    }, transfer).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(pageNumber) {
    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
      return Promise.reject(new Error("Invalid page request."));
    }
    const pageIndex = pageNumber - 1,
      cachedPromise = this.#pagePromises.get(pageIndex);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex
    }).then(pageInfo => {
      if (this.destroyed) {
        throw new Error("Transport destroyed");
      }
      if (pageInfo.refStr) {
        this.#pageRefCache.set(pageInfo.refStr, pageNumber);
      }
      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
      this.#pageCache.set(pageIndex, page);
      return page;
    });
    this.#pagePromises.set(pageIndex, promise);
    return promise;
  }
  getPageIndex(ref) {
    if (!isRefProxy(ref)) {
      return Promise.reject(new Error("Invalid pageIndex request."));
    }
    return this.messageHandler.sendWithPromise("GetPageIndex", {
      num: ref.num,
      gen: ref.gen
    });
  }
  getAnnotations(pageIndex, intent) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex,
      intent
    });
  }
  getFieldObjects() {
    return this.#cacheSimpleMethod("GetFieldObjects");
  }
  hasJSActions() {
    return this.#cacheSimpleMethod("HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(id) {
    if (typeof id !== "string") {
      return Promise.reject(new Error("Invalid destination request."));
    }
    return this.messageHandler.sendWithPromise("GetDestination", {
      id
    });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getDocJSActions() {
    return this.#cacheSimpleMethod("GetDocJSActions");
  }
  getPageJSActions(pageIndex) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex
    });
  }
  getStructTree(pageIndex) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex
    });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(renderingIntent) {
    return this.#cacheSimpleMethod("GetOptionalContentConfig").then(data => new OptionalContentConfig(data, renderingIntent));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const name = "GetMetadata",
      cachedPromise = this.#methodPromises.get(name);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise(name, null).then(results => ({
      info: results[0],
      metadata: results[1] ? new Metadata(results[1]) : null,
      contentDispositionFilename: this._fullReader?.filename ?? null,
      contentLength: this._fullReader?.contentLength ?? null
    }));
    this.#methodPromises.set(name, promise);
    return promise;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(keepLoadedFonts = false) {
    if (this.destroyed) {
      return;
    }
    await this.messageHandler.sendWithPromise("Cleanup", null);
    for (const page of this.#pageCache.values()) {
      const cleanupSuccessful = page.cleanup();
      if (!cleanupSuccessful) {
        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
      }
    }
    this.commonObjs.clear();
    if (!keepLoadedFonts) {
      this.fontLoader.clear();
    }
    this.#methodPromises.clear();
    this.filterFactory.destroy(true);
    TextLayer.cleanup();
  }
  cachedPageNumber(ref) {
    if (!isRefProxy(ref)) {
      return null;
    }
    const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;
    return this.#pageRefCache.get(refStr) ?? null;
  }
}
const INITIAL_DATA = Symbol("INITIAL_DATA");
class PDFObjects {
  #objs = Object.create(null);
  #ensureObj(objId) {
    return this.#objs[objId] ||= {
      ...Promise.withResolvers(),
      data: INITIAL_DATA
    };
  }
  get(objId, callback = null) {
    if (callback) {
      const obj = this.#ensureObj(objId);
      obj.promise.then(() => callback(obj.data));
      return null;
    }
    const obj = this.#objs[objId];
    if (!obj || obj.data === INITIAL_DATA) {
      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
    }
    return obj.data;
  }
  has(objId) {
    const obj = this.#objs[objId];
    return !!obj && obj.data !== INITIAL_DATA;
  }
  resolve(objId, data = null) {
    const obj = this.#ensureObj(objId);
    obj.data = data;
    obj.resolve();
  }
  clear() {
    for (const objId in this.#objs) {
      const {
        data
      } = this.#objs[objId];
      data?.bitmap?.close();
    }
    this.#objs = Object.create(null);
  }
  *[Symbol.iterator]() {
    for (const objId in this.#objs) {
      const {
        data
      } = this.#objs[objId];
      if (data === INITIAL_DATA) {
        continue;
      }
      yield [objId, data];
    }
  }
}
class RenderTask {
  #internalRenderTask = null;
  constructor(internalRenderTask) {
    this.#internalRenderTask = internalRenderTask;
    this.onContinue = null;
  }
  get promise() {
    return this.#internalRenderTask.capability.promise;
  }
  cancel(extraDelay = 0) {
    this.#internalRenderTask.cancel(null, extraDelay);
  }
  get separateAnnots() {
    const {
      separateAnnots
    } = this.#internalRenderTask.operatorList;
    if (!separateAnnots) {
      return false;
    }
    const {
      annotationCanvasMap
    } = this.#internalRenderTask;
    return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;
  }
}
class InternalRenderTask {
  #rAF = null;
  static #canvasInUse = new WeakSet();
  constructor({
    callback,
    params,
    objs,
    commonObjs,
    annotationCanvasMap,
    operatorList,
    pageIndex,
    canvasFactory,
    filterFactory,
    useRequestAnimationFrame = false,
    pdfBug = false,
    pageColors = null
  }) {
    this.callback = callback;
    this.params = params;
    this.objs = objs;
    this.commonObjs = commonObjs;
    this.annotationCanvasMap = annotationCanvasMap;
    this.operatorListIdx = null;
    this.operatorList = operatorList;
    this._pageIndex = pageIndex;
    this.canvasFactory = canvasFactory;
    this.filterFactory = filterFactory;
    this._pdfBug = pdfBug;
    this.pageColors = pageColors;
    this.running = false;
    this.graphicsReadyCallback = null;
    this.graphicsReady = false;
    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
    this.cancelled = false;
    this.capability = Promise.withResolvers();
    this.task = new RenderTask(this);
    this._cancelBound = this.cancel.bind(this);
    this._continueBound = this._continue.bind(this);
    this._scheduleNextBound = this._scheduleNext.bind(this);
    this._nextBound = this._next.bind(this);
    this._canvas = params.canvasContext.canvas;
  }
  get completed() {
    return this.capability.promise.catch(function () {});
  }
  initializeGraphics({
    transparency = false,
    optionalContentConfig
  }) {
    if (this.cancelled) {
      return;
    }
    if (this._canvas) {
      if (InternalRenderTask.#canvasInUse.has(this._canvas)) {
        throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
      }
      InternalRenderTask.#canvasInUse.add(this._canvas);
    }
    if (this._pdfBug && globalThis.StepperManager?.enabled) {
      this.stepper = globalThis.StepperManager.create(this._pageIndex);
      this.stepper.init(this.operatorList);
      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
    }
    const {
      canvasContext,
      viewport,
      transform,
      background
    } = this.params;
    this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
      optionalContentConfig
    }, this.annotationCanvasMap, this.pageColors);
    this.gfx.beginDrawing({
      transform,
      viewport,
      transparency,
      background
    });
    this.operatorListIdx = 0;
    this.graphicsReady = true;
    this.graphicsReadyCallback?.();
  }
  cancel(error = null, extraDelay = 0) {
    this.running = false;
    this.cancelled = true;
    this.gfx?.endDrawing();
    if (this.#rAF) {
      window.cancelAnimationFrame(this.#rAF);
      this.#rAF = null;
    }
    InternalRenderTask.#canvasInUse.delete(this._canvas);
    this.callback(error || new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));
  }
  operatorListChanged() {
    if (!this.graphicsReady) {
      this.graphicsReadyCallback ||= this._continueBound;
      return;
    }
    this.stepper?.updateOperatorList(this.operatorList);
    if (this.running) {
      return;
    }
    this._continue();
  }
  _continue() {
    this.running = true;
    if (this.cancelled) {
      return;
    }
    if (this.task.onContinue) {
      this.task.onContinue(this._scheduleNextBound);
    } else {
      this._scheduleNext();
    }
  }
  _scheduleNext() {
    if (this._useRequestAnimationFrame) {
      this.#rAF = window.requestAnimationFrame(() => {
        this.#rAF = null;
        this._nextBound().catch(this._cancelBound);
      });
    } else {
      Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
  }
  async _next() {
    if (this.cancelled) {
      return;
    }
    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
    if (this.operatorListIdx === this.operatorList.argsArray.length) {
      this.running = false;
      if (this.operatorList.lastChunk) {
        this.gfx.endDrawing();
        InternalRenderTask.#canvasInUse.delete(this._canvas);
        this.callback();
      }
    }
  }
}
const version = "4.4.168";
const build = "19fbc8998";
function makeColorComp(n) {
  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
}
function scaleAndClamp(x) {
  return Math.max(0, Math.min(255, 255 * x));
}
class ColorConverters {
  static CMYK_G([c, y, m, k]) {
    return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
  }
  static G_CMYK([g]) {
    return ["CMYK", 0, 0, 0, 1 - g];
  }
  static G_RGB([g]) {
    return ["RGB", g, g, g];
  }
  static G_rgb([g]) {
    g = scaleAndClamp(g);
    return [g, g, g];
  }
  static G_HTML([g]) {
    const G = makeColorComp(g);
    return `#${G}${G}${G}`;
  }
  static RGB_G([r, g, b]) {
    return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
  }
  static RGB_rgb(color) {
    return color.map(scaleAndClamp);
  }
  static RGB_HTML(color) {
    return `#${color.map(makeColorComp).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([c, y, m, k]) {
    return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
  }
  static CMYK_rgb([c, y, m, k]) {
    return [scaleAndClamp(1 - Math.min(1, c + k)), scaleAndClamp(1 - Math.min(1, m + k)), scaleAndClamp(1 - Math.min(1, y + k))];
  }
  static CMYK_HTML(components) {
    const rgb = this.CMYK_RGB(components).slice(1);
    return this.RGB_HTML(rgb);
  }
  static RGB_CMYK([r, g, b]) {
    const c = 1 - r;
    const m = 1 - g;
    const y = 1 - b;
    const k = Math.min(c, m, y);
    return ["CMYK", c, m, y, k];
  }
}

class XfaLayer {
  static setupStorage(html, id, element, storage, intent) {
    const storedData = storage.getValue(id, {
      value: null
    });
    switch (element.name) {
      case "textarea":
        if (storedData.value !== null) {
          html.textContent = storedData.value;
        }
        if (intent === "print") {
          break;
        }
        html.addEventListener("input", event => {
          storage.setValue(id, {
            value: event.target.value
          });
        });
        break;
      case "input":
        if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
          if (storedData.value === element.attributes.xfaOn) {
            html.setAttribute("checked", true);
          } else if (storedData.value === element.attributes.xfaOff) {
            html.removeAttribute("checked");
          }
          if (intent === "print") {
            break;
          }
          html.addEventListener("change", event => {
            storage.setValue(id, {
              value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (storedData.value !== null) {
            html.setAttribute("value", storedData.value);
          }
          if (intent === "print") {
            break;
          }
          html.addEventListener("input", event => {
            storage.setValue(id, {
              value: event.target.value
            });
          });
        }
        break;
      case "select":
        if (storedData.value !== null) {
          html.setAttribute("value", storedData.value);
          for (const option of element.children) {
            if (option.attributes.value === storedData.value) {
              option.attributes.selected = true;
            } else if (option.attributes.hasOwnProperty("selected")) {
              delete option.attributes.selected;
            }
          }
        }
        html.addEventListener("input", event => {
          const options = event.target.options;
          const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
          storage.setValue(id, {
            value
          });
        });
        break;
    }
  }
  static setAttributes({
    html,
    element,
    storage = null,
    intent,
    linkService
  }) {
    const {
      attributes
    } = element;
    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
    if (attributes.type === "radio") {
      attributes.name = `${attributes.name}-${intent}`;
    }
    for (const [key, value] of Object.entries(attributes)) {
      if (value === null || value === undefined) {
        continue;
      }
      switch (key) {
        case "class":
          if (value.length) {
            html.setAttribute(key, value.join(" "));
          }
          break;
        case "dataId":
          break;
        case "id":
          html.setAttribute("data-element-id", value);
          break;
        case "style":
          Object.assign(html.style, value);
          break;
        case "textContent":
          html.textContent = value;
          break;
        default:
          if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
            html.setAttribute(key, value);
          }
      }
    }
    if (isHTMLAnchorElement) {
      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
    }
    if (storage && attributes.dataId) {
      this.setupStorage(html, attributes.dataId, element, storage);
    }
  }
  static render(parameters) {
    const storage = parameters.annotationStorage;
    const linkService = parameters.linkService;
    const root = parameters.xfaHtml;
    const intent = parameters.intent || "display";
    const rootHtml = document.createElement(root.name);
    if (root.attributes) {
      this.setAttributes({
        html: rootHtml,
        element: root,
        intent,
        linkService
      });
    }
    const isNotForRichText = intent !== "richText";
    const rootDiv = parameters.div;
    rootDiv.append(rootHtml);
    if (parameters.viewport) {
      const transform = `matrix(${parameters.viewport.transform.join(",")})`;
      rootDiv.style.transform = transform;
    }
    if (isNotForRichText) {
      rootDiv.setAttribute("class", "xfaLayer xfaFont");
    }
    const textDivs = [];
    if (root.children.length === 0) {
      if (root.value) {
        const node = document.createTextNode(root.value);
        rootHtml.append(node);
        if (isNotForRichText && XfaText.shouldBuildText(root.name)) {
          textDivs.push(node);
        }
      }
      return {
        textDivs
      };
    }
    const stack = [[root, -1, rootHtml]];
    while (stack.length > 0) {
      const [parent, i, html] = stack.at(-1);
      if (i + 1 === parent.children.length) {
        stack.pop();
        continue;
      }
      const child = parent.children[++stack.at(-1)[1]];
      if (child === null) {
        continue;
      }
      const {
        name
      } = child;
      if (name === "#text") {
        const node = document.createTextNode(child.value);
        textDivs.push(node);
        html.append(node);
        continue;
      }
      const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);
      html.append(childHtml);
      if (child.attributes) {
        this.setAttributes({
          html: childHtml,
          element: child,
          storage,
          intent,
          linkService
        });
      }
      if (child.children?.length > 0) {
        stack.push([child, -1, childHtml]);
      } else if (child.value) {
        const node = document.createTextNode(child.value);
        if (isNotForRichText && XfaText.shouldBuildText(name)) {
          textDivs.push(node);
        }
        childHtml.append(node);
      }
    }
    for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
      el.setAttribute("readOnly", true);
    }
    return {
      textDivs
    };
  }
  static update(parameters) {
    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
    parameters.div.style.transform = transform;
    parameters.div.hidden = false;
  }
}





const DEFAULT_TAB_INDEX = 1000;
const annotation_layer_DEFAULT_FONT_SIZE = 9;
const GetElementsByNameSet = new WeakSet();
function getRectDims(rect) {
  return {
    width: rect[2] - rect[0],
    height: rect[3] - rect[1]
  };
}
class AnnotationElementFactory {
  static create(parameters) {
    const subtype = parameters.data.annotationType;
    switch (subtype) {
      case AnnotationType.LINK:
        return new LinkAnnotationElement(parameters);
      case AnnotationType.TEXT:
        return new TextAnnotationElement(parameters);
      case AnnotationType.WIDGET:
        const fieldType = parameters.data.fieldType;
        switch (fieldType) {
          case "Tx":
            return new TextWidgetAnnotationElement(parameters);
          case "Btn":
            if (parameters.data.radioButton) {
              return new RadioButtonWidgetAnnotationElement(parameters);
            } else if (parameters.data.checkBox) {
              return new CheckboxWidgetAnnotationElement(parameters);
            }
            return new PushButtonWidgetAnnotationElement(parameters);
          case "Ch":
            return new ChoiceWidgetAnnotationElement(parameters);
          case "Sig":
            return new SignatureWidgetAnnotationElement(parameters);
        }
        return new WidgetAnnotationElement(parameters);
      case AnnotationType.POPUP:
        return new PopupAnnotationElement(parameters);
      case AnnotationType.FREETEXT:
        return new FreeTextAnnotationElement(parameters);
      case AnnotationType.LINE:
        return new LineAnnotationElement(parameters);
      case AnnotationType.SQUARE:
        return new SquareAnnotationElement(parameters);
      case AnnotationType.CIRCLE:
        return new CircleAnnotationElement(parameters);
      case AnnotationType.POLYLINE:
        return new PolylineAnnotationElement(parameters);
      case AnnotationType.CARET:
        return new CaretAnnotationElement(parameters);
      case AnnotationType.INK:
        return new InkAnnotationElement(parameters);
      case AnnotationType.POLYGON:
        return new PolygonAnnotationElement(parameters);
      case AnnotationType.HIGHLIGHT:
        return new HighlightAnnotationElement(parameters);
      case AnnotationType.UNDERLINE:
        return new UnderlineAnnotationElement(parameters);
      case AnnotationType.SQUIGGLY:
        return new SquigglyAnnotationElement(parameters);
      case AnnotationType.STRIKEOUT:
        return new StrikeOutAnnotationElement(parameters);
      case AnnotationType.STAMP:
        return new StampAnnotationElement(parameters);
      case AnnotationType.FILEATTACHMENT:
        return new FileAttachmentAnnotationElement(parameters);
      default:
        return new AnnotationElement(parameters);
    }
  }
}
class AnnotationElement {
  #updates = null;
  #hasBorder = false;
  #popupElement = null;
  constructor(parameters, {
    isRenderable = false,
    ignoreBorder = false,
    createQuadrilaterals = false
  } = {}) {
    this.isRenderable = isRenderable;
    this.data = parameters.data;
    this.layer = parameters.layer;
    this.linkService = parameters.linkService;
    this.downloadManager = parameters.downloadManager;
    this.imageResourcesPath = parameters.imageResourcesPath;
    this.renderForms = parameters.renderForms;
    this.svgFactory = parameters.svgFactory;
    this.annotationStorage = parameters.annotationStorage;
    this.enableScripting = parameters.enableScripting;
    this.hasJSActions = parameters.hasJSActions;
    this._fieldObjects = parameters.fieldObjects;
    this.parent = parameters.parent;
    if (isRenderable) {
      this.container = this._createContainer(ignoreBorder);
    }
    if (createQuadrilaterals) {
      this._createQuadrilaterals();
    }
  }
  static _hasPopupData({
    titleObj,
    contentsObj,
    richText
  }) {
    return !!(titleObj?.str || contentsObj?.str || richText?.str);
  }
  get hasPopupData() {
    return AnnotationElement._hasPopupData(this.data);
  }
  updateEdited(params) {
    if (!this.container) {
      return;
    }
    this.#updates ||= {
      rect: this.data.rect.slice(0)
    };
    const {
      rect
    } = params;
    if (rect) {
      this.#setRectEdited(rect);
    }
    this.#popupElement?.popup.updateEdited(params);
  }
  resetEdited() {
    if (!this.#updates) {
      return;
    }
    this.#setRectEdited(this.#updates.rect);
    this.#popupElement?.popup.resetEdited();
    this.#updates = null;
  }
  #setRectEdited(rect) {
    const {
      container: {
        style
      },
      data: {
        rect: currentRect,
        rotation
      },
      parent: {
        viewport: {
          rawDims: {
            pageWidth,
            pageHeight,
            pageX,
            pageY
          }
        }
      }
    } = this;
    currentRect?.splice(0, 4, ...rect);
    const {
      width,
      height
    } = getRectDims(rect);
    style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
    style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;
    if (rotation === 0) {
      style.width = `${100 * width / pageWidth}%`;
      style.height = `${100 * height / pageHeight}%`;
    } else {
      this.setRotation(rotation);
    }
  }
  _createContainer(ignoreBorder) {
    const {
      data,
      parent: {
        page,
        viewport
      }
    } = this;
    const container = document.createElement("section");
    container.setAttribute("data-annotation-id", data.id);
    if (!(this instanceof WidgetAnnotationElement)) {
      container.tabIndex = DEFAULT_TAB_INDEX;
    }
    const {
      style
    } = container;
    style.zIndex = this.parent.zIndex++;
    if (data.popupRef) {
      container.setAttribute("aria-haspopup", "dialog");
    }
    if (data.alternativeText) {
      container.title = data.alternativeText;
    }
    if (data.noRotate) {
      container.classList.add("norotate");
    }
    if (!data.rect || this instanceof PopupAnnotationElement) {
      const {
        rotation
      } = data;
      if (!data.hasOwnCanvas && rotation !== 0) {
        this.setRotation(rotation, container);
      }
      return container;
    }
    const {
      width,
      height
    } = getRectDims(data.rect);
    if (!ignoreBorder && data.borderStyle.width > 0) {
      style.borderWidth = `${data.borderStyle.width}px`;
      const horizontalRadius = data.borderStyle.horizontalCornerRadius;
      const verticalRadius = data.borderStyle.verticalCornerRadius;
      if (horizontalRadius > 0 || verticalRadius > 0) {
        const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
        style.borderRadius = radius;
      } else if (this instanceof RadioButtonWidgetAnnotationElement) {
        const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
        style.borderRadius = radius;
      }
      switch (data.borderStyle.style) {
        case AnnotationBorderStyleType.SOLID:
          style.borderStyle = "solid";
          break;
        case AnnotationBorderStyleType.DASHED:
          style.borderStyle = "dashed";
          break;
        case AnnotationBorderStyleType.BEVELED:
          warn("Unimplemented border style: beveled");
          break;
        case AnnotationBorderStyleType.INSET:
          warn("Unimplemented border style: inset");
          break;
        case AnnotationBorderStyleType.UNDERLINE:
          style.borderBottomStyle = "solid";
          break;
      }
      const borderColor = data.borderColor || null;
      if (borderColor) {
        this.#hasBorder = true;
        style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
      } else {
        style.borderWidth = 0;
      }
    }
    const rect = Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
    const {
      pageWidth,
      pageHeight,
      pageX,
      pageY
    } = viewport.rawDims;
    style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
    style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;
    const {
      rotation
    } = data;
    if (data.hasOwnCanvas || rotation === 0) {
      style.width = `${100 * width / pageWidth}%`;
      style.height = `${100 * height / pageHeight}%`;
    } else {
      this.setRotation(rotation, container);
    }
    return container;
  }
  setRotation(angle, container = this.container) {
    if (!this.data.rect) {
      return;
    }
    const {
      pageWidth,
      pageHeight
    } = this.parent.viewport.rawDims;
    const {
      width,
      height
    } = getRectDims(this.data.rect);
    let elementWidth, elementHeight;
    if (angle % 180 === 0) {
      elementWidth = 100 * width / pageWidth;
      elementHeight = 100 * height / pageHeight;
    } else {
      elementWidth = 100 * height / pageWidth;
      elementHeight = 100 * width / pageHeight;
    }
    container.style.width = `${elementWidth}%`;
    container.style.height = `${elementHeight}%`;
    container.setAttribute("data-main-rotation", (360 - angle) % 360);
  }
  get _commonActions() {
    const setColor = (jsName, styleName, event) => {
      const color = event.detail[jsName];
      const colorType = color[0];
      const colorArray = color.slice(1);
      event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);
      this.annotationStorage.setValue(this.data.id, {
        [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)
      });
    };
    return shadow(this, "_commonActions", {
      display: event => {
        const {
          display
        } = event.detail;
        const hidden = display % 2 === 1;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          noView: hidden,
          noPrint: display === 1 || display === 2
        });
      },
      print: event => {
        this.annotationStorage.setValue(this.data.id, {
          noPrint: !event.detail.print
        });
      },
      hidden: event => {
        const {
          hidden
        } = event.detail;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          noPrint: hidden,
          noView: hidden
        });
      },
      focus: event => {
        setTimeout(() => event.target.focus({
          preventScroll: false
        }), 0);
      },
      userName: event => {
        event.target.title = event.detail.userName;
      },
      readonly: event => {
        event.target.disabled = event.detail.readonly;
      },
      required: event => {
        this._setRequired(event.target, event.detail.required);
      },
      bgColor: event => {
        setColor("bgColor", "backgroundColor", event);
      },
      fillColor: event => {
        setColor("fillColor", "backgroundColor", event);
      },
      fgColor: event => {
        setColor("fgColor", "color", event);
      },
      textColor: event => {
        setColor("textColor", "color", event);
      },
      borderColor: event => {
        setColor("borderColor", "borderColor", event);
      },
      strokeColor: event => {
        setColor("strokeColor", "borderColor", event);
      },
      rotation: event => {
        const angle = event.detail.rotation;
        this.setRotation(angle);
        this.annotationStorage.setValue(this.data.id, {
          rotation: angle
        });
      }
    });
  }
  _dispatchEventFromSandbox(actions, jsEvent) {
    const commonActions = this._commonActions;
    for (const name of Object.keys(jsEvent.detail)) {
      const action = actions[name] || commonActions[name];
      action?.(jsEvent);
    }
  }
  _setDefaultPropertiesFromJS(element) {
    if (!this.enableScripting) {
      return;
    }
    const storedData = this.annotationStorage.getRawValue(this.data.id);
    if (!storedData) {
      return;
    }
    const commonActions = this._commonActions;
    for (const [actionName, detail] of Object.entries(storedData)) {
      const action = commonActions[actionName];
      if (action) {
        const eventProxy = {
          detail: {
            [actionName]: detail
          },
          target: element
        };
        action(eventProxy);
        delete storedData[actionName];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container) {
      return;
    }
    const {
      quadPoints
    } = this.data;
    if (!quadPoints) {
      return;
    }
    const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map(x => Math.fround(x));
    if (quadPoints.length === 8) {
      const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);
      if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {
        return;
      }
    }
    const {
      style
    } = this.container;
    let svgBuffer;
    if (this.#hasBorder) {
      const {
        borderColor,
        borderWidth
      } = style;
      style.borderWidth = 0;
      svgBuffer = ["url('data:image/svg+xml;utf8,", `<svg xmlns="http://www.w3.org/2000/svg"`, ` preserveAspectRatio="none" viewBox="0 0 1 1">`, `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`];
      this.container.classList.add("hasBorder");
    }
    const width = rectTrX - rectBlX;
    const height = rectTrY - rectBlY;
    const {
      svgFactory
    } = this;
    const svg = svgFactory.createElement("svg");
    svg.classList.add("quadrilateralsContainer");
    svg.setAttribute("width", 0);
    svg.setAttribute("height", 0);
    const defs = svgFactory.createElement("defs");
    svg.append(defs);
    const clipPath = svgFactory.createElement("clipPath");
    const id = `clippath_${this.data.id}`;
    clipPath.setAttribute("id", id);
    clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
    defs.append(clipPath);
    for (let i = 2, ii = quadPoints.length; i < ii; i += 8) {
      const trX = quadPoints[i];
      const trY = quadPoints[i + 1];
      const blX = quadPoints[i + 2];
      const blY = quadPoints[i + 3];
      const rect = svgFactory.createElement("rect");
      const x = (blX - rectBlX) / width;
      const y = (rectTrY - trY) / height;
      const rectWidth = (trX - blX) / width;
      const rectHeight = (trY - blY) / height;
      rect.setAttribute("x", x);
      rect.setAttribute("y", y);
      rect.setAttribute("width", rectWidth);
      rect.setAttribute("height", rectHeight);
      clipPath.append(rect);
      svgBuffer?.push(`<rect vector-effect="non-scaling-stroke" x="${x}" y="${y}" width="${rectWidth}" height="${rectHeight}"/>`);
    }
    if (this.#hasBorder) {
      svgBuffer.push(`</g></svg>')`);
      style.backgroundImage = svgBuffer.join("");
    }
    this.container.append(svg);
    this.container.style.clipPath = `url(#${id})`;
  }
  _createPopup() {
    const {
      container,
      data
    } = this;
    container.setAttribute("aria-haspopup", "dialog");
    const popup = this.#popupElement = new PopupAnnotationElement({
      data: {
        color: data.color,
        titleObj: data.titleObj,
        modificationDate: data.modificationDate,
        contentsObj: data.contentsObj,
        richText: data.richText,
        parentRect: data.rect,
        borderStyle: 0,
        id: `popup_${data.id}`,
        rotation: data.rotation
      },
      parent: this.parent,
      elements: [this]
    });
    this.parent.div.append(popup.render());
  }
  render() {
    unreachable("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(name, skipId = null) {
    const fields = [];
    if (this._fieldObjects) {
      const fieldObj = this._fieldObjects[name];
      if (fieldObj) {
        for (const {
          page,
          id,
          exportValues
        } of fieldObj) {
          if (page === -1) {
            continue;
          }
          if (id === skipId) {
            continue;
          }
          const exportValue = typeof exportValues === "string" ? exportValues : null;
          const domElement = document.querySelector(`[data-element-id="${id}"]`);
          if (domElement && !GetElementsByNameSet.has(domElement)) {
            warn(`_getElementsByName - element not allowed: ${id}`);
            continue;
          }
          fields.push({
            id,
            exportValue,
            domElement
          });
        }
      }
      return fields;
    }
    for (const domElement of document.getElementsByName(name)) {
      const {
        exportValue
      } = domElement;
      const id = domElement.getAttribute("data-element-id");
      if (id === skipId) {
        continue;
      }
      if (!GetElementsByNameSet.has(domElement)) {
        continue;
      }
      fields.push({
        id,
        exportValue,
        domElement
      });
    }
    return fields;
  }
  show() {
    if (this.container) {
      this.container.hidden = false;
    }
    this.popup?.maybeShow();
  }
  hide() {
    if (this.container) {
      this.container.hidden = true;
    }
    this.popup?.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const triggers = this.getElementsToTriggerPopup();
    if (Array.isArray(triggers)) {
      for (const element of triggers) {
        element.classList.add("highlightArea");
      }
    } else {
      triggers.classList.add("highlightArea");
    }
  }
  get _isEditable() {
    return false;
  }
  _editOnDoubleClick() {
    if (!this._isEditable) {
      return;
    }
    const {
      annotationEditorType: mode,
      data: {
        id: editId
      }
    } = this;
    this.container.addEventListener("dblclick", () => {
      this.linkService.eventBus?.dispatch("switchannotationeditormode", {
        source: this,
        mode,
        editId
      });
    });
  }
}
class LinkAnnotationElement extends AnnotationElement {
  constructor(parameters, options = null) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: !!options?.ignoreBorder,
      createQuadrilaterals: true
    });
    this.isTooltipOnly = parameters.data.isTooltipOnly;
  }
  render() {
    const {
      data,
      linkService
    } = this;
    const link = document.createElement("a");
    link.setAttribute("data-element-id", data.id);
    let isBound = false;
    if (data.url) {
      linkService.addLinkAttributes(link, data.url, data.newWindow);
      isBound = true;
    } else if (data.action) {
      this._bindNamedAction(link, data.action);
      isBound = true;
    } else if (data.attachment) {
      this.#bindAttachment(link, data.attachment, data.attachmentDest);
      isBound = true;
    } else if (data.setOCGState) {
      this.#bindSetOCGState(link, data.setOCGState);
      isBound = true;
    } else if (data.dest) {
      this._bindLink(link, data.dest);
      isBound = true;
    } else {
      if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
        this._bindJSAction(link, data);
        isBound = true;
      }
      if (data.resetForm) {
        this._bindResetFormAction(link, data.resetForm);
        isBound = true;
      } else if (this.isTooltipOnly && !isBound) {
        this._bindLink(link, "");
        isBound = true;
      }
    }
    this.container.classList.add("linkAnnotation");
    if (isBound) {
      this.container.append(link);
    }
    return this.container;
  }
  #setInternalLink() {
    this.container.setAttribute("data-internal-link", "");
  }
  _bindLink(link, destination) {
    link.href = this.linkService.getDestinationHash(destination);
    link.onclick = () => {
      if (destination) {
        this.linkService.goToDestination(destination);
      }
      return false;
    };
    if (destination || destination === "") {
      this.#setInternalLink();
    }
  }
  _bindNamedAction(link, action) {
    link.href = this.linkService.getAnchorUrl("");
    link.onclick = () => {
      this.linkService.executeNamedAction(action);
      return false;
    };
    this.#setInternalLink();
  }
  #bindAttachment(link, attachment, dest = null) {
    link.href = this.linkService.getAnchorUrl("");
    if (attachment.description) {
      link.title = attachment.description;
    }
    link.onclick = () => {
      this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);
      return false;
    };
    this.#setInternalLink();
  }
  #bindSetOCGState(link, action) {
    link.href = this.linkService.getAnchorUrl("");
    link.onclick = () => {
      this.linkService.executeSetOCGState(action);
      return false;
    };
    this.#setInternalLink();
  }
  _bindJSAction(link, data) {
    link.href = this.linkService.getAnchorUrl("");
    const map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const name of Object.keys(data.actions)) {
      const jsName = map.get(name);
      if (!jsName) {
        continue;
      }
      link[jsName] = () => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: data.id,
            name
          }
        });
        return false;
      };
    }
    if (!link.onclick) {
      link.onclick = () => false;
    }
    this.#setInternalLink();
  }
  _bindResetFormAction(link, resetForm) {
    const otherClickAction = link.onclick;
    if (!otherClickAction) {
      link.href = this.linkService.getAnchorUrl("");
    }
    this.#setInternalLink();
    if (!this._fieldObjects) {
      warn(`_bindResetFormAction - "resetForm" action not supported, ` + "ensure that the `fieldObjects` parameter is provided.");
      if (!otherClickAction) {
        link.onclick = () => false;
      }
      return;
    }
    link.onclick = () => {
      otherClickAction?.();
      const {
        fields: resetFormFields,
        refs: resetFormRefs,
        include
      } = resetForm;
      const allFields = [];
      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
        const fieldIds = new Set(resetFormRefs);
        for (const fieldName of resetFormFields) {
          const fields = this._fieldObjects[fieldName] || [];
          for (const {
            id
          } of fields) {
            fieldIds.add(id);
          }
        }
        for (const fields of Object.values(this._fieldObjects)) {
          for (const field of fields) {
            if (fieldIds.has(field.id) === include) {
              allFields.push(field);
            }
          }
        }
      } else {
        for (const fields of Object.values(this._fieldObjects)) {
          allFields.push(...fields);
        }
      }
      const storage = this.annotationStorage;
      const allIds = [];
      for (const field of allFields) {
        const {
          id
        } = field;
        allIds.push(id);
        switch (field.type) {
          case "text":
            {
              const value = field.defaultValue || "";
              storage.setValue(id, {
                value
              });
              break;
            }
          case "checkbox":
          case "radiobutton":
            {
              const value = field.defaultValue === field.exportValues;
              storage.setValue(id, {
                value
              });
              break;
            }
          case "combobox":
          case "listbox":
            {
              const value = field.defaultValue || "";
              storage.setValue(id, {
                value
              });
              break;
            }
          default:
            continue;
        }
        const domElement = document.querySelector(`[data-element-id="${id}"]`);
        if (!domElement) {
          continue;
        } else if (!GetElementsByNameSet.has(domElement)) {
          warn(`_bindResetFormAction - element not allowed: ${id}`);
          continue;
        }
        domElement.dispatchEvent(new Event("resetform"));
      }
      if (this.enableScripting) {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: "app",
            ids: allIds,
            name: "ResetForm"
          }
        });
      }
      return false;
    };
  }
}
class TextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true
    });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const image = document.createElement("img");
    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
    image.setAttribute("data-l10n-id", "pdfjs-text-annotation-type");
    image.setAttribute("data-l10n-args", JSON.stringify({
      type: this.data.name
    }));
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.append(image);
    return this.container;
  }
}
class WidgetAnnotationElement extends AnnotationElement {
  render() {
    return this.container;
  }
  showElementAndHideCanvas(element) {
    if (this.data.hasOwnCanvas) {
      if (element.previousSibling?.nodeName === "CANVAS") {
        element.previousSibling.hidden = true;
      }
      element.hidden = false;
    }
  }
  _getKeyModifier(event) {
    return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;
  }
  _setEventListener(element, elementData, baseName, eventName, valueGetter) {
    if (baseName.includes("mouse")) {
      element.addEventListener(baseName, event => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event),
            shift: event.shiftKey,
            modifier: this._getKeyModifier(event)
          }
        });
      });
    } else {
      element.addEventListener(baseName, event => {
        if (baseName === "blur") {
          if (!elementData.focused || !event.relatedTarget) {
            return;
          }
          elementData.focused = false;
        } else if (baseName === "focus") {
          if (elementData.focused) {
            return;
          }
          elementData.focused = true;
        }
        if (!valueGetter) {
          return;
        }
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event)
          }
        });
      });
    }
  }
  _setEventListeners(element, elementData, names, getter) {
    for (const [baseName, eventName] of names) {
      if (eventName === "Action" || this.data.actions?.[eventName]) {
        if (eventName === "Focus" || eventName === "Blur") {
          elementData ||= {
            focused: false
          };
        }
        this._setEventListener(element, elementData, baseName, eventName, getter);
        if (eventName === "Focus" && !this.data.actions?.Blur) {
          this._setEventListener(element, elementData, "blur", "Blur", null);
        } else if (eventName === "Blur" && !this.data.actions?.Focus) {
          this._setEventListener(element, elementData, "focus", "Focus", null);
        }
      }
    }
  }
  _setBackgroundColor(element) {
    const color = this.data.backgroundColor || null;
    element.style.backgroundColor = color === null ? "transparent" : Util.makeHexColor(color[0], color[1], color[2]);
  }
  _setTextStyle(element) {
    const TEXT_ALIGNMENT = ["left", "center", "right"];
    const {
      fontColor
    } = this.data.defaultAppearanceData;
    const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;
    const style = element.style;
    let computedFontSize;
    const BORDER_SIZE = 2;
    const roundToOneDecimal = x => Math.round(10 * x) / 10;
    if (this.data.multiLine) {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
      const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;
      const lineHeight = height / numberOfLines;
      computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));
    } else {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
      computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));
    }
    style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
    style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
    if (this.data.textAlignment !== null) {
      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
    }
  }
  _setRequired(element, isRequired) {
    if (isRequired) {
      element.setAttribute("required", true);
    } else {
      element.removeAttribute("required");
    }
    element.setAttribute("aria-required", isRequired);
  }
}
class TextWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
    super(parameters, {
      isRenderable
    });
  }
  setPropertyOnSiblings(base, key, value, keyInStorage) {
    const storage = this.annotationStorage;
    for (const element of this._getElementsByName(base.name, base.id)) {
      if (element.domElement) {
        element.domElement[key] = value;
      }
      storage.setValue(element.id, {
        [keyInStorage]: value
      });
    }
  }
  render() {
    const storage = this.annotationStorage;
    const id = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let element = null;
    if (this.renderForms) {
      const storedData = storage.getValue(id, {
        value: this.data.fieldValue
      });
      let textContent = storedData.value || "";
      const maxLen = storage.getValue(id, {
        charLimit: this.data.maxLen
      }).charLimit;
      if (maxLen && textContent.length > maxLen) {
        textContent = textContent.slice(0, maxLen);
      }
      let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join("\n") || null;
      if (fieldFormattedValues && this.data.comb) {
        fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
      }
      const elementData = {
        userValue: textContent,
        formattedValue: fieldFormattedValues,
        lastCommittedValue: null,
        commitKey: 1,
        focused: false
      };
      if (this.data.multiLine) {
        element = document.createElement("textarea");
        element.textContent = fieldFormattedValues ?? textContent;
        if (this.data.doNotScroll) {
          element.style.overflowY = "hidden";
        }
      } else {
        element = document.createElement("input");
        element.type = "text";
        element.setAttribute("value", fieldFormattedValues ?? textContent);
        if (this.data.doNotScroll) {
          element.style.overflowX = "hidden";
        }
      }
      if (this.data.hasOwnCanvas) {
        element.hidden = true;
      }
      GetElementsByNameSet.add(element);
      element.setAttribute("data-element-id", id);
      element.disabled = this.data.readOnly;
      element.name = this.data.fieldName;
      element.tabIndex = DEFAULT_TAB_INDEX;
      this._setRequired(element, this.data.required);
      if (maxLen) {
        element.maxLength = maxLen;
      }
      element.addEventListener("input", event => {
        storage.setValue(id, {
          value: event.target.value
        });
        this.setPropertyOnSiblings(element, "value", event.target.value, "value");
        elementData.formattedValue = null;
      });
      element.addEventListener("resetform", event => {
        const defaultValue = this.data.defaultFieldValue ?? "";
        element.value = elementData.userValue = defaultValue;
        elementData.formattedValue = null;
      });
      let blurListener = event => {
        const {
          formattedValue
        } = elementData;
        if (formattedValue !== null && formattedValue !== undefined) {
          event.target.value = formattedValue;
        }
        event.target.scrollLeft = 0;
      };
      if (this.enableScripting && this.hasJSActions) {
        element.addEventListener("focus", event => {
          if (elementData.focused) {
            return;
          }
          const {
            target
          } = event;
          if (elementData.userValue) {
            target.value = elementData.userValue;
          }
          elementData.lastCommittedValue = target.value;
          elementData.commitKey = 1;
          if (!this.data.actions?.Focus) {
            elementData.focused = true;
          }
        });
        element.addEventListener("updatefromsandbox", jsEvent => {
          this.showElementAndHideCanvas(jsEvent.target);
          const actions = {
            value(event) {
              elementData.userValue = event.detail.value ?? "";
              storage.setValue(id, {
                value: elementData.userValue.toString()
              });
              event.target.value = elementData.userValue;
            },
            formattedValue(event) {
              const {
                formattedValue
              } = event.detail;
              elementData.formattedValue = formattedValue;
              if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {
                event.target.value = formattedValue;
              }
              storage.setValue(id, {
                formattedValue
              });
            },
            selRange(event) {
              event.target.setSelectionRange(...event.detail.selRange);
            },
            charLimit: event => {
              const {
                charLimit
              } = event.detail;
              const {
                target
              } = event;
              if (charLimit === 0) {
                target.removeAttribute("maxLength");
                return;
              }
              target.setAttribute("maxLength", charLimit);
              let value = elementData.userValue;
              if (!value || value.length <= charLimit) {
                return;
              }
              value = value.slice(0, charLimit);
              target.value = elementData.userValue = value;
              storage.setValue(id, {
                value
              });
              this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id,
                  name: "Keystroke",
                  value,
                  willCommit: true,
                  commitKey: 1,
                  selStart: target.selectionStart,
                  selEnd: target.selectionEnd
                }
              });
            }
          };
          this._dispatchEventFromSandbox(actions, jsEvent);
        });
        element.addEventListener("keydown", event => {
          elementData.commitKey = 1;
          let commitKey = -1;
          if (event.key === "Escape") {
            commitKey = 0;
          } else if (event.key === "Enter" && !this.data.multiLine) {
            commitKey = 2;
          } else if (event.key === "Tab") {
            elementData.commitKey = 3;
          }
          if (commitKey === -1) {
            return;
          }
          const {
            value
          } = event.target;
          if (elementData.lastCommittedValue === value) {
            return;
          }
          elementData.lastCommittedValue = value;
          elementData.userValue = value;
          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id,
              name: "Keystroke",
              value,
              willCommit: true,
              commitKey,
              selStart: event.target.selectionStart,
              selEnd: event.target.selectionEnd
            }
          });
        });
        const _blurListener = blurListener;
        blurListener = null;
        element.addEventListener("blur", event => {
          if (!elementData.focused || !event.relatedTarget) {
            return;
          }
          if (!this.data.actions?.Blur) {
            elementData.focused = false;
          }
          const {
            value
          } = event.target;
          elementData.userValue = value;
          if (elementData.lastCommittedValue !== value) {
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                willCommit: true,
                commitKey: elementData.commitKey,
                selStart: event.target.selectionStart,
                selEnd: event.target.selectionEnd
              }
            });
          }
          _blurListener(event);
        });
        if (this.data.actions?.Keystroke) {
          element.addEventListener("beforeinput", event => {
            elementData.lastCommittedValue = null;
            const {
              data,
              target
            } = event;
            const {
              value,
              selectionStart,
              selectionEnd
            } = target;
            let selStart = selectionStart,
              selEnd = selectionEnd;
            switch (event.inputType) {
              case "deleteWordBackward":
                {
                  const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                  if (match) {
                    selStart -= match[0].length;
                  }
                  break;
                }
              case "deleteWordForward":
                {
                  const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                  if (match) {
                    selEnd += match[0].length;
                  }
                  break;
                }
              case "deleteContentBackward":
                if (selectionStart === selectionEnd) {
                  selStart -= 1;
                }
                break;
              case "deleteContentForward":
                if (selectionStart === selectionEnd) {
                  selEnd += 1;
                }
                break;
            }
            event.preventDefault();
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                change: data || "",
                willCommit: false,
                selStart,
                selEnd
              }
            });
          });
        }
        this._setEventListeners(element, elementData, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.value);
      }
      if (blurListener) {
        element.addEventListener("blur", blurListener);
      }
      if (this.data.comb) {
        const fieldWidth = this.data.rect[2] - this.data.rect[0];
        const combWidth = fieldWidth / maxLen;
        element.classList.add("comb");
        element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
      }
    } else {
      element = document.createElement("div");
      element.textContent = this.data.fieldValue;
      element.style.verticalAlign = "middle";
      element.style.display = "table-cell";
      if (this.data.hasOwnCanvas) {
        element.hidden = true;
      }
    }
    this._setTextStyle(element);
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
}
class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: !!parameters.data.hasOwnCanvas
    });
  }
}
class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.exportValue === data.fieldValue
    }).value;
    if (typeof value === "string") {
      value = value !== "Off";
      storage.setValue(id, {
        value
      });
    }
    this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;
    this._setRequired(element, this.data.required);
    element.type = "checkbox";
    element.name = data.fieldName;
    if (value) {
      element.setAttribute("checked", true);
    }
    element.setAttribute("exportValue", data.exportValue);
    element.tabIndex = DEFAULT_TAB_INDEX;
    element.addEventListener("change", event => {
      const {
        name,
        checked
      } = event.target;
      for (const checkbox of this._getElementsByName(name, id)) {
        const curChecked = checked && checkbox.exportValue === data.exportValue;
        if (checkbox.domElement) {
          checkbox.domElement.checked = curChecked;
        }
        storage.setValue(checkbox.id, {
          value: curChecked
        });
      }
      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", event => {
      const defaultValue = data.defaultFieldValue || "Off";
      event.target.checked = defaultValue === data.exportValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      element.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value(event) {
            event.target.checked = event.detail.value !== "Off";
            storage.setValue(id, {
              value: event.target.checked
            });
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
    }
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
}
class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.fieldValue === data.buttonValue
    }).value;
    if (typeof value === "string") {
      value = value !== data.buttonValue;
      storage.setValue(id, {
        value
      });
    }
    if (value) {
      for (const radio of this._getElementsByName(data.fieldName, id)) {
        storage.setValue(radio.id, {
          value: false
        });
      }
    }
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;
    this._setRequired(element, this.data.required);
    element.type = "radio";
    element.name = data.fieldName;
    if (value) {
      element.setAttribute("checked", true);
    }
    element.tabIndex = DEFAULT_TAB_INDEX;
    element.addEventListener("change", event => {
      const {
        name,
        checked
      } = event.target;
      for (const radio of this._getElementsByName(name, id)) {
        storage.setValue(radio.id, {
          value: false
        });
      }
      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", event => {
      const defaultValue = data.defaultFieldValue;
      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      const pdfButtonValue = data.buttonValue;
      element.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value: event => {
            const checked = pdfButtonValue === event.detail.value;
            for (const radio of this._getElementsByName(event.target.name)) {
              const curChecked = checked && radio.id === id;
              if (radio.domElement) {
                radio.domElement.checked = curChecked;
              }
              storage.setValue(radio.id, {
                value: curChecked
              });
            }
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
    }
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
}
class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      ignoreBorder: parameters.data.hasAppearance
    });
  }
  render() {
    const container = super.render();
    container.classList.add("buttonWidgetAnnotation", "pushButton");
    const linkElement = container.lastChild;
    if (this.enableScripting && this.hasJSActions && linkElement) {
      this._setDefaultPropertiesFromJS(linkElement);
      linkElement.addEventListener("updatefromsandbox", jsEvent => {
        this._dispatchEventFromSandbox({}, jsEvent);
      });
    }
    return container;
  }
}
class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const storage = this.annotationStorage;
    const id = this.data.id;
    const storedData = storage.getValue(id, {
      value: this.data.fieldValue
    });
    const selectElement = document.createElement("select");
    GetElementsByNameSet.add(selectElement);
    selectElement.setAttribute("data-element-id", id);
    selectElement.disabled = this.data.readOnly;
    this._setRequired(selectElement, this.data.required);
    selectElement.name = this.data.fieldName;
    selectElement.tabIndex = DEFAULT_TAB_INDEX;
    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
    if (!this.data.combo) {
      selectElement.size = this.data.options.length;
      if (this.data.multiSelect) {
        selectElement.multiple = true;
      }
    }
    selectElement.addEventListener("resetform", event => {
      const defaultValue = this.data.defaultFieldValue;
      for (const option of selectElement.options) {
        option.selected = option.value === defaultValue;
      }
    });
    for (const option of this.data.options) {
      const optionElement = document.createElement("option");
      optionElement.textContent = option.displayValue;
      optionElement.value = option.exportValue;
      if (storedData.value.includes(option.exportValue)) {
        optionElement.setAttribute("selected", true);
        addAnEmptyEntry = false;
      }
      selectElement.append(optionElement);
    }
    let removeEmptyEntry = null;
    if (addAnEmptyEntry) {
      const noneOptionElement = document.createElement("option");
      noneOptionElement.value = " ";
      noneOptionElement.setAttribute("hidden", true);
      noneOptionElement.setAttribute("selected", true);
      selectElement.prepend(noneOptionElement);
      removeEmptyEntry = () => {
        noneOptionElement.remove();
        selectElement.removeEventListener("input", removeEmptyEntry);
        removeEmptyEntry = null;
      };
      selectElement.addEventListener("input", removeEmptyEntry);
    }
    const getValue = isExport => {
      const name = isExport ? "value" : "textContent";
      const {
        options,
        multiple
      } = selectElement;
      if (!multiple) {
        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
      }
      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);
    };
    let selectedValues = getValue(false);
    const getItems = event => {
      const options = event.target.options;
      return Array.prototype.map.call(options, option => ({
        displayValue: option.textContent,
        exportValue: option.value
      }));
    };
    if (this.enableScripting && this.hasJSActions) {
      selectElement.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value(event) {
            removeEmptyEntry?.();
            const value = event.detail.value;
            const values = new Set(Array.isArray(value) ? value : [value]);
            for (const option of selectElement.options) {
              option.selected = values.has(option.value);
            }
            storage.setValue(id, {
              value: getValue(true)
            });
            selectedValues = getValue(false);
          },
          multipleSelection(event) {
            selectElement.multiple = true;
          },
          remove(event) {
            const options = selectElement.options;
            const index = event.detail.remove;
            options[index].selected = false;
            selectElement.remove(index);
            if (options.length > 0) {
              const i = Array.prototype.findIndex.call(options, option => option.selected);
              if (i === -1) {
                options[0].selected = true;
              }
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          clear(event) {
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }
            storage.setValue(id, {
              value: null,
              items: []
            });
            selectedValues = getValue(false);
          },
          insert(event) {
            const {
              index,
              displayValue,
              exportValue
            } = event.detail.insert;
            const selectChild = selectElement.children[index];
            const optionElement = document.createElement("option");
            optionElement.textContent = displayValue;
            optionElement.value = exportValue;
            if (selectChild) {
              selectChild.before(optionElement);
            } else {
              selectElement.append(optionElement);
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          items(event) {
            const {
              items
            } = event.detail;
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }
            for (const item of items) {
              const {
                displayValue,
                exportValue
              } = item;
              const optionElement = document.createElement("option");
              optionElement.textContent = displayValue;
              optionElement.value = exportValue;
              selectElement.append(optionElement);
            }
            if (selectElement.options.length > 0) {
              selectElement.options[0].selected = true;
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          indices(event) {
            const indices = new Set(event.detail.indices);
            for (const option of event.target.options) {
              option.selected = indices.has(option.index);
            }
            storage.setValue(id, {
              value: getValue(true)
            });
            selectedValues = getValue(false);
          },
          editable(event) {
            event.target.disabled = !event.detail.editable;
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      selectElement.addEventListener("input", event => {
        const exportValue = getValue(true);
        const change = getValue(false);
        storage.setValue(id, {
          value: exportValue
        });
        event.preventDefault();
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id,
            name: "Keystroke",
            value: selectedValues,
            change,
            changeEx: exportValue,
            willCommit: false,
            commitKey: 1,
            keyDown: false
          }
        });
      });
      this._setEventListeners(selectElement, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], event => event.target.value);
    } else {
      selectElement.addEventListener("input", function (event) {
        storage.setValue(id, {
          value: getValue(true)
        });
      });
    }
    if (this.data.combo) {
      this._setTextStyle(selectElement);
    }
    this._setBackgroundColor(selectElement);
    this._setDefaultPropertiesFromJS(selectElement);
    this.container.append(selectElement);
    return this.container;
  }
}
class PopupAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const {
      data,
      elements
    } = parameters;
    super(parameters, {
      isRenderable: AnnotationElement._hasPopupData(data)
    });
    this.elements = elements;
    this.popup = null;
  }
  render() {
    this.container.classList.add("popupAnnotation");
    const popup = this.popup = new PopupElement({
      container: this.container,
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText,
      rect: this.data.rect,
      parentRect: this.data.parentRect || null,
      parent: this.parent,
      elements: this.elements,
      open: this.data.open
    });
    const elementIds = [];
    for (const element of this.elements) {
      element.popup = popup;
      elementIds.push(element.data.id);
      element.addHighlightArea();
    }
    this.container.setAttribute("aria-controls", elementIds.map(id => `${AnnotationPrefix}${id}`).join(","));
    return this.container;
  }
}
class PopupElement {
  #boundKeyDown = this.#keyDown.bind(this);
  #boundHide = this.#hide.bind(this);
  #boundShow = this.#show.bind(this);
  #boundToggle = this.#toggle.bind(this);
  #color = null;
  #container = null;
  #contentsObj = null;
  #dateObj = null;
  #elements = null;
  #parent = null;
  #parentRect = null;
  #pinned = false;
  #popup = null;
  #position = null;
  #rect = null;
  #richText = null;
  #titleObj = null;
  #updates = null;
  #wasVisible = false;
  constructor({
    container,
    color,
    elements,
    titleObj,
    modificationDate,
    contentsObj,
    richText,
    parent,
    rect,
    parentRect,
    open
  }) {
    this.#container = container;
    this.#titleObj = titleObj;
    this.#contentsObj = contentsObj;
    this.#richText = richText;
    this.#parent = parent;
    this.#color = color;
    this.#rect = rect;
    this.#parentRect = parentRect;
    this.#elements = elements;
    this.#dateObj = PDFDateString.toDateObject(modificationDate);
    this.trigger = elements.flatMap(e => e.getElementsToTriggerPopup());
    for (const element of this.trigger) {
      element.addEventListener("click", this.#boundToggle);
      element.addEventListener("mouseenter", this.#boundShow);
      element.addEventListener("mouseleave", this.#boundHide);
      element.classList.add("popupTriggerArea");
    }
    for (const element of elements) {
      element.container?.addEventListener("keydown", this.#boundKeyDown);
    }
    this.#container.hidden = true;
    if (open) {
      this.#toggle();
    }
  }
  render() {
    if (this.#popup) {
      return;
    }
    const popup = this.#popup = document.createElement("div");
    popup.className = "popup";
    if (this.#color) {
      const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);
      if (CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")) {
        popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
      } else {
        const BACKGROUND_ENLIGHT = 0.7;
        popup.style.backgroundColor = Util.makeHexColor(...this.#color.map(c => Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));
      }
    }
    const header = document.createElement("span");
    header.className = "header";
    const title = document.createElement("h1");
    header.append(title);
    ({
      dir: title.dir,
      str: title.textContent
    } = this.#titleObj);
    popup.append(header);
    if (this.#dateObj) {
      const modificationDate = document.createElement("span");
      modificationDate.classList.add("popupDate");
      modificationDate.setAttribute("data-l10n-id", "pdfjs-annotation-date-string");
      modificationDate.setAttribute("data-l10n-args", JSON.stringify({
        date: this.#dateObj.toLocaleDateString(),
        time: this.#dateObj.toLocaleTimeString()
      }));
      header.append(modificationDate);
    }
    const html = this.#html;
    if (html) {
      XfaLayer.render({
        xfaHtml: html,
        intent: "richText",
        div: popup
      });
      popup.lastChild.classList.add("richText", "popupContent");
    } else {
      const contents = this._formatContents(this.#contentsObj);
      popup.append(contents);
    }
    this.#container.append(popup);
  }
  get #html() {
    const richText = this.#richText;
    const contentsObj = this.#contentsObj;
    if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {
      return this.#richText.html || null;
    }
    return null;
  }
  get #fontSize() {
    return this.#html?.attributes?.style?.fontSize || 0;
  }
  get #fontColor() {
    return this.#html?.attributes?.style?.color || null;
  }
  #makePopupContent(text) {
    const popupLines = [];
    const popupContent = {
      str: text,
      html: {
        name: "div",
        attributes: {
          dir: "auto"
        },
        children: [{
          name: "p",
          children: popupLines
        }]
      }
    };
    const lineAttributes = {
      style: {
        color: this.#fontColor,
        fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--scale-factor))` : ""
      }
    };
    for (const line of text.split("\n")) {
      popupLines.push({
        name: "span",
        value: line,
        attributes: lineAttributes
      });
    }
    return popupContent;
  }
  _formatContents({
    str,
    dir
  }) {
    const p = document.createElement("p");
    p.classList.add("popupContent");
    p.dir = dir;
    const lines = str.split(/(?:\r\n?|\n)/);
    for (let i = 0, ii = lines.length; i < ii; ++i) {
      const line = lines[i];
      p.append(document.createTextNode(line));
      if (i < ii - 1) {
        p.append(document.createElement("br"));
      }
    }
    return p;
  }
  #keyDown(event) {
    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
      return;
    }
    if (event.key === "Enter" || event.key === "Escape" && this.#pinned) {
      this.#toggle();
    }
  }
  updateEdited({
    rect,
    popupContent
  }) {
    this.#updates ||= {
      contentsObj: this.#contentsObj,
      richText: this.#richText
    };
    if (rect) {
      this.#position = null;
    }
    if (popupContent) {
      this.#richText = this.#makePopupContent(popupContent);
      this.#contentsObj = null;
    }
    this.#popup?.remove();
    this.#popup = null;
  }
  resetEdited() {
    if (!this.#updates) {
      return;
    }
    ({
      contentsObj: this.#contentsObj,
      richText: this.#richText
    } = this.#updates);
    this.#updates = null;
    this.#popup?.remove();
    this.#popup = null;
    this.#position = null;
  }
  #setPosition() {
    if (this.#position !== null) {
      return;
    }
    const {
      page: {
        view
      },
      viewport: {
        rawDims: {
          pageWidth,
          pageHeight,
          pageX,
          pageY
        }
      }
    } = this.#parent;
    let useParentRect = !!this.#parentRect;
    let rect = useParentRect ? this.#parentRect : this.#rect;
    for (const element of this.#elements) {
      if (!rect || Util.intersect(element.data.rect, rect) !== null) {
        rect = element.data.rect;
        useParentRect = true;
        break;
      }
    }
    const normalizedRect = Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);
    const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
    const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
    const popupLeft = normalizedRect[0] + parentWidth;
    const popupTop = normalizedRect[1];
    this.#position = [100 * (popupLeft - pageX) / pageWidth, 100 * (popupTop - pageY) / pageHeight];
    const {
      style
    } = this.#container;
    style.left = `${this.#position[0]}%`;
    style.top = `${this.#position[1]}%`;
  }
  #toggle() {
    this.#pinned = !this.#pinned;
    if (this.#pinned) {
      this.#show();
      this.#container.addEventListener("click", this.#boundToggle);
      this.#container.addEventListener("keydown", this.#boundKeyDown);
    } else {
      this.#hide();
      this.#container.removeEventListener("click", this.#boundToggle);
      this.#container.removeEventListener("keydown", this.#boundKeyDown);
    }
  }
  #show() {
    if (!this.#popup) {
      this.render();
    }
    if (!this.isVisible) {
      this.#setPosition();
      this.#container.hidden = false;
      this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;
    } else if (this.#pinned) {
      this.#container.classList.add("focused");
    }
  }
  #hide() {
    this.#container.classList.remove("focused");
    if (this.#pinned || !this.isVisible) {
      return;
    }
    this.#container.hidden = true;
    this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;
  }
  forceHide() {
    this.#wasVisible = this.isVisible;
    if (!this.#wasVisible) {
      return;
    }
    this.#container.hidden = true;
  }
  maybeShow() {
    if (!this.#wasVisible) {
      return;
    }
    if (!this.#popup) {
      this.#show();
    }
    this.#wasVisible = false;
    this.#container.hidden = false;
  }
  get isVisible() {
    return this.#container.hidden === false;
  }
}
class FreeTextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.textContent = parameters.data.textContent;
    this.textPosition = parameters.data.textPosition;
    this.annotationEditorType = AnnotationEditorType.FREETEXT;
  }
  render() {
    this.container.classList.add("freeTextAnnotation");
    if (this.textContent) {
      const content = document.createElement("div");
      content.classList.add("annotationTextContent");
      content.setAttribute("role", "comment");
      for (const line of this.textContent) {
        const lineSpan = document.createElement("span");
        lineSpan.textContent = line;
        content.append(lineSpan);
      }
      this.container.append(content);
    }
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this._editOnDoubleClick();
    return this.container;
  }
  get _isEditable() {
    return this.data.hasOwnCanvas;
  }
}
class LineAnnotationElement extends AnnotationElement {
  #line = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    const line = this.#line = this.svgFactory.createElement("svg:line");
    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
    line.setAttribute("stroke-width", data.borderStyle.width || 1);
    line.setAttribute("stroke", "transparent");
    line.setAttribute("fill", "transparent");
    svg.append(line);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#line;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class SquareAnnotationElement extends AnnotationElement {
  #square = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const square = this.#square = this.svgFactory.createElement("svg:rect");
    square.setAttribute("x", borderWidth / 2);
    square.setAttribute("y", borderWidth / 2);
    square.setAttribute("width", width - borderWidth);
    square.setAttribute("height", height - borderWidth);
    square.setAttribute("stroke-width", borderWidth || 1);
    square.setAttribute("stroke", "transparent");
    square.setAttribute("fill", "transparent");
    svg.append(square);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#square;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class CircleAnnotationElement extends AnnotationElement {
  #circle = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const circle = this.#circle = this.svgFactory.createElement("svg:ellipse");
    circle.setAttribute("cx", width / 2);
    circle.setAttribute("cy", height / 2);
    circle.setAttribute("rx", width / 2 - borderWidth / 2);
    circle.setAttribute("ry", height / 2 - borderWidth / 2);
    circle.setAttribute("stroke-width", borderWidth || 1);
    circle.setAttribute("stroke", "transparent");
    circle.setAttribute("fill", "transparent");
    svg.append(circle);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#circle;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class PolylineAnnotationElement extends AnnotationElement {
  #polyline = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.containerClassName = "polylineAnnotation";
    this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect,
        vertices,
        borderStyle,
        popupRef
      }
    } = this;
    if (!vertices) {
      return this.container;
    }
    const {
      width,
      height
    } = getRectDims(rect);
    const svg = this.svgFactory.create(width, height, true);
    let points = [];
    for (let i = 0, ii = vertices.length; i < ii; i += 2) {
      const x = vertices[i] - rect[0];
      const y = rect[3] - vertices[i + 1];
      points.push(`${x},${y}`);
    }
    points = points.join(" ");
    const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);
    polyline.setAttribute("points", points);
    polyline.setAttribute("stroke-width", borderStyle.width || 1);
    polyline.setAttribute("stroke", "transparent");
    polyline.setAttribute("fill", "transparent");
    svg.append(polyline);
    this.container.append(svg);
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#polyline;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class PolygonAnnotationElement extends PolylineAnnotationElement {
  constructor(parameters) {
    super(parameters);
    this.containerClassName = "polygonAnnotation";
    this.svgElementName = "svg:polygon";
  }
}
class CaretAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("caretAnnotation");
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
}
class InkAnnotationElement extends AnnotationElement {
  #polylines = [];
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.containerClassName = "inkAnnotation";
    this.svgElementName = "svg:polyline";
    this.annotationEditorType = AnnotationEditorType.INK;
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect,
        inkLists,
        borderStyle,
        popupRef
      }
    } = this;
    const {
      width,
      height
    } = getRectDims(rect);
    const svg = this.svgFactory.create(width, height, true);
    for (const inkList of inkLists) {
      let points = [];
      for (let i = 0, ii = inkList.length; i < ii; i += 2) {
        const x = inkList[i] - rect[0];
        const y = rect[3] - inkList[i + 1];
        points.push(`${x},${y}`);
      }
      points = points.join(" ");
      const polyline = this.svgFactory.createElement(this.svgElementName);
      this.#polylines.push(polyline);
      polyline.setAttribute("points", points);
      polyline.setAttribute("stroke-width", borderStyle.width || 1);
      polyline.setAttribute("stroke", "transparent");
      polyline.setAttribute("fill", "transparent");
      if (!popupRef && this.hasPopupData) {
        this._createPopup();
      }
      svg.append(polyline);
    }
    this.container.append(svg);
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#polylines;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class HighlightAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("highlightAnnotation");
    return this.container;
  }
}
class UnderlineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("underlineAnnotation");
    return this.container;
  }
}
class SquigglyAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("squigglyAnnotation");
    return this.container;
  }
}
class StrikeOutAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("strikeoutAnnotation");
    return this.container;
  }
}
class StampAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("stampAnnotation");
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
}
class FileAttachmentAnnotationElement extends AnnotationElement {
  #trigger = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true
    });
    const {
      file
    } = this.data;
    this.filename = file.filename;
    this.content = file.content;
    this.linkService.eventBus?.dispatch("fileattachmentannotation", {
      source: this,
      ...file
    });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const {
      container,
      data
    } = this;
    let trigger;
    if (data.hasAppearance || data.fillAlpha === 0) {
      trigger = document.createElement("div");
    } else {
      trigger = document.createElement("img");
      trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? "paperclip" : "pushpin"}.svg`;
      if (data.fillAlpha && data.fillAlpha < 1) {
        trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;
      }
    }
    trigger.addEventListener("dblclick", this.#download.bind(this));
    this.#trigger = trigger;
    const {
      isMac
    } = util_FeatureTest.platform;
    container.addEventListener("keydown", evt => {
      if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
        this.#download();
      }
    });
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    } else {
      trigger.classList.add("popupTriggerArea");
    }
    container.append(trigger);
    return container;
  }
  getElementsToTriggerPopup() {
    return this.#trigger;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
  #download() {
    this.downloadManager?.openOrDownloadData(this.content, this.filename);
  }
}
class AnnotationLayer {
  #accessibilityManager = null;
  #annotationCanvasMap = null;
  #editableAnnotations = new Map();
  constructor({
    div,
    accessibilityManager,
    annotationCanvasMap,
    annotationEditorUIManager,
    page,
    viewport
  }) {
    this.div = div;
    this.#accessibilityManager = accessibilityManager;
    this.#annotationCanvasMap = annotationCanvasMap;
    this.page = page;
    this.viewport = viewport;
    this.zIndex = 0;
    this._annotationEditorUIManager = annotationEditorUIManager;
  }
  #appendElement(element, id) {
    const contentElement = element.firstChild || element;
    contentElement.id = `${AnnotationPrefix}${id}`;
    this.div.append(element);
    this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);
  }
  async render(params) {
    const {
      annotations
    } = params;
    const layer = this.div;
    setLayerDimensions(layer, this.viewport);
    const popupToElements = new Map();
    const elementParams = {
      data: null,
      layer,
      linkService: params.linkService,
      downloadManager: params.downloadManager,
      imageResourcesPath: params.imageResourcesPath || "",
      renderForms: params.renderForms !== false,
      svgFactory: new DOMSVGFactory(),
      annotationStorage: params.annotationStorage || new AnnotationStorage(),
      enableScripting: params.enableScripting === true,
      hasJSActions: params.hasJSActions,
      fieldObjects: params.fieldObjects,
      parent: this,
      elements: null
    };
    for (const data of annotations) {
      if (data.noHTML) {
        continue;
      }
      const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;
      if (!isPopupAnnotation) {
        const {
          width,
          height
        } = getRectDims(data.rect);
        if (width <= 0 || height <= 0) {
          continue;
        }
      } else {
        const elements = popupToElements.get(data.id);
        if (!elements) {
          continue;
        }
        elementParams.elements = elements;
      }
      elementParams.data = data;
      const element = AnnotationElementFactory.create(elementParams);
      if (!element.isRenderable) {
        continue;
      }
      if (!isPopupAnnotation && data.popupRef) {
        const elements = popupToElements.get(data.popupRef);
        if (!elements) {
          popupToElements.set(data.popupRef, [element]);
        } else {
          elements.push(element);
        }
      }
      const rendered = element.render();
      if (data.hidden) {
        rendered.style.visibility = "hidden";
      }
      this.#appendElement(rendered, data.id);
      if (element.annotationEditorType > 0) {
        this.#editableAnnotations.set(element.data.id, element);
        this._annotationEditorUIManager?.renderAnnotationElement(element);
      }
    }
    this.#setAnnotationCanvasMap();
  }
  update({
    viewport
  }) {
    const layer = this.div;
    this.viewport = viewport;
    setLayerDimensions(layer, {
      rotation: viewport.rotation
    });
    this.#setAnnotationCanvasMap();
    layer.hidden = false;
  }
  #setAnnotationCanvasMap() {
    if (!this.#annotationCanvasMap) {
      return;
    }
    const layer = this.div;
    for (const [id, canvas] of this.#annotationCanvasMap) {
      const element = layer.querySelector(`[data-annotation-id="${id}"]`);
      if (!element) {
        continue;
      }
      canvas.className = "annotationContent";
      const {
        firstChild
      } = element;
      if (!firstChild) {
        element.append(canvas);
      } else if (firstChild.nodeName === "CANVAS") {
        firstChild.replaceWith(canvas);
      } else if (!firstChild.classList.contains("annotationContent")) {
        firstChild.before(canvas);
      } else {
        firstChild.after(canvas);
      }
    }
    this.#annotationCanvasMap.clear();
  }
  getEditableAnnotations() {
    return Array.from(this.#editableAnnotations.values());
  }
  getEditableAnnotation(id) {
    return this.#editableAnnotations.get(id);
  }
}




const EOL_PATTERN = /\r\n?|\n/g;
class FreeTextEditor extends AnnotationEditor {
  #boundEditorDivBlur = this.editorDivBlur.bind(this);
  #boundEditorDivFocus = this.editorDivFocus.bind(this);
  #boundEditorDivInput = this.editorDivInput.bind(this);
  #boundEditorDivKeydown = this.editorDivKeydown.bind(this);
  #boundEditorDivPaste = this.editorDivPaste.bind(this);
  #color;
  #content = "";
  #editorDivId = `${this.id}-editor`;
  #fontSize;
  #initialData = null;
  static _freeTextDefaultContent = "";
  static _internalPadding = 0;
  static _defaultColor = null;
  static _defaultFontSize = 10;
  static get _keyboardManager() {
    const proto = FreeTextEditor.prototype;
    const arrowChecker = self => self.isEmpty();
    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
    const big = AnnotationEditorUIManager.TRANSLATE_BIG;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], proto.commitOrRemove, {
      bubbles: true
    }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], proto.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], proto._translateEmpty, {
      args: [-small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto._translateEmpty, {
      args: [-big, 0],
      checker: arrowChecker
    }], [["ArrowRight", "mac+ArrowRight"], proto._translateEmpty, {
      args: [small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto._translateEmpty, {
      args: [big, 0],
      checker: arrowChecker
    }], [["ArrowUp", "mac+ArrowUp"], proto._translateEmpty, {
      args: [0, -small],
      checker: arrowChecker
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto._translateEmpty, {
      args: [0, -big],
      checker: arrowChecker
    }], [["ArrowDown", "mac+ArrowDown"], proto._translateEmpty, {
      args: [0, small],
      checker: arrowChecker
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto._translateEmpty, {
      args: [0, big],
      checker: arrowChecker
    }]]));
  }
  static _type = "freetext";
  static _editorType = AnnotationEditorType.FREETEXT;
  constructor(params) {
    super({
      ...params,
      name: "freeTextEditor"
    });
    this.#color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;
    this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager, {
      strings: ["pdfjs-free-text-default-content"]
    });
    const style = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.FREETEXT_SIZE:
        FreeTextEditor._defaultFontSize = value;
        break;
      case AnnotationEditorParamsType.FREETEXT_COLOR:
        FreeTextEditor._defaultColor = value;
        break;
    }
  }
  updateParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.FREETEXT_SIZE:
        this.#updateFontSize(value);
        break;
      case AnnotationEditorParamsType.FREETEXT_COLOR:
        this.#updateColor(value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, this.#color]];
  }
  #updateFontSize(fontSize) {
    const setFontsize = size => {
      this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;
      this.translate(0, -(size - this.#fontSize) * this.parentScale);
      this.#fontSize = size;
      this.#setEditorDimensions();
    };
    const savedFontsize = this.#fontSize;
    this.addCommands({
      cmd: setFontsize.bind(this, fontSize),
      undo: setFontsize.bind(this, savedFontsize),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType.FREETEXT_SIZE,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  #updateColor(color) {
    const setColor = col => {
      this.#color = this.editorDiv.style.color = col;
    };
    const savedColor = this.#color;
    this.addCommands({
      cmd: setColor.bind(this, color),
      undo: setColor.bind(this, savedColor),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType.FREETEXT_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  _translateEmpty(x, y) {
    this._uiManager.translateSelectedEditors(x, y, true);
  }
  getInitialTranslation() {
    const scale = this.parentScale;
    return [-FreeTextEditor._internalPadding * scale, -(FreeTextEditor._internalPadding + this.#fontSize) * scale];
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  enableEditMode() {
    if (this.isInEditMode()) {
      return;
    }
    this.parent.setEditingState(false);
    this.parent.updateToolbar(AnnotationEditorType.FREETEXT);
    super.enableEditMode();
    this.overlayDiv.classList.remove("enabled");
    this.editorDiv.contentEditable = true;
    this._isDraggable = false;
    this.div.removeAttribute("aria-activedescendant");
    const signal = this._uiManager._signal;
    this.editorDiv.addEventListener("keydown", this.#boundEditorDivKeydown, {
      signal
    });
    this.editorDiv.addEventListener("focus", this.#boundEditorDivFocus, {
      signal
    });
    this.editorDiv.addEventListener("blur", this.#boundEditorDivBlur, {
      signal
    });
    this.editorDiv.addEventListener("input", this.#boundEditorDivInput, {
      signal
    });
    this.editorDiv.addEventListener("paste", this.#boundEditorDivPaste, {
      signal
    });
  }
  disableEditMode() {
    if (!this.isInEditMode()) {
      return;
    }
    this.parent.setEditingState(true);
    super.disableEditMode();
    this.overlayDiv.classList.add("enabled");
    this.editorDiv.contentEditable = false;
    this.div.setAttribute("aria-activedescendant", this.#editorDivId);
    this._isDraggable = true;
    this.editorDiv.removeEventListener("keydown", this.#boundEditorDivKeydown);
    this.editorDiv.removeEventListener("focus", this.#boundEditorDivFocus);
    this.editorDiv.removeEventListener("blur", this.#boundEditorDivBlur);
    this.editorDiv.removeEventListener("input", this.#boundEditorDivInput);
    this.editorDiv.removeEventListener("paste", this.#boundEditorDivPaste);
    this.div.focus({
      preventScroll: true
    });
    this.isEditing = false;
    this.parent.div.classList.add("freetextEditing");
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    super.focusin(event);
    if (event.target !== this.editorDiv) {
      this.editorDiv.focus();
    }
  }
  onceAdded() {
    if (this.width) {
      return;
    }
    this.enableEditMode();
    this.editorDiv.focus();
    if (this._initialOptions?.isCentered) {
      this.center();
    }
    this._initialOptions = null;
  }
  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }
  remove() {
    this.isEditing = false;
    if (this.parent) {
      this.parent.setEditingState(true);
      this.parent.div.classList.add("freetextEditing");
    }
    super.remove();
  }
  #extractText() {
    const buffer = [];
    this.editorDiv.normalize();
    for (const child of this.editorDiv.childNodes) {
      buffer.push(FreeTextEditor.#getNodeContent(child));
    }
    return buffer.join("\n");
  }
  #setEditorDimensions() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    let rect;
    if (this.isAttachedToDOM) {
      rect = this.div.getBoundingClientRect();
    } else {
      const {
        currentLayer,
        div
      } = this;
      const savedDisplay = div.style.display;
      const savedVisibility = div.classList.contains("hidden");
      div.classList.remove("hidden");
      div.style.display = "hidden";
      currentLayer.div.append(this.div);
      rect = div.getBoundingClientRect();
      div.remove();
      div.style.display = savedDisplay;
      div.classList.toggle("hidden", savedVisibility);
    }
    if (this.rotation % 180 === this.parentRotation % 180) {
      this.width = rect.width / parentWidth;
      this.height = rect.height / parentHeight;
    } else {
      this.width = rect.height / parentWidth;
      this.height = rect.width / parentHeight;
    }
    this.fixAndSetPosition();
  }
  commit() {
    if (!this.isInEditMode()) {
      return;
    }
    super.commit();
    this.disableEditMode();
    const savedText = this.#content;
    const newText = this.#content = this.#extractText().trimEnd();
    if (savedText === newText) {
      return;
    }
    const setText = text => {
      this.#content = text;
      if (!text) {
        this.remove();
        return;
      }
      this.#setContent();
      this._uiManager.rebuild(this);
      this.#setEditorDimensions();
    };
    this.addCommands({
      cmd: () => {
        setText(newText);
      },
      undo: () => {
        setText(savedText);
      },
      mustExec: false
    });
    this.#setEditorDimensions();
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode();
    this.editorDiv.focus();
  }
  dblclick(event) {
    this.enterInEditMode();
  }
  keydown(event) {
    if (event.target === this.div && event.key === "Enter") {
      this.enterInEditMode();
      event.preventDefault();
    }
  }
  editorDivKeydown(event) {
    FreeTextEditor._keyboardManager.exec(this, event);
  }
  editorDivFocus(event) {
    this.isEditing = true;
  }
  editorDivBlur(event) {
    this.isEditing = false;
  }
  editorDivInput(event) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment");
    this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox");
    this.editorDiv.setAttribute("aria-multiline", true);
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this.width) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.editorDiv = document.createElement("div");
    this.editorDiv.className = "internal";
    this.editorDiv.setAttribute("id", this.#editorDivId);
    this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text");
    this.enableEditing();
    AnnotationEditor._l10nPromise.get("pdfjs-free-text-default-content").then(msg => this.editorDiv?.setAttribute("default-content", msg));
    this.editorDiv.contentEditable = true;
    const {
      style
    } = this.editorDiv;
    style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;
    style.color = this.#color;
    this.div.append(this.editorDiv);
    this.overlayDiv = document.createElement("div");
    this.overlayDiv.classList.add("overlay", "enabled");
    this.div.append(this.overlayDiv);
    bindEvents(this, this.div, ["dblclick", "keydown"]);
    if (this.width) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      if (this.annotationElementId) {
        const {
          position
        } = this.#initialData;
        let [tx, ty] = this.getInitialTranslation();
        [tx, ty] = this.pageTranslationToScreen(tx, ty);
        const [pageWidth, pageHeight] = this.pageDimensions;
        const [pageX, pageY] = this.pageTranslation;
        let posX, posY;
        switch (this.rotation) {
          case 0:
            posX = baseX + (position[0] - pageX) / pageWidth;
            posY = baseY + this.height - (position[1] - pageY) / pageHeight;
            break;
          case 90:
            posX = baseX + (position[0] - pageX) / pageWidth;
            posY = baseY - (position[1] - pageY) / pageHeight;
            [tx, ty] = [ty, -tx];
            break;
          case 180:
            posX = baseX - this.width + (position[0] - pageX) / pageWidth;
            posY = baseY - (position[1] - pageY) / pageHeight;
            [tx, ty] = [-tx, -ty];
            break;
          case 270:
            posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;
            posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;
            [tx, ty] = [-ty, tx];
            break;
        }
        this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
      } else {
        this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
      }
      this.#setContent();
      this._isDraggable = true;
      this.editorDiv.contentEditable = false;
    } else {
      this._isDraggable = false;
      this.editorDiv.contentEditable = true;
    }
    return this.div;
  }
  static #getNodeContent(node) {
    return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, "");
  }
  editorDivPaste(event) {
    const clipboardData = event.clipboardData || window.clipboardData;
    const {
      types
    } = clipboardData;
    if (types.length === 1 && types[0] === "text/plain") {
      return;
    }
    event.preventDefault();
    const paste = FreeTextEditor.#deserializeContent(clipboardData.getData("text") || "").replaceAll(EOL_PATTERN, "\n");
    if (!paste) {
      return;
    }
    const selection = window.getSelection();
    if (!selection.rangeCount) {
      return;
    }
    this.editorDiv.normalize();
    selection.deleteFromDocument();
    const range = selection.getRangeAt(0);
    if (!paste.includes("\n")) {
      range.insertNode(document.createTextNode(paste));
      this.editorDiv.normalize();
      selection.collapseToStart();
      return;
    }
    const {
      startContainer,
      startOffset
    } = range;
    const bufferBefore = [];
    const bufferAfter = [];
    if (startContainer.nodeType === Node.TEXT_NODE) {
      const parent = startContainer.parentElement;
      bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, ""));
      if (parent !== this.editorDiv) {
        let buffer = bufferBefore;
        for (const child of this.editorDiv.childNodes) {
          if (child === parent) {
            buffer = bufferAfter;
            continue;
          }
          buffer.push(FreeTextEditor.#getNodeContent(child));
        }
      }
      bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, ""));
    } else if (startContainer === this.editorDiv) {
      let buffer = bufferBefore;
      let i = 0;
      for (const child of this.editorDiv.childNodes) {
        if (i++ === startOffset) {
          buffer = bufferAfter;
        }
        buffer.push(FreeTextEditor.#getNodeContent(child));
      }
    }
    this.#content = `${bufferBefore.join("\n")}${paste}${bufferAfter.join("\n")}`;
    this.#setContent();
    const newRange = new Range();
    let beforeLength = bufferBefore.reduce((acc, line) => acc + line.length, 0);
    for (const {
      firstChild
    } of this.editorDiv.childNodes) {
      if (firstChild.nodeType === Node.TEXT_NODE) {
        const length = firstChild.nodeValue.length;
        if (beforeLength <= length) {
          newRange.setStart(firstChild, beforeLength);
          newRange.setEnd(firstChild, beforeLength);
          break;
        }
        beforeLength -= length;
      }
    }
    selection.removeAllRanges();
    selection.addRange(newRange);
  }
  #setContent() {
    this.editorDiv.replaceChildren();
    if (!this.#content) {
      return;
    }
    for (const line of this.#content.split("\n")) {
      const div = document.createElement("div");
      div.append(line ? document.createTextNode(line) : document.createElement("br"));
      this.editorDiv.append(div);
    }
  }
  #serializeContent() {
    return this.#content.replaceAll("\xa0", " ");
  }
  static #deserializeContent(content) {
    return content.replaceAll(" ", "\xa0");
  }
  get contentDiv() {
    return this.editorDiv;
  }
  static deserialize(data, parent, uiManager) {
    let initialData = null;
    if (data instanceof FreeTextAnnotationElement) {
      const {
        data: {
          defaultAppearanceData: {
            fontSize,
            fontColor
          },
          rect,
          rotation,
          id
        },
        textContent,
        textPosition,
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      if (!textContent || textContent.length === 0) {
        return null;
      }
      initialData = data = {
        annotationType: AnnotationEditorType.FREETEXT,
        color: Array.from(fontColor),
        fontSize,
        value: textContent.join("\n"),
        position: textPosition,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        id,
        deleted: false
      };
    }
    const editor = super.deserialize(data, parent, uiManager);
    editor.#fontSize = data.fontSize;
    editor.#color = Util.makeHexColor(...data.color);
    editor.#content = FreeTextEditor.#deserializeContent(data.value);
    editor.annotationElementId = data.id || null;
    editor.#initialData = initialData;
    return editor;
  }
  serialize(isForCopying = false) {
    if (this.isEmpty()) {
      return null;
    }
    if (this.deleted) {
      return {
        pageIndex: this.pageIndex,
        id: this.annotationElementId,
        deleted: true
      };
    }
    const padding = FreeTextEditor._internalPadding * this.parentScale;
    const rect = this.getRect(padding, padding);
    const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);
    const serialized = {
      annotationType: AnnotationEditorType.FREETEXT,
      color,
      fontSize: this.#fontSize,
      value: this.#serializeContent(),
      pageIndex: this.pageIndex,
      rect,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
    if (isForCopying) {
      return serialized;
    }
    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
      return null;
    }
    serialized.id = this.annotationElementId;
    return serialized;
  }
  #hasElementChanged(serialized) {
    const {
      value,
      fontSize,
      color,
      pageIndex
    } = this.#initialData;
    return this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i) => c !== color[i]) || serialized.pageIndex !== pageIndex;
  }
  renderAnnotationElement(annotation) {
    const content = super.renderAnnotationElement(annotation);
    if (this.deleted) {
      return content;
    }
    const {
      style
    } = content;
    style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;
    style.color = this.#color;
    content.replaceChildren();
    for (const line of this.#content.split("\n")) {
      const div = document.createElement("div");
      div.append(line ? document.createTextNode(line) : document.createElement("br"));
      content.append(div);
    }
    const padding = FreeTextEditor._internalPadding * this.parentScale;
    annotation.updateEdited({
      rect: this.getRect(padding, padding),
      popupContent: this.#content
    });
    return content;
  }
  resetAnnotationElement(annotation) {
    super.resetAnnotationElement(annotation);
    annotation.resetEdited();
  }
}

class Outliner {
  #box;
  #verticalEdges = [];
  #intervals = [];
  constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true) {
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    const EPSILON = 10 ** -4;
    for (const {
      x,
      y,
      width,
      height
    } of boxes) {
      const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;
      const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;
      const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;
      const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;
      const left = [x1, y1, y2, true];
      const right = [x2, y1, y2, false];
      this.#verticalEdges.push(left, right);
      minX = Math.min(minX, x1);
      maxX = Math.max(maxX, x2);
      minY = Math.min(minY, y1);
      maxY = Math.max(maxY, y2);
    }
    const bboxWidth = maxX - minX + 2 * innerMargin;
    const bboxHeight = maxY - minY + 2 * innerMargin;
    const shiftedMinX = minX - innerMargin;
    const shiftedMinY = minY - innerMargin;
    const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);
    const lastPoint = [lastEdge[0], lastEdge[2]];
    for (const edge of this.#verticalEdges) {
      const [x, y1, y2] = edge;
      edge[0] = (x - shiftedMinX) / bboxWidth;
      edge[1] = (y1 - shiftedMinY) / bboxHeight;
      edge[2] = (y2 - shiftedMinY) / bboxHeight;
    }
    this.#box = {
      x: shiftedMinX,
      y: shiftedMinY,
      width: bboxWidth,
      height: bboxHeight,
      lastPoint
    };
  }
  getOutlines() {
    this.#verticalEdges.sort((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);
    const outlineVerticalEdges = [];
    for (const edge of this.#verticalEdges) {
      if (edge[3]) {
        outlineVerticalEdges.push(...this.#breakEdge(edge));
        this.#insert(edge);
      } else {
        this.#remove(edge);
        outlineVerticalEdges.push(...this.#breakEdge(edge));
      }
    }
    return this.#getOutlines(outlineVerticalEdges);
  }
  #getOutlines(outlineVerticalEdges) {
    const edges = [];
    const allEdges = new Set();
    for (const edge of outlineVerticalEdges) {
      const [x, y1, y2] = edge;
      edges.push([x, y1, edge], [x, y2, edge]);
    }
    edges.sort((a, b) => a[1] - b[1] || a[0] - b[0]);
    for (let i = 0, ii = edges.length; i < ii; i += 2) {
      const edge1 = edges[i][2];
      const edge2 = edges[i + 1][2];
      edge1.push(edge2);
      edge2.push(edge1);
      allEdges.add(edge1);
      allEdges.add(edge2);
    }
    const outlines = [];
    let outline;
    while (allEdges.size > 0) {
      const edge = allEdges.values().next().value;
      let [x, y1, y2, edge1, edge2] = edge;
      allEdges.delete(edge);
      let lastPointX = x;
      let lastPointY = y1;
      outline = [x, y2];
      outlines.push(outline);
      while (true) {
        let e;
        if (allEdges.has(edge1)) {
          e = edge1;
        } else if (allEdges.has(edge2)) {
          e = edge2;
        } else {
          break;
        }
        allEdges.delete(e);
        [x, y1, y2, edge1, edge2] = e;
        if (lastPointX !== x) {
          outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);
          lastPointX = x;
        }
        lastPointY = lastPointY === y1 ? y2 : y1;
      }
      outline.push(lastPointX, lastPointY);
    }
    return new HighlightOutline(outlines, this.#box);
  }
  #binarySearch(y) {
    const array = this.#intervals;
    let start = 0;
    let end = array.length - 1;
    while (start <= end) {
      const middle = start + end >> 1;
      const y1 = array[middle][0];
      if (y1 === y) {
        return middle;
      }
      if (y1 < y) {
        start = middle + 1;
      } else {
        end = middle - 1;
      }
    }
    return end + 1;
  }
  #insert([, y1, y2]) {
    const index = this.#binarySearch(y1);
    this.#intervals.splice(index, 0, [y1, y2]);
  }
  #remove([, y1, y2]) {
    const index = this.#binarySearch(y1);
    for (let i = index; i < this.#intervals.length; i++) {
      const [start, end] = this.#intervals[i];
      if (start !== y1) {
        break;
      }
      if (start === y1 && end === y2) {
        this.#intervals.splice(i, 1);
        return;
      }
    }
    for (let i = index - 1; i >= 0; i--) {
      const [start, end] = this.#intervals[i];
      if (start !== y1) {
        break;
      }
      if (start === y1 && end === y2) {
        this.#intervals.splice(i, 1);
        return;
      }
    }
  }
  #breakEdge(edge) {
    const [x, y1, y2] = edge;
    const results = [[x, y1, y2]];
    const index = this.#binarySearch(y2);
    for (let i = 0; i < index; i++) {
      const [start, end] = this.#intervals[i];
      for (let j = 0, jj = results.length; j < jj; j++) {
        const [, y3, y4] = results[j];
        if (end <= y3 || y4 <= start) {
          continue;
        }
        if (y3 >= start) {
          if (y4 > end) {
            results[j][1] = end;
          } else {
            if (jj === 1) {
              return [];
            }
            results.splice(j, 1);
            j--;
            jj--;
          }
          continue;
        }
        results[j][2] = start;
        if (y4 > end) {
          results.push([x, end, y4]);
        }
      }
    }
    return results;
  }
}
class Outline {
  toSVGPath() {
    throw new Error("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    throw new Error("Abstract getter `box` must be implemented.");
  }
  serialize(_bbox, _rotation) {
    throw new Error("Abstract method `serialize` must be implemented.");
  }
  get free() {
    return this instanceof FreeHighlightOutline;
  }
}
class HighlightOutline extends Outline {
  #box;
  #outlines;
  constructor(outlines, box) {
    super();
    this.#outlines = outlines;
    this.#box = box;
  }
  toSVGPath() {
    const buffer = [];
    for (const polygon of this.#outlines) {
      let [prevX, prevY] = polygon;
      buffer.push(`M${prevX} ${prevY}`);
      for (let i = 2; i < polygon.length; i += 2) {
        const x = polygon[i];
        const y = polygon[i + 1];
        if (x === prevX) {
          buffer.push(`V${y}`);
          prevY = y;
        } else if (y === prevY) {
          buffer.push(`H${x}`);
          prevX = x;
        }
      }
      buffer.push("Z");
    }
    return buffer.join(" ");
  }
  serialize([blX, blY, trX, trY], _rotation) {
    const outlines = [];
    const width = trX - blX;
    const height = trY - blY;
    for (const outline of this.#outlines) {
      const points = new Array(outline.length);
      for (let i = 0; i < outline.length; i += 2) {
        points[i] = blX + outline[i] * width;
        points[i + 1] = trY - outline[i + 1] * height;
      }
      outlines.push(points);
    }
    return outlines;
  }
  get box() {
    return this.#box;
  }
}
class FreeOutliner {
  #box;
  #bottom = [];
  #innerMargin;
  #isLTR;
  #top = [];
  #last = new Float64Array(18);
  #lastX;
  #lastY;
  #min;
  #min_dist;
  #scaleFactor;
  #thickness;
  #points = [];
  static #MIN_DIST = 8;
  static #MIN_DIFF = 2;
  static #MIN = FreeOutliner.#MIN_DIST + FreeOutliner.#MIN_DIFF;
  constructor({
    x,
    y
  }, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
    this.#box = box;
    this.#thickness = thickness * scaleFactor;
    this.#isLTR = isLTR;
    this.#last.set([NaN, NaN, NaN, NaN, x, y], 6);
    this.#innerMargin = innerMargin;
    this.#min_dist = FreeOutliner.#MIN_DIST * scaleFactor;
    this.#min = FreeOutliner.#MIN * scaleFactor;
    this.#scaleFactor = scaleFactor;
    this.#points.push(x, y);
  }
  get free() {
    return true;
  }
  isEmpty() {
    return isNaN(this.#last[8]);
  }
  #getLastCoords() {
    const lastTop = this.#last.subarray(4, 6);
    const lastBottom = this.#last.subarray(16, 18);
    const [x, y, width, height] = this.#box;
    return [(this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width, (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height, (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width, (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height];
  }
  add({
    x,
    y
  }) {
    this.#lastX = x;
    this.#lastY = y;
    const [layerX, layerY, layerWidth, layerHeight] = this.#box;
    let [x1, y1, x2, y2] = this.#last.subarray(8, 12);
    const diffX = x - x2;
    const diffY = y - y2;
    const d = Math.hypot(diffX, diffY);
    if (d < this.#min) {
      return false;
    }
    const diffD = d - this.#min_dist;
    const K = diffD / d;
    const shiftX = K * diffX;
    const shiftY = K * diffY;
    let x0 = x1;
    let y0 = y1;
    x1 = x2;
    y1 = y2;
    x2 += shiftX;
    y2 += shiftY;
    this.#points?.push(x, y);
    const nX = -shiftY / diffD;
    const nY = shiftX / diffD;
    const thX = nX * this.#thickness;
    const thY = nY * this.#thickness;
    this.#last.set(this.#last.subarray(2, 8), 0);
    this.#last.set([x2 + thX, y2 + thY], 4);
    this.#last.set(this.#last.subarray(14, 18), 12);
    this.#last.set([x2 - thX, y2 - thY], 16);
    if (isNaN(this.#last[6])) {
      if (this.#top.length === 0) {
        this.#last.set([x1 + thX, y1 + thY], 2);
        this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);
        this.#last.set([x1 - thX, y1 - thY], 14);
        this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);
      }
      this.#last.set([x0, y0, x1, y1, x2, y2], 6);
      return !this.isEmpty();
    }
    this.#last.set([x0, y0, x1, y1, x2, y2], 6);
    const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));
    if (angle < Math.PI / 2) {
      [x1, y1, x2, y2] = this.#last.subarray(2, 6);
      this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
      [x1, y1, x0, y0] = this.#last.subarray(14, 18);
      this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);
      return true;
    }
    [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);
    this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
    [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);
    this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
    return true;
  }
  toSVGPath() {
    if (this.isEmpty()) {
      return "";
    }
    const top = this.#top;
    const bottom = this.#bottom;
    const lastTop = this.#last.subarray(4, 6);
    const lastBottom = this.#last.subarray(16, 18);
    const [x, y, width, height] = this.#box;
    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
    if (isNaN(this.#last[6]) && !this.isEmpty()) {
      return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;
    }
    const buffer = [];
    buffer.push(`M${top[4]} ${top[5]}`);
    for (let i = 6; i < top.length; i += 6) {
      if (isNaN(top[i])) {
        buffer.push(`L${top[i + 4]} ${top[i + 5]}`);
      } else {
        buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);
      }
    }
    buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);
    for (let i = bottom.length - 6; i >= 6; i -= 6) {
      if (isNaN(bottom[i])) {
        buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);
      } else {
        buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);
      }
    }
    buffer.push(`L${bottom[4]} ${bottom[5]} Z`);
    return buffer.join(" ");
  }
  getOutlines() {
    const top = this.#top;
    const bottom = this.#bottom;
    const last = this.#last;
    const lastTop = last.subarray(4, 6);
    const lastBottom = last.subarray(16, 18);
    const [layerX, layerY, layerWidth, layerHeight] = this.#box;
    const points = new Float64Array((this.#points?.length ?? 0) + 2);
    for (let i = 0, ii = points.length - 2; i < ii; i += 2) {
      points[i] = (this.#points[i] - layerX) / layerWidth;
      points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;
    }
    points[points.length - 2] = (this.#lastX - layerX) / layerWidth;
    points[points.length - 1] = (this.#lastY - layerY) / layerHeight;
    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
    if (isNaN(last[6]) && !this.isEmpty()) {
      const outline = new Float64Array(36);
      outline.set([NaN, NaN, NaN, NaN, (last[2] - layerX) / layerWidth, (last[3] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[4] - layerX) / layerWidth, (last[5] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (last[16] - layerX) / layerWidth, (last[17] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[14] - layerX) / layerWidth, (last[15] - layerY) / layerHeight], 0);
      return new FreeHighlightOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
    }
    const outline = new Float64Array(this.#top.length + 24 + this.#bottom.length);
    let N = top.length;
    for (let i = 0; i < N; i += 2) {
      if (isNaN(top[i])) {
        outline[i] = outline[i + 1] = NaN;
        continue;
      }
      outline[i] = top[i];
      outline[i + 1] = top[i + 1];
    }
    outline.set([NaN, NaN, NaN, NaN, (lastTop[0] - layerX) / layerWidth, (lastTop[1] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (lastBottom[0] - layerX) / layerWidth, (lastBottom[1] - layerY) / layerHeight], N);
    N += 24;
    for (let i = bottom.length - 6; i >= 6; i -= 6) {
      for (let j = 0; j < 6; j += 2) {
        if (isNaN(bottom[i + j])) {
          outline[N] = outline[N + 1] = NaN;
          N += 2;
          continue;
        }
        outline[N] = bottom[i + j];
        outline[N + 1] = bottom[i + j + 1];
        N += 2;
      }
    }
    outline.set([NaN, NaN, NaN, NaN, bottom[4], bottom[5]], N);
    return new FreeHighlightOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
  }
}
class FreeHighlightOutline extends Outline {
  #box;
  #bbox = null;
  #innerMargin;
  #isLTR;
  #points;
  #scaleFactor;
  #outline;
  constructor(outline, points, box, scaleFactor, innerMargin, isLTR) {
    super();
    this.#outline = outline;
    this.#points = points;
    this.#box = box;
    this.#scaleFactor = scaleFactor;
    this.#innerMargin = innerMargin;
    this.#isLTR = isLTR;
    this.#computeMinMax(isLTR);
    const {
      x,
      y,
      width,
      height
    } = this.#bbox;
    for (let i = 0, ii = outline.length; i < ii; i += 2) {
      outline[i] = (outline[i] - x) / width;
      outline[i + 1] = (outline[i + 1] - y) / height;
    }
    for (let i = 0, ii = points.length; i < ii; i += 2) {
      points[i] = (points[i] - x) / width;
      points[i + 1] = (points[i + 1] - y) / height;
    }
  }
  toSVGPath() {
    const buffer = [`M${this.#outline[4]} ${this.#outline[5]}`];
    for (let i = 6, ii = this.#outline.length; i < ii; i += 6) {
      if (isNaN(this.#outline[i])) {
        buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);
        continue;
      }
      buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);
    }
    buffer.push("Z");
    return buffer.join(" ");
  }
  serialize([blX, blY, trX, trY], rotation) {
    const width = trX - blX;
    const height = trY - blY;
    let outline;
    let points;
    switch (rotation) {
      case 0:
        outline = this.#rescale(this.#outline, blX, trY, width, -height);
        points = this.#rescale(this.#points, blX, trY, width, -height);
        break;
      case 90:
        outline = this.#rescaleAndSwap(this.#outline, blX, blY, width, height);
        points = this.#rescaleAndSwap(this.#points, blX, blY, width, height);
        break;
      case 180:
        outline = this.#rescale(this.#outline, trX, blY, -width, height);
        points = this.#rescale(this.#points, trX, blY, -width, height);
        break;
      case 270:
        outline = this.#rescaleAndSwap(this.#outline, trX, trY, -width, -height);
        points = this.#rescaleAndSwap(this.#points, trX, trY, -width, -height);
        break;
    }
    return {
      outline: Array.from(outline),
      points: [Array.from(points)]
    };
  }
  #rescale(src, tx, ty, sx, sy) {
    const dest = new Float64Array(src.length);
    for (let i = 0, ii = src.length; i < ii; i += 2) {
      dest[i] = tx + src[i] * sx;
      dest[i + 1] = ty + src[i + 1] * sy;
    }
    return dest;
  }
  #rescaleAndSwap(src, tx, ty, sx, sy) {
    const dest = new Float64Array(src.length);
    for (let i = 0, ii = src.length; i < ii; i += 2) {
      dest[i] = tx + src[i + 1] * sx;
      dest[i + 1] = ty + src[i] * sy;
    }
    return dest;
  }
  #computeMinMax(isLTR) {
    const outline = this.#outline;
    let lastX = outline[4];
    let lastY = outline[5];
    let minX = lastX;
    let minY = lastY;
    let maxX = lastX;
    let maxY = lastY;
    let lastPointX = lastX;
    let lastPointY = lastY;
    const ltrCallback = isLTR ? Math.max : Math.min;
    for (let i = 6, ii = outline.length; i < ii; i += 6) {
      if (isNaN(outline[i])) {
        minX = Math.min(minX, outline[i + 4]);
        minY = Math.min(minY, outline[i + 5]);
        maxX = Math.max(maxX, outline[i + 4]);
        maxY = Math.max(maxY, outline[i + 5]);
        if (lastPointY < outline[i + 5]) {
          lastPointX = outline[i + 4];
          lastPointY = outline[i + 5];
        } else if (lastPointY === outline[i + 5]) {
          lastPointX = ltrCallback(lastPointX, outline[i + 4]);
        }
      } else {
        const bbox = Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6));
        minX = Math.min(minX, bbox[0]);
        minY = Math.min(minY, bbox[1]);
        maxX = Math.max(maxX, bbox[2]);
        maxY = Math.max(maxY, bbox[3]);
        if (lastPointY < bbox[3]) {
          lastPointX = bbox[2];
          lastPointY = bbox[3];
        } else if (lastPointY === bbox[3]) {
          lastPointX = ltrCallback(lastPointX, bbox[2]);
        }
      }
      lastX = outline[i + 4];
      lastY = outline[i + 5];
    }
    const x = minX - this.#innerMargin,
      y = minY - this.#innerMargin,
      width = maxX - minX + 2 * this.#innerMargin,
      height = maxY - minY + 2 * this.#innerMargin;
    this.#bbox = {
      x,
      y,
      width,
      height,
      lastPoint: [lastPointX, lastPointY]
    };
  }
  get box() {
    return this.#bbox;
  }
  getNewOutline(thickness, innerMargin) {
    const {
      x,
      y,
      width,
      height
    } = this.#bbox;
    const [layerX, layerY, layerWidth, layerHeight] = this.#box;
    const sx = width * layerWidth;
    const sy = height * layerHeight;
    const tx = x * layerWidth + layerX;
    const ty = y * layerHeight + layerY;
    const outliner = new FreeOutliner({
      x: this.#points[0] * sx + tx,
      y: this.#points[1] * sy + ty
    }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);
    for (let i = 2; i < this.#points.length; i += 2) {
      outliner.add({
        x: this.#points[i] * sx + tx,
        y: this.#points[i + 1] * sy + ty
      });
    }
    return outliner.getOutlines();
  }
}



class ColorPicker {
  #boundKeyDown = this.#keyDown.bind(this);
  #boundPointerDown = this.#pointerDown.bind(this);
  #button = null;
  #buttonSwatch = null;
  #defaultColor;
  #dropdown = null;
  #dropdownWasFromKeyboard = false;
  #isMainColorPicker = false;
  #editor = null;
  #eventBus;
  #uiManager = null;
  #type;
  static get _keyboardManager() {
    return shadow(this, "_keyboardManager", new KeyboardManager([[["Escape", "mac+Escape"], ColorPicker.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], ColorPicker.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], ColorPicker.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], ColorPicker.prototype._moveToPrevious], [["Home", "mac+Home"], ColorPicker.prototype._moveToBeginning], [["End", "mac+End"], ColorPicker.prototype._moveToEnd]]));
  }
  constructor({
    editor = null,
    uiManager = null
  }) {
    if (editor) {
      this.#isMainColorPicker = false;
      this.#type = AnnotationEditorParamsType.HIGHLIGHT_COLOR;
      this.#editor = editor;
    } else {
      this.#isMainColorPicker = true;
      this.#type = AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR;
    }
    this.#uiManager = editor?._uiManager || uiManager;
    this.#eventBus = this.#uiManager._eventBus;
    this.#defaultColor = editor?.color || this.#uiManager?.highlightColors.values().next().value || "#FFFF98";
  }
  renderButton() {
    const button = this.#button = document.createElement("button");
    button.className = "colorPicker";
    button.tabIndex = "0";
    button.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button");
    button.setAttribute("aria-haspopup", true);
    const signal = this.#uiManager._signal;
    button.addEventListener("click", this.#openDropdown.bind(this), {
      signal
    });
    button.addEventListener("keydown", this.#boundKeyDown, {
      signal
    });
    const swatch = this.#buttonSwatch = document.createElement("span");
    swatch.className = "swatch";
    swatch.setAttribute("aria-hidden", true);
    swatch.style.backgroundColor = this.#defaultColor;
    button.append(swatch);
    return button;
  }
  renderMainDropdown() {
    const dropdown = this.#dropdown = this.#getDropdownRoot();
    dropdown.setAttribute("aria-orientation", "horizontal");
    dropdown.setAttribute("aria-labelledby", "highlightColorPickerLabel");
    return dropdown;
  }
  #getDropdownRoot() {
    const div = document.createElement("div");
    const signal = this.#uiManager._signal;
    div.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    div.className = "dropdown";
    div.role = "listbox";
    div.setAttribute("aria-multiselectable", false);
    div.setAttribute("aria-orientation", "vertical");
    div.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
    for (const [name, color] of this.#uiManager.highlightColors) {
      const button = document.createElement("button");
      button.tabIndex = "0";
      button.role = "option";
      button.setAttribute("data-color", color);
      button.title = name;
      button.setAttribute("data-l10n-id", `pdfjs-editor-colorpicker-${name}`);
      const swatch = document.createElement("span");
      button.append(swatch);
      swatch.className = "swatch";
      swatch.style.backgroundColor = color;
      button.setAttribute("aria-selected", color === this.#defaultColor);
      button.addEventListener("click", this.#colorSelect.bind(this, color), {
        signal
      });
      div.append(button);
    }
    div.addEventListener("keydown", this.#boundKeyDown, {
      signal
    });
    return div;
  }
  #colorSelect(color, event) {
    event.stopPropagation();
    this.#eventBus.dispatch("switchannotationeditorparams", {
      source: this,
      type: this.#type,
      value: color
    });
  }
  _colorSelectFromKeyboard(event) {
    if (event.target === this.#button) {
      this.#openDropdown(event);
      return;
    }
    const color = event.target.getAttribute("data-color");
    if (!color) {
      return;
    }
    this.#colorSelect(color, event);
  }
  _moveToNext(event) {
    if (!this.#isDropdownVisible) {
      this.#openDropdown(event);
      return;
    }
    if (event.target === this.#button) {
      this.#dropdown.firstChild?.focus();
      return;
    }
    event.target.nextSibling?.focus();
  }
  _moveToPrevious(event) {
    if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {
      if (this.#isDropdownVisible) {
        this._hideDropdownFromKeyboard();
      }
      return;
    }
    if (!this.#isDropdownVisible) {
      this.#openDropdown(event);
    }
    event.target.previousSibling?.focus();
  }
  _moveToBeginning(event) {
    if (!this.#isDropdownVisible) {
      this.#openDropdown(event);
      return;
    }
    this.#dropdown.firstChild?.focus();
  }
  _moveToEnd(event) {
    if (!this.#isDropdownVisible) {
      this.#openDropdown(event);
      return;
    }
    this.#dropdown.lastChild?.focus();
  }
  #keyDown(event) {
    ColorPicker._keyboardManager.exec(this, event);
  }
  #openDropdown(event) {
    if (this.#isDropdownVisible) {
      this.hideDropdown();
      return;
    }
    this.#dropdownWasFromKeyboard = event.detail === 0;
    window.addEventListener("pointerdown", this.#boundPointerDown, {
      signal: this.#uiManager._signal
    });
    if (this.#dropdown) {
      this.#dropdown.classList.remove("hidden");
      return;
    }
    const root = this.#dropdown = this.#getDropdownRoot();
    this.#button.append(root);
  }
  #pointerDown(event) {
    if (this.#dropdown?.contains(event.target)) {
      return;
    }
    this.hideDropdown();
  }
  hideDropdown() {
    this.#dropdown?.classList.add("hidden");
    window.removeEventListener("pointerdown", this.#boundPointerDown);
  }
  get #isDropdownVisible() {
    return this.#dropdown && !this.#dropdown.classList.contains("hidden");
  }
  _hideDropdownFromKeyboard() {
    if (this.#isMainColorPicker) {
      return;
    }
    if (!this.#isDropdownVisible) {
      this.#editor?.unselect();
      return;
    }
    this.hideDropdown();
    this.#button.focus({
      preventScroll: true,
      focusVisible: this.#dropdownWasFromKeyboard
    });
  }
  updateColor(color) {
    if (this.#buttonSwatch) {
      this.#buttonSwatch.style.backgroundColor = color;
    }
    if (!this.#dropdown) {
      return;
    }
    const i = this.#uiManager.highlightColors.values();
    for (const child of this.#dropdown.children) {
      child.setAttribute("aria-selected", i.next().value === color);
    }
  }
  destroy() {
    this.#button?.remove();
    this.#button = null;
    this.#buttonSwatch = null;
    this.#dropdown?.remove();
    this.#dropdown = null;
  }
}






class HighlightEditor extends AnnotationEditor {
  #anchorNode = null;
  #anchorOffset = 0;
  #boxes;
  #clipPathId = null;
  #colorPicker = null;
  #focusOutlines = null;
  #focusNode = null;
  #focusOffset = 0;
  #highlightDiv = null;
  #highlightOutlines = null;
  #id = null;
  #isFreeHighlight = false;
  #boundKeydown = this.#keydown.bind(this);
  #lastPoint = null;
  #opacity;
  #outlineId = null;
  #text = "";
  #thickness;
  #methodOfCreation = "";
  static _defaultColor = null;
  static _defaultOpacity = 1;
  static _defaultThickness = 12;
  static _l10nPromise;
  static _type = "highlight";
  static _editorType = AnnotationEditorType.HIGHLIGHT;
  static _freeHighlightId = -1;
  static _freeHighlight = null;
  static _freeHighlightClipId = "";
  static get _keyboardManager() {
    const proto = HighlightEditor.prototype;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], proto._moveCaret, {
      args: [0]
    }], [["ArrowRight", "mac+ArrowRight"], proto._moveCaret, {
      args: [1]
    }], [["ArrowUp", "mac+ArrowUp"], proto._moveCaret, {
      args: [2]
    }], [["ArrowDown", "mac+ArrowDown"], proto._moveCaret, {
      args: [3]
    }]]));
  }
  constructor(params) {
    super({
      ...params,
      name: "highlightEditor"
    });
    this.color = params.color || HighlightEditor._defaultColor;
    this.#thickness = params.thickness || HighlightEditor._defaultThickness;
    this.#opacity = params.opacity || HighlightEditor._defaultOpacity;
    this.#boxes = params.boxes || null;
    this.#methodOfCreation = params.methodOfCreation || "";
    this.#text = params.text || "";
    this._isDraggable = false;
    if (params.highlightId > -1) {
      this.#isFreeHighlight = true;
      this.#createFreeOutlines(params);
      this.#addToDrawLayer();
    } else {
      this.#anchorNode = params.anchorNode;
      this.#anchorOffset = params.anchorOffset;
      this.#focusNode = params.focusNode;
      this.#focusOffset = params.focusOffset;
      this.#createOutlines();
      this.#addToDrawLayer();
      this.rotate(this.rotation);
    }
  }
  get telemetryInitialData() {
    return {
      action: "added",
      type: this.#isFreeHighlight ? "free_highlight" : "highlight",
      color: this._uiManager.highlightColorNames.get(this.color),
      thickness: this.#thickness,
      methodOfCreation: this.#methodOfCreation
    };
  }
  get telemetryFinalData() {
    return {
      type: "highlight",
      color: this._uiManager.highlightColorNames.get(this.color)
    };
  }
  static computeTelemetryFinalData(data) {
    return {
      numberOfColors: data.get("color").size
    };
  }
  #createOutlines() {
    const outliner = new Outliner(this.#boxes, 0.001);
    this.#highlightOutlines = outliner.getOutlines();
    ({
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    } = this.#highlightOutlines.box);
    const outlinerForOutline = new Outliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === "ltr");
    this.#focusOutlines = outlinerForOutline.getOutlines();
    const {
      lastPoint
    } = this.#focusOutlines.box;
    this.#lastPoint = [(lastPoint[0] - this.x) / this.width, (lastPoint[1] - this.y) / this.height];
  }
  #createFreeOutlines({
    highlightOutlines,
    highlightId,
    clipPathId
  }) {
    this.#highlightOutlines = highlightOutlines;
    const extraThickness = 1.5;
    this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 0.0025);
    if (highlightId >= 0) {
      this.#id = highlightId;
      this.#clipPathId = clipPathId;
      this.parent.drawLayer.finalizeLine(highlightId, highlightOutlines);
      this.#outlineId = this.parent.drawLayer.highlightOutline(this.#focusOutlines);
    } else if (this.parent) {
      const angle = this.parent.viewport.rotation;
      this.parent.drawLayer.updateLine(this.#id, highlightOutlines);
      this.parent.drawLayer.updateBox(this.#id, HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360));
      this.parent.drawLayer.updateLine(this.#outlineId, this.#focusOutlines);
      this.parent.drawLayer.updateBox(this.#outlineId, HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle));
    }
    const {
      x,
      y,
      width,
      height
    } = highlightOutlines.box;
    switch (this.rotation) {
      case 0:
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        break;
      case 90:
        {
          const [pageWidth, pageHeight] = this.parentDimensions;
          this.x = y;
          this.y = 1 - x;
          this.width = width * pageHeight / pageWidth;
          this.height = height * pageWidth / pageHeight;
          break;
        }
      case 180:
        this.x = 1 - x;
        this.y = 1 - y;
        this.width = width;
        this.height = height;
        break;
      case 270:
        {
          const [pageWidth, pageHeight] = this.parentDimensions;
          this.x = 1 - y;
          this.y = x;
          this.width = width * pageHeight / pageWidth;
          this.height = height * pageWidth / pageHeight;
          break;
        }
    }
    const {
      lastPoint
    } = this.#focusOutlines.box;
    this.#lastPoint = [(lastPoint[0] - x) / width, (lastPoint[1] - y) / height];
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
    HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || "#fff066";
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:
        HighlightEditor._defaultColor = value;
        break;
      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
        HighlightEditor._defaultThickness = value;
        break;
    }
  }
  translateInPage(x, y) {}
  get toolbarPosition() {
    return this.#lastPoint;
  }
  updateParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
        this.#updateColor(value);
        break;
      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
        this.#updateThickness(value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR, HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, HighlightEditor._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, this.color || HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, this.#thickness || HighlightEditor._defaultThickness], [AnnotationEditorParamsType.HIGHLIGHT_FREE, this.#isFreeHighlight]];
  }
  #updateColor(color) {
    const setColor = col => {
      this.color = col;
      this.parent?.drawLayer.changeColor(this.#id, col);
      this.#colorPicker?.updateColor(col);
    };
    const savedColor = this.color;
    this.addCommands({
      cmd: setColor.bind(this, color),
      undo: setColor.bind(this, savedColor),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
    this._reportTelemetry({
      action: "color_changed",
      color: this._uiManager.highlightColorNames.get(color)
    }, true);
  }
  #updateThickness(thickness) {
    const savedThickness = this.#thickness;
    const setThickness = th => {
      this.#thickness = th;
      this.#changeThickness(th);
    };
    this.addCommands({
      cmd: setThickness.bind(this, thickness),
      undo: setThickness.bind(this, savedThickness),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType.INK_THICKNESS,
      overwriteIfSameType: true,
      keepUndo: true
    });
    this._reportTelemetry({
      action: "thickness_changed",
      thickness
    }, true);
  }
  async addEditToolbar() {
    const toolbar = await super.addEditToolbar();
    if (!toolbar) {
      return null;
    }
    if (this._uiManager.highlightColors) {
      this.#colorPicker = new ColorPicker({
        editor: this
      });
      toolbar.addColorPicker(this.#colorPicker);
    }
    return toolbar;
  }
  disableEditing() {
    super.disableEditing();
    this.div.classList.toggle("disabled", true);
  }
  enableEditing() {
    super.enableEditing();
    this.div.classList.toggle("disabled", false);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(this.#getRotation());
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(tx, ty) {
    return super.getRect(tx, ty, this.#getRotation());
  }
  onceAdded() {
    this.parent.addUndoableEditor(this);
    this.div.focus();
  }
  remove() {
    this.#cleanDrawLayer();
    this._reportTelemetry({
      action: "deleted"
    });
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    this.#addToDrawLayer();
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  setParent(parent) {
    let mustBeSelected = false;
    if (this.parent && !parent) {
      this.#cleanDrawLayer();
    } else if (parent) {
      this.#addToDrawLayer(parent);
      mustBeSelected = !this.parent && this.div?.classList.contains("selectedEditor");
    }
    super.setParent(parent);
    this.show(this._isVisible);
    if (mustBeSelected) {
      this.select();
    }
  }
  #changeThickness(thickness) {
    if (!this.#isFreeHighlight) {
      return;
    }
    this.#createFreeOutlines({
      highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)
    });
    this.fixAndSetPosition();
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.setDims(this.width * parentWidth, this.height * parentHeight);
  }
  #cleanDrawLayer() {
    if (this.#id === null || !this.parent) {
      return;
    }
    this.parent.drawLayer.remove(this.#id);
    this.#id = null;
    this.parent.drawLayer.remove(this.#outlineId);
    this.#outlineId = null;
  }
  #addToDrawLayer(parent = this.parent) {
    if (this.#id !== null) {
      return;
    }
    ({
      id: this.#id,
      clipPathId: this.#clipPathId
    } = parent.drawLayer.highlight(this.#highlightOutlines, this.color, this.#opacity));
    this.#outlineId = parent.drawLayer.highlightOutline(this.#focusOutlines);
    if (this.#highlightDiv) {
      this.#highlightDiv.style.clipPath = this.#clipPathId;
    }
  }
  static #rotateBbox({
    x,
    y,
    width,
    height
  }, angle) {
    switch (angle) {
      case 90:
        return {
          x: 1 - y - height,
          y: x,
          width: height,
          height: width
        };
      case 180:
        return {
          x: 1 - x - width,
          y: 1 - y - height,
          width,
          height
        };
      case 270:
        return {
          x: y,
          y: 1 - x - width,
          width: height,
          height: width
        };
    }
    return {
      x,
      y,
      width,
      height
    };
  }
  rotate(angle) {
    const {
      drawLayer
    } = this.parent;
    let box;
    if (this.#isFreeHighlight) {
      angle = (angle - this.rotation + 360) % 360;
      box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);
    } else {
      box = HighlightEditor.#rotateBbox(this, angle);
    }
    drawLayer.rotate(this.#id, angle);
    drawLayer.rotate(this.#outlineId, angle);
    drawLayer.updateBox(this.#id, box);
    drawLayer.updateBox(this.#outlineId, HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle));
  }
  render() {
    if (this.div) {
      return this.div;
    }
    const div = super.render();
    if (this.#text) {
      div.setAttribute("aria-label", this.#text);
      div.setAttribute("role", "mark");
    }
    if (this.#isFreeHighlight) {
      div.classList.add("free");
    } else {
      this.div.addEventListener("keydown", this.#boundKeydown, {
        signal: this._uiManager._signal
      });
    }
    const highlightDiv = this.#highlightDiv = document.createElement("div");
    div.append(highlightDiv);
    highlightDiv.setAttribute("aria-hidden", "true");
    highlightDiv.className = "internal";
    highlightDiv.style.clipPath = this.#clipPathId;
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.setDims(this.width * parentWidth, this.height * parentHeight);
    bindEvents(this, this.#highlightDiv, ["pointerover", "pointerleave"]);
    this.enableEditing();
    return div;
  }
  pointerover() {
    this.parent.drawLayer.addClass(this.#outlineId, "hovered");
  }
  pointerleave() {
    this.parent.drawLayer.removeClass(this.#outlineId, "hovered");
  }
  #keydown(event) {
    HighlightEditor._keyboardManager.exec(this, event);
  }
  _moveCaret(direction) {
    this.parent.unselect(this);
    switch (direction) {
      case 0:
      case 2:
        this.#setCaret(true);
        break;
      case 1:
      case 3:
        this.#setCaret(false);
        break;
    }
  }
  #setCaret(start) {
    if (!this.#anchorNode) {
      return;
    }
    const selection = window.getSelection();
    if (start) {
      selection.setPosition(this.#anchorNode, this.#anchorOffset);
    } else {
      selection.setPosition(this.#focusNode, this.#focusOffset);
    }
  }
  select() {
    super.select();
    if (!this.#outlineId) {
      return;
    }
    this.parent?.drawLayer.removeClass(this.#outlineId, "hovered");
    this.parent?.drawLayer.addClass(this.#outlineId, "selected");
  }
  unselect() {
    super.unselect();
    if (!this.#outlineId) {
      return;
    }
    this.parent?.drawLayer.removeClass(this.#outlineId, "selected");
    if (!this.#isFreeHighlight) {
      this.#setCaret(false);
    }
  }
  get _mustFixPosition() {
    return !this.#isFreeHighlight;
  }
  show(visible = this._isVisible) {
    super.show(visible);
    if (this.parent) {
      this.parent.drawLayer.show(this.#id, visible);
      this.parent.drawLayer.show(this.#outlineId, visible);
    }
  }
  #getRotation() {
    return this.#isFreeHighlight ? this.rotation : 0;
  }
  #serializeBoxes() {
    if (this.#isFreeHighlight) {
      return null;
    }
    const [pageWidth, pageHeight] = this.pageDimensions;
    const boxes = this.#boxes;
    const quadPoints = new Float32Array(boxes.length * 8);
    let i = 0;
    for (const {
      x,
      y,
      width,
      height
    } of boxes) {
      const sx = x * pageWidth;
      const sy = (1 - y - height) * pageHeight;
      quadPoints[i] = quadPoints[i + 4] = sx;
      quadPoints[i + 1] = quadPoints[i + 3] = sy;
      quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;
      quadPoints[i + 5] = quadPoints[i + 7] = sy + height * pageHeight;
      i += 8;
    }
    return quadPoints;
  }
  #serializeOutlines(rect) {
    return this.#highlightOutlines.serialize(rect, this.#getRotation());
  }
  static startHighlighting(parent, isLTR, {
    target: textLayer,
    x,
    y
  }) {
    const {
      x: layerX,
      y: layerY,
      width: parentWidth,
      height: parentHeight
    } = textLayer.getBoundingClientRect();
    const pointerMove = e => {
      this.#highlightMove(parent, e);
    };
    const signal = parent._signal;
    const pointerDownOptions = {
      capture: true,
      passive: false,
      signal
    };
    const pointerDown = e => {
      e.preventDefault();
      e.stopPropagation();
    };
    const pointerUpCallback = e => {
      textLayer.removeEventListener("pointermove", pointerMove);
      window.removeEventListener("blur", pointerUpCallback);
      window.removeEventListener("pointerup", pointerUpCallback);
      window.removeEventListener("pointerdown", pointerDown, pointerDownOptions);
      window.removeEventListener("contextmenu", noContextMenu);
      this.#endHighlight(parent, e);
    };
    window.addEventListener("blur", pointerUpCallback, {
      signal
    });
    window.addEventListener("pointerup", pointerUpCallback, {
      signal
    });
    window.addEventListener("pointerdown", pointerDown, pointerDownOptions);
    window.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    textLayer.addEventListener("pointermove", pointerMove, {
      signal
    });
    this._freeHighlight = new FreeOutliner({
      x,
      y
    }, [layerX, layerY, parentWidth, parentHeight], parent.scale, this._defaultThickness / 2, isLTR, 0.001);
    ({
      id: this._freeHighlightId,
      clipPathId: this._freeHighlightClipId
    } = parent.drawLayer.highlight(this._freeHighlight, this._defaultColor, this._defaultOpacity, true));
  }
  static #highlightMove(parent, event) {
    if (this._freeHighlight.add(event)) {
      parent.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
    }
  }
  static #endHighlight(parent, event) {
    if (!this._freeHighlight.isEmpty()) {
      parent.createAndAddNewEditor(event, false, {
        highlightId: this._freeHighlightId,
        highlightOutlines: this._freeHighlight.getOutlines(),
        clipPathId: this._freeHighlightClipId,
        methodOfCreation: "main_toolbar"
      });
    } else {
      parent.drawLayer.removeFreeHighlight(this._freeHighlightId);
    }
    this._freeHighlightId = -1;
    this._freeHighlight = null;
    this._freeHighlightClipId = "";
  }
  static deserialize(data, parent, uiManager) {
    const editor = super.deserialize(data, parent, uiManager);
    const {
      rect: [blX, blY, trX, trY],
      color,
      quadPoints
    } = data;
    editor.color = Util.makeHexColor(...color);
    editor.#opacity = data.opacity;
    const [pageWidth, pageHeight] = editor.pageDimensions;
    editor.width = (trX - blX) / pageWidth;
    editor.height = (trY - blY) / pageHeight;
    const boxes = editor.#boxes = [];
    for (let i = 0; i < quadPoints.length; i += 8) {
      boxes.push({
        x: (quadPoints[4] - trX) / pageWidth,
        y: (trY - (1 - quadPoints[i + 5])) / pageHeight,
        width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,
        height: (quadPoints[i + 5] - quadPoints[i + 1]) / pageHeight
      });
    }
    editor.#createOutlines();
    return editor;
  }
  serialize(isForCopying = false) {
    if (this.isEmpty() || isForCopying) {
      return null;
    }
    const rect = this.getRect(0, 0);
    const color = AnnotationEditor._colorManager.convert(this.color);
    return {
      annotationType: AnnotationEditorType.HIGHLIGHT,
      color,
      opacity: this.#opacity,
      thickness: this.#thickness,
      quadPoints: this.#serializeBoxes(),
      outlines: this.#serializeOutlines(rect),
      pageIndex: this.pageIndex,
      rect,
      rotation: this.#getRotation(),
      structTreeParentId: this._structTreeParentId
    };
  }
  static canCreateNewEmptyEditor() {
    return false;
  }
}





class InkEditor extends AnnotationEditor {
  #baseHeight = 0;
  #baseWidth = 0;
  #boundCanvasPointermove = this.canvasPointermove.bind(this);
  #boundCanvasPointerleave = this.canvasPointerleave.bind(this);
  #boundCanvasPointerup = this.canvasPointerup.bind(this);
  #boundCanvasPointerdown = this.canvasPointerdown.bind(this);
  #canvasContextMenuTimeoutId = null;
  #currentPath2D = new Path2D();
  #disableEditing = false;
  #hasSomethingToDraw = false;
  #isCanvasInitialized = false;
  #observer = null;
  #realWidth = 0;
  #realHeight = 0;
  #requestFrameCallback = null;
  static _defaultColor = null;
  static _defaultOpacity = 1;
  static _defaultThickness = 1;
  static _type = "ink";
  static _editorType = AnnotationEditorType.INK;
  constructor(params) {
    super({
      ...params,
      name: "inkEditor"
    });
    this.color = params.color || null;
    this.thickness = params.thickness || null;
    this.opacity = params.opacity || null;
    this.paths = [];
    this.bezierPath2D = [];
    this.allRawPaths = [];
    this.currentPath = [];
    this.scaleFactor = 1;
    this.translationX = this.translationY = 0;
    this.x = 0;
    this.y = 0;
    this._willKeepAspectRatio = true;
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.INK_THICKNESS:
        InkEditor._defaultThickness = value;
        break;
      case AnnotationEditorParamsType.INK_COLOR:
        InkEditor._defaultColor = value;
        break;
      case AnnotationEditorParamsType.INK_OPACITY:
        InkEditor._defaultOpacity = value / 100;
        break;
    }
  }
  updateParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.INK_THICKNESS:
        this.#updateThickness(value);
        break;
      case AnnotationEditorParamsType.INK_COLOR:
        this.#updateColor(value);
        break;
      case AnnotationEditorParamsType.INK_OPACITY:
        this.#updateOpacity(value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || AnnotationEditor._defaultLineColor], [AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]];
  }
  get propertiesToUpdate() {
    return [[AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || AnnotationEditor._defaultLineColor], [AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))]];
  }
  #updateThickness(thickness) {
    const setThickness = th => {
      this.thickness = th;
      this.#fitToContent();
    };
    const savedThickness = this.thickness;
    this.addCommands({
      cmd: setThickness.bind(this, thickness),
      undo: setThickness.bind(this, savedThickness),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType.INK_THICKNESS,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  #updateColor(color) {
    const setColor = col => {
      this.color = col;
      this.#redraw();
    };
    const savedColor = this.color;
    this.addCommands({
      cmd: setColor.bind(this, color),
      undo: setColor.bind(this, savedColor),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType.INK_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  #updateOpacity(opacity) {
    const setOpacity = op => {
      this.opacity = op;
      this.#redraw();
    };
    opacity /= 100;
    const savedOpacity = this.opacity;
    this.addCommands({
      cmd: setOpacity.bind(this, opacity),
      undo: setOpacity.bind(this, savedOpacity),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType.INK_OPACITY,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (!this.canvas) {
      this.#createCanvas();
      this.#createObserver();
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
      this.#setCanvasDims();
    }
    this.#fitToContent();
  }
  remove() {
    if (this.canvas === null) {
      return;
    }
    if (!this.isEmpty()) {
      this.commit();
    }
    this.canvas.width = this.canvas.height = 0;
    this.canvas.remove();
    this.canvas = null;
    if (this.#canvasContextMenuTimeoutId) {
      clearTimeout(this.#canvasContextMenuTimeoutId);
      this.#canvasContextMenuTimeoutId = null;
    }
    this.#observer?.disconnect();
    this.#observer = null;
    super.remove();
  }
  setParent(parent) {
    if (!this.parent && parent) {
      this._uiManager.removeShouldRescale(this);
    } else if (this.parent && parent === null) {
      this._uiManager.addShouldRescale(this);
    }
    super.setParent(parent);
  }
  onScaleChanging() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const width = this.width * parentWidth;
    const height = this.height * parentHeight;
    this.setDimensions(width, height);
  }
  enableEditMode() {
    if (this.#disableEditing || this.canvas === null) {
      return;
    }
    super.enableEditMode();
    this._isDraggable = false;
    this.canvas.addEventListener("pointerdown", this.#boundCanvasPointerdown, {
      signal: this._uiManager._signal
    });
  }
  disableEditMode() {
    if (!this.isInEditMode() || this.canvas === null) {
      return;
    }
    super.disableEditMode();
    this._isDraggable = !this.isEmpty();
    this.div.classList.remove("editing");
    this.canvas.removeEventListener("pointerdown", this.#boundCanvasPointerdown);
  }
  onceAdded() {
    this._isDraggable = !this.isEmpty();
  }
  isEmpty() {
    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
  }
  #getInitialBBox() {
    const {
      parentRotation,
      parentDimensions: [width, height]
    } = this;
    switch (parentRotation) {
      case 90:
        return [0, height, height, width];
      case 180:
        return [width, height, width, height];
      case 270:
        return [width, 0, height, width];
      default:
        return [0, 0, width, height];
    }
  }
  #setStroke() {
    const {
      ctx,
      color,
      opacity,
      thickness,
      parentScale,
      scaleFactor
    } = this;
    ctx.lineWidth = thickness * parentScale / scaleFactor;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.miterLimit = 10;
    ctx.strokeStyle = `${color}${opacityToHex(opacity)}`;
  }
  #startDrawing(x, y) {
    const signal = this._uiManager._signal;
    this.canvas.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    this.canvas.addEventListener("pointerleave", this.#boundCanvasPointerleave, {
      signal
    });
    this.canvas.addEventListener("pointermove", this.#boundCanvasPointermove, {
      signal
    });
    this.canvas.addEventListener("pointerup", this.#boundCanvasPointerup, {
      signal
    });
    this.canvas.removeEventListener("pointerdown", this.#boundCanvasPointerdown);
    this.isEditing = true;
    if (!this.#isCanvasInitialized) {
      this.#isCanvasInitialized = true;
      this.#setCanvasDims();
      this.thickness ||= InkEditor._defaultThickness;
      this.color ||= InkEditor._defaultColor || AnnotationEditor._defaultLineColor;
      this.opacity ??= InkEditor._defaultOpacity;
    }
    this.currentPath.push([x, y]);
    this.#hasSomethingToDraw = false;
    this.#setStroke();
    this.#requestFrameCallback = () => {
      this.#drawPoints();
      if (this.#requestFrameCallback) {
        window.requestAnimationFrame(this.#requestFrameCallback);
      }
    };
    window.requestAnimationFrame(this.#requestFrameCallback);
  }
  #draw(x, y) {
    const [lastX, lastY] = this.currentPath.at(-1);
    if (this.currentPath.length > 1 && x === lastX && y === lastY) {
      return;
    }
    const currentPath = this.currentPath;
    let path2D = this.#currentPath2D;
    currentPath.push([x, y]);
    this.#hasSomethingToDraw = true;
    if (currentPath.length <= 2) {
      path2D.moveTo(...currentPath[0]);
      path2D.lineTo(x, y);
      return;
    }
    if (currentPath.length === 3) {
      this.#currentPath2D = path2D = new Path2D();
      path2D.moveTo(...currentPath[0]);
    }
    this.#makeBezierCurve(path2D, ...currentPath.at(-3), ...currentPath.at(-2), x, y);
  }
  #endPath() {
    if (this.currentPath.length === 0) {
      return;
    }
    const lastPoint = this.currentPath.at(-1);
    this.#currentPath2D.lineTo(...lastPoint);
  }
  #stopDrawing(x, y) {
    this.#requestFrameCallback = null;
    x = Math.min(Math.max(x, 0), this.canvas.width);
    y = Math.min(Math.max(y, 0), this.canvas.height);
    this.#draw(x, y);
    this.#endPath();
    let bezier;
    if (this.currentPath.length !== 1) {
      bezier = this.#generateBezierPoints();
    } else {
      const xy = [x, y];
      bezier = [[xy, xy.slice(), xy.slice(), xy]];
    }
    const path2D = this.#currentPath2D;
    const currentPath = this.currentPath;
    this.currentPath = [];
    this.#currentPath2D = new Path2D();
    const cmd = () => {
      this.allRawPaths.push(currentPath);
      this.paths.push(bezier);
      this.bezierPath2D.push(path2D);
      this._uiManager.rebuild(this);
    };
    const undo = () => {
      this.allRawPaths.pop();
      this.paths.pop();
      this.bezierPath2D.pop();
      if (this.paths.length === 0) {
        this.remove();
      } else {
        if (!this.canvas) {
          this.#createCanvas();
          this.#createObserver();
        }
        this.#fitToContent();
      }
    };
    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }
  #drawPoints() {
    if (!this.#hasSomethingToDraw) {
      return;
    }
    this.#hasSomethingToDraw = false;
    const thickness = Math.ceil(this.thickness * this.parentScale);
    const lastPoints = this.currentPath.slice(-3);
    const x = lastPoints.map(xy => xy[0]);
    const y = lastPoints.map(xy => xy[1]);
    Math.min(...x) - thickness;
    Math.max(...x) + thickness;
    Math.min(...y) - thickness;
    Math.max(...y) + thickness;
    const {
      ctx
    } = this;
    ctx.save();
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    for (const path of this.bezierPath2D) {
      ctx.stroke(path);
    }
    ctx.stroke(this.#currentPath2D);
    ctx.restore();
  }
  #makeBezierCurve(path2D, x0, y0, x1, y1, x2, y2) {
    const prevX = (x0 + x1) / 2;
    const prevY = (y0 + y1) / 2;
    const x3 = (x1 + x2) / 2;
    const y3 = (y1 + y2) / 2;
    path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);
  }
  #generateBezierPoints() {
    const path = this.currentPath;
    if (path.length <= 2) {
      return [[path[0], path[0], path.at(-1), path.at(-1)]];
    }
    const bezierPoints = [];
    let i;
    let [x0, y0] = path[0];
    for (i = 1; i < path.length - 2; i++) {
      const [x1, y1] = path[i];
      const [x2, y2] = path[i + 1];
      const x3 = (x1 + x2) / 2;
      const y3 = (y1 + y2) / 2;
      const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];
      const control2 = [x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3];
      bezierPoints.push([[x0, y0], control1, control2, [x3, y3]]);
      [x0, y0] = [x3, y3];
    }
    const [x1, y1] = path[i];
    const [x2, y2] = path[i + 1];
    const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];
    const control2 = [x2 + 2 * (x1 - x2) / 3, y2 + 2 * (y1 - y2) / 3];
    bezierPoints.push([[x0, y0], control1, control2, [x2, y2]]);
    return bezierPoints;
  }
  #redraw() {
    if (this.isEmpty()) {
      this.#updateTransform();
      return;
    }
    this.#setStroke();
    const {
      canvas,
      ctx
    } = this;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    this.#updateTransform();
    for (const path of this.bezierPath2D) {
      ctx.stroke(path);
    }
  }
  commit() {
    if (this.#disableEditing) {
      return;
    }
    super.commit();
    this.isEditing = false;
    this.disableEditMode();
    this.setInForeground();
    this.#disableEditing = true;
    this.div.classList.add("disabled");
    this.#fitToContent(true);
    this.select();
    this.parent.addInkEditorIfNeeded(true);
    this.moveInDOM();
    this.div.focus({
      preventScroll: true
    });
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    super.focusin(event);
    this.enableEditMode();
  }
  canvasPointerdown(event) {
    if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {
      return;
    }
    this.setInForeground();
    event.preventDefault();
    if (!this.div.contains(document.activeElement)) {
      this.div.focus({
        preventScroll: true
      });
    }
    this.#startDrawing(event.offsetX, event.offsetY);
  }
  canvasPointermove(event) {
    event.preventDefault();
    this.#draw(event.offsetX, event.offsetY);
  }
  canvasPointerup(event) {
    event.preventDefault();
    this.#endDrawing(event);
  }
  canvasPointerleave(event) {
    this.#endDrawing(event);
  }
  #endDrawing(event) {
    this.canvas.removeEventListener("pointerleave", this.#boundCanvasPointerleave);
    this.canvas.removeEventListener("pointermove", this.#boundCanvasPointermove);
    this.canvas.removeEventListener("pointerup", this.#boundCanvasPointerup);
    this.canvas.addEventListener("pointerdown", this.#boundCanvasPointerdown, {
      signal: this._uiManager._signal
    });
    if (this.#canvasContextMenuTimeoutId) {
      clearTimeout(this.#canvasContextMenuTimeoutId);
    }
    this.#canvasContextMenuTimeoutId = setTimeout(() => {
      this.#canvasContextMenuTimeoutId = null;
      this.canvas.removeEventListener("contextmenu", noContextMenu);
    }, 10);
    this.#stopDrawing(event.offsetX, event.offsetY);
    this.addToAnnotationStorage();
    this.setInBackground();
  }
  #createCanvas() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.canvas.height = 0;
    this.canvas.className = "inkEditorCanvas";
    this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas");
    this.div.append(this.canvas);
    this.ctx = this.canvas.getContext("2d");
  }
  #createObserver() {
    this.#observer = new ResizeObserver(entries => {
      const rect = entries[0].contentRect;
      if (rect.width && rect.height) {
        this.setDimensions(rect.width, rect.height);
      }
    });
    this.#observer.observe(this.div);
    this._uiManager._signal.addEventListener("abort", () => {
      this.#observer?.disconnect();
      this.#observer = null;
    }, {
      once: true
    });
  }
  get isResizable() {
    return !this.isEmpty() && this.#disableEditing;
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this.width) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.div.setAttribute("data-l10n-id", "pdfjs-ink");
    const [x, y, w, h] = this.#getInitialBBox();
    this.setAt(x, y, 0, 0);
    this.setDims(w, h);
    this.#createCanvas();
    if (this.width) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);
      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
      this.#isCanvasInitialized = true;
      this.#setCanvasDims();
      this.setDims(this.width * parentWidth, this.height * parentHeight);
      this.#redraw();
      this.div.classList.add("disabled");
    } else {
      this.div.classList.add("editing");
      this.enableEditMode();
    }
    this.#createObserver();
    return this.div;
  }
  #setCanvasDims() {
    if (!this.#isCanvasInitialized) {
      return;
    }
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.canvas.width = Math.ceil(this.width * parentWidth);
    this.canvas.height = Math.ceil(this.height * parentHeight);
    this.#updateTransform();
  }
  setDimensions(width, height) {
    const roundedWidth = Math.round(width);
    const roundedHeight = Math.round(height);
    if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) {
      return;
    }
    this.#realWidth = roundedWidth;
    this.#realHeight = roundedHeight;
    this.canvas.style.visibility = "hidden";
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.width = width / parentWidth;
    this.height = height / parentHeight;
    this.fixAndSetPosition();
    if (this.#disableEditing) {
      this.#setScaleFactor(width, height);
    }
    this.#setCanvasDims();
    this.#redraw();
    this.canvas.style.visibility = "visible";
    this.fixDims();
  }
  #setScaleFactor(width, height) {
    const padding = this.#getPadding();
    const scaleFactorW = (width - padding) / this.#baseWidth;
    const scaleFactorH = (height - padding) / this.#baseHeight;
    this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
  }
  #updateTransform() {
    const padding = this.#getPadding() / 2;
    this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);
  }
  static #buildPath2D(bezier) {
    const path2D = new Path2D();
    for (let i = 0, ii = bezier.length; i < ii; i++) {
      const [first, control1, control2, second] = bezier[i];
      if (i === 0) {
        path2D.moveTo(...first);
      }
      path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);
    }
    return path2D;
  }
  static #toPDFCoordinates(points, rect, rotation) {
    const [blX, blY, trX, trY] = rect;
    switch (rotation) {
      case 0:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          points[i] += blX;
          points[i + 1] = trY - points[i + 1];
        }
        break;
      case 90:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          const x = points[i];
          points[i] = points[i + 1] + blX;
          points[i + 1] = x + blY;
        }
        break;
      case 180:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          points[i] = trX - points[i];
          points[i + 1] += blY;
        }
        break;
      case 270:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          const x = points[i];
          points[i] = trX - points[i + 1];
          points[i + 1] = trY - x;
        }
        break;
      default:
        throw new Error("Invalid rotation");
    }
    return points;
  }
  static #fromPDFCoordinates(points, rect, rotation) {
    const [blX, blY, trX, trY] = rect;
    switch (rotation) {
      case 0:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          points[i] -= blX;
          points[i + 1] = trY - points[i + 1];
        }
        break;
      case 90:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          const x = points[i];
          points[i] = points[i + 1] - blY;
          points[i + 1] = x - blX;
        }
        break;
      case 180:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          points[i] = trX - points[i];
          points[i + 1] -= blY;
        }
        break;
      case 270:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          const x = points[i];
          points[i] = trY - points[i + 1];
          points[i + 1] = trX - x;
        }
        break;
      default:
        throw new Error("Invalid rotation");
    }
    return points;
  }
  #serializePaths(s, tx, ty, rect) {
    const paths = [];
    const padding = this.thickness / 2;
    const shiftX = s * tx + padding;
    const shiftY = s * ty + padding;
    for (const bezier of this.paths) {
      const buffer = [];
      const points = [];
      for (let j = 0, jj = bezier.length; j < jj; j++) {
        const [first, control1, control2, second] = bezier[j];
        if (first[0] === second[0] && first[1] === second[1] && jj === 1) {
          const p0 = s * first[0] + shiftX;
          const p1 = s * first[1] + shiftY;
          buffer.push(p0, p1);
          points.push(p0, p1);
          break;
        }
        const p10 = s * first[0] + shiftX;
        const p11 = s * first[1] + shiftY;
        const p20 = s * control1[0] + shiftX;
        const p21 = s * control1[1] + shiftY;
        const p30 = s * control2[0] + shiftX;
        const p31 = s * control2[1] + shiftY;
        const p40 = s * second[0] + shiftX;
        const p41 = s * second[1] + shiftY;
        if (j === 0) {
          buffer.push(p10, p11);
          points.push(p10, p11);
        }
        buffer.push(p20, p21, p30, p31, p40, p41);
        points.push(p20, p21);
        if (j === jj - 1) {
          points.push(p40, p41);
        }
      }
      paths.push({
        bezier: InkEditor.#toPDFCoordinates(buffer, rect, this.rotation),
        points: InkEditor.#toPDFCoordinates(points, rect, this.rotation)
      });
    }
    return paths;
  }
  #getBbox() {
    let xMin = Infinity;
    let xMax = -Infinity;
    let yMin = Infinity;
    let yMax = -Infinity;
    for (const path of this.paths) {
      for (const [first, control1, control2, second] of path) {
        const bbox = Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);
        xMin = Math.min(xMin, bbox[0]);
        yMin = Math.min(yMin, bbox[1]);
        xMax = Math.max(xMax, bbox[2]);
        yMax = Math.max(yMax, bbox[3]);
      }
    }
    return [xMin, yMin, xMax, yMax];
  }
  #getPadding() {
    return this.#disableEditing ? Math.ceil(this.thickness * this.parentScale) : 0;
  }
  #fitToContent(firstTime = false) {
    if (this.isEmpty()) {
      return;
    }
    if (!this.#disableEditing) {
      this.#redraw();
      return;
    }
    const bbox = this.#getBbox();
    const padding = this.#getPadding();
    this.#baseWidth = Math.max(AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);
    this.#baseHeight = Math.max(AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);
    const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);
    const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.width = width / parentWidth;
    this.height = height / parentHeight;
    this.setAspectRatio(width, height);
    const prevTranslationX = this.translationX;
    const prevTranslationY = this.translationY;
    this.translationX = -bbox[0];
    this.translationY = -bbox[1];
    this.#setCanvasDims();
    this.#redraw();
    this.#realWidth = width;
    this.#realHeight = height;
    this.setDims(width, height);
    const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;
    this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);
  }
  static deserialize(data, parent, uiManager) {
    if (data instanceof InkAnnotationElement) {
      return null;
    }
    const editor = super.deserialize(data, parent, uiManager);
    editor.thickness = data.thickness;
    editor.color = Util.makeHexColor(...data.color);
    editor.opacity = data.opacity;
    const [pageWidth, pageHeight] = editor.pageDimensions;
    const width = editor.width * pageWidth;
    const height = editor.height * pageHeight;
    const scaleFactor = editor.parentScale;
    const padding = data.thickness / 2;
    editor.#disableEditing = true;
    editor.#realWidth = Math.round(width);
    editor.#realHeight = Math.round(height);
    const {
      paths,
      rect,
      rotation
    } = data;
    for (let {
      bezier
    } of paths) {
      bezier = InkEditor.#fromPDFCoordinates(bezier, rect, rotation);
      const path = [];
      editor.paths.push(path);
      let p0 = scaleFactor * (bezier[0] - padding);
      let p1 = scaleFactor * (bezier[1] - padding);
      for (let i = 2, ii = bezier.length; i < ii; i += 6) {
        const p10 = scaleFactor * (bezier[i] - padding);
        const p11 = scaleFactor * (bezier[i + 1] - padding);
        const p20 = scaleFactor * (bezier[i + 2] - padding);
        const p21 = scaleFactor * (bezier[i + 3] - padding);
        const p30 = scaleFactor * (bezier[i + 4] - padding);
        const p31 = scaleFactor * (bezier[i + 5] - padding);
        path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);
        p0 = p30;
        p1 = p31;
      }
      const path2D = this.#buildPath2D(path);
      editor.bezierPath2D.push(path2D);
    }
    const bbox = editor.#getBbox();
    editor.#baseWidth = Math.max(AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);
    editor.#baseHeight = Math.max(AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);
    editor.#setScaleFactor(width, height);
    return editor;
  }
  serialize() {
    if (this.isEmpty()) {
      return null;
    }
    const rect = this.getRect(0, 0);
    const color = AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
    return {
      annotationType: AnnotationEditorType.INK,
      color,
      thickness: this.thickness,
      opacity: this.opacity,
      paths: this.#serializePaths(this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),
      pageIndex: this.pageIndex,
      rect,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
  }
}




class StampEditor extends AnnotationEditor {
  #bitmap = null;
  #bitmapId = null;
  #bitmapPromise = null;
  #bitmapUrl = null;
  #bitmapFile = null;
  #bitmapFileName = "";
  #canvas = null;
  #observer = null;
  #resizeTimeoutId = null;
  #isSvg = false;
  #hasBeenAddedInUndoStack = false;
  static _type = "stamp";
  static _editorType = AnnotationEditorType.STAMP;
  constructor(params) {
    super({
      ...params,
      name: "stampEditor"
    });
    this.#bitmapUrl = params.bitmapUrl;
    this.#bitmapFile = params.bitmapFile;
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
  }
  static get supportedTypes() {
    const types = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
    return shadow(this, "supportedTypes", types.map(type => `image/${type}`));
  }
  static get supportedTypesStr() {
    return shadow(this, "supportedTypesStr", this.supportedTypes.join(","));
  }
  static isHandlingMimeForPasting(mime) {
    return this.supportedTypes.includes(mime);
  }
  static paste(item, parent) {
    parent.pasteEditor(AnnotationEditorType.STAMP, {
      bitmapFile: item.getAsFile()
    });
  }
  #getBitmapFetched(data, fromId = false) {
    if (!data) {
      this.remove();
      return;
    }
    this.#bitmap = data.bitmap;
    if (!fromId) {
      this.#bitmapId = data.id;
      this.#isSvg = data.isSvg;
    }
    if (data.file) {
      this.#bitmapFileName = data.file.name;
    }
    this.#createCanvas();
  }
  #getBitmapDone() {
    this.#bitmapPromise = null;
    this._uiManager.enableWaiting(false);
    if (this.#canvas) {
      this.div.focus();
    }
  }
  #getBitmap() {
    if (this.#bitmapId) {
      this._uiManager.enableWaiting(true);
      this._uiManager.imageManager.getFromId(this.#bitmapId).then(data => this.#getBitmapFetched(data, true)).finally(() => this.#getBitmapDone());
      return;
    }
    if (this.#bitmapUrl) {
      const url = this.#bitmapUrl;
      this.#bitmapUrl = null;
      this._uiManager.enableWaiting(true);
      this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());
      return;
    }
    if (this.#bitmapFile) {
      const file = this.#bitmapFile;
      this.#bitmapFile = null;
      this._uiManager.enableWaiting(true);
      this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());
      return;
    }
    const input = document.createElement("input");
    input.type = "file";
    input.accept = StampEditor.supportedTypesStr;
    const signal = this._uiManager._signal;
    this.#bitmapPromise = new Promise(resolve => {
      input.addEventListener("change", async () => {
        if (!input.files || input.files.length === 0) {
          this.remove();
        } else {
          this._uiManager.enableWaiting(true);
          const data = await this._uiManager.imageManager.getFromFile(input.files[0]);
          this.#getBitmapFetched(data);
        }
        resolve();
      }, {
        signal
      });
      input.addEventListener("cancel", () => {
        this.remove();
        resolve();
      }, {
        signal
      });
    }).finally(() => this.#getBitmapDone());
    input.click();
  }
  remove() {
    if (this.#bitmapId) {
      this.#bitmap = null;
      this._uiManager.imageManager.deleteId(this.#bitmapId);
      this.#canvas?.remove();
      this.#canvas = null;
      this.#observer?.disconnect();
      this.#observer = null;
      if (this.#resizeTimeoutId) {
        clearTimeout(this.#resizeTimeoutId);
        this.#resizeTimeoutId = null;
      }
    }
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      if (this.#bitmapId) {
        this.#getBitmap();
      }
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (this.#bitmapId && this.#canvas === null) {
      this.#getBitmap();
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  onceAdded() {
    this._isDraggable = true;
    this.div.focus();
  }
  isEmpty() {
    return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId);
  }
  get isResizable() {
    return true;
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this.width) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.div.hidden = true;
    this.addAltTextButton();
    if (this.#bitmap) {
      this.#createCanvas();
    } else {
      this.#getBitmap();
    }
    if (this.width) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
    }
    return this.div;
  }
  #createCanvas() {
    const {
      div
    } = this;
    let {
      width,
      height
    } = this.#bitmap;
    const [pageWidth, pageHeight] = this.pageDimensions;
    const MAX_RATIO = 0.75;
    if (this.width) {
      width = this.width * pageWidth;
      height = this.height * pageHeight;
    } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {
      const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);
      width *= factor;
      height *= factor;
    }
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);
    this._uiManager.enableWaiting(false);
    const canvas = this.#canvas = document.createElement("canvas");
    div.append(canvas);
    div.hidden = false;
    this.#drawBitmap(width, height);
    this.#createObserver();
    if (!this.#hasBeenAddedInUndoStack) {
      this.parent.addUndoableEditor(this);
      this.#hasBeenAddedInUndoStack = true;
    }
    this._reportTelemetry({
      action: "inserted_image"
    });
    if (this.#bitmapFileName) {
      canvas.setAttribute("aria-label", this.#bitmapFileName);
    }
  }
  #setDimensions(width, height) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.width = width / parentWidth;
    this.height = height / parentHeight;
    this.setDims(width, height);
    if (this._initialOptions?.isCentered) {
      this.center();
    } else {
      this.fixAndSetPosition();
    }
    this._initialOptions = null;
    if (this.#resizeTimeoutId !== null) {
      clearTimeout(this.#resizeTimeoutId);
    }
    const TIME_TO_WAIT = 200;
    this.#resizeTimeoutId = setTimeout(() => {
      this.#resizeTimeoutId = null;
      this.#drawBitmap(width, height);
    }, TIME_TO_WAIT);
  }
  #scaleBitmap(width, height) {
    const {
      width: bitmapWidth,
      height: bitmapHeight
    } = this.#bitmap;
    let newWidth = bitmapWidth;
    let newHeight = bitmapHeight;
    let bitmap = this.#bitmap;
    while (newWidth > 2 * width || newHeight > 2 * height) {
      const prevWidth = newWidth;
      const prevHeight = newHeight;
      if (newWidth > 2 * width) {
        newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);
      }
      if (newHeight > 2 * height) {
        newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);
      }
      const offscreen = new OffscreenCanvas(newWidth, newHeight);
      const ctx = offscreen.getContext("2d");
      ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
      bitmap = offscreen.transferToImageBitmap();
    }
    return bitmap;
  }
  #drawBitmap(width, height) {
    width = Math.ceil(width);
    height = Math.ceil(height);
    const canvas = this.#canvas;
    if (!canvas || canvas.width === width && canvas.height === height) {
      return;
    }
    canvas.width = width;
    canvas.height = height;
    const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(width, height);
    if (this._uiManager.hasMLManager && !this.hasAltText()) {
      const offscreen = new OffscreenCanvas(width, height);
      const ctx = offscreen.getContext("2d");
      ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);
      this._uiManager.mlGuess({
        service: "image-to-text",
        request: {
          data: ctx.getImageData(0, 0, width, height).data,
          width,
          height,
          channels: 4
        }
      }).then(response => {
        const altText = response?.output || "";
        if (this.parent && altText && !this.hasAltText()) {
          this.altTextData = {
            altText,
            decorative: false
          };
        }
      });
    }
    const ctx = canvas.getContext("2d");
    ctx.filter = this._uiManager.hcmFilter;
    ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);
  }
  getImageForAltText() {
    return this.#canvas;
  }
  #serializeBitmap(toUrl) {
    if (toUrl) {
      if (this.#isSvg) {
        const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);
        if (url) {
          return url;
        }
      }
      const canvas = document.createElement("canvas");
      ({
        width: canvas.width,
        height: canvas.height
      } = this.#bitmap);
      const ctx = canvas.getContext("2d");
      ctx.drawImage(this.#bitmap, 0, 0);
      return canvas.toDataURL();
    }
    if (this.#isSvg) {
      const [pageWidth, pageHeight] = this.pageDimensions;
      const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);
      const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);
      const offscreen = new OffscreenCanvas(width, height);
      const ctx = offscreen.getContext("2d");
      ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);
      return offscreen.transferToImageBitmap();
    }
    return structuredClone(this.#bitmap);
  }
  #createObserver() {
    if (!this._uiManager._signal) {
      return;
    }
    this.#observer = new ResizeObserver(entries => {
      const rect = entries[0].contentRect;
      if (rect.width && rect.height) {
        this.#setDimensions(rect.width, rect.height);
      }
    });
    this.#observer.observe(this.div);
    this._uiManager._signal.addEventListener("abort", () => {
      this.#observer?.disconnect();
      this.#observer = null;
    }, {
      once: true
    });
  }
  static deserialize(data, parent, uiManager) {
    if (data instanceof StampAnnotationElement) {
      return null;
    }
    const editor = super.deserialize(data, parent, uiManager);
    const {
      rect,
      bitmapUrl,
      bitmapId,
      isSvg,
      accessibilityData
    } = data;
    if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
      editor.#bitmapId = bitmapId;
    } else {
      editor.#bitmapUrl = bitmapUrl;
    }
    editor.#isSvg = isSvg;
    const [parentWidth, parentHeight] = editor.pageDimensions;
    editor.width = (rect[2] - rect[0]) / parentWidth;
    editor.height = (rect[3] - rect[1]) / parentHeight;
    if (accessibilityData) {
      editor.altTextData = accessibilityData;
    }
    return editor;
  }
  serialize(isForCopying = false, context = null) {
    if (this.isEmpty()) {
      return null;
    }
    const serialized = {
      annotationType: AnnotationEditorType.STAMP,
      bitmapId: this.#bitmapId,
      pageIndex: this.pageIndex,
      rect: this.getRect(0, 0),
      rotation: this.rotation,
      isSvg: this.#isSvg,
      structTreeParentId: this._structTreeParentId
    };
    if (isForCopying) {
      serialized.bitmapUrl = this.#serializeBitmap(true);
      serialized.accessibilityData = this.altTextData;
      return serialized;
    }
    const {
      decorative,
      altText
    } = this.altTextData;
    if (!decorative && altText) {
      serialized.accessibilityData = {
        type: "Figure",
        alt: altText
      };
    }
    if (context === null) {
      return serialized;
    }
    context.stamps ||= new Map();
    const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;
    if (!context.stamps.has(this.#bitmapId)) {
      context.stamps.set(this.#bitmapId, {
        area,
        serialized
      });
      serialized.bitmap = this.#serializeBitmap(false);
    } else if (this.#isSvg) {
      const prevData = context.stamps.get(this.#bitmapId);
      if (area > prevData.area) {
        prevData.area = area;
        prevData.serialized.bitmap.close();
        prevData.serialized.bitmap = this.#serializeBitmap(false);
      }
    }
    return serialized;
  }
}







class AnnotationEditorLayer {
  #accessibilityManager;
  #allowClick = false;
  #annotationLayer = null;
  #boundPointerup = null;
  #boundPointerdown = null;
  #boundTextLayerPointerDown = null;
  #editorFocusTimeoutId = null;
  #editors = new Map();
  #hadPointerDown = false;
  #isCleaningUp = false;
  #isDisabling = false;
  #textLayer = null;
  #uiManager;
  static _initialized = false;
  static #editorTypes = new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor].map(type => [type._editorType, type]));
  constructor({
    uiManager,
    pageIndex,
    div,
    accessibilityManager,
    annotationLayer,
    drawLayer,
    textLayer,
    viewport,
    l10n
  }) {
    const editorTypes = [...AnnotationEditorLayer.#editorTypes.values()];
    if (!AnnotationEditorLayer._initialized) {
      AnnotationEditorLayer._initialized = true;
      for (const editorType of editorTypes) {
        editorType.initialize(l10n, uiManager);
      }
    }
    uiManager.registerEditorTypes(editorTypes);
    this.#uiManager = uiManager;
    this.pageIndex = pageIndex;
    this.div = div;
    this.#accessibilityManager = accessibilityManager;
    this.#annotationLayer = annotationLayer;
    this.viewport = viewport;
    this.#textLayer = textLayer;
    this.drawLayer = drawLayer;
    this.#uiManager.addLayer(this);
  }
  get isEmpty() {
    return this.#editors.size === 0;
  }
  get isInvisible() {
    return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;
  }
  updateToolbar(mode) {
    this.#uiManager.updateToolbar(mode);
  }
  updateMode(mode = this.#uiManager.getMode()) {
    this.#cleanup();
    switch (mode) {
      case AnnotationEditorType.NONE:
        this.disableTextSelection();
        this.togglePointerEvents(false);
        this.toggleAnnotationLayerPointerEvents(true);
        this.disableClick();
        return;
      case AnnotationEditorType.INK:
        this.addInkEditorIfNeeded(false);
        this.disableTextSelection();
        this.togglePointerEvents(true);
        this.disableClick();
        break;
      case AnnotationEditorType.HIGHLIGHT:
        this.enableTextSelection();
        this.togglePointerEvents(false);
        this.disableClick();
        break;
      default:
        this.disableTextSelection();
        this.togglePointerEvents(true);
        this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(false);
    const {
      classList
    } = this.div;
    for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {
      classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);
    }
    this.div.hidden = false;
  }
  hasTextLayer(textLayer) {
    return textLayer === this.#textLayer?.div;
  }
  addInkEditorIfNeeded(isCommitting) {
    if (this.#uiManager.getMode() !== AnnotationEditorType.INK) {
      return;
    }
    if (!isCommitting) {
      for (const editor of this.#editors.values()) {
        if (editor.isEmpty()) {
          editor.setInBackground();
          return;
        }
      }
    }
    const editor = this.createAndAddNewEditor({
      offsetX: 0,
      offsetY: 0
    }, false);
    editor.setInBackground();
  }
  setEditingState(isEditing) {
    this.#uiManager.setEditingState(isEditing);
  }
  addCommands(params) {
    this.#uiManager.addCommands(params);
  }
  togglePointerEvents(enabled = false) {
    this.div.classList.toggle("disabled", !enabled);
  }
  toggleAnnotationLayerPointerEvents(enabled = false) {
    this.#annotationLayer?.div.classList.toggle("disabled", !enabled);
  }
  enable() {
    this.div.tabIndex = 0;
    this.togglePointerEvents(true);
    const annotationElementIds = new Set();
    for (const editor of this.#editors.values()) {
      editor.enableEditing();
      editor.show(true);
      if (editor.annotationElementId) {
        this.#uiManager.removeChangedExistingAnnotation(editor);
        annotationElementIds.add(editor.annotationElementId);
      }
    }
    if (!this.#annotationLayer) {
      return;
    }
    const editables = this.#annotationLayer.getEditableAnnotations();
    for (const editable of editables) {
      editable.hide();
      if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {
        continue;
      }
      if (annotationElementIds.has(editable.data.id)) {
        continue;
      }
      const editor = this.deserialize(editable);
      if (!editor) {
        continue;
      }
      this.addOrRebuild(editor);
      editor.enableEditing();
    }
  }
  disable() {
    this.#isDisabling = true;
    this.div.tabIndex = -1;
    this.togglePointerEvents(false);
    const changedAnnotations = new Map();
    const resetAnnotations = new Map();
    for (const editor of this.#editors.values()) {
      editor.disableEditing();
      if (!editor.annotationElementId) {
        continue;
      }
      if (editor.serialize() !== null) {
        changedAnnotations.set(editor.annotationElementId, editor);
        continue;
      } else {
        resetAnnotations.set(editor.annotationElementId, editor);
      }
      this.getEditableAnnotation(editor.annotationElementId)?.show();
      editor.remove();
    }
    if (this.#annotationLayer) {
      const editables = this.#annotationLayer.getEditableAnnotations();
      for (const editable of editables) {
        const {
          id
        } = editable.data;
        if (this.#uiManager.isDeletedAnnotationElement(id)) {
          continue;
        }
        let editor = resetAnnotations.get(id);
        if (editor) {
          editor.resetAnnotationElement(editable);
          editor.show(false);
          editable.show();
          continue;
        }
        editor = changedAnnotations.get(id);
        if (editor) {
          this.#uiManager.addChangedExistingAnnotation(editor);
          editor.renderAnnotationElement(editable);
          editor.show(false);
        }
        editable.show();
      }
    }
    this.#cleanup();
    if (this.isEmpty) {
      this.div.hidden = true;
    }
    const {
      classList
    } = this.div;
    for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {
      classList.remove(`${editorType._type}Editing`);
    }
    this.disableTextSelection();
    this.toggleAnnotationLayerPointerEvents(true);
    this.#isDisabling = false;
  }
  getEditableAnnotation(id) {
    return this.#annotationLayer?.getEditableAnnotation(id) || null;
  }
  setActiveEditor(editor) {
    const currentActive = this.#uiManager.getActive();
    if (currentActive === editor) {
      return;
    }
    this.#uiManager.setActiveEditor(editor);
  }
  enableTextSelection() {
    this.div.tabIndex = -1;
    if (this.#textLayer?.div && !this.#boundTextLayerPointerDown) {
      this.#boundTextLayerPointerDown = this.#textLayerPointerDown.bind(this);
      this.#textLayer.div.addEventListener("pointerdown", this.#boundTextLayerPointerDown, {
        signal: this.#uiManager._signal
      });
      this.#textLayer.div.classList.add("highlighting");
    }
  }
  disableTextSelection() {
    this.div.tabIndex = 0;
    if (this.#textLayer?.div && this.#boundTextLayerPointerDown) {
      this.#textLayer.div.removeEventListener("pointerdown", this.#boundTextLayerPointerDown);
      this.#boundTextLayerPointerDown = null;
      this.#textLayer.div.classList.remove("highlighting");
    }
  }
  #textLayerPointerDown(event) {
    this.#uiManager.unselectAll();
    if (event.target === this.#textLayer.div) {
      const {
        isMac
      } = util_FeatureTest.platform;
      if (event.button !== 0 || event.ctrlKey && isMac) {
        return;
      }
      this.#uiManager.showAllEditors("highlight", true, true);
      this.#textLayer.div.classList.add("free");
      HighlightEditor.startHighlighting(this, this.#uiManager.direction === "ltr", event);
      this.#textLayer.div.addEventListener("pointerup", () => {
        this.#textLayer.div.classList.remove("free");
      }, {
        once: true,
        signal: this.#uiManager._signal
      });
      event.preventDefault();
    }
  }
  enableClick() {
    if (this.#boundPointerdown) {
      return;
    }
    const signal = this.#uiManager._signal;
    this.#boundPointerdown = this.pointerdown.bind(this);
    this.#boundPointerup = this.pointerup.bind(this);
    this.div.addEventListener("pointerdown", this.#boundPointerdown, {
      signal
    });
    this.div.addEventListener("pointerup", this.#boundPointerup, {
      signal
    });
  }
  disableClick() {
    if (!this.#boundPointerdown) {
      return;
    }
    this.div.removeEventListener("pointerdown", this.#boundPointerdown);
    this.div.removeEventListener("pointerup", this.#boundPointerup);
    this.#boundPointerdown = null;
    this.#boundPointerup = null;
  }
  attach(editor) {
    this.#editors.set(editor.id, editor);
    const {
      annotationElementId
    } = editor;
    if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {
      this.#uiManager.removeDeletedAnnotationElement(editor);
    }
  }
  detach(editor) {
    this.#editors.delete(editor.id);
    this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
    if (!this.#isDisabling && editor.annotationElementId) {
      this.#uiManager.addDeletedAnnotationElement(editor);
    }
  }
  remove(editor) {
    this.detach(editor);
    this.#uiManager.removeEditor(editor);
    editor.div.remove();
    editor.isAttachedToDOM = false;
    if (!this.#isCleaningUp) {
      this.addInkEditorIfNeeded(false);
    }
  }
  changeParent(editor) {
    if (editor.parent === this) {
      return;
    }
    if (editor.parent && editor.annotationElementId) {
      this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);
      AnnotationEditor.deleteAnnotationElement(editor);
      editor.annotationElementId = null;
    }
    this.attach(editor);
    editor.parent?.detach(editor);
    editor.setParent(this);
    if (editor.div && editor.isAttachedToDOM) {
      editor.div.remove();
      this.div.append(editor.div);
    }
  }
  add(editor) {
    if (editor.parent === this && editor.isAttachedToDOM) {
      return;
    }
    this.changeParent(editor);
    this.#uiManager.addEditor(editor);
    this.attach(editor);
    if (!editor.isAttachedToDOM) {
      const div = editor.render();
      this.div.append(div);
      editor.isAttachedToDOM = true;
    }
    editor.fixAndSetPosition();
    editor.onceAdded();
    this.#uiManager.addToAnnotationStorage(editor);
    editor._reportTelemetry(editor.telemetryInitialData);
  }
  moveEditorInDOM(editor) {
    if (!editor.isAttachedToDOM) {
      return;
    }
    const {
      activeElement
    } = document;
    if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {
      editor._focusEventsAllowed = false;
      this.#editorFocusTimeoutId = setTimeout(() => {
        this.#editorFocusTimeoutId = null;
        if (!editor.div.contains(document.activeElement)) {
          editor.div.addEventListener("focusin", () => {
            editor._focusEventsAllowed = true;
          }, {
            once: true,
            signal: this.#uiManager._signal
          });
          activeElement.focus();
        } else {
          editor._focusEventsAllowed = true;
        }
      }, 0);
    }
    editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
  }
  addOrRebuild(editor) {
    if (editor.needsToBeRebuilt()) {
      editor.parent ||= this;
      editor.rebuild();
      editor.show();
    } else {
      this.add(editor);
    }
  }
  addUndoableEditor(editor) {
    const cmd = () => editor._uiManager.rebuild(editor);
    const undo = () => {
      editor.remove();
    };
    this.addCommands({
      cmd,
      undo,
      mustExec: false
    });
  }
  getNextId() {
    return this.#uiManager.getId();
  }
  get #currentEditorType() {
    return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());
  }
  get _signal() {
    return this.#uiManager._signal;
  }
  #createNewEditor(params) {
    const editorType = this.#currentEditorType;
    return editorType ? new editorType.prototype.constructor(params) : null;
  }
  canCreateNewEmptyEditor() {
    return this.#currentEditorType?.canCreateNewEmptyEditor();
  }
  pasteEditor(mode, params) {
    this.#uiManager.updateToolbar(mode);
    this.#uiManager.updateMode(mode);
    const {
      offsetX,
      offsetY
    } = this.#getCenterPoint();
    const id = this.getNextId();
    const editor = this.#createNewEditor({
      parent: this,
      id,
      x: offsetX,
      y: offsetY,
      uiManager: this.#uiManager,
      isCentered: true,
      ...params
    });
    if (editor) {
      this.add(editor);
    }
  }
  deserialize(data) {
    return AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;
  }
  createAndAddNewEditor(event, isCentered, data = {}) {
    const id = this.getNextId();
    const editor = this.#createNewEditor({
      parent: this,
      id,
      x: event.offsetX,
      y: event.offsetY,
      uiManager: this.#uiManager,
      isCentered,
      ...data
    });
    if (editor) {
      this.add(editor);
    }
    return editor;
  }
  #getCenterPoint() {
    const {
      x,
      y,
      width,
      height
    } = this.div.getBoundingClientRect();
    const tlX = Math.max(0, x);
    const tlY = Math.max(0, y);
    const brX = Math.min(window.innerWidth, x + width);
    const brY = Math.min(window.innerHeight, y + height);
    const centerX = (tlX + brX) / 2 - x;
    const centerY = (tlY + brY) / 2 - y;
    const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];
    return {
      offsetX,
      offsetY
    };
  }
  addNewEditor() {
    this.createAndAddNewEditor(this.#getCenterPoint(), true);
  }
  setSelected(editor) {
    this.#uiManager.setSelected(editor);
  }
  toggleSelected(editor) {
    this.#uiManager.toggleSelected(editor);
  }
  isSelected(editor) {
    return this.#uiManager.isSelected(editor);
  }
  unselect(editor) {
    this.#uiManager.unselect(editor);
  }
  pointerup(event) {
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    if (event.target !== this.div) {
      return;
    }
    if (!this.#hadPointerDown) {
      return;
    }
    this.#hadPointerDown = false;
    if (!this.#allowClick) {
      this.#allowClick = true;
      return;
    }
    if (this.#uiManager.getMode() === AnnotationEditorType.STAMP) {
      this.#uiManager.unselectAll();
      return;
    }
    this.createAndAddNewEditor(event, false);
  }
  pointerdown(event) {
    if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {
      this.enableTextSelection();
    }
    if (this.#hadPointerDown) {
      this.#hadPointerDown = false;
      return;
    }
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    if (event.target !== this.div) {
      return;
    }
    this.#hadPointerDown = true;
    const editor = this.#uiManager.getActive();
    this.#allowClick = !editor || editor.isEmpty();
  }
  findNewParent(editor, x, y) {
    const layer = this.#uiManager.findParent(x, y);
    if (layer === null || layer === this) {
      return false;
    }
    layer.changeParent(editor);
    return true;
  }
  destroy() {
    if (this.#uiManager.getActive()?.parent === this) {
      this.#uiManager.commitOrRemove();
      this.#uiManager.setActiveEditor(null);
    }
    if (this.#editorFocusTimeoutId) {
      clearTimeout(this.#editorFocusTimeoutId);
      this.#editorFocusTimeoutId = null;
    }
    for (const editor of this.#editors.values()) {
      this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
      editor.setParent(null);
      editor.isAttachedToDOM = false;
      editor.div.remove();
    }
    this.div = null;
    this.#editors.clear();
    this.#uiManager.removeLayer(this);
  }
  #cleanup() {
    this.#isCleaningUp = true;
    for (const editor of this.#editors.values()) {
      if (editor.isEmpty()) {
        editor.remove();
      }
    }
    this.#isCleaningUp = false;
  }
  render({
    viewport
  }) {
    this.viewport = viewport;
    setLayerDimensions(this.div, viewport);
    for (const editor of this.#uiManager.getEditors(this.pageIndex)) {
      this.add(editor);
      editor.rebuild();
    }
    this.updateMode();
  }
  update({
    viewport
  }) {
    this.#uiManager.commitOrRemove();
    this.#cleanup();
    const oldRotation = this.viewport.rotation;
    const rotation = viewport.rotation;
    this.viewport = viewport;
    setLayerDimensions(this.div, {
      rotation
    });
    if (oldRotation !== rotation) {
      for (const editor of this.#editors.values()) {
        editor.rotate(rotation);
      }
    }
    this.addInkEditorIfNeeded(false);
  }
  get pageDimensions() {
    const {
      pageWidth,
      pageHeight
    } = this.viewport.rawDims;
    return [pageWidth, pageHeight];
  }
  get scale() {
    return this.#uiManager.viewParameters.realScale;
  }
}


class DrawLayer {
  #parent = null;
  #id = 0;
  #mapping = new Map();
  #toUpdate = new Map();
  constructor({
    pageIndex
  }) {
    this.pageIndex = pageIndex;
  }
  setParent(parent) {
    if (!this.#parent) {
      this.#parent = parent;
      return;
    }
    if (this.#parent !== parent) {
      if (this.#mapping.size > 0) {
        for (const root of this.#mapping.values()) {
          root.remove();
          parent.append(root);
        }
      }
      this.#parent = parent;
    }
  }
  static get _svgFactory() {
    return shadow(this, "_svgFactory", new DOMSVGFactory());
  }
  static #setBox(element, {
    x = 0,
    y = 0,
    width = 1,
    height = 1
  } = {}) {
    const {
      style
    } = element;
    style.top = `${100 * y}%`;
    style.left = `${100 * x}%`;
    style.width = `${100 * width}%`;
    style.height = `${100 * height}%`;
  }
  #createSVG(box) {
    const svg = DrawLayer._svgFactory.create(1, 1, true);
    this.#parent.append(svg);
    svg.setAttribute("aria-hidden", true);
    DrawLayer.#setBox(svg, box);
    return svg;
  }
  #createClipPath(defs, pathId) {
    const clipPath = DrawLayer._svgFactory.createElement("clipPath");
    defs.append(clipPath);
    const clipPathId = `clip_${pathId}`;
    clipPath.setAttribute("id", clipPathId);
    clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
    const clipPathUse = DrawLayer._svgFactory.createElement("use");
    clipPath.append(clipPathUse);
    clipPathUse.setAttribute("href", `#${pathId}`);
    clipPathUse.classList.add("clip");
    return clipPathId;
  }
  highlight(outlines, color, opacity, isPathUpdatable = false) {
    const id = this.#id++;
    const root = this.#createSVG(outlines.box);
    root.classList.add("highlight");
    if (outlines.free) {
      root.classList.add("free");
    }
    const defs = DrawLayer._svgFactory.createElement("defs");
    root.append(defs);
    const path = DrawLayer._svgFactory.createElement("path");
    defs.append(path);
    const pathId = `path_p${this.pageIndex}_${id}`;
    path.setAttribute("id", pathId);
    path.setAttribute("d", outlines.toSVGPath());
    if (isPathUpdatable) {
      this.#toUpdate.set(id, path);
    }
    const clipPathId = this.#createClipPath(defs, pathId);
    const use = DrawLayer._svgFactory.createElement("use");
    root.append(use);
    root.setAttribute("fill", color);
    root.setAttribute("fill-opacity", opacity);
    use.setAttribute("href", `#${pathId}`);
    this.#mapping.set(id, root);
    return {
      id,
      clipPathId: `url(#${clipPathId})`
    };
  }
  highlightOutline(outlines) {
    const id = this.#id++;
    const root = this.#createSVG(outlines.box);
    root.classList.add("highlightOutline");
    const defs = DrawLayer._svgFactory.createElement("defs");
    root.append(defs);
    const path = DrawLayer._svgFactory.createElement("path");
    defs.append(path);
    const pathId = `path_p${this.pageIndex}_${id}`;
    path.setAttribute("id", pathId);
    path.setAttribute("d", outlines.toSVGPath());
    path.setAttribute("vector-effect", "non-scaling-stroke");
    let maskId;
    if (outlines.free) {
      root.classList.add("free");
      const mask = DrawLayer._svgFactory.createElement("mask");
      defs.append(mask);
      maskId = `mask_p${this.pageIndex}_${id}`;
      mask.setAttribute("id", maskId);
      mask.setAttribute("maskUnits", "objectBoundingBox");
      const rect = DrawLayer._svgFactory.createElement("rect");
      mask.append(rect);
      rect.setAttribute("width", "1");
      rect.setAttribute("height", "1");
      rect.setAttribute("fill", "white");
      const use = DrawLayer._svgFactory.createElement("use");
      mask.append(use);
      use.setAttribute("href", `#${pathId}`);
      use.setAttribute("stroke", "none");
      use.setAttribute("fill", "black");
      use.setAttribute("fill-rule", "nonzero");
      use.classList.add("mask");
    }
    const use1 = DrawLayer._svgFactory.createElement("use");
    root.append(use1);
    use1.setAttribute("href", `#${pathId}`);
    if (maskId) {
      use1.setAttribute("mask", `url(#${maskId})`);
    }
    const use2 = use1.cloneNode();
    root.append(use2);
    use1.classList.add("mainOutline");
    use2.classList.add("secondaryOutline");
    this.#mapping.set(id, root);
    return id;
  }
  finalizeLine(id, line) {
    const path = this.#toUpdate.get(id);
    this.#toUpdate.delete(id);
    this.updateBox(id, line.box);
    path.setAttribute("d", line.toSVGPath());
  }
  updateLine(id, line) {
    const root = this.#mapping.get(id);
    const defs = root.firstChild;
    const path = defs.firstChild;
    path.setAttribute("d", line.toSVGPath());
  }
  removeFreeHighlight(id) {
    this.remove(id);
    this.#toUpdate.delete(id);
  }
  updatePath(id, line) {
    this.#toUpdate.get(id).setAttribute("d", line.toSVGPath());
  }
  updateBox(id, box) {
    DrawLayer.#setBox(this.#mapping.get(id), box);
  }
  show(id, visible) {
    this.#mapping.get(id).classList.toggle("hidden", !visible);
  }
  rotate(id, angle) {
    this.#mapping.get(id).setAttribute("data-main-rotation", angle);
  }
  changeColor(id, color) {
    this.#mapping.get(id).setAttribute("fill", color);
  }
  changeOpacity(id, opacity) {
    this.#mapping.get(id).setAttribute("fill-opacity", opacity);
  }
  addClass(id, className) {
    this.#mapping.get(id).classList.add(className);
  }
  removeClass(id, className) {
    this.#mapping.get(id).classList.remove(className);
  }
  remove(id) {
    if (this.#parent === null) {
      return;
    }
    this.#mapping.get(id).remove();
    this.#mapping.delete(id);
  }
  destroy() {
    this.#parent = null;
    for (const root of this.#mapping.values()) {
      root.remove();
    }
    this.#mapping.clear();
  }
}

__webpack_exports__.AbortException;
__webpack_exports__.AnnotationEditorLayer;
__webpack_exports__.AnnotationEditorParamsType;
__webpack_exports__.AnnotationEditorType;
__webpack_exports__.AnnotationEditorUIManager;
__webpack_exports__.AnnotationLayer;
__webpack_exports__.AnnotationMode;
__webpack_exports__.CMapCompressionType;
__webpack_exports__.ColorPicker;
__webpack_exports__.DOMSVGFactory;
__webpack_exports__.DrawLayer;
__webpack_exports__.FeatureTest;
var __webpack_exports__GlobalWorkerOptions = __webpack_exports__.GlobalWorkerOptions;
__webpack_exports__.ImageKind;
__webpack_exports__.InvalidPDFException;
__webpack_exports__.MissingPDFException;
__webpack_exports__.OPS;
__webpack_exports__.Outliner;
__webpack_exports__.PDFDataRangeTransport;
__webpack_exports__.PDFDateString;
__webpack_exports__.PDFWorker;
__webpack_exports__.PasswordResponses;
__webpack_exports__.PermissionFlag;
__webpack_exports__.PixelsPerInch;
__webpack_exports__.RenderingCancelledException;
__webpack_exports__.TextLayer;
__webpack_exports__.UnexpectedResponseException;
__webpack_exports__.Util;
__webpack_exports__.VerbosityLevel;
__webpack_exports__.XfaLayer;
__webpack_exports__.build;
__webpack_exports__.createValidAbsoluteUrl;
__webpack_exports__.fetchData;
var __webpack_exports__getDocument = __webpack_exports__.getDocument;
__webpack_exports__.getFilenameFromUrl;
__webpack_exports__.getPdfFilenameFromUrl;
__webpack_exports__.getXfaPageViewport;
__webpack_exports__.isDataScheme;
__webpack_exports__.isPdfFile;
__webpack_exports__.noContextMenu;
__webpack_exports__.normalizeUnicode;
__webpack_exports__.renderTextLayer;
__webpack_exports__.setLayerDimensions;
__webpack_exports__.shadow;
__webpack_exports__.updateTextLayer;
__webpack_exports__.version;

/*global GmCXt,mg$*/


__webpack_exports__GlobalWorkerOptions.workerSrc =
	GmCXt.getBaseUrl('/common/pdfLibJS/pdf.worker.js');

let showMe = {
    ready: true,
    autoPlayNextStep: false,
    slideshowAutoplay: false
    // settings: getShowMeSettings()
};
// let navigationLock = false; // Prevent overlapping navigation
// let pendingDirection = null; // Queue pending navigation direction (e.g., 'prev' or 'next')


function updateShowMeSettings() {
    showMe.settings = getShowMeSettings();
}

function getShowMeSettings() {
    return {
        showMeSetting: GmCXt.getAppSetting('showMeSetting'),
        giphy: GmCXt.getAppSetting('giphy'),
        video: GmCXt.getAppSetting('video')
    };
}

GmCXt.imgThumLength = 5;

let invalidSegmentGuide = [];

let nextStepAutoPlayTimeout = null;

function showControl(selector) {
    mg$(selector).show();
}

function hideControl(selector) {
    mg$(selector).hide();
}

function show(selector) {
    mg$(selector).css("display", "block");
}

function hide(selector) {
    mg$(selector).css("display", "none");
}

function showIn(selector) {
    mg$(selector).css("display", "inline-block");
}

function showFlex(selector) {
    mg$(selector).css("display", "flex");
}

function showInlineFlex(selector) {
    mg$(selector).css("display", "inline-flex");
}

function disable(selector) {
    mg$(selector).css({
        "opacity": ".5",
        "pointer-events": "none"
    });
}

function reset(selector) {
    mg$(selector).css({
        "opacity": "",
        "pointer-events": ""
    });
}

function activate(selector) {
    mg$(selector).addClass('mgPlayerJSTest_showMe-player-active-mode');
}

function inactivate(selector) {
    mg$(selector).removeClass('mgPlayerJSTest_showMe-player-active-mode');
}

function removeStyle(selector) {
    mg$(selector).removeAttr("style");
}

function disableSlideshowAutoplay() {
    if (showMe.slideshowAutoplay === true) {

        showMe.slideshowAutoplay = false;
        showMe.autoPlayNextStep = false;

    }
}

function playModeView(selector) {
    if (!GmCXt.FT.audio) {
        hideControl(".mgPlayerJSTest_showMe-play-ctrl-audio");
    }

    if (selector === 'slideshow') {
        mg$('.mgPlayerJSTest_slideshow-main').css({
            "height": "calc(100% - 150px)"
        });

        if (window.matchMedia("(max-width: 480px)").matches && !GmCXt.isMiniPlayer) {
            mg$('.mgPlayerJSTest_slideshow-main').css({
                "height": "calc(100% - 17%)"
            });
        }

        mg$('.mgPlayerJSTest_iframe-wrapper-div').css({
            "height": "89%"
        });
    } else if (selector === 'video' || selector === 'gif' || selector === 'giphy') {
        mg$('.mgPlayerJSTest_slideshow-main').css({
            "height": "86%"
        });

        if (window.matchMedia("(max-width: 480px)").matches && !GmCXt.isMiniPlayer) {
            mg$('.mgPlayerJSTest_slideshow-main').css({
                "height": "calc(100% - 12%)"
            });
        }

        mg$('.mgPlayerJSTest_iframe-wrapper-div').css({
            "height": "92%"
        });
        disableSlideshowAutoplay();
    }
}

if (GmCXt.requestHandler === undefined) {
    GmCXt.requestHandler = {};
}

function hideSlideShowPlayer() {
    mg$('.mgPlayerJSTest_tour-player-panel').hide();
    hide('.mgPlayerJSTest_showMe-player-ctrl-container');
}

function showSlideShowPlayer() {
    updateShowMeSettings();

    GmCXt.increaseSidePanelWidth();
    mg$('.mgPlayerJSTest_ege-panel').css({
        'width': '500px',
        'right': '-9550px',
        'transition': 'width 0s'
    });

    mg$(".mgPlayerJSTest_slideshow-panel").css({
        "display": "block",
        "left": "50%"
    });
    mg$('.mgPlayerJSTest_tour-player-panel').show();
    show('.mgPlayerJSTest_showMe-player-ctrl-container');
    mg$('.mgPlayerJSTest_thumbnail-preview-wrapper').empty();
}

function getBulCount(el) {
    let length = mg$(el).find('li').length;
    mg$(el).find('li').each(function(i) {
        let braketValue = mg$(this).text().replace(/.*\{|\}/g, '');
        if (braketValue.indexOf(';') !== -1) {
            let o = braketValue.split(';')[1];
            if (o && o.trim() === 'optional') {
                length--;
            }
        }
    });
    return length;
}

function updateDropdown(li) {
    let val = mg$(li).find('select').val();
    mg$(li).find('select').remove();
    mg$(li).html(mg$(li).html() + val);

}

function updateTextarea(li) {
    let input = mg$(li).find('textarea');
    let val = mg$(input).val().trim();
    let optional = mg$(input).attr('optional');
    if (!val && optional === 'true') {
        mg$(li).remove();
        return;
    }

    if (val[val.length - 1] === '.') {
        val = val.substring(0, (val.length - 1));
    }

    mg$(li).find('textarea').remove();
    mg$(li).html(mg$(li).html() + val);
}

function updatePowerFormHtml() {

    mg$('.mgPlayerJSTest_form-injector-form').find('li').each(function() {
        let li = mg$(this).html();
        if (li.indexOf('<select') !== -1) {
            updateDropdown(this);
        } else if (li.indexOf('<textarea') !== -1) {
            updateTextarea(this);
        }
    });

    mg$('.mgPlayerJSTest_power-form-error').remove();
    mg$('.mgPlayerJSTest_form-injector-form-title').remove();

    let bulLength = mg$('.mgPlayerJSTest_form-injector-form').find('li').length;
    let text = mg$('.mgPlayerJSTest_form-injector-form').text().trim();
    if (bulLength === 1 && (text.toLowerCase() === 'yes' || text.toLowerCase() === 'no')) {
        mg$('.mgPlayerJSTest_form-injector-form').html(mg$('.mgPlayerJSTest_form-injector-form').text());
    }
}

function validate(input) {

    let max = mg$(input).attr('maxlength');
    max = parseInt(max);
    let val = mg$(input).val().length;
    if (val >= max) {
        mg$(input).next('.mgPlayerJSTest_power-form-error').show();
        if (val > max) return true;
    } else {
        mg$(input).next('.mgPlayerJSTest_power-form-error').hide();
        return false;
    }
}

function validateTextarea() {
    validate(this);
}

function validatePowerForm() {
    let valid = true;
    mg$('.mgPlayerJSTest_form-injector-form').find('li').each(function() {
        let li = mg$(this).html();
        if (li.indexOf('<textarea') !== -1) {
            let input = mg$(this).find('textarea');
            let val = mg$(input).val().trim();
            let optional = mg$(input).attr('optional');
            if ((!val && optional !== 'true') || validate(input)) {
                mg$(this).find('.mgPlayerJSTest_power-form-error').show();
                valid = false;
            }
        }
    });
    return valid;
}

function getOldVal(l) {
    let val = '';
    if (l && mg$(l).text().indexOf(':') !== -1) {
        val = mg$(l).text().substring(mg$(l).text().indexOf(':') + 1);
    } else {
        val = mg$(l).text();
    }

    return val;
}

function getDropDownHtml(r, l) {
    let oldValue = getOldVal(l);
    let dd = r.split('|');
    let html = "<select>";
    let selected = '';

    for (let i = 0; i < dd.length; i++) {
        if (oldValue && oldValue.replace(/\s/g, "").toLowerCase() === dd[i].replace(/\s/g, "").toLowerCase()) {
            selected = 'selected';
        } else {
            selected = '';
        }

        if (dd[i].length > 25) {
            var cliptxt = dd[i].slice(0, 25) + "...";
        } else {
            var cliptxt = dd[i];
        }
        html = html + "<option " + selected + " title ='" + dd[i] + "' value = '" + dd[i] + "' >" +
			cliptxt + "</option>";
    }

    return html + "</select>";
}

function getTextareaHtml(r, l) {
    let oldValue = getOldVal(l);
    let charCount = parseInt(r.split('char')[0]);
    let type = r.split(';')[1];
    let optional = false;
    if (type && type.trim() === 'optional') {
        optional = true;
    }
    let html = "<textarea optional='" + optional + "' maxlength='" + charCount + "'  value='" + oldValue + "' >" + oldValue + "</textarea>" +
		"<wmgPlayerJSTest_ class='mgPlayerJSTest_power-form-error'>" + GmCXt.label.powerFormMandatory + " " + charCount + " </wmgPlayerJSTest_>";

    return html;
}

function checkPreFilledData(he, v) {
    let oldBulLength = getBulCount(he);
    let newBulLength = getBulCount(v);
    let preFilled = false;

    if (oldBulLength >= newBulLength) {
        preFilled = true;
    }

    return preFilled;
}

function getFormHtml(he, v) {
    v = v.replace(/&nbsp;/gm, "");
    let oldText = mg$(he).text().trim().toLowerCase();
    let newBulLength = getBulCount(v);
    let preFilled = checkPreFilledData(he, v);
    let formHtml = '';
    mg$(v).find('li').each(function(i) {
        let label = mg$(this).text().replace(/{(.*?)}/g, '');
        let braketValue = mg$(this).text().replace(/.*\{|\}/g, '');
        let innerHtml = '';
        let oldLi = '';

        if (preFilled) {
            let breakLoop = false;
            mg$(he).find('li').each(function(j) {
                if (!breakLoop) {
                    let oldLabel = (mg$(this).text().indexOf(':') !== -1) ? mg$(this).text().split(':')[0] : '';
                    oldLabel = oldLabel.replace(/\s/g, "");

                    if (oldLabel && label.replace(/\s/g, "").indexOf(oldLabel) === 0) {
                        oldLi = mg$(he).find('li')[j];
                        breakLoop = true;
                    } else if (!oldLabel && !label) {
                        oldLi = mg$(he).find('li')[i];
                        breakLoop = true;
                    }
                }
            });
        }

        if (newBulLength === 1 && (oldText === 'yes' || oldText === 'no')) {
            oldLi = mg$(he);
        }

        if (braketValue.indexOf('|') !== -1) {
            innerHtml = getDropDownHtml(braketValue, oldLi);

        } else if (braketValue.indexOf('char') !== -1) {
            innerHtml = getTextareaHtml(braketValue, oldLi);
        }
        formHtml = formHtml + "<li>" + label + innerHtml + "</li>";
    });

    return formHtml;
}

function expandPowerForm() {
    if (mg$('.mgPlayerJSTest_form-injector-old-value-wrapper').css('display') === 'none') {
        mg$('.mgPlayerJSTest_form-injector-old-value-wrapper').css({
            "display": "inline-block"
        });
        mg$('.mgPlayerJSTest_form-injector-form').css({
            "width": "56%",
            "border-left": "1px solid #bdbdbd"
        });
        mg$('.mgPlayerJSTest_power-form-expand-icon').css({
            "transform": "rotate(180deg)"
        });
    } else {
        mg$('.mgPlayerJSTest_form-injector-old-value-wrapper').css({
            "display": "none"
        });
        mg$('.mgPlayerJSTest_form-injector-form').css({
            "width": "100%",
            "border-left": "none"
        });
        mg$('.mgPlayerJSTest_power-form-expand-icon').css({
            "transform": "rotate(0deg)"
        });
    }
}

function openPowerForm(data) {
    let he = data.he;
    let tag = data.tag;
    let value = data.value;
    let jobId = data.jobId;
    let step = data.step;
    let isPreview = data.isPreview;
    let powerFormLabel = GmCXt.label.powerFormNewData;
    if (!checkPreFilledData(he, value)) {
        powerFormLabel = powerFormLabel + "<br/><p class='mgPlayerJSTest_font-size-11'> " + GmCXt.label.powerFormNewDataMore + "</p>";
    }

    let html = "<wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-wrapper mgPlayerJSTest_form-injector-wrapper" + jobId + "'>" +
		"   <wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-wrapper-inner'>" +
		"   <wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-header'>" +
		"       <wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-title'>" + GmCXt.label.powerFormTitle + "</wmgPlayerJSTest_>" +
		"       <wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-brand-logo'>" + GmCXt.getPopupLogo() + "</wmgPlayerJSTest_>" +
		"   </wmgPlayerJSTest_>" +
		"       <wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-form-container'>" +
		"           <wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-old-value-wrapper'>" +
		"               <wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-old-value-title'>" + GmCXt.label.powerFormOldData + "</wmgPlayerJSTest_>" +
		"               <wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-old-value'>" + he + "</wmgPlayerJSTest_>" +
		"           </wmgPlayerJSTest_>" +
		"           <wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-form'>" +
		"               <wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-form-title'>" + powerFormLabel + "</wmgPlayerJSTest_>" +
		"               <ul>" + getFormHtml(he, value) + "</ul>" +
		"           </wmgPlayerJSTest_>" +
		"       </wmgPlayerJSTest_>" +
		"       <wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-btns'>" +
		"           <wmgPlayerJSTest_ class='mgPlayerJSTest_power-form-expand-icon'></wmgPlayerJSTest_>" +
		"           <wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-cancel mgPlayerJSTest_btn-default mgPlayerJSTest_btn-neutral'>" + GmCXt.label.btnCancel + " </wmgPlayerJSTest_>" +
		"           <wmgPlayerJSTest_ class='mgPlayerJSTest_form-injector-submit mgPlayerJSTest_btn-default'> " + GmCXt.label.btnSubmit + "</wmgPlayerJSTest_>" +
		"       </wmgPlayerJSTest_>" +
		"   </wmgPlayerJSTest_>" +
		" </wmgPlayerJSTest_>";

    mg$('.mgPlayerJSTest_form-injector-wrapper').remove();
    mg$("body").append(html);

    let logo = GmCXt.getBrandLogo();
    if (!logo) {
        mg$(".mgPlayerJSTest_form-injector-brand-logo").html(GmCXt.svgs.white_myguide_logo);
    }

    mg$(".mgPlayerJSTest_power-form-expand-icon").html(GmCXt.svgs.expand_power_form);

    mg$('.mgPlayerJSTest_form-injector-form li textarea').off('change keyup paste').on('change keyup paste', validateTextarea);
    mg$('.mgPlayerJSTest_power-form-expand-icon').off('click').on('click', expandPowerForm);
    mg$('.mgPlayerJSTest_form-injector-submit').off('click').on('click', function() {

        if (!validatePowerForm()) return;

        if (!isPreview && step) {
            GmCXt.updateTooltipActionInfo(step.tour_id, step.step_id, step.step_settings.smarttip, "submit");
        }

        updatePowerFormHtml();
        let formHtml = mg$('.mgPlayerJSTest_form-injector-form').html();
        let data = {
            he: he,
            tag: tag,
            formHtml: formHtml,
            forceInsert: true,
            jobId: jobId
        };
        GmCXt.sendMessageToAllWindows('mgPlayerJSTest_action:insert_power_html', data);
        GmCXt.closePowerForm();
    });

    mg$('.mgPlayerJSTest_form-injector-cancel').off('click').on('click', function() {
        if (!isPreview && step) {
            GmCXt.updateTooltipActionInfo(step.tour_id, step.step_id, step.step_settings.smarttip, "cancel");
        }
        GmCXt.closePowerFormSp();
    });
}

function getCustomImgName() {
    let name = 'mgPlayerJSTest_custom-image';
    return name;
}

function updatePlayStructure(tour) {

    let playStructure = GmCXt.getGuidePlayStructure(tour);

    GmCXt.playerI.playStructure = GmCXt.playerI.playStructure.concat(playStructure);
}

function getVideoHTML(videoURL, isNative) {
    let html = "";

    if (isNative) {
        html = "<video id='video-container' width='100%' disablePictureInPicture controls autoplay ";
        html += " class='mgPlayerJSTest_play-video-iframe' " + playAudio() + "> ";
        html += " <source src='" + videoURL + "' ";
        html += " type='video/mp4'  autostart='true'></video> ";
    } else {
        html = "<iframe class='mgPlayerJSTest_play-video-iframe' src='" + videoURL + "' ";
        html += " width='100%' title='Guideme video iframe'  height='100%' frameborder='0' allowfullscreen ></iframe> ";
    }

    return html;
}

function setVideoControls() {

    hide('.mgPlayerJSTest_showMe-player-ctrl-container');

    hide('.mgPlayerJSTest_slideshow-next-button');
    hide('.mgPlayerJSTest_slideshow-prev-button');

    mg$('.mgPlayerJSTest_slideshow-tour-title').text(GmCXt.playerI.title);
    mg$('.mgPlayerJSTest_slideshow-logo').attr('src', GmCXt.brandLogo());

    let html = getVideoHTML(GmCXt.playerI.video_url, true);

    mg$('.mgPlayerJSTest_iframe-wrapper-div').html(html);
}

GmCXt.requestHandler.playVideo = function(message) {

    setVideoControls();

    let video = document.getElementById('video-container');
    video.onended = function() {
        closeStep();
        GmCXt.requestHandler.videoAssignmentPlayed();
    };
};

function addSlidePlayerThumbnail(stepId, sList) {
    let steps, stepsLength, index;
    if (!stepId && sList) {
        if (GmCXt.branchStepExistInPS()) {
            steps = GmCXt.getStepSortedByPS(GmCXt.playerI.playStructure, GmCXt.playerI.currentStepId);
            stepId = GmCXt.playerI.currentStepId;
        } else {
            steps = sList;
        }
    } else {

        if (GmCXt.branchStepExistInPS() && stepId) {
            steps = GmCXt.getStepSortedByPS(GmCXt.playerI.playStructure, stepId);
        } else {
            steps = GmCXt.playerI.tour.steps;
        }
    }

    stepsLength = steps.length;

    steps.forEach(function(el, i) {
        if (el.step_id === GmCXt.playerI.currentStepId) {
            index = i;
        }
    });

    if (stepsLength > 5) {
        if (index >= GmCXt.imgThumLength) {
            stepsLength = index + 1;
        } else {
            stepsLength = GmCXt.imgThumLength;
        }
    }

    createThumbnail(stepId, stepsLength, steps);
}

function showSlideShowControls() {


    showControl('.mgPlayerJSTest_player-audio-controls');
    showControl('.mgPlayerJSTest_step-thumbnail-container');
    showControl('.mgPlayerJSTest_mode-slideshow');
    showControl('.mgPlayerJSTest_mode-giphy');
    showControl('.mgPlayerJSTest_mode-video');
    showControl('.mgPlayerJSTest_showMe-play-mode-autoplay-wrapper');
    showControl('.mgPlayerJSTest_showMe-play-mode-autoplay');
    if (GmCXt.containBranchStep(GmCXt.playerI.tour)) {
        hideControl('.mgPlayerJSTest_mode-video');
        hideControl('.mgPlayerJSTest_mode-giphy');
        hideControl('.mgPlayerJSTest_autoplay-option-checkbox');
        hideControl('.mgPlayerJSTest_showMe-play-mode-autoplay-wrapper');
        disableSlideshowAutoplay();
    }

    setShowMeOptions();
    showControl('.mgPlayerJSTest_resize-slideshow');
}

function hideShowControls() {
    showSlideShowControls();

    let mFiles = GmCXt.playerI.tour.media_files;
    if (!mFiles || mFiles[0] === undefined) {

        disable('.mgPlayerJSTest_mode-video');
        disable('.mgPlayerJSTest_mode-giphy');

    } else {

        if (mFiles[0].video && showMe.settings.video) reset('.mgPlayerJSTest_mode-video');
        else disable('.mgPlayerJSTest_mode-video');

        if (mFiles[0].gify && showMe.settings.giphy) reset('.mgPlayerJSTest_mode-giphy');
        else disable('.mgPlayerJSTest_mode-giphy');
    }
}

function attachThumbEvent() {

    mg$(document).off('click').on('click', '.slideshow-thumbnail-img', function(e) {

        GmCXt.playerI.currentStepId = mg$(this).attr('stepId');

        closeStep();
        playSlideshowStep();
        mg$('.slideshow-thumbnail').removeClass('mgPlayerJSTest_active-thumbnail');
        mg$(this).children().addClass('mgPlayerJSTest_active-thumbnail');
    });
}

GmCXt.requestHandler.playSlideshow = function(mode) {

    showSlideShowPlayer();
    GmCXt.stopAudio();

    showMe.autoPlayNextStep = false;
    showMe.slideshowAutoplay = false;

    loadSlideshowConstant();

    mg$("#mgPlayerJSTest_player-audio-controls-header").addClass('mgPlayerJSTest_display-none-imp');

    if (!GmCXt.playerI.playStructure || GmCXt.playerI.playStructure.length === 0) {
        GmCXt.playerI.playStructure = [];
        updatePlayStructure(GmCXt.playerI.tour);
    }

    hideShowControls();

    let sId = null;
    if (GmCXt.playerI.currentStepId)
        sId = GmCXt.playerI.currentStepId;


    if (sId) {
        let s = GmCXt.getStepFromPlayerI(sId);
        if (s.step_type !== GmCXt.STEP_TYPE_GUIDE) {
            addSlidePlayerThumbnail(sId);
        }
    }

    attachThumbEvent();

    if (showMe.slideshowAutoplay === true)
        showMe.autoPlayNextStep = true;
    else
        showMe.autoPlayNextStep = false;

    initSlideshowControls();

    GmCXt.tourPlayStarted = false;
    GmCXt.tourPlayCompleted = false;

    if (GmCXt.playerI.isAutolaunch) {
        GmCXt.setAutoTour(GmCXt.playerI.tour.tour_id);
    } else {
        GmCXt.setAutoTour(0);
    }

    GmCXt.isLastStepPlayedOnShowme = false;
    GmCXt.isVideoEndedOnShowme = false;
    GmCXt.isGiphyPlayedOnShowme = false;
    GmCXt.isVideoPlayedOnShowMe = false;

    switch (GmCXt.playerI.type) {
    case GmCXt.TOUR_PLAYER_SLIDESHOW:
        playSlideshowStep();
        break;

    case GmCXt.TOUR_PLAYER_VIDEO:
        playVideoStep();
        break;

    case GmCXt.TOUR_PLAYER_GIPHY:
        playGuideGiphy();
        break;
    }

    mg$(document).off('keydown').on('keydown', keydownEventListener);
    activeSlideshowThumbnail();

    GmCXt.getStepFromPlayerI(GmCXt.playerI.currentStepId);
    let currentThumPos = findIndex() + 1;
    mg$('.mgPlayerJSTest_thumbnail-preview-wrapper').scrollLeft(112 * (currentThumPos));
	
};

function initSlideshowControls() {

    GmCXt.playerI.totalStepCount = parseInt(GmCXt.playerI.tour.step_count);

    if (GmCXt.playerI.totalStepCount > 4) {
        reset('.mgPlayerJSTest_control-thumbnail-prev');
        reset('.mgPlayerJSTest_control-thumbnail-next');
    } else {
        disable('.mgPlayerJSTest_control-thumbnail-prev');
        disable('.mgPlayerJSTest_control-thumbnail-next');
    }

    showIn('.mgPlayerJSTest_slideshow-main');
    showIn('.mgPlayerJSTest_slideshow-next-button');
    showIn('.mgPlayerJSTest_slideshow-prev-button');

    show(".mgPlayerJSTest_tour-player-panel");

    mg$('.mgPlayerJSTest_slideshow-tour-title').text(GmCXt.playerI.tour.tour_title);
    mg$(".mgPlayerJSTest_slideshow-logo").attr('src', GmCXt.brandLogo());

    removeStyle('#mgPlayerJSTest_svg-prev-bg');
    removeStyle('#mgPlayerJSTest_svg-next-bg');
    removeStyle('#mgPlayerJSTest_svg-next-arrow');
    removeStyle('#mgPlayerJSTest_svg-prev-arrow');

}

function keydownEventListener(e) {

    if (e.which === 37) {
        playPreviousStep();

    } else if (e.which === 39) {
        playNextStep();

    } else if (e.which === 27) {
        // escape key pressed
        closeSlideshow();
    }
}

function loadSlideshowConstant() {
    mg$('.mgPlayerJSTest_slideshow-redirect-link').text(GmCXt.label.redirectLivetour);
    mg$(".mgPlayerJSTest_slideshow-image-spinner img").attr('src', GmCXt.loader());

    showIn('.mgPlayerJSTest_slideshow-main');
    showIn('.mgPlayerJSTest_slideshow-next-button');
    showIn('.mgPlayerJSTest_slideshow-prev-button');

    attachDOMEvents();
    attachStringConstant();
    attachSvgConstant();

}

function attachStringConstant() {
    mg$('.mgPlayerJSTest_popup-content-wrapper').html(GmCXt.label.guideNotAvailable);
    mg$('.mgPlayerJSTest_redirect-to-link-ok-btn').html(GmCXt.label.ok);

    mg$('.mgPlayerJSTest_label-in-app').html(GmCXt.label.inApp);
    mg$('.mgPlayerJSTest_label-video').html(GmCXt.label.video);
    mg$('.mgPlayerJSTest_label-giphy').html(GmCXt.label.giphy);
    mg$('.mgPlayerJSTest_label-slideshow').html(GmCXt.label.slideshow);
    mg$('.mgPlayerJSTest_label-live').html(GmCXt.label.live);
    mg$('#mgPlayerJSTest_btn-autoplay').html(GmCXt.label.autoplay);
    mg$('#mgPlayerJSTest_btn-autoplay-on').html(GmCXt.label.on);
    mg$('#mgPlayerJSTest_btn-autoplay-off').html(GmCXt.label.off);

}

function attachSvgConstant() {
    // mg$(".mgPlayerJSTest_resize-slideshow-maximize").html(GmCXt.svgs.slideshow_maximize);
    // mg$(".mgPlayerJSTest_resize-slideshow-minimize").html(GmCXt.svgs.slideshow_minimize);
    mg$(".mgPlayerJSTest_icon-close-slideshow").html(GmCXt.svgs.close_slideshow);
    mg$(".mgPlayerJSTest_icon-close-oops-msg").html(GmCXt.svgs.close_slideshow);
    mg$(".mgPlayerJSTest_icon-slideshow-prev-button").html(GmCXt.svgs.slideshow_prev_button);
    mg$(".mgPlayerJSTest_icon-slideshow-next-button").html(GmCXt.svgs.slideshow_next_button);
    mg$(".mgPlayerJSTest_control-icon-prev").html(GmCXt.svgs.slideshow_prev_button);
    mg$(".mgPlayerJSTest_control-icon-next").html(GmCXt.svgs.slideshow_next_button);
    mg$(".mgPlayerJSTest_playerbar-icon-slideshow-prev").html(GmCXt.svgs.playerbar_prev_button);
    mg$(".mgPlayerJSTest_playerbar-icon-slideshow-next").html(GmCXt.svgs.playerbar_next_button);
    mg$(".mgPlayerJSTest_btn-audio-mute").html(GmCXt.svgs.play_step_audio_off);
    mg$(".mgPlayerJSTest_btn-audio-unmute").html(GmCXt.svgs.play_step_audio_on);
    mg$(".mgPlayerJSTest_icon-mode-video").html(GmCXt.svgs.slideshow_video_mode);
    mg$(".mgPlayerJSTest_icon-mode-giphy").html(GmCXt.svgs.slideshow_giphy_mode);
    mg$(".mgPlayerJSTest_icon-mode-slideshow").html(GmCXt.svgs.slideshow_mode);
    mg$(".mgPlayerJSTest_icon-player-close").html(GmCXt.svgs.playerbar_close);
    mg$("#mgPlayerJSTest_zoom-in").html(GmCXt.svgs.add_icon);
    mg$("#mgPlayerJSTest_zoom-out").html(GmCXt.svgs.subtract_icon);
}

function attachDOMEvents() {

    mg$(".mgPlayerJSTest_slideshow-close").off('click').on("click", closeSlideshow);
    mg$(".mgPlayerJSTest_player-close").off('click').on("click", closeSlideshow);

    mg$(".mgPlayerJSTest_player-audio-controls").off('click').on("click", slideshowAudioIconClickEvent);

    mg$(".mgPlayerJSTest_mode-video").off('click').on("click", playVideoStep);
    mg$(".mgPlayerJSTest_mode-giphy").off('click').on("click", playGuideGiphy);
    mg$(".mgPlayerJSTest_mode-slideshow").off('click').on("click", playSlideshowStep);


    // Optional: Add click handler for the button if it’s not triggering the checkbox directly
    // mg$('#mgPlayerJSTest_custom-slider').on('click', function (e) {
    //   e.preventDefault(); // Prevent default button behavior
    //   let checkbox = mg$('#mgPlayerJSTest_slider-checkbox');
    //   checkbox.prop('checked', !checkbox.prop('checked')).trigger('change'); // Toggle state and fire 'change' event
    // });

    // jQuery click event to toggle checkbox state

    mg$('.mgPlayerJSTest_autoplay-custom-slider').on('click', function() {
        let checkbox = mg$('.mgPlayerJSTest_autoplay-slider-checkbox');
        checkbox.prop('checked', !checkbox.prop('checked')).trigger('change');
    });


    // Handle the 'change' event of the checkbox
    mg$('#mgPlayerJSTest_autoplay-slider-checkbox').on('change', function() {
        if (mg$(this).prop('checked')) {
            // If checked, perform the operation for ON state
            // Add your operation here, e.g., enabling autoplay
            if (showMe.videoPaused) {
                resumeVideoStep();
            } else {
                playSlideshowStep();
            }

            showMe.slideshowAutoplay = true;
            showMe.autoPlayNextStep = true;

        } else {

            pauseVideoStep();
            pauseAudio();

            showMe.slideshowAutoplay = false;
            showMe.autoPlayNextStep = false;
        }
    });

    mg$(".mgPlayerJSTest_slideshow-next-button").off('click').on("click", function(e) {
        playNextStep();
    });

    mg$(".mgPlayerJSTest_slideshow-prev-button").off('click').on("click", function(e) {
        playPreviousStep();
    });

    mg$(".mgPlayerJSTest_control-thumbnail-next").off('click').on("click", function() {
        playNextStep();
    });

    mg$("#mgPlayerJSTest_slideshow-popup-next-button").off('click').on("click", function() {
        playNextStep();
    });

    mg$(".mgPlayerJSTest_control-thumbnail-prev").off('click').on("click", function() {
        playPreviousStep();
    });

    mg$("#mgPlayerJSTest_slideshow-popup-prev-button").off('click').on("click", function() {
        playPreviousStep();
    });



    // mg$(".mgPlayerJSTest_resize-slideshow-maximize").off('click').on("click", function(e) {
    // 	resizeSlideshowWindow('full', true);
    // });

    // mg$(".mgPlayerJSTest_resize-slideshow-minimize").off('click').on("click", function(e) {
    // 	resizeSlideshowWindow('small', true);
    // });


}

function pauseVideoStep() {
    if (GmCXt.playerI) {
        let step = GmCXt.getStepFromPlayerI(GmCXt.playerI.currentStepId);

        if (step.step_type === GmCXt.STEP_TYPE_VIDEO) {
            showMe.videoPaused = true;
            let vid = document.getElementById("video-container");
            if (vid) {
                vid.pause();
            }
        }
    }
}

function resumeVideoStep() {
    let step = GmCXt.getStepFromPlayerI(GmCXt.playerI.currentStepId);

    if (step.step_type === GmCXt.STEP_TYPE_VIDEO) {
        let vid = document.getElementById("video-container");
        vid.play();
    }
}

function removeVideo() {
    mg$('.mgPlayerJSTest_iframe-wrapper-div').find('iframe').remove();

    if (mg$('.mgPlayerJSTest_iframe-wrapper-div').find('video').length)
        mg$('.mgPlayerJSTest_iframe-wrapper-div').find('video').remove();
}

function closeSlideshowActivities() {
    if (GmCXt.playerI) {
        let TS = GmCXt.playerI.tour.tour_settings;
        if (TS && TS.play_structure && TS.play_structure.length) {
            if (GmCXt.playerI.tour && GmCXt.playerI.tour.steps && GmCXt.playerI.tour.steps.length && GmCXt.playerI.tour.steps[0].step_id === TS.play_structure[0].id &&
				GmCXt.isLastStep(GmCXt.playerI.currentStepId, TS.play_structure)) {
                GmCXt.playerI.completeEventTracked = true;
            }
        }
    }

    trackSlideshowEvents(GmCXt.playerI.currentStepId);

    showMe.autoPlayNextStep = false;

    GmCXt.stopAudio();

    pauseVideoStep();
    pauseAudio();
    GmCXt.stopSlideshow();

    GmCXt.imgThumLength = 5;
    mg$('.mgPlayerJSTest_ege-panel').css({
        'width': '500px',
        'max-width': '500px',
        'transition': 'width 0s',
        'right': 'initial'
    });
}

function showExitSurveyShowMe() {
    let os = GmCXt.getOrgSettings();
    if (os && os.exitSentiment) {
        let data = {
            tour: GmCXt.playerI.tour,
            guideNotCompleted: true
        };
        GmCXt.showSurveyScreen(data, data.guideNotCompleted);
    }
}

function closeSlideshow(e) {
    Gm.slideState.set({});
    closeSlideshowActivities();

    if (GmCXt.playerI && GmCXt.isPlayer() && !GmCXt.playerI.giphyPlayed) {
        let nextStepinPS;
        let isLastStep = false;

        if (!GmCXt.isLastStep(GmCXt.playerI.currentStepId, GmCXt.playerI.playStructure)) {
            nextStepinPS = GmCXt.getTail(GmCXt.playerI.currentStepId, GmCXt.playerI.playStructure);
            isLastStep = GmCXt.isLastStep(nextStepinPS.step_id, GmCXt.playerI.playStructure);
		
            if ((!GmCXt.isVideoEndedOnShowme && GmCXt.playerI.type === GmCXt.TOUR_PLAYER_VIDEO) ||
				(nextStepinPS && GmCXt.playerI.type !== GmCXt.TOUR_PLAYER_VIDEO &&
					!isLastStep && nextStepinPS.step_type !== GmCXt.STEP_TYPE_SURVEY && nextStepinPS.step_type !== GmCXt.STEP_TYPE_ERROR_HANDLER) ||
				(!isLastStep && nextStepinPS && invalidSegmentGuide.indexOf(nextStepinPS.step_id) !== -1)) {
                showExitSurveyShowMe();
            }
        }
        invalidSegmentGuide = [];
    }

    if (GmCXt.FT.isPlayer) {
        const playedStep = GmCXt.getStepFromPlayerI(GmCXt.playerI.currentStepId);
        rootScope.setPlayedStepsInfo(playedStep);
    }
	
    GmCXt.tourPlayerI.closeGuide(false, true);

    mg$('.mgPlayerJSTest_panel').removeAttr('style');
    GmCXt.closeAppPanel();
    GmCXt.requestHandler.closeSlideshow();
    GmCXt.cleanPlayer();
}

GmCXt.stopSlideshow = function() {
    closeStep();
    GmCXt.reduceSidePanelWidth();
    mg$(".mgPlayerJSTest_slideshow-panel").css("display", "none");
};

function enableTab() {

    hide('.mgPlayerJSTest_slideshow-next-button');
    hide('.mgPlayerJSTest_slideshow-prev-button');

    showSlideShowControls();

    switch (GmCXt.playerI.type) {

    case GmCXt.TOUR_PLAYER_SLIDESHOW:
        enableSlideshow();
        break;

    case GmCXt.TOUR_PLAYER_VIDEO:
        enableVideo();
        break;

    case GmCXt.TOUR_PLAYER_GIPHY:
        enableGiphy();
        break;
    }

}

function showIframe() {

    removeVideo();

    mg$('.mgPlayerJSTest_iframe-wrapper-div').empty();

    show('.mgPlayerJSTest_iframe-wrapper-div');
}

function enableGiphy() {

    showIframe();

    disable('.mgPlayerJSTest_player-audio-controls');

    hide('.mgPlayerJSTest_slideshow-step-img-div');

    inactivate('.mgPlayerJSTest_mode-slideshow');
    inactivate('.mgPlayerJSTest_mode-video');

    activate('.mgPlayerJSTest_mode-giphy');

    hide('.mgPlayerJSTest_step-thumbnail-container');
    show('.mgPlayerJSTest_showMe-play-bar');

    hideControl('.mgPlayerJSTest_showMe-play-mode-autoplay-wrapper');

    playModeView('gif');
}

function enableVideo() {

    showIframe();

    disable('.mgPlayerJSTest_player-audio-controls');

    hide('.mgPlayerJSTest_slideshow-step-img-div');

    inactivate('.mgPlayerJSTest_mode-slideshow');
    inactivate('.mgPlayerJSTest_mode-giphy');

    activate('.mgPlayerJSTest_mode-video');

    hide('.mgPlayerJSTest_step-thumbnail-container');
    show('.mgPlayerJSTest_showMe-play-bar');

    hideControl('.mgPlayerJSTest_showMe-play-mode-autoplay-wrapper');

    playModeView('video');
}

function enableSlideshow() {
    removeVideo();

    activate('.mgPlayerJSTest_mode-slideshow');

    inactivate('.mgPlayerJSTest_mode-video');
    inactivate('.mgPlayerJSTest_mode-giphy');

    show('.mgPlayerJSTest_slideshow-next-button');
    show('.mgPlayerJSTest_slideshow-prev-button');

    reset('.mgPlayerJSTest_showMe-play-mode-autoplay');
    reset('.mgPlayerJSTest_player-audio-controls');

    showFlex('.mgPlayerJSTest_step-thumbnail-container');
    hide('.mgPlayerJSTest_showMe-play-bar');

    playModeView('slideshow');

    // if (mg$(".mgPlayerJSTest_resize-slideshow-minimize").is(":visible")) {
    // 	resizeSlideshowWindow('full', true);
    // }

    let step = GmCXt.getStepFromPlayerI(GmCXt.playerI.currentStepId);

    if (step !== undefined) {

        switch (step.step_type) {

        case GmCXt.STEP_TYPE_VIDEO:

            show('.mgPlayerJSTest_iframe-wrapper-div');
            hide('.mgPlayerJSTest_slideshow-step-img-div');

            disable('.mgPlayerJSTest_player-audio-controls');

            inactivate('.mgPlayerJSTest_mode-video');
            activate('.mgPlayerJSTest_mode-slideshow');
            inactivate('.mgPlayerJSTest_mode-giphy');

            mg$(".mgPlayerJSTest_iframe-wrapper-div").css({
                height: '98%'
            });
            break;

        default:

            hide('.mgPlayerJSTest_iframe-wrapper-div');
            show('.mgPlayerJSTest_slideshow-step-img-div');
            showIn('.mgPlayerJSTest_player-audio-controls');
            break;
        }
    }
    mg$('.mgPlayerJSTest_slideshow-step-img').attr('src', '').attr('alt', '');
}

function playVideoStep() {
    GmCXt.stopAudio();
    GmCXt.playerI.type = GmCXt.TOUR_PLAYER_VIDEO;

    const info = GmCXt.playerI.tour.media_files[0];

    if (info) {
        let videoUrl = "";
        let nativeVideo = false;

        if (info.video && info.video !== "0") {
            nativeVideo = true;
            videoUrl = info.video;
        }

        let orgVideoUrl = videoUrl + GmCXt.getCdnSign();

        videoUrl = GmCXt.getUrlWithLang(videoUrl);

        enableTab();

        GmCXt.checkAssetUrl(videoUrl, orgVideoUrl, function(url) {

            if (url) videoUrl = url;

            let html = getVideoHTML(videoUrl, nativeVideo);

            mg$('.mgPlayerJSTest_iframe-wrapper-div').html(html);

            if (!GmCXt.playerI.videoPlayed) {
                GmCXt.playerI.videoPlayed = true;
            }

            let videoId = document.getElementById('video-container');
            GmCXt.isVideoPlayedOnShowMe = true;
            GmCXt.isVideoEndedOnShowme = false;
            videoId.onended = function() {
                GmCXt.isVideoEndedOnShowme = true;
            };

        });
    }
}

GmCXt.getUrlWithLang = function(url) {

    let urlextstr = url.split(".");
    let urlExt = "." + urlextstr[urlextstr.length - 1];
    let urlFilename = url.replace(urlExt, "");
    let urlLang = "";
    let tempUrl = "";

    if (GmCXt.enableTranslation && GmCXt.language) {
        if (GmCXt.defaultLang) {
            urlFilename = urlFilename.replace("_" + GmCXt.defaultLang.language, "");
        }
        urlLang = "_" + GmCXt.language;
    }

    tempUrl = urlFilename + urlLang + urlExt + GmCXt.getCdnSign();

    return tempUrl;
};

function playGuideGiphy() {
    GmCXt.stopAudio();
    GmCXt.playerI.type = GmCXt.TOUR_PLAYER_GIPHY;

    enableTab();

    let showGif = function(src) {

        if (src) {
            infoSrc = src;
        }
        if (!GmCXt.onPrem()) {
            infoSrc += '&d="' + Date.now() + '"';
        }
        let html = "<img class='gif-item " + getCustomImgName() + "' src='" + infoSrc + "' alt='" + GmCXt.playerI.tour.tour_title + "' />";

        mg$('.mgPlayerJSTest_iframe-wrapper-div').empty().html(html);

        if (!GmCXt.playerI.giphyPlayed) {
            GmCXt.playerI.giphyPlayed = true;
        }

        GmCXt.isGiphyPlayedOnShowme = true;
    };

    if (GmCXt.playerI.tour.media_files[0]) {
        var infoSrc = GmCXt.playerI.tour.media_files[0].gify;

        let orgGifUrl = infoSrc + GmCXt.getCdnSign();

        infoSrc = GmCXt.getUrlWithLang(infoSrc);

        GmCXt.checkAssetUrl(infoSrc, orgGifUrl, showGif);
    }
}

function activeSlideshowThumbnail() {
    mg$('.slideshow-thumbnail').removeClass('mgPlayerJSTest_active-thumbnail');
    mg$('.slideshow-thumbnail.img-thumbnail-' + GmCXt.playerI.currentStepId).addClass('mgPlayerJSTest_active-thumbnail');
}

function playNextStep() {
    stepPlay("next");
}

function playLiveStep() {
    GmCXt.requestHandler.playGuide({});
}

function playPreviousStep() {
    stepPlay("previous");
}



function isCurrStepShowMe() {
    let step = GmCXt.getCurrentStep(GmCXt.playerI.currentStepId);
    if (step.step_settings.displayPreview !== true) {
        return true;
    } else if (GmCXt.playerI.linkGuidePlayMode && GmCXt.playerI.linkGuidePlayMode === "Show Me" &&
		GmCXt.playerI.linkedGuides && GmCXt.playerI.linkedGuides.includes(step.tour_id)) {
        return true;
    } else {
        return false;
    }
}


// Helper function to check if a step is valid for thumbnail creation
function isValidThumbnailStep(step) {
    return step &&
		step.step_type !== GmCXt.STEP_TYPE_SURVEY &&
		step.step_type !== GmCXt.STEP_TYPE_TRANSPORT &&
		step.step_type !== GmCXt.STEP_TYPE_ERROR_HANDLER;
}


function stepPlay(stepDir) {

    if (GmCXt.isEmpty(GmCXt.playerI) || GmCXt.isEmpty(GmCXt.playerI.tour) || GmCXt.isEmpty(GmCXt.playerI.tour.steps)) {
        return;
    }
    let stepID = null;
    let steps = GmCXt.playerI.tour.steps;
    let batchSize = 4; // load 4 thumbnails at a time
    let thumbsCreated = 0; // To track how many thumbnails are created in the batch

    let currentThumPos = findThumbIndex() + 1;
    if (showMe.ready === true && GmCXt.playerI) {

        if (stepDir === 'previous') {
            let prevStepsList = GmCXt.getPreviousStepsList(parseInt(GmCXt.playerI.currentStepId));
            if (prevStepsList && prevStepsList.length > 1) {
                for (let i = 0; i < prevStepsList.length; i++) {
                    if (mg$("#mgPlayerJSTest_slideshow-thumb-" + prevStepsList[i] + "") &&
						mg$("#mgPlayerJSTest_slideshow-thumb-" + prevStepsList[i] + "").length) {
                        stepID = prevStepsList[i];
                        break;
                    }

                }
            } else {
                stepID = GmCXt.getPreviousStepId(parseInt(GmCXt.playerI.currentStepId), 'slideshow');
            }
        } else {
            stepID = GmCXt.getTail(GmCXt.playerI.currentStepId, GmCXt.playerI.playStructure);
            GmCXt.markAutoLaunchTourDoNotShow(GmCXt.playerI.tour);
        }

        if (stepID) {
            showMe.ready = false;
            closeStep();

            GmCXt.playerI.currentStepId = stepID;
            var step = GmCXt.getStepFromPlayerI(stepID);
            if (GmCXt.isAutomationStep(step) || step.step_type === undefined) {
                showMe.ready = true;
                stepPlay(stepDir);
                return;
            }

            if (!isCurrStepShowMe() && GmCXt.playerI.mode === 'live') {

                closeSlideshowActivities();
                GmCXt.playerI.type = "live";
                playLiveStep();
                return;
            } else {
                var step = GmCXt.getStepFromPlayerI(stepID);
                if (step.step_type === GmCXt.STEP_TYPE_SURVEY || step.step_type === GmCXt.STEP_TYPE_ERROR_HANDLER) {
                    showMe.ready = true;
                    if (GmCXt.isLastStep(step.step_id, GmCXt.playerI.playStructure)) {
                        setPrevNextButtons(step);
                    } else {
                        stepPlay(stepDir);
                    }
                    return;
                } else if (step.step_type === GmCXt.STEP_TYPE_GUIDE) {
                    showMe.ready = true;
                    ({
                        tour_id: step.step_settings.tour_id
                    });

                    if (GmCXt.enableTranslation && GmCXt.language) {
                        if (!GmCXt.checkDefaultLangForTour(GmCXt.playerI.tour, GmCXt.language)) {
                            GmCXt.language;
                        }
                    }
                    mg$('#mgPlayerJSTest_spinner').addClass('show');
                    disable('.mgPlayerJSTest_slideshow-prev-button');
                    disable('.mgPlayerJSTest_control-thumbnail-prev');
                    disable('.mgPlayerJSTest_slideshow-next-button');
                    disable('.mgPlayerJSTest_control-thumbnail-next');
                    GmCXt.getSteps(data).then(function(_tour) {
                        let valid = !!_tour;
                        if (valid) {
                            invalidSegmentGuide.splice(invalidSegmentGuide.indexOf(step.step_id), 1);
                            playSlideshowStep();
                        } else {
                            removeSlideThum(step.step_id);
                            invalidSegmentGuide.push(step.step_id);
                            if (GmCXt.isLastStep(step.step_id, GmCXt.playerI.playStructure)) {
                                setPrevNextButtons(step);
                            } else {
                                stepPlay(stepDir);
                            }
                            mg$('#mgPlayerJSTest_spinner').removeClass('show');
                            return;
                        }
                    });

                } else {
                    playSlideshowStep();
                }
            }


            if (GmCXt.containBranchStep(GmCXt.playerI.tour)) {
                let t_ind = findIndex();
                if (stepDir === 'next' && GmCXt.imgThumLength !== parseInt(GmCXt.playerI.tour.step_count) &&
					steps[t_ind] && isValidThumbnailStep(steps[t_ind]) &&
					(currentThumPos === GmCXt.imgThumLength || (currentThumPos === 0 &&
						GmCXt.getPreviousStepId(parseInt(steps[t_ind].step_id)) === GmCXt.playerI.mergingFromId))) {
                    createSlideThum(steps[t_ind]);
                    GmCXt.imgThumLength += 1;
                }
            } else {
                // Create thumbnails when the position reaches the threshold for loading the next batch
                if (currentThumPos >= (GmCXt.imgThumLength - 4) && stepDir === 'next') {

                    for (let i = GmCXt.imgThumLength; i < GmCXt.imgThumLength + batchSize && i < steps.length; i++) {
                        let step = steps[i];

                        if (isValidThumbnailStep(step)) {
                            createSlideThum(step);
                            thumbsCreated++;
                        }

                        if (thumbsCreated >= batchSize) {
                            break;
                        }
                    }

                    // Update GmCXt.imgThumLength after batch creation
                    GmCXt.imgThumLength += thumbsCreated;
                }
            }
            activeSlideshowThumbnail();

            if (stepDir === 'previous' && step.step_type !== GmCXt.STEP_TYPE_BRANCH && currentThumPos <= GmCXt.imgThumLength-2)
                mg$('.mgPlayerJSTest_thumbnail-preview-wrapper').scrollLeft(mg$('.mgPlayerJSTest_thumbnail-preview-wrapper').scrollLeft() - mg$('.mgPlayerJSTest_thumbnail-preview').outerWidth(true));
            else if (stepDir === 'next' && currentThumPos >= 3)
                mg$('.mgPlayerJSTest_thumbnail-preview-wrapper').scrollLeft(mg$('.mgPlayerJSTest_thumbnail-preview-wrapper').scrollLeft() + mg$('.mgPlayerJSTest_thumbnail-preview').outerWidth(true));

            // if (mg$(".mgPlayerJSTest_resize-slideshow-minimize").is(":visible"))
            // 	resizeSlideshowWindow('full', true);
        }
    }
}

function playSlideshowStep() {
    GmCXt.playerI.type = GmCXt.TOUR_PLAYER_SLIDESHOW;
    enableTab();
    mg$('#mgPlayerJSTest_tooltipPopup').hide();
    let steps = GmCXt.playerI.tour.steps;

    function cb(newSteps) {

        if (!newSteps.length) {
            removeSlideThum(GmCXt.playerI.currentStepId);
            showMe.ready = true;
            playNextStep();
            return;
        }
        if (GmCXt.branchStepExistInPS()) {
            let id = '#mgPlayerJSTest_slideshow-thumb-' + GmCXt.playerI.currentStepId;
            mg$(id).nextAll('.slideshow-thumbnail-img').remove();
            removeSlideThum(GmCXt.playerI.currentStepId);
        }


        GmCXt.concatLinkGuideSteps(newSteps);

        GmCXt.playerI.currentStepId = GmCXt.playerI.linkGuideFS;

        GmCXt.playerI.tour.step_count;

        let steps = GmCXt.playerI.tour.steps;

        if (GmCXt.containBranchStep(GmCXt.playerI.tour)) {
            GmCXt.playerI.tour.tour_settings.play_structure = GmCXt.playerI.playStructure;
        }

        if (GmCXt.branchStepExist(GmCXt.playerI.tour)) {
            steps = GmCXt.getStepSortedByPS(GmCXt.playerI.playStructure, GmCXt.playerI.currentStepId);
        } else {
            steps = GmCXt.playerI.tour.steps;
        }

        addSlidePlayerThumbnail(undefined, steps);

        activeSlideshowThumbnail();

        playSlideStep();
    }

    function segmentCheckCB(steps, mainStepId) {
        if (GmCXt.isEmpty(steps)) {
            removeSlideThum(mainStepId);
            invalidSegmentGuide.push(step.step_id);
        }
        cb(steps);
        mg$('.mgPlayerJSTest_thumbnail-preview-wrapper').scrollLeft(mg$('.mgPlayerJSTest_thumbnail-preview-wrapper').scrollLeft() + mg$('.mgPlayerJSTest_thumbnail-preview').outerWidth(true));
        // if (mg$(".mgPlayerJSTest_resize-slideshow-minimize").is(":visible"))
        // 	resizeSlideshowWindow('full', true);
    }

    var step = GmCXt.getStepFromPlayerI(GmCXt.playerI.currentStepId);

    if (parseInt(step.step_order) === steps.length) {
        GmCXt.isLastStepPlayedOnShowme = true;
    }
    if (step.step_type === 'guide') {

        let d = {
            tour_id: step.step_settings.tour_id
        };

        if (GmCXt.enableTranslation && GmCXt.language) {
            if (!GmCXt.checkDefaultLangForTour(GmCXt.playerI.tour, GmCXt.language)) {
                d.language = GmCXt.language;
            }
        }

        if (GmCXt.apiPlayer) {
            d.forceJSONApi = true;
        }

        GmCXt.getSteps(d).then(function(_tour) {
            if (!_tour) {
                segmentCheckCB([], step.step_id);
            } else {
                GmCXt.checkGuidesBasedOnSegment([_tour], function(_t) {

                    if (!GmCXt.isEmpty(_t)) {
                        _tour.steps = GmCXt.filterOutAutomationSteps(_tour.steps);
                        GmCXt.updatePlayStructureLinkGuide(_tour);
                    } else {
                        _tour.steps = [];
                    }

                    segmentCheckCB(_tour.steps, step.step_id);

                });
            }
        });

    } else {
        playSlideStep();
    }
}

function playSlideVideo(step) {
    let videoUrl = step.step_video_url + GmCXt.getCdnSign();

    let playVid = function(url) {

        if (url) videoUrl = url;

        let html = getVideoHTML(videoUrl, true);

        mg$('.mgPlayerJSTest_iframe-wrapper-div').html(html);


        mg$('.mgPlayerJSTest_focus-controls-wrapper').addClass('mgPlayerJSTest_display-none');

        let vid = document.getElementById('video-container');

        vid.addEventListener('error', function(event) {
            GmCXt.toastMsg(GmCXt.label.unprocessedVideo).show();
            vid.controls = false;
            vid.removeEventListener('error', null, true);
        }, true);

        vid.onended = function() {

            if (GmCXt.isLastStep(step.step_id, GmCXt.playerI.playStructure)) {
                closeSlideshow();
            } else {
                GmCXt.timeout(function() {
                    if (showMe.autoPlayNextStep) {
                        playNextStep();
                    }
                }, 2000);
            }
        };
    };

    GmCXt.checkAssetUrl(videoUrl, videoUrl, playVid);
}

function playSlideBranch(step) {

    mg$('.mgPlayerJSTest_slideshow-thumb-' + step.step_id).nextAll('.slideshow-thumbnail-img').remove();
    mg$('#mgPlayerJSTest_spinner').removeClass('show');

    hideControl('.mgPlayerJSTest_slideshow-next-button');
    showControl(".mgPlayerJSTest_slideshow-branch-content");

    let branchButtons = '';
    let ss = step.step_settings;
    let branch = ss.branch;
    let PS = GmCXt.playerI.playStructure;
    let node = getNode(PS, step.step_id);

    mg$(".mgPlayerJSTest_slideshow-branch-heading-label").html(step.step_title);

    for (let i = 0; i < branch.length; i++) {
        let branchName = branch[i].branchName;
        let tail = node.branch[i].tail;
        branchButtons = branchButtons +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_slideshow-branch-btn mgPlayerJSTest_btn-default' tail=" + tail + ">" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_slideshow-branch-icon'>" +
			"</wmgPlayerJSTest_>" +
			"<label class='mgPlayerJSTest_slideshow-branch-label mgPlayerJSTest_line-clamp mgPlayerJSTest_line-clamp-1'>" + branchName + "</label>" +
			"</wmgPlayerJSTest_>";
    }

    mg$('.mgPlayerJSTest_slideshow-button-container').append(branchButtons);

    if (branch.length <= 1) {
        mg$('.mgPlayerJSTest_slideshow-button-container').addClass('mgPlayerJSTest_text-align-center');
    } else {
        mg$('.mgPlayerJSTest_slideshow-button-container').removeClass('mgPlayerJSTest_text-align-center');
    }

    disable('.mgPlayerJSTest_control-thumbnail-next');
    mg$(".mgPlayerJSTest_slideshow-branch-icon").html(GmCXt.svgs.branch_slideshow);
    addBranchButtonsListener();
    // Update the shared store to notify Svelte
    Gm.slideState.set({
        step,
        isImageUpdated: false
    });
}



function playSlideImage(step) {
    mg$('#mgPlayerJSTest_spinner').addClass('show');

    mg$('.mgPlayerJSTest_slideshow-step-img').off('load').on('load', function() {
        mg$('#mgPlayerJSTest_spinner').removeClass('show');
    });

    let cropFlag = false;


    let type = undefined;
    if (step.step_type === GmCXt.STEP_TYPE_INLINE) {
        type = GmCXt.STEP_TYPE_INLINE;
    }
    let slideImgURL = getImgURL(step, cropFlag, type);


    mg$('.mgPlayerJSTest_slideshow-step-img').addClass(getCustomImgName());

    mg$('.mgPlayerJSTest_slideshow-step-img').attr('alt', GmCXt.concatHTMLStringWithSpace(step.step_title)); // Apply the styles;

    // Update the shared store to notify Svelte
    Gm.slideState.set({
        step,
        isImageUpdated: true,
        slideImgURL
    });

}

function setPrevNextButtons(step) {

    reset('.mgPlayerJSTest_slideshow-prev-button');
    reset('.mgPlayerJSTest_slideshow-next-button');
    reset('.mgPlayerJSTest_control-thumbnail-prev');
    reset('.mgPlayerJSTest_control-thumbnail-next');

    if (step.step_type === GmCXt.STEP_TYPE_BRANCH) {
        disable('.mgPlayerJSTest_control-thumbnail-next');
    }

    let prevStepId = GmCXt.getPreviousStepId(parseInt(GmCXt.playerI.currentStepId));
    let prevStep = GmCXt.getStepFromPlayerI(prevStepId);

    if (GmCXt.isFirstNonAutomationStep() || (prevStep && (prevStep.step_type === GmCXt.STEP_TYPE_SURVEY || prevStep.step_type === GmCXt.STEP_TYPE_ERROR_HANDLER)) &&
		GmCXt.isFirstNonAutomationStep(prevStep.step_id)) {
        disable('.mgPlayerJSTest_slideshow-prev-button');
        disable('.mgPlayerJSTest_control-thumbnail-prev');
    }

    let nxtStepID = GmCXt.getTail(step.step_id, GmCXt.playerI.playStructure);
    let nxtStep = GmCXt.getStepFromPlayerI(nxtStepID);

    if (GmCXt.isLastStep(step.step_id, GmCXt.playerI.playStructure) ||
		(nxtStep && nxtStep.step_type === GmCXt.STEP_TYPE_SURVEY && nxtStep.step_type === GmCXt.STEP_TYPE_ERROR_HANDLER &&
			GmCXt.isLastStep(nxtStep.step_id, GmCXt.playerI.playStructure))) {

        disable('.mgPlayerJSTest_slideshow-next-button');
        disable('.mgPlayerJSTest_control-thumbnail-next');

        if (GmCXt.isFirstNonAutomationStep()) {
            disable('.mgPlayerJSTest_slideshow-prev-button');
            disable('.mgPlayerJSTest_control-thumbnail-prev');
        }
    }
}

function playStep(stepId) {
    clearTimeout(nextStepAutoPlayTimeout);
    nextStepAutoPlayTimeout = GmCXt.timeout(function() {
        if (showMe.autoPlayNextStep === true && GmCXt.playerI.currentStepId !== stepId) {
            playNextStep();
        }
    }, 5000);
}

function playAudioAndPlayNext(step, PI) {

    GmCXt.storage().get(['stepAudioRunningStatus']).then(function(items) {
        if (GmCXt.audioObject) GmCXt.audioObject.pause();

        let nextStepId = GmCXt.getTail(GmCXt.playerI.currentStepId, GmCXt.playerI.playStructure);

        // Play step audio by default or if user has switched on step audio
        // by clicking on the step audio icon.
        let audioT = "";

        let playSSAudio = function(url) {

            if (url) {
                audioT = url;
            }

            GmCXt.audioObject = new Audio(audioT);

            GmCXt.audioObject.onended = function() {

                if (!GmCXt.isLastStep(step.step_id, GmCXt.playerI.playStructure)) {
                    playStep(nextStepId);
                }
            };

            playAudioObject();

            GmCXt.stepAudioRunningStatus = true;

            showControl('.mgPlayerJSTest_btn-audio-unmute');
            hideControl('.mgPlayerJSTest_btn-audio-mute');
            mg$('.mgPlayerJSTest_player-audio-controls').addClass('playing-audio');
        };

        if (GmCXt.isDefined(step.step_audio) &&
			GmCXt.getAudioPreference(items.stepAudioRunningStatus)) {

            let message = {
                audioTrack: step.step_audio};
            audioT = message.audioTrack;

            if (audioT && audioT.indexOf(GmCXt.user.cdn_signature.split("=")[0]) === -1) {
                audioT = audioT + GmCXt.getCdnSign();
            }

            GmCXt.checkAssetUrl(audioT, audioT, playSSAudio);

        } else {

            playStep(nextStepId);

            GmCXt.stepAudioRunningStatus = false;

            hideControl('.mgPlayerJSTest_btn-audio-unmute');
            showControl('.mgPlayerJSTest_btn-audio-mute');
            mg$('.mgPlayerJSTest_player-audio-controls').removeClass('playing-audio');

        }
    });
}

function trackSlideshowEvents(step) {

    if (GmCXt.playerI && GmCXt.playerI.tour.tour_settings.segment_groups) {
        GmCXt.getTourSegmentDetail(GmCXt.playerI.tour);
    }

    if (GmCXt.playerI && GmCXt.playerI.taskObj && GmCXt.playerI.taskObj.taskId) {
        GmCXt.playerI.taskObj.taskId;
    }

    /*if (GmCXt.isVideoPlayedOnShowMe) {
		var isAudio = !mg$('#video-container').prop('muted');
		//GmCXt.trackerV1.trackGuideShowMe(GmCXt.playerI.tour, 'video', GmCXt.playerI.origin, isAudio, validSegments);

	}
	if (GmCXt.isGiphyPlayedOnShowme) {
		//GmCXt.trackerV1.trackGuideShowMe(GmCXt.playerI.tour, 'gif', GmCXt.playerI.origin, false, validSegments);

	}

	if ((!GmCXt.playerI.originalMode || GmCXt.playerI.origin) &&
		GmCXt.playerI.mode === 'slideshow') {
		//GmCXt.trackerV1.trackGuideShowMe(GmCXt.playerI.tour, 'ppt', GmCXt.playerI.origin, GmCXt.stepAudioRunningStatus, validSegments);
	}*/
}

function playSlideStep() {

    hideControl(".mgPlayerJSTest_slideshow-branch-content");
    mg$('.mgPlayerJSTest_slideshow-button-container').empty();
    enableTab();

    if (mg$('.mgPlayerJSTest_focus-controls-wrapper').hasClass("mgPlayerJSTest_display-none")) {
        mg$('.mgPlayerJSTest_focus-controls-wrapper').removeClass('mgPlayerJSTest_display-none');
    }

    // document.getElementById('mgPlayerJSTest_tooltipPopup').style.display = 'none';

    // if (mg$('#mgPlayerJSTest_tooltipPopup').length) {
    //   mg$('#mgPlayerJSTest_tooltipPopup').css('display', 'none');
    // }
    // if (mg$('#mgPlayerJSTest_howto-circle').length) {
    //   mg$('#mgPlayerJSTest_howto-circle').css('display', 'none');
    // }
    let step = GmCXt.getStepFromPlayerI(GmCXt.playerI.currentStepId);

    let nextStepId = GmCXt.getTail(GmCXt.playerI.currentStepId, GmCXt.playerI.playStructure);

    if (step === undefined) return;

    let stepType = step.step_type;

    if (stepType === GmCXt.STEP_TYPE_VIDEO)
        playSlideVideo(step);
    else if (stepType === GmCXt.STEP_TYPE_BRANCH || GmCXt.isTrue(step.step_settings.inlineBranch))
        playSlideBranch(step);
    else if (stepType === GmCXt.STEP_TYPE_SURVEY || stepType === GmCXt.STEP_TYPE_ERROR_HANDLER) {
        if (nextStepId) {
            GmCXt.playerI.currentStepId = nextStepId;
            playSlideStep();
        }
        return;
    } else {
        playSlideImage(step);
    }

    mg$('.mgPlayerJSTest_slideshow-step-title').text(step.step_title);

    step.step_description = GmCXt.updateOrgAndAddSignature(GmCXt.restoreAssetSrc(step.step_description));

    mg$('.mgPlayerJSTest_slideshow-step-desc').html(step.step_description);

    activeSlideshowThumbnail();

    if (stepType !== GmCXt.STEP_TYPE_VIDEO) {
        playAudioAndPlayNext(step, GmCXt.playerI);
    }
    GmCXt.trackStepEvent(step, "");
    setPrevNextButtons(step);

    GmCXt.playerI.lastStepStatus = 'success';
    showMe.ready = true;
}

function getImgURL(step, isCropped, type) {

    if (type === GmCXt.STEP_TYPE_BRANCH) {
        return GmCXt.conf.staticContentPath + "default_branch.png";
    }

    let imgURL = "";
    let screenurl;
    switch (type) {
    case GmCXt.STEP_TYPE_VIDEO:
        screenurl = step.image_url;
        break;
    case GmCXt.STEP_TYPE_INLINE:
        screenurl = step.thumbnail_url;
        break;

    case GmCXt.STEP_TYPE_MESSAGE:
        if (step.thumbnail_url.includes("default_icon")) {
            screenurl = step.thumbnail_url;
        } else {

            screenurl = step.screen_url;
        }

    default:
        if (step.screen_url) {
            screenurl = step.screen_url;
        } else if (step.step_screen_temp) {
            imgURL = step.step_screen_temp;
        }
        break;

    }

    if (!imgURL) {
        let filename = screenurl.substring(screenurl.lastIndexOf('/') + 1);
        let signext = filename.split('.');
        let ext = "";

        if (signext.length > 1) ext = signext[1].split('?');

        if (isCropped && (filename.indexOf('default_icon') === -1)) {
            let cropedfilename = signext[0] + "." + ext[0];
            imgURL = screenurl.replace(filename, cropedfilename);
        } else {
            let imgfilename = signext[0] + "." + ext[0];
            imgURL = screenurl.replace(filename, imgfilename);
        }

        imgURL += GmCXt.getCdnSign();
    }

    return imgURL;
}

function slideshowAudioIconClickEvent(e) {
    GmCXt.stopAudio();

    let step = GmCXt.getStepFromPlayerI(GmCXt.playerI.currentStepId);

    GmCXt.audioObject = new Audio(GmCXt.updateOrgAndAddSignature(GmCXt.restoreAssetSrc(step.step_audio)));

    // mg$('.mgPlayerJSTest_slideshow-audio img').attr('src', "");

    if (mg$('.mgPlayerJSTest_player-audio-controls').hasClass("playing-audio")) {
        GmCXt.audioObject.pause();
        mg$('.mgPlayerJSTest_player-audio-controls').removeClass('playing-audio');
        GmCXt.storage().set({
            'stepAudioRunningStatus': false
        });

        GmCXt.stepAudioRunningStatus = false;

        hideControl('.mgPlayerJSTest_btn-audio-unmute');
        showControl('.mgPlayerJSTest_btn-audio-mute');

    } else {

        playAudioObject();

        mg$('.mgPlayerJSTest_player-audio-controls').addClass('playing-audio');
        GmCXt.storage().set({
            'stepAudioRunningStatus': true
        });

        GmCXt.stepAudioRunningStatus = true;

        showControl('.mgPlayerJSTest_btn-audio-unmute');
        hideControl('.mgPlayerJSTest_btn-audio-mute');
    }
}

function closeStep() {

    GmCXt.stopAudio();
    // Close video
    removeVideo();
}

function playAudio() {
    if (!GmCXt.getGlobalAudioPrference() && !GmCXt.FT.audio) {
        return 'muted';
    }
    return '';
}

function setShowMeOptions() {

    if (showMe.settings.showMeSetting &&
		!GmCXt.containBranchStep(GmCXt.playerI.tour)
    ) {
        showInlineFlex('.mgPlayerJSTest_mode-video');
        if (!showMe.settings.giphy) {
            hide('.mgPlayerJSTest_mode-giphy');
        }
        if (!showMe.settings.video) {
            hide('.mgPlayerJSTest_mode-video');
        }
    } else {
        hide('.mgPlayerJSTest_mode-giphy');
        hide('.mgPlayerJSTest_mode-video');
    }
}

function playAudioObject() {
    let promise = GmCXt.audioObject.play();
    if (promise !== undefined) {
        promise.then(function() {
            // Autoplay started!
        }).catch(function() {
            // Autoplay was prevented.
        });
    }
}

function addBranchButtonsListener() {

    mg$(".mgPlayerJSTest_slideshow-branch-btn").on("click", function(e) {
        let nextStepId = e.currentTarget.getAttribute("tail");

        if (GmCXt.convertType(nextStepId)) {
            GmCXt.playerI.currentStepId = nextStepId;
            GmCXt.playerI.tour.steps;
            let nStep = GmCXt.getStepFromPlayerI(GmCXt.playerI.currentStepId);
            if (GmCXt.isLastStep(nStep.step_id, GmCXt.playerI.playStructure) && nStep.step_type === GmCXt.STEP_TYPE_SURVEY) {
                e.preventDefault();
                return;
            }

            mg$('.mgPlayerJSTest_slideshow-button-container').empty();
            hideControl(".mgPlayerJSTest_slideshow-branch-content");
            mg$(".mgPlayerJSTest_slideshow-branch-btn").off("click");

            showMe.ready = false;
            closeStep();

            if (nStep.step_type !== GmCXt.STEP_TYPE_GUIDE) {
                findIndex();
                addSlidePlayerThumbnail(nextStepId);
                mg$('.mgPlayerJSTest_thumbnail-preview-wrapper').scrollLeft(mg$('.mgPlayerJSTest_thumbnail-preview-wrapper').scrollLeft() + mg$('.mgPlayerJSTest_thumbnail-preview').outerWidth(true));
            }
            if (GmCXt.playerI.mode === 'live') {
                playLiveStep();
            } else {
                playSlideshowStep();
            }
        }

    });
}

function getNode(PS, stepID) {

    for (let i = 0; i < PS.length; i++) {
        if (PS[i].id === stepID)
            return PS[i];
    }
}

function createSlideThum(step) {

    let sid = "#mgPlayerJSTest_slideshow-thumb-" + step.step_id;
    if (step.step_type !== GmCXt.STEP_TYPE_SURVEY && mg$(sid).length === 0 && step.step_type !== GmCXt.STEP_TYPE_ERROR_HANDLER &&
		!(mg$("#mgPlayerJSTest_slideshow-thumb-" + step.step_id + "") &&
			mg$("#mgPlayerJSTest_slideshow-thumb-" + step.step_id + "").length)) {

        let slideImgURL = getImgURL(step, step.is_screen_url_processed, step.step_type);

        let thumbnail = "<button id='mgPlayerJSTest_slideshow-thumb-" + step.step_id + "' class='mgPlayerJSTest_thumbnail-preview mgPlayerJSTest_inline-block-vm mgPlayerJSTest_cursor-pointer slideshow-thumbnail-img mgPlayerJSTest_position-relative mgPlayerJSTest_slideshow-thumb-" + step.step_id + " mgPlayerJSTest_lbl-btn'" +
			" stepId='" + step.step_id + "'>" +
			// "<wmgPlayerJSTest_ class='mgPlayerJSTest_thumbnail-step-count mgPlayerJSTest_position-center'>Step 1</wmgPlayerJSTest_>" +
			"<img class='" + getCustomImgName() + " slideshow-thumbnail img-thumbnail-" + step.step_id +
			"' src=" + slideImgURL + " err-src='" + GmCXt.conf.staticContentPath + "technology.jpg'></button>";

        mg$('.mgPlayerJSTest_thumbnail-preview-wrapper').append(thumbnail);
    }
}

function removeSlideThum(id) {

    id = '#mgPlayerJSTest_slideshow-thumb-' + id;

    mg$(id).remove();

}

function createThumbnail(stepId, stepLength, steps) {
    if (stepId === undefined) mg$('.mgPlayerJSTest_thumbnail-preview-wrapper').empty();

    let currentStepCount = findIndex() + 1;
    let stepCountView = "<wmgPlayerJSTest_ class='mgPlayerJSTest_step-count-wrapper'><wmgPlayerJSTest_ class='mgPlayerJSTest_step-count'>Step " + currentStepCount + " of " + parseInt(GmCXt.playerI.tour.step_count) + "</wmgPlayerJSTest_></wmgPlayerJSTest_>";
    mg$('.mgPlayerJSTest_thumbnail-preview-wrapper').append(stepCountView);

    for (let i = 0; i < stepLength; i++) {
        if (steps[i] && invalidSegmentGuide.indexOf(steps[i].step_id) === -1) {
            createSlideThum(steps[i]);
        }
        if ((steps[i].step_type === GmCXt.STEP_TYPE_SURVEY || steps[i].step_type === GmCXt.STEP_TYPE_TRANSPORT ||
				steps[i].step_type === GmCXt.STEP_TYPE_ERROR_HANDLER) && stepLength < steps.length) {
            stepLength = stepLength + 1;
        }
    }
}

function findIndex() {
    let index = -1;
    GmCXt.playerI.tour.steps.forEach(function(el, i) {
        if (el.step_id === GmCXt.playerI.currentStepId) {
            index = i;
        }
    });
    return index;
}

function findThumbIndex() {
    let index = -1;
    let thumbs = mg$('.mgPlayerJSTest_thumbnail-preview');
    for (let i = 0; i < thumbs.length; i++) {
        if (thumbs[i].id === "mgPlayerJSTest_slideshow-thumb-" + GmCXt.playerI.currentStepId) {
            index = i;
        }
    }
    return index;
}

GmCXt.removeDuplicateGuides = function(tours) {
    let tId = [];
    tours = tours.filter(function(t) {
        if (tId.indexOf(t.tour_id) === -1) {
            tId.push(t.tour_id);
            return t;
        }
    });
    return tours;
};

GmCXt.removeDuplicateCategories = function(cats) {
    let cId = [];
    cats = cats.filter(function(c) {
        if (cId.indexOf(c.category_id) === -1) {
            cId.push(c.category_id);
            return c;
        }
    });
    return cats;
};

GmCXt.migrateTour = function(t) {

    if (t) {
        let s = t.tour_settings;

        // For versions < 1.2.5
        // smartTip property is removed in v1.2.5
        if (s.smartTip) {

            s.tour_url = s.smartTip.url;

            let e = 'matchUrl';
            if (s.smartTip.matchDomain) {
                e = 'matchDomain';
            }
            s.smartTipTriggerEvent = e;

            delete s.smartTip;
        }

        t.tour_settings = s;
    }

    return t;
};

function linkedGuidePSCheck(playStructure) {
    if (playStructure.length) {
        let ps = playStructure.filter(function(node) {
            return node.tail === null;
        });

        if (ps.length > 1) {
            return true;
        }
    }
    return false;
}

GmCXt.checkAndCorrectPS = function(tour) {

    if (!GmCXt.containBranchStep(tour)) {

        let tourSettings = GmCXt.parseJSON(tour.tour_settings);
        let playStructure = tourSettings.play_structure;

        if (!playStructure ||
			(Array.isArray(playStructure) &&
				(!playStructure.length || playStructure.length < tour.steps.length)) ||
			linkedGuidePSCheck(playStructure)
        ) {
            tourSettings.play_structure = GmCXt.buildGuidePlayStructure(tour);
            tour.tour_settings = tourSettings;
        }
    }

    return tour;
};

GmCXt.makeSlideshowFullScreen = function(data) {
    let playerType = ["slideshow", "video", "giphy"];
    if ((GmCXt.playerI && GmCXt.inArrayString(GmCXt.playerI.type, playerType)) || data.isPowerform) {
        if (data.size === 'full') {
            mg$(".mgPlayerJSTest_slideshow-panel").css({
                width: '100%',
                height: '100%',
                top: '0px',
                transform: 'translate(0,0)'
            });
            mg$(".mgPlayerJSTest_slideshow-panel").addClass('mgPlayerJSTest_slideshow-panel-left');
            mg$(".mgPlayerJSTest_slideshow-step-img").css({
                'top': '50%',
                'transform': 'translate(-50%,-50%)'
            });
        } else {
            mg$(".mgPlayerJSTest_slideshow-panel").css({
                width: '85%',
                height: '90%',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%,-50%)'
            });

            mg$(".mgPlayerJSTest_slideshow-panel").removeClass('mgPlayerJSTest_slideshow-panel-left');
            mg$(".mgPlayerJSTest_slideshow-step-img").css({
                'top': '50%',
                'transform': 'translate(-50%,-50%)'
            });
        }
    }
};


GmCXt.getPopUpHTML = function(url, isNative, title, desc, isVideoStep) {
    function htmlToPlaintext(text) {
        return text ? String(text).replace(/<[^>]+>/gm, '') : '';
    }

    let html = "<wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-container'></wmgPlayerJSTest_>" +
		"<wmgPlayerJSTest_ class='mgPlayerJSTest_video-panel' >" +
		"<wmgPlayerJSTest_ class='mgPlayerJSTest_video-panel-header'>" +
		"<wmgPlayerJSTest_ class='mgPlayerJSTest_video-panel-header-labels'>" +
		"<wmgPlayerJSTest_ class='mgPlayerJSTest_video-panel-header-title'>" +
		htmlToPlaintext(title) +
		"<wmgPlayerJSTest_ class='mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-right mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y'>" +
		"<wmgPlayerJSTest_ class='mgPlayerJSTest_tooltip-title'>" + htmlToPlaintext(title) + "</wmgPlayerJSTest_>" +
		"</wmgPlayerJSTest_>" +
		"</wmgPlayerJSTest_>" +
		"<wmgPlayerJSTest_ class='mgPlayerJSTest_video-panel-header-desc'>" +
		htmlToPlaintext(desc) +
		"<wmgPlayerJSTest_ class='mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-right mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y'>" +
		"<wmgPlayerJSTest_ class='mgPlayerJSTest_tooltip-title'>" + htmlToPlaintext(desc) + "</wmgPlayerJSTest_>" +
		"</wmgPlayerJSTest_>" +
		"</wmgPlayerJSTest_>" +
		"</wmgPlayerJSTest_>" +
		"<wmgPlayerJSTest_ class='mgPlayerJSTest_video-panel-controls'>";

    if (!isVideoStep) {
        html += "<wmgPlayerJSTest_ class='mgPlayerJSTest_video-panel-header-maximize'>" +
			"<button class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_audio-button-image mgPlayerJSTest_icons-hover-effect mgPlayerJSTest_inline-block-vm' aria-label='maximize image' >" +
			"<span>" +
			"</span>" +
			"</button>" +
			"</wmgPlayerJSTest_>";

        html += "<wmgPlayerJSTest_ class='mgPlayerJSTest_video-panel-header-maximize'>" +
			"<button class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_max-button-image mgPlayerJSTest_icons-hover-effect mgPlayerJSTest_inline-block-vm' aria-label='maximize image' >" +
			"<span>" +
			"</span>" +
			"</button>" +
			"</wmgPlayerJSTest_>";
    }

    html += "<wmgPlayerJSTest_ class='mgPlayerJSTest_video-panel-header-close'>" +
		"<button class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_close-button-video mgPlayerJSTest_icons-hover-effect mgPlayerJSTest_inline-block-vm' aria-label='close video player' >" +
		"<span>" +
		"</span>" +
		"</button>" +
		"</wmgPlayerJSTest_>" +
		"</wmgPlayerJSTest_>" +
		"</wmgPlayerJSTest_>";
    if (isVideoStep)
        html += GmCXt.getVideoPopUpIFrameHTML(url, isNative);
    else
        html += GmCXt.getImagePopUpIFrameHTML(url, isNative);

    html += GmCXt.getPopUpFooterHTML() + " </wmgPlayerJSTest_>";

    return html;
};

function addVideoPanelEvents(step, isVideoStep, data) {
    let os = GmCXt.getStepSettings();
    let popupDesign = os.popupDesign;
    let fullScreen = false;

    if (popupDesign) {
        if (popupDesign.type === 'default') {
            mg$('#mgPlayerJSTest_play_step_prev').removeClass('mgPlayerJSTest_popup-classic-design-navigation-prev');
            mg$('#mgPlayerJSTest_play_step_prev').addClass('mgPlayerJSTest_play-step-prev');
            mg$('#mgPlayerJSTest_play_step_next').removeClass('mgPlayerJSTest_popup-classic-navigation-next');
            mg$('#mgPlayerJSTest_play_step_next').addClass('mgPlayerJSTest_play-step-next');
        } else if (popupDesign.type === 'classic') {
            mg$('#mgPlayerJSTest_play_step_prev').removeClass('mgPlayerJSTest_play-step-prev');
            mg$('#mgPlayerJSTest_play_step_prev').addClass('mgPlayerJSTest_popup-classic-design-navigation-prev');
            mg$('#mgPlayerJSTest_play_step_next').removeClass('mgPlayerJSTest_play-step-next');
            mg$('#mgPlayerJSTest_play_step_next').addClass('mgPlayerJSTest_popup-classic-navigation-next');
        }
    }

    mg$('#mgPlayerJSTest_play_step_prev').css({
        "background-color": popupDesign.current.prevBtnBackground,
        "color": popupDesign.current.prevBtnColor,
        "border-color": popupDesign.current.prevBtnColor
    });

    mg$('#mgPlayerJSTest_play_step_prev svg path').css({
        "fill": popupDesign.current.prevBtnColor
    });

    mg$('#mgPlayerJSTest_play_step_next').css({
        "background-color": popupDesign.current.nextBtnBackground,
        "color": popupDesign.current.nextBtnColor,
        "border-color": popupDesign.current.nextBtnColor
    });

    mg$('#mgPlayerJSTest_play_step_next svg path').css({
        "fill": popupDesign.current.nextBtnColor
    });

    mg$(".mgPlayerJSTest_close-button-video").off("click").on("click", videoStepCloseEvent);
    mg$("#mgPlayerJSTest_play_step_prev").hide();

    if (isVideoStep) {

        let vid = document.getElementById('mgPlayerJSTest_step-video-container');

        vid.onpause = function() {
            mg$(".mgPlayerJSTest_video-iframe-overlay").html(GmCXt.svgs.icon_play_step);
        };

        vid.onplay = function() {
            mg$(".mgPlayerJSTest_video-iframe-overlay").html(GmCXt.svgs.icon_pause_step);
        };

        vid.onended = function() {
            if (GmCXt.isLastStep(step.step_id, GmCXt.playerI.playStructure)) {
                GmCXt.tourPlayerI.closeGuide(false, true);
            }
        };

        let videoEle = mg$('video#mgPlayerJSTest_step-video-container');

        if (step.step_settings.showFullScreen) {
            mg$(".mgPlayerJSTest_video-panel").css({
                "height": "100%",
                "width": "100%",
                "justify-content": "center"
            });
            mg$(".mgPlayerJSTest_video-panel-iframe-wrapper").css({
                "height": "100%",
                "width": "100%",
                "margin-left": "0"
            });

        }

        videoEle.bind('webkitfullscreenchange mozfullscreenchange fullscreenchange', function(e) {
            let fullScreen = document.fullScreen || document.mozFullScreen || document.webkitIsFullScreen;

            if (fullScreen) {
                videoEle.css({
                    "opacity": "1",
                    "border-width": "0px"
                });
            } else {
                videoEle.css({
                    "opacity": "",
                    "border-width": "1px"
                });
            }
        });
    } else {
        var data = {
            audioTrack: step.step_audio,
            step: step,
            playerInstance: GmCXt.playerI
        };
        if (GmCXt.playerI.playAudio && GmCXt.FT.audio) {
            GmCXt.playStepAudio(data);
        }

        mg$(".mgPlayerJSTest_max-button-image").off("click").on("click", function() {
            if (fullScreen) {
                mg$(".mgPlayerJSTest_video-panel").css({
                    "height": "650px",
                    "width": "850px"
                });
                mg$(".mgPlayerJSTest_play-video-iframe").css({
                    'height': '100%',
                    'width': '99%',
                });
                mg$(".mgPlayerJSTest_video-panel-iframe-wrapper").css({
                    'height': '70%',
                    'width': '92%',
                    'margin-left': '4%',
                });
                mg$(".mgPlayerJSTest_play-video-iframe").removeClass('mgPlayerJSTest_position-center');
                mg$(".mgPlayerJSTest_max-button-image span").html(GmCXt.svgs.fullscreen);
            } else {
                mg$(".mgPlayerJSTest_video-panel").css({
                    "height": "100%",
                    "width": "100%"
                });
                mg$(".mgPlayerJSTest_play-video-iframe").css({
                    'height': 'auto',
                    'width': 'auto',
                });
                mg$(".mgPlayerJSTest_video-panel-iframe-wrapper").css({
                    'height': '100%',
                    'width': '100%',
                    'margin-left': '0',
                });
                mg$(".mgPlayerJSTest_play-video-iframe").addClass('mgPlayerJSTest_position-center');
                mg$(".mgPlayerJSTest_max-button-image span").html(GmCXt.svgs.smallscreen);
            }
            fullScreen = !fullScreen;
        });
        mg$(".mgPlayerJSTest_audio-button-image").off("click").on("click", function() {
            if (GmCXt.playerI.playAudio) {
                mg$(".mgPlayerJSTest_audio-button-image span").html(GmCXt.svgs.play_step_audio_off);
                GmCXt.stopAudio();
            } else if (GmCXt.FT.audio) {
                mg$(".mgPlayerJSTest_audio-button-image span").html(GmCXt.svgs.play_step_audio_on);
                GmCXt.playStepAudio(data);
            }
            GmCXt.playerI.playAudio = !GmCXt.playerI.playAudio;
        });

    }

    let prevStep = GmCXt.getPreviousStepId(parseInt(GmCXt.playerI.currentStepId));

    if (prevStep !== null && data.prev_btn) {
        mg$("#mgPlayerJSTest_play_step_prev").show();
        mg$("#mgPlayerJSTest_play_step_prev").off("click").on("click", playPrevVideoStep);
    }

    if (GmCXt.isLastStep(step.step_id, GmCXt.playerI.playStructure)) {
        mg$("#mgPlayerJSTest_play_step_next").html(GmCXt.label.close);
        mg$("#mgPlayerJSTest_play_step_next").off("click").on("click", videoStepCloseEvent);
    } else {
        mg$("#mgPlayerJSTest_play_step_next").off("click").on("click", playNextVideoStep);
    }
}

function addVideoPanelSvgs() {
    mg$(".mgPlayerJSTest_close-button-video span").html(GmCXt.svgs.popup_close);
    mg$(".mgPlayerJSTest_video-iframe-overlay").html(GmCXt.svgs.icon_play_step);
    mg$(".mgPlayerJSTest_max-button-image span").html(GmCXt.svgs.fullscreen);
    if (GmCXt.playerI.playAudio)
        mg$(".mgPlayerJSTest_audio-button-image span").html(GmCXt.svgs.play_step_audio_on);
    else
        mg$(".mgPlayerJSTest_audio-button-image span").html(GmCXt.svgs.play_step_audio_off);
}

function playPrevVideoStep() {
    GmCXt.requestHandler.playTourPrevStep();
    GmCXt.increaseSidePanelWidth();
}

function playNextVideoStep() {
    GmCXt.requestHandler.playTourNextStep();
    GmCXt.increaseSidePanelWidth();
}

function videoStepCloseEvent(e) {
    let vid = document.getElementById('mgPlayerJSTest_step-video-container');
    if (vid)
        vid.pause();
    GmCXt.confirmTourClose();
}

GmCXt.getVideoPopUpIFrameHTML = function(videoURL) {
    let html = "<wmgPlayerJSTest_ class='mgPlayerJSTest_video-panel-iframe-wrapper'>";
    html += "<wmgPlayerJSTest_ class='mgPlayerJSTest_video-iframe-overlay'></wmgPlayerJSTest_>";
    html += "<video id='mgPlayerJSTest_step-video-container' width='100%' disablePictureInPicture controls autoplay controlsList='nodownload'" +
		" class='mgPlayerJSTest_play-video-iframe' > " +
		" <source src='" + videoURL + "' " +
		" type='video/mp4'  autostart='true'></video> ";
    html += "</wmgPlayerJSTest_>";

    return html;
};

GmCXt.getImagePopUpIFrameHTML = function(imageURL) {
    let html = "<wmgPlayerJSTest_ class='mgPlayerJSTest_video-panel-iframe-wrapper'>";
    html += "<img id='mgPlayerJSTest_step-image-container' width='100%' " +
		" class='mgPlayerJSTest_play-video-iframe' " +
		" src='" + imageURL + "'></img> ";
    html += "</wmgPlayerJSTest_>";

    return html;
};

GmCXt.getPopUpFooterHTML = function() {
    let os = GmCXt.getStepSettings();
    let popupDesign = os.popupDesign;
    let labelBtnPrev = (popupDesign.type === 'classic' ? GmCXt.label.btnPrevious : GmCXt.label.btnPrev);
    let iconBtnPrev = (popupDesign.type === 'classic' ? GmCXt.svgs.iconClassicNavPrev : "");
    let iconBtnNext = (popupDesign.type === 'classic' ? GmCXt.svgs.iconClassicNavNext : "");

    let as = GmCXt.getAppSetting();
    let organization = GmCXt.organization;

    if (organization && as) {
        var labelStepPopupNext = GmCXt.getAppSetting("userLabels").next;
        var labelStepPopupPrev = GmCXt.getAppSetting("userLabels").btnPrev;
    }

    let html = "<wmgPlayerJSTest_ class='mgPlayerJSTest_video-step-popup-footer mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-flex-end'>" +
		"<wmgPlayerJSTest_ class='mgPlayerJSTest_play-video-step-navigation mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-flex-end'>";

    if (GmCXt.playerI && GmCXt.playerI.tour && !GmCXt.playerI.tour.tour_settings.step_settings.hidePrevBtn) {
        html += "<button class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_play-step-prev mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center' id='mgPlayerJSTest_play_step_prev' aria-label='" + (labelStepPopupPrev ? labelStepPopupPrev : labelBtnPrev) + "' >" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center'>" + iconBtnPrev + "</wmgPlayerJSTest_>" +
			(labelStepPopupPrev ? labelStepPopupPrev : labelBtnPrev) +
			"</button>";
    }

    html += "<button class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_play-step-next mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center' id='mgPlayerJSTest_play_step_next' aria-label='" + (labelStepPopupNext ? labelStepPopupNext : GmCXt.label.next) + "' >" +
		(labelStepPopupNext ? labelStepPopupNext : GmCXt.label.next) +

		"<wmgPlayerJSTest_ class='mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center'>" + iconBtnNext + "</wmgPlayerJSTest_>" +
		"</button>" +
		"</wmgPlayerJSTest_>" +
		"</wmgPlayerJSTest_>";

    return html;
};

GmCXt.playStepInMyShowShell = function(isVideoStep, data) {
    mg$(window).focus();

    if (GmCXt.isEmpty(GmCXt.playerI)) return;
    let step = GmCXt.getCurrentStep(GmCXt.playerI.currentStepId);
    if (isVideoStep)
        var contentUrl = step.step_video_url + GmCXt.getCdnSign();
    else
        var contentUrl = step.screen_url;

    function play(url) {
        if (GmCXt.isEmpty(GmCXt.playerI)) return;
        if (url) contentUrl = url;
        let html = GmCXt.getPopUpHTML(contentUrl, true, step.step_title, step.step_description, isVideoStep);
        mg$("body").append(html);

        addVideoPanelSvgs();
        addVideoPanelEvents(step, isVideoStep, data);

        GmCXt.showNotificationHtml(false, true);

        GmCXt.timeout(function() {
            mg$(".mgPlayerJSTest_close-button-video").focus();
            if (GmCXt.accessibility) {
                mg$(".mgPlayerJSTest_play-video-step-navigation").addClass("mgPlayerJSTest_accessibility-theme");
                mg$("#mgPlayerJSTest_play_step_prev").addClass("mgPlayerJSTest_ass-default-btn");
                mg$("#mgPlayerJSTest_play_step_next").addClass("mgPlayerJSTest_ass-default-btn");
            }
        }, 500);
    }
    GmCXt.checkAssetUrl(contentUrl, contentUrl, play);
};

GmCXt.getPDFMediaPlayerIcons = function() {
    mg$(".mgPlayerJSTest_icon-popout-media-player").html(GmCXt.svgs.external_link_white);
    mg$(".mgPlayerJSTest_icon-close-media-player").html(GmCXt.svgs.close_media_popup);
    mg$(".mgPlayerJSTest_icon-print-media-player").html(GmCXt.svgs.print_icon);
    mg$(".mgPlayerJSTest_icon-min-media-player").html(GmCXt.svgs.min_pdf_icon);
    mg$(".mgPlayerJSTest_icon-max-media-player").html(GmCXt.svgs.max_pdf_icon);
    mg$(".mgPlayerJSTest_icon-page-down-media-player").html(GmCXt.svgs.page_down_icon);
    mg$(".mgPlayerJSTest_icon-page-up-media-player").html(GmCXt.svgs.page_up_icon);
    mg$(".mgPlayerJSTest_icon-pdf-download").html(GmCXt.svgs.pdf_download_icon);
};

GmCXt.showSurveyForTutorial = function(tour) {
    if (GmCXt.isPlayer() && tour && tour.tour_type.indexOf('onboarding_tour') !== -1 && tour.tour_settings.sentiment && !GmCXt.isEmpty(tour.tour_settings.sentiment.sentimentCode)) {
        let data = {
            tour: tour,
            guideNotCompleted: false
        };

        GmCXt.handleCloseApp();
		
        GmCXt.getSurveyScreen(data, data.guideNotCompleted);
    }
};

GmCXt.closeMediaPlayer = function(d, tour, taskObj) {
    let isTaskList = mg$('.mgPlayerJSTest_play-from-task-player').length > 0 ? true : false;

    let html = mg$('.mgPlayerJSTest_media-player-panel').html();
    mg$('.mgPlayerJSTest_media-player-panel').html('');
    mg$('.mgPlayerJSTest_media-player-panel').html(html);

    if (GmCXt.isDefined(GmCXt.trackerEnable)) GmCXt.trackerUtil = GmCXt.trackerEnable;

    let triggerSrc = "showme";
    let taskListId = null;
    if (isTaskList) {
        mg$('.mgPlayerJSTest_media-player-panel').removeClass('mgPlayerJSTest_play-from-task-player');
        triggerSrc = "task_list";
        if (taskObj && taskObj.taskId) {
            taskListId = taskObj.taskId;
        }
    }

    mg$('.mgPlayerJSTest_media-player-panel').hide();
    mg$('#mgPlayerJSTest_media-iframe').remove();
    mg$('#mgPlayerJSTest_media-video').remove();
    GmCXt.isMediaPlayerOn = false;
    mg$(".mgPlayerJSTest_preview-step-popup-container").removeClass("mgPlayerJSTest_preview-step-popup-container-mp");

    if (!(d && d.terminate) && !GmCXt.isEmpty(GmCXt.playerI) && GmCXt.playerI.linkGuidePlayMode === "PDF") {
        showMe.ready = true;
        delete GmCXt.playerI.linkGuidePlayMode;
        playNextStep();
    } else {

        GmCXt.showSurveyForTutorial(tour);

        if (GmCXt.isTutorialLink) {
            mg$(".mgPlayerJSTest_overlay-tours-popup").show();
            mg$(".mgPlayerJSTest_overlay-container").show();
        } else {
            GmCXt.reduceSidePanelWidth();
            mg$('.mgPlayerJSTest_ege-panel').css({
                'width': '500px',
                'right': '0px',
                'max-width': '500px',
                'transition': '0s'
            });
        }

        if (GmCXt.pdfPlayedOnUploadTut) {
            GmCXt.trackerV1.trackTutGuide(tour, "upload_tutorial_guide_same_tab", triggerSrc, taskListId);
        }
    }

    if (isTaskList) {
        GmCXt.handleCloseApp();
    }
    GmCXt.isTutorialLink = false;
};


GmCXt.addMediaPlayerEvent = function() {
    mg$("#mgPlayerJSTest_media-player-close").off('click').on("click", GmCXt.closeMediaPlayer);
};

GmCXt.hidePdfControls = function() {
    mg$('.mgPlayerJSTest_options-left').hide();
    mg$('#mgPlayerJSTest_pdf-canvas').hide();
    mg$('#mgPlayerJSTest_media-player-print').hide();
    mg$('#mgPlayerJSTest_media-player-popout').hide();
    mg$('#mgPlayerJSTest_icon-pdf-download').hide();
};
GmCXt.showPdfControls = function() {
    mg$('.mgPlayerJSTest_options-left').show();
    mg$('#mgPlayerJSTest_pdf-canvas').hide();
    mg$('#mgPlayerJSTest_media-player-print').show();
    mg$('#mgPlayerJSTest_media-player-popout').show();
    mg$('#mgPlayerJSTest_icon-pdf-download').show();
};

GmCXt.openPdfLinkStep = function(pdf_url) {
    let cb = function(assetUrl) {

        if (assetUrl) pdf_url = assetUrl;

        GmCXt.openPdf(pdf_url);
    };

    tempUrl = GmCXt.getUrlWithLang(pdf_url);

    pdf_url = pdf_url + GmCXt.getCdnSign();

    GmCXt.checkAssetUrl(tempUrl, pdf_url, cb);
};

GmCXt.openPdf = function(pdf_url, tour, taskObj) {
    GmCXt.trackerEnable = GmCXt.trackerUtil;
    mg$(".mgPlayerJSTest_preview-step-popup-container").addClass("mgPlayerJSTest_preview-step-popup-container-mp");
    GmCXt.isMediaPlayerOn = true;
    GmCXt.increaseSidePanelWidth();
    mg$('.mgPlayerJSTest_media-player-panel').show();
    mg$('#mgPlayerJSTest_media-iframe').remove();
    mg$('#mgPlayerJSTest_media-video').remove();
    mg$('#mgPlayerJSTest_pdf-container').css({
        'background': '#FFFFFF'
    });

    mg$(".mgPlayerJSTest_pdf-image-spinner").show();
    mg$(".mgPlayerJSTest_pdf-image-spinner img").attr('src', GmCXt.loader());
    GmCXt.hidePdfControls();

    let pageNum = 1;
    let pdfScale = 1; // make pdfScale a global variable
    let shownPdf; // another global we'll use for the buttons
    let url = pdf_url; // PDF to load: change this to a file that exists;

    function handelTutorialPDFControls() {
        let t = tour;

        if (!t) {
            if (GmCXt.playerI && GmCXt.playerI.tour) {
                t = GmCXt.playerI.tour;
            }
        }

        if (t) {
            let organization = GmCXt.organization;
            let admin_settings = organization.admin_settings;
            let downloadBtn = document.getElementById("mgPlayerJSTest_icon-pdf-download");
            let printbutton = document.getElementById("mgPlayerJSTest_media-player-print");

            if (admin_settings && admin_settings.mediafile_creation) {
                if (t.tour_settings && t.tour_settings.downloadGuideFiles &&
					!t.tour_settings.downloadGuideFiles.pdf_file) {
                    downloadBtn.style.display = "none";
                    printbutton.style.display = "none";
                }
            } else {
                downloadBtn.style.display = "none";
                printbutton.style.display = "none";
            }
        }
    }

    function renderPage(page) {
        let scale = pdfScale; // render with global pdfScale variable
        let viewport = page.getViewport({
            scale: scale
        });
        let canvas = document.getElementById('mgPlayerJSTest_pdf-canvas');
        let context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        let renderContext = {
            canvasContext: context,
            viewport: viewport
        };
        page.render(renderContext);

        mg$(".mgPlayerJSTest_pdf-image-spinner").attr('style', "display: none;");
        GmCXt.showPdfControls();
        canvas.style.display = "block";
        mg$(".mgPlayerJSTest_media-player-page-cnt-text")[0].innerHTML = page.pageNumber;
        handelTutorialPDFControls();
    }

    async function loadPdfDoc() {
        let loadingTask = __webpack_exports__getDocument({
            url: url
        });

        await loadingTask.promise.then(function getPdf(pdf) {
            mg$(".mgPlayerJSTest_media-player-page-cnt-text-total")[0].innerHTML = "of " + pdf._pdfInfo.numPages;
            mg$('.mgPlayerJSTest_media-player-zoom-text')[0].innerText = "100%";

            pdf.total_pages = pdf._pdfInfo.numPages;
            displayPage(pdf, 1);
            shownPdf = pdf;

        }).catch(function(e) {
            GmCXt.toastMsg(GmCXt.label.mediaFileNotFound).show();
            GmCXt.timeout(function() {
                GmCXt.closeMediaPlayer();
            }, 1000);
        });
        /*let pdfDoc = PDFJS.getDocument(url).then(function getPdf(pdf) {
			mg$(".mgPlayerJSTest_media-player-page-cnt-text-total")[0].innerHTML = "of " + pdf.numPages;
			mg$('.mgPlayerJSTest_media-player-zoom-text')[0].innerText = "100%";
			if (this.pdf) {
				this.pdf.destroy();
			}
			this.pdf = pdf;
			this.total_pages = this.pdf.numPages;
			displayPage(pdf, 1);
			shownPdf = pdf;

		}).catch(function(e) {
			GmCXt.toastMsg(GmCXt.label.mediaFileNotFound).show();
			GmCXt.timeout(function() {
				GmCXt.closeMediaPlayer();
			}, 1000);
		});*/
    }

    function displayPage(pdf, num) {

        if (parseInt(num) === parseInt(pdf._pdfInfo.numPages)) {
            GmCXt.fullPdfPlayedOnUploadTutGuide = true;
        }

        try {
            pdf.getPage(num).then(function getPage(page) {
                renderPage(page);
            });
        } catch (e) {
            pageNum = 1;
            loadPdfDoc();
        }

    }

    loadPdfDoc();

    const nextbutton = document.getElementById("mgPlayerJSTest_media-player-pd");
    nextbutton.onclick = function() {

        if (pageNum >= shownPdf.total_pages) {
            return;
        }
        pageNum++;
        displayPage(shownPdf, pageNum);
    };

    const prevbutton = document.getElementById("mgPlayerJSTest_media-player-pu");
    prevbutton.onclick = function() {
        if (pageNum <= 1) {
            return;
        }
        pageNum--;
        displayPage(shownPdf, pageNum);
    };

    const zoominbutton = document.getElementById("mgPlayerJSTest_max-media-player");
    zoominbutton.onclick = function() {
        pdfScale = pdfScale + 0.25;
        mg$('.mgPlayerJSTest_media-player-zoom-text')[0].innerText = (parseFloat(pdfScale) * 100) + "%";
        displayPage(shownPdf, pageNum);
    };

    const zoomoutbutton = document.getElementById("mgPlayerJSTest_min-media-player");
    zoomoutbutton.onclick = function() {
        if (pdfScale <= 0.25) {
            return;
        }
        pdfScale = pdfScale - 0.25;
        mg$('.mgPlayerJSTest_media-player-zoom-text')[0].innerText = (parseFloat(pdfScale) * 100) + "%";
        displayPage(shownPdf, pageNum);
    };

    function SaveToDisk(fileURL, fileName) {
        // for non-IE
        if (!window.ActiveXObject) {
            let save = document.createElement('a');
            save.href = fileURL;
            save.target = '_blank';
            save.download = fileName;

            const evt = new MouseEvent('click', {
                'view': window,
                'bubbles': true,
                'cancelable': false
            });
            save.dispatchEvent(evt);

            (window.URL || window.webkitURL).revokeObjectURL(save.href);
        }

        // for IE
        else if (!!window.ActiveXObject && document.execCommand) {
            let _window = window.open(fileURL, '_blank');
            _window.document.close();
            _window.document.execCommand('SaveAs', true, fileName);
            _window.close();
        }
    }

    const downloadBtn = document.getElementById("mgPlayerJSTest_icon-pdf-download");
    downloadBtn.onclick = function() {
        SaveToDisk(pdf_url, "myPdf.pdf");
    };

    const printbutton = document.getElementById("mgPlayerJSTest_media-player-print");
    printbutton.onclick = function() {
        printJS(pdf_url);
    };

    const popOutBtn = document.getElementById("mgPlayerJSTest_media-player-popout");
    popOutBtn.onclick = function() {
        let a = document.createElement('a');
        a.href = pdf_url;
        a.target = '_blank';
        a.click();
        a.remove();
    };

    GmCXt.getPDFMediaPlayerIcons();

    mg$("#mgPlayerJSTest_media-player-close").off('click').one("click", function() {
        GmCXt.closeMediaPlayer(undefined, tour, taskObj);
    });
    mg$(document).keyup(function(e) {
        if (e.key === "Escape") {
            GmCXt.closeMediaPlayer(undefined, tour, taskObj);
        }
    });
};

function getMPVideoHTML() {
    let html = "";

    html = "<video id='mgPlayerJSTest_media-video' width='99%' height='99%' frameborder='0' disablePictureInPicture controls autoplay > ";
    html += "</video> ";

    return html;
}

GmCXt.openVideoPlayer = function(video_url) {
    mg$(".mgPlayerJSTest_preview-step-popup-container").addClass("mgPlayerJSTest_preview-step-popup-container-mp");
    GmCXt.isMediaPlayerOn = true;

    GmCXt.increaseSidePanelWidth();
    mg$('.mgPlayerJSTest_ege-panel').css({
        'width': '500px',
        'right': '-9550px',
        'transition': '0s'
    });

    mg$("#mgPlayerJSTest_pdf-container").removeAttr("style");
    mg$('.mgPlayerJSTest_media-player-panel').show();
    mg$(".mgPlayerJSTest_icon-close-media-player").html(GmCXt.svgs.close_media_popup);
    mg$("#mgPlayerJSTest_media-player-close").off('click').on("click", GmCXt.closeMediaPlayer);
    mg$(".mgPlayerJSTest_pdf-image-spinner").show();
    mg$(".mgPlayerJSTest_pdf-image-spinner img").attr('src', GmCXt.loader());

    GmCXt.hidePdfControls();

    mg$('#mgPlayerJSTest_media-iframe').remove();
    mg$('#mgPlayerJSTest_media-video').remove();

    new URL(video_url);

    let videoHtml = getMPVideoHTML();
    mg$("#mgPlayerJSTest_pdf-container").append(videoHtml);

    mg$('#mgPlayerJSTest_media-video')[0].addEventListener('error', function() {
        GmCXt.toastMsg(GmCXt.label.mediaFileNotFound).show();
        GmCXt.timeout(function() {
            GmCXt.closeMediaPlayer();
        }, 1000);
    });
    mg$('#mgPlayerJSTest_media-video').attr('src', video_url);
    mg$('#mgPlayerJSTest_media-video')[0].load();

    GmCXt.timeout(function() {
        mg$(".mgPlayerJSTest_pdf-image-spinner").hide();
    }, 1000);
};

GmCXt.closePowerFormSp = function() {
    mg$('.mgPlayerJSTest_form-injector-wrapper').remove();
    GmCXt.stopSlideshow();
    mg$('.mgPlayerJSTest_ege-panel').css({
        'width': '500px',
        'max-width': '500px',
        'transition': 'width 0s'
    });
    GmCXt.handleCloseApp(true);
};

GmCXt.showPowerForm = function(data) {
    showSlideShowPlayer();
    hideSlideShowPlayer();
    openPowerForm(data);
};

GmCXt.removePowerForm = function() {
    if (mg$('.mgPlayerJSTest_form-injector-wrapper_' + message.data.step_id).length) {
        mg$('.mgPlayerJSTest_form-injector-wrapper_' + message.data.step_id).remove();
        GmCXt.closePowerFormSp();
    }
};

GmCXt.removeVideoPlayer = function() {
    mg$(".mgPlayerJSTest_overlay-container").remove();
    mg$(".mgPlayerJSTest_video-panel").remove();
    GmCXt.openSidePanelNotificaton();
};

/* src/components/SlideShow.svelte generated by Svelte v4.2.20 */

function add_css(target) {
	append_styles(target, "svelte-n59gq7", ".mgPlayerJSTest_autoplay-option-checkbox.svelte-n59gq7.svelte-n59gq7{display:flex;align-items:center;margin:5px;&:hover {\n\t\t\t& .mgPlayerJSTest_title-tooltip-wrapper {\n\t\t\t\tfont-weight: normal !important;\n\t\t\t\tdisplay: block !important;\n\t\t\t\ttop: 25px !important;\n\t\t\t}\n\t\t}}.mgPlayerJSTest_autoplay-custom-checkbox.svelte-n59gq7.svelte-n59gq7{position:relative;display:inline-block;width:40px;height:18px}input[type='checkbox'].svelte-n59gq7.svelte-n59gq7{opacity:0;width:0;height:0}.mgPlayerJSTest_autoplay-custom-slider.svelte-n59gq7.svelte-n59gq7{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;-webkit-transition:0.4s;transition:0.4s;width:36px;height:18px;border-radius:50px;background-color:#8e8fa6 !important;background-size:cover !important}.mgPlayerJSTest_autoplay-custom-slider.svelte-n59gq7.svelte-n59gq7::before{position:absolute;content:'';height:14px;width:14px;left:2px;bottom:2px;border-radius:50%;background-color:#ffffff !important;-webkit-transition:0.4s;transition:0.4s;background-size:cover}input[type='checkbox'].svelte-n59gq7:checked+.mgPlayerJSTest_autoplay-custom-slider.svelte-n59gq7{background-color:var(--mg-primary) !important}input[type='checkbox'].svelte-n59gq7:checked+.mgPlayerJSTest_autoplay-custom-slider.svelte-n59gq7::before{-webkit-transform:translateX(18px);-ms-transform:translateX(18px);transform:translateX(18px)}.mgPlayerJSTest_autoplay-text.svelte-n59gq7.svelte-n59gq7{font-size:16px;color:#333;font-weight:400;user-select:none}.mgPlayerJSTest_preview-step-popup-container.svelte-n59gq7.svelte-n59gq7{z-index:initial;position:absolute}");
}

// (522:2) {#if showZoomInError}
function create_if_block_3(ctx) {
	let wmgPlayerJSTest_;
	let t0_value = GmCXt.label.zoomIn + "";
	let t0;
	let t1;
	let span;
	let raw_value = GmCXt.svgs.close_slideshow + "";
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_zoom-error");
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_zoom-in-error");
			attr(wmgPlayerJSTest_, "role", "alertdialog");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t0);
			append(wmgPlayerJSTest_, t1);
			append(wmgPlayerJSTest_, span);
			span.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(span, "click", /*closeErrorAlert*/ ctx[25]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			dispose();
		}
	};
}

// (545:3) {#if showZoomOutError}
function create_if_block_2(ctx) {
	let wmgPlayerJSTest_;
	let t0_value = GmCXt.label.zoomOut + "";
	let t0;
	let t1;
	let span;
	let raw_value = GmCXt.svgs.close_slideshow + "";
	let mounted;
	let dispose;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			attr(wmgPlayerJSTest_, "class", "mgPlayerJSTest_zoom-error");
			attr(wmgPlayerJSTest_, "id", "zoom-out-error");
			attr(wmgPlayerJSTest_, "role", "alertdialog");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			append(wmgPlayerJSTest_, t0);
			append(wmgPlayerJSTest_, t1);
			append(wmgPlayerJSTest_, span);
			span.innerHTML = raw_value;

			if (!mounted) {
				dispose = listen(span, "click", /*closeErrorAlert*/ ctx[25]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}

			mounted = false;
			dispose();
		}
	};
}

// (563:5) {#if stepData?.step_description && stepData.step_description != ''}
function create_if_block_1(ctx) {
	let wmgPlayerJSTest_;
	let raw_value = /*stepData*/ ctx[8]?.step_description + "";

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "class", "step-desc");
			attr(wmgPlayerJSTest_, "style", /*stepDescStyle*/ ctx[14]);
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
			wmgPlayerJSTest_.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*stepData*/ 256 && raw_value !== (raw_value = /*stepData*/ ctx[8]?.step_description + "")) wmgPlayerJSTest_.innerHTML = raw_value;
			if (dirty[0] & /*stepDescStyle*/ 16384) {
				attr(wmgPlayerJSTest_, "style", /*stepDescStyle*/ ctx[14]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

// (591:3) {#if elementX && elementY && elementLength && elementHeight}
function create_if_block(ctx) {
	let wmgPlayerJSTest_;

	return {
		c() {
			wmgPlayerJSTest_ = element("wmgPlayerJSTest_");
			attr(wmgPlayerJSTest_, "id", "mgPlayerJSTest_howto-circle");
			set_style(wmgPlayerJSTest_, "left", /*elementX*/ ctx[3] + "px");
			set_style(wmgPlayerJSTest_, "top", /*elementY*/ ctx[4] + "px");
			set_style(wmgPlayerJSTest_, "width", /*elementLength*/ ctx[6] + "px");
			set_style(wmgPlayerJSTest_, "height", /*elementHeight*/ ctx[5] + "px");
			set_style(wmgPlayerJSTest_, "position", "absolute");
			set_style(wmgPlayerJSTest_, "border", "5px solid transparent");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*elementX*/ 8) {
				set_style(wmgPlayerJSTest_, "left", /*elementX*/ ctx[3] + "px");
			}

			if (dirty[0] & /*elementY*/ 16) {
				set_style(wmgPlayerJSTest_, "top", /*elementY*/ ctx[4] + "px");
			}

			if (dirty[0] & /*elementLength*/ 64) {
				set_style(wmgPlayerJSTest_, "width", /*elementLength*/ ctx[6] + "px");
			}

			if (dirty[0] & /*elementHeight*/ 32) {
				set_style(wmgPlayerJSTest_, "height", /*elementHeight*/ ctx[5] + "px");
			}
		},
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_);
			}
		}
	};
}

function create_fragment(ctx) {
	let wmgPlayerJSTest_46;
	let wmgPlayerJSTest_18;
	let wmgPlayerJSTest_0;
	let t0;
	let wmgPlayerJSTest_17;
	let wmgPlayerJSTest_4;
	let wmgPlayerJSTest_1;
	let wmgPlayerJSTest_1_class_value;
	let t1;
	let wmgPlayerJSTest_3;
	let t3;
	let wmgPlayerJSTest_8;
	let wmgPlayerJSTest_5;
	let wmgPlayerJSTest_5_class_value;
	let t4;
	let wmgPlayerJSTest_7;
	let t6;
	let wmgPlayerJSTest_11;
	let label0;
	let t8;
	let wmgPlayerJSTest_10;
	let wmgPlayerJSTest_9;
	let t10;
	let wmgPlayerJSTest_13;
	let t12;
	let wmgPlayerJSTest_16;
	let button2;
	let t13;
	let wmgPlayerJSTest_15;
	let wmgPlayerJSTest_14;
	let t15;
	let wmgPlayerJSTest_38;
	let t16;
	let wmgPlayerJSTest_19;
	let t17;
	let wmgPlayerJSTest_28;
	let img0;
	let img0_class_value;
	let img0_style_value;
	let img0_src_value;
	let t18;
	let t19;
	let wmgPlayerJSTest_24;
	let wmgPlayerJSTest_22;
	let wmgPlayerJSTest_21;
	let wmgPlayerJSTest_20;
	let raw_value = /*stepData*/ ctx[8]?.step_title + "";
	let t20;
	let t21;
	let wmgPlayerJSTest_23;
	let button3;
	let t22_value = GmCXt.label.btnPrev + "";
	let t22;
	let button3_hidden_value;
	let t23;
	let button4;

	let t24_value = (/*nextPopupButton*/ ctx[12] === false
	? GmCXt.label.close
	: GmCXt.label.next) + "";

	let t24;
	let wmgPlayerJSTest_24_class_value;
	let t25;
	let t26;
	let wmgPlayerJSTest_27;
	let wmgPlayerJSTest_28_class_value;
	let wmgPlayerJSTest_28_style_value;
	let t27;
	let button5;
	let t28;
	let button6;
	let t29;
	let wmgPlayerJSTest_33;
	let t32;
	let wmgPlayerJSTest_37;
	let t38;
	let wmgPlayerJSTest_43;
	let t41;
	let wmgPlayerJSTest_45;
	let mounted;
	let dispose;
	let if_block0 = /*showZoomInError*/ ctx[1] && create_if_block_3(ctx);
	let if_block1 = /*showZoomOutError*/ ctx[2] && create_if_block_2(ctx);
	let if_block2 = /*stepData*/ ctx[8]?.step_description && /*stepData*/ ctx[8].step_description != '' && create_if_block_1(ctx);
	let if_block3 = /*elementX*/ ctx[3] && /*elementY*/ ctx[4] && /*elementLength*/ ctx[6] && /*elementHeight*/ ctx[5] && create_if_block(ctx);

	return {
		c() {
			wmgPlayerJSTest_46 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_18 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_0.innerHTML = `<h3 class="mgPlayerJSTest_slideshow-tour-title mgPlayerJSTest_font-weight-normal mgPlayerJSTest_no-margin"></h3>`;
			t0 = space();
			wmgPlayerJSTest_17 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_4 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_1 = element("wmgPlayerJSTest_");
			t1 = space();
			wmgPlayerJSTest_3 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_3.innerHTML = `<wmgPlayerJSTest_ class="mgPlayerJSTest_tooltip-title">Zoom in</wmgPlayerJSTest_>`;
			t3 = space();
			wmgPlayerJSTest_8 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_5 = element("wmgPlayerJSTest_");
			t4 = space();
			wmgPlayerJSTest_7 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_7.innerHTML = `<wmgPlayerJSTest_ class="mgPlayerJSTest_tooltip-title">Zoom out</wmgPlayerJSTest_>`;
			t6 = space();
			wmgPlayerJSTest_11 = element("wmgPlayerJSTest_");
			label0 = element("label");
			label0.innerHTML = `<input class="mgPlayerJSTest_autoplay-user-pref-scope svelte-n59gq7" type="checkbox" id="mgPlayerJSTest_autoplay-slider-checkbox"/> <span class="mgPlayerJSTest_autoplay-custom-slider svelte-n59gq7"></span>`;
			t8 = space();
			wmgPlayerJSTest_10 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_9 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_9.textContent = `${GmCXt.label.autoplay}`;
			t10 = space();
			wmgPlayerJSTest_13 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_13.innerHTML = `<wmgPlayerJSTest_ class="mgPlayerJSTest_player-audio-controls mgPlayerJSTest_position-center"><button id="mgPlayerJSTest_btn-audio-mute" class="mgPlayerJSTest_lbl-btn mgPlayerJSTest_btn-audio-mute mgPlayerJSTest_cursor-pointer mgPlayerJSTest_display-none" aria-label="slideshow audio mute button"></button> <button id="mgPlayerJSTest_btn-audio-unmute" class="mgPlayerJSTest_lbl-btn mgPlayerJSTest_btn-audio-unmute mgPlayerJSTest_cursor-pointer" aria-label="slideshow audio unmute button"></button></wmgPlayerJSTest_>`;
			t12 = space();
			wmgPlayerJSTest_16 = element("wmgPlayerJSTest_");
			button2 = element("button");
			t13 = space();
			wmgPlayerJSTest_15 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_14 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_14.textContent = `${GmCXt.label.close}`;
			t15 = space();
			wmgPlayerJSTest_38 = element("wmgPlayerJSTest_");
			if (if_block0) if_block0.c();
			t16 = space();
			wmgPlayerJSTest_19 = element("wmgPlayerJSTest_");
			t17 = space();
			wmgPlayerJSTest_28 = element("wmgPlayerJSTest_");
			img0 = element("img");
			t18 = space();
			if (if_block1) if_block1.c();
			t19 = space();
			wmgPlayerJSTest_24 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_22 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_21 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_20 = element("wmgPlayerJSTest_");
			t20 = space();
			if (if_block2) if_block2.c();
			t21 = space();
			wmgPlayerJSTest_23 = element("wmgPlayerJSTest_");
			button3 = element("button");
			t22 = text(t22_value);
			t23 = space();
			button4 = element("button");
			t24 = text(t24_value);
			t25 = space();
			if (if_block3) if_block3.c();
			t26 = space();
			wmgPlayerJSTest_27 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_27.innerHTML = `<wmgPlayerJSTest_ class="mgPlayerJSTest_slideshow-spinner-outer"><wmgPlayerJSTest_ class="mgPlayerJSTest_slideshow-image-spinner"><img alt="slideshow spinner image"/></wmgPlayerJSTest_></wmgPlayerJSTest_>`;
			t27 = space();
			button5 = element("button");
			button5.innerHTML = `<span class="mgPlayerJSTest_icon-slideshow-prev-button mgPlayerJSTest_inline-block-vm mgPlayerJSTest_position-center"></span>`;
			t28 = space();
			button6 = element("button");
			button6.innerHTML = `<span class="mgPlayerJSTest_icon-slideshow-next-button mgPlayerJSTest_inline-block-vm mgPlayerJSTest_position-center"></span>`;
			t29 = space();
			wmgPlayerJSTest_33 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_33.innerHTML = `<wmgPlayerJSTest_><wmgPlayerJSTest_ class="mgPlayerJSTest_slideshow-step-num mgPlayerJSTest_inline-block-vm"></wmgPlayerJSTest_> <wmgPlayerJSTest_ class="mgPlayerJSTest_slideshow-step-title mgPlayerJSTest_inline-block-vm"></wmgPlayerJSTest_></wmgPlayerJSTest_> <wmgPlayerJSTest_ class="mgPlayerJSTest_slideshow-step-desc"></wmgPlayerJSTest_>`;
			t32 = space();
			wmgPlayerJSTest_37 = element("wmgPlayerJSTest_");

			wmgPlayerJSTest_37.innerHTML = `<wmgPlayerJSTest_ class="mgPlayerJSTest_slideshow-branch-heading"><label class="mgPlayerJSTest_slideshow-branch-heading-label mgPlayerJSTest_font-size-15">Select the <span class="mgPlayerJSTest_font-weight-600">Branch</span>
					that you want to play further</label></wmgPlayerJSTest_> <wmgPlayerJSTest_ class="mgPlayerJSTest_slideshow-branch-heading"><label class="mgPlayerJSTest_slideshow-branch-step-desc mgPlayerJSTest_font-size-15"></label></wmgPlayerJSTest_> <wmgPlayerJSTest_ class="mgPlayerJSTest_slideshow-button-container"></wmgPlayerJSTest_>`;

			t38 = space();
			wmgPlayerJSTest_43 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_43.innerHTML = `<wmgPlayerJSTest_ class="mgPlayerJSTest_popup-content-wrapper"><span class="mgPlayerJSTest_step-url"></span></wmgPlayerJSTest_> <wmgPlayerJSTest_ class="mgPlayerJSTest_popup-btn-wrapper"><wmgPlayerJSTest_ class="mgPlayerJSTest_redirect-to-link-ok-btn mgPlayerJSTest_ok-btn mgPlayerJSTest_btn-default mgPlayerJSTest_inline-block-vt"></wmgPlayerJSTest_> <wmgPlayerJSTest_ class="mgPlayerJSTest_redirect-to-link-cancel-btn mgPlayerJSTest_cancel-btn mgPlayerJSTest_btn-default mgPlayerJSTest_inline-block-vt"></wmgPlayerJSTest_></wmgPlayerJSTest_>`;
			t41 = space();
			wmgPlayerJSTest_45 = element("wmgPlayerJSTest_");
			wmgPlayerJSTest_45.innerHTML = `<button id="mgPlayerJSTest_btn-thumbnail-prev" class="mgPlayerJSTest_lbl-btn mgPlayerJSTest_control-thumbnail-prev mgPlayerJSTest_cursor-pointer mgPlayerJSTest_position-relative" aria-label="slideshow thumbnail previous button"><span class="mgPlayerJSTest_control-icon-prev mgPlayerJSTest_inline-block-vm mgPlayerJSTest_position-center"></span></button> <wmgPlayerJSTest_ id="mgPlayerJSTest_thumbnail-preview-wrapper" class="mgPlayerJSTest_thumbnail-preview-wrapper mgPlayerJSTest_width-100"></wmgPlayerJSTest_> <button id="mgPlayerJSTest_btn-thumbnail-next" class="mgPlayerJSTest_lbl-btn mgPlayerJSTest_control-thumbnail-next mgPlayerJSTest_cursor-pointer mgPlayerJSTest_position-relative" aria-label="slideshow thumbnail next button"><span class="mgPlayerJSTest_control-icon-next mgPlayerJSTest_inline-block-vm mgPlayerJSTest_position-center"></span></button>`;
			attr(wmgPlayerJSTest_0, "class", "mgPlayerJSTest_slideshow-header-left mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center");
			attr(wmgPlayerJSTest_1, "id", "mgPlayerJSTest_zoom-in");
			attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_zoom mgPlayerJSTest_cursor-pointer mgPlayerJSTest_focus-controls-wrapper " + (/*showFocusWrapper*/ ctx[9] ? '' : 'mgPlayerJSTest_display-none'));
			attr(wmgPlayerJSTest_3, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left");
			attr(wmgPlayerJSTest_4, "class", "mgPlayerJSTest_btn-zoom-in-wrapper mgPlayerJSTest_position-relative");
			attr(wmgPlayerJSTest_5, "id", "mgPlayerJSTest_zoom-out");
			attr(wmgPlayerJSTest_5, "class", wmgPlayerJSTest_5_class_value = "mgPlayerJSTest_zoom mgPlayerJSTest_cursor-pointer mgPlayerJSTest_focus-controls-wrapper " + (/*showFocusWrapper*/ ctx[9] ? '' : 'mgPlayerJSTest_display-none'));
			attr(wmgPlayerJSTest_7, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left");
			attr(wmgPlayerJSTest_8, "class", "mgPlayerJSTest_btn-zoom-out-wrapper mgPlayerJSTest_position-relative");
			attr(label0, "class", "mgPlayerJSTest_autoplay-custom-checkbox svelte-n59gq7");
			attr(wmgPlayerJSTest_9, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_10, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left");
			attr(wmgPlayerJSTest_11, "class", "mgPlayerJSTest_autoplay-option-checkbox mgPlayerJSTest_autoplay-cursor-pointer mgPlayerJSTest_position-relative svelte-n59gq7");
			attr(wmgPlayerJSTest_13, "class", "mgPlayerJSTest_showMe-play-ctrl-audio mgPlayerJSTest_position-relative");
			attr(button2, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_icon-close-slideshow mgPlayerJSTest_inline-block-vm");
			attr(button2, "aria-label", "slideshow close button");
			attr(wmgPlayerJSTest_14, "class", "mgPlayerJSTest_tooltip-title");
			attr(wmgPlayerJSTest_15, "class", "mgPlayerJSTest_title-tooltip-wrapper mgPlayerJSTest_position-bottom-left");
			attr(wmgPlayerJSTest_16, "class", "mgPlayerJSTest_inline-block-vm mgPlayerJSTest_slideshow-close mgPlayerJSTest_position-relative");
			attr(wmgPlayerJSTest_17, "class", "mgPlayerJSTest_slideshow-header-right mgPlayerJSTest_display-flex mgPlayerJSTest_display-inline-flex mgPlayerJSTest_align-items-center");
			attr(wmgPlayerJSTest_18, "class", "mgPlayerJSTest_slideshow-header mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-between mgPlayerJSTest_padding-15");
			attr(wmgPlayerJSTest_19, "class", "mgPlayerJSTest_iframe-wrapper-div");
			attr(img0, "id", "mgPlayerJSTest_slide-img");

			attr(img0, "class", img0_class_value = "" + (null_to_empty(`${/*notScaleStep*/ ctx[19]
			? 'mgPlayerJSTest_slideshow-step-img'
			: 'mgPlayerJSTest_slideshow-step-img-inline'}`) + " svelte-n59gq7"));

			attr(img0, "style", img0_style_value = /*notScaleStep*/ ctx[19]
			? 'top: 50%; transform: translate(-50%, -50%);'
			: `transition: ${/*scale*/ ctx[0] > /*minScale*/ ctx[7] ? '1s' : 'unset'}; z-index: -1; transform-origin: 0px 0px; transform: translate(${/*removeImageStyle*/ ctx[20]
				? '0,0'
				: `calc(-50% * ${/*scale*/ ctx[0]}), 0`}) scale(${/*scale*/ ctx[0]}); left: ${/*removeImageStyle*/ ctx[20] ? '0' : '50%'}`);

			if (!src_url_equal(img0.src, img0_src_value = /*slideImgURL*/ ctx[18])) attr(img0, "src", img0_src_value);
			attr(img0, "alt", "");
			attr(wmgPlayerJSTest_20, "class", "step-title");
			attr(wmgPlayerJSTest_20, "style", /*stepTitleStyle*/ ctx[13]);
			attr(wmgPlayerJSTest_21, "class", "mgPlayerJSTest_justify-content-space-between mgPlayerJSTest_step-data-title");
			attr(wmgPlayerJSTest_22, "class", "mgPlayerJSTest_step-data mgPlayerJSTest_overflow mgPlayerJSTest_overflow-y mgPlayerJSTest_scrollbar-thin");

			set_style(wmgPlayerJSTest_22, "height", /*stepData*/ ctx[8]?.step_description && /*stepData*/ ctx[8].step_description != ''
			? '80px'
			: '56px');

			attr(button3, "id", "mgPlayerJSTest_slideshow-popup-prev-button");
			attr(button3, "class", "mgPlayerJSTest_action-btn mgPlayerJSTest_prev");
			attr(button3, "style", /*prevStyle*/ ctx[17]);
			attr(button3, "aria-label", "Prev");
			button3.hidden = button3_hidden_value = !/*prevPopupButton*/ ctx[11];
			attr(button4, "id", "mgPlayerJSTest_slideshow-popup-next-button");
			attr(button4, "class", "mgPlayerJSTest_action-btn mgPlayerJSTest_next");
			attr(button4, "style", /*nextStyle*/ ctx[16]);
			attr(wmgPlayerJSTest_23, "class", "mgPlayerJSTest_action-container");
			attr(wmgPlayerJSTest_24, "id", "mgPlayerJSTest_tooltipPopup");
			attr(wmgPlayerJSTest_24, "class", wmgPlayerJSTest_24_class_value = "mgPlayerJSTest_preview-step-popup-container " + /*tooltipAlignment*/ ctx[10] + " svelte-n59gq7");
			attr(wmgPlayerJSTest_24, "style", /*mainarea*/ ctx[15]);
			attr(wmgPlayerJSTest_27, "id", "mgPlayerJSTest_spinner");
			attr(wmgPlayerJSTest_27, "class", "mgPlayerJSTest_loader-wrapper");
			attr(wmgPlayerJSTest_28, "id", "mgPlayerJSTest_image_scroll");

			attr(wmgPlayerJSTest_28, "class", wmgPlayerJSTest_28_class_value = "" + (null_to_empty(`mgPlayerJSTest_slideshow-step-img-div mgPlayerJSTest_position-center ${/*notScaleStep*/ ctx[19]
			? ''
			: 'mgPlayerJSTest_overflow mgPlayerJSTest_scrollbar-thin'} `) + " svelte-n59gq7"));

			attr(wmgPlayerJSTest_28, "style", wmgPlayerJSTest_28_style_value = `${/*notScaleStep*/ ctx[19]
			? 'overflow: unset; transition: unset;'
			: ''}`);

			attr(button5, "id", "mgPlayerJSTest_slideshow-prev-button");
			attr(button5, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_slideshow-prev-button");
			attr(button5, "aria-label", "slideshow previous step button");
			attr(button6, "id", "mgPlayerJSTest_slideshow-next-button");
			attr(button6, "class", "mgPlayerJSTest_lbl-btn mgPlayerJSTest_slideshow-next-button");
			attr(button6, "aria-label", "slideshow next step button");
			attr(wmgPlayerJSTest_33, "class", "mgPlayerJSTest_slideshow-step-content");
			attr(wmgPlayerJSTest_37, "class", "mgPlayerJSTest_slideshow-branch-content");
			attr(wmgPlayerJSTest_38, "class", "mgPlayerJSTest_slideshow-main");
			attr(wmgPlayerJSTest_43, "class", "mgPlayerJSTest_popup");
			attr(wmgPlayerJSTest_45, "class", "mgPlayerJSTest_step-thumbnail-container mgPlayerJSTest_width-100");
			attr(wmgPlayerJSTest_46, "class", "mgPlayerJSTest_tour-player-panel mgPlayerJSTest_display-none");
		},
		m(target, anchor) {
			insert(target, wmgPlayerJSTest_46, anchor);
			append(wmgPlayerJSTest_46, wmgPlayerJSTest_18);
			append(wmgPlayerJSTest_18, wmgPlayerJSTest_0);
			append(wmgPlayerJSTest_18, t0);
			append(wmgPlayerJSTest_18, wmgPlayerJSTest_17);
			append(wmgPlayerJSTest_17, wmgPlayerJSTest_4);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_1);
			append(wmgPlayerJSTest_4, t1);
			append(wmgPlayerJSTest_4, wmgPlayerJSTest_3);
			append(wmgPlayerJSTest_17, t3);
			append(wmgPlayerJSTest_17, wmgPlayerJSTest_8);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_5);
			append(wmgPlayerJSTest_8, t4);
			append(wmgPlayerJSTest_8, wmgPlayerJSTest_7);
			append(wmgPlayerJSTest_17, t6);
			append(wmgPlayerJSTest_17, wmgPlayerJSTest_11);
			append(wmgPlayerJSTest_11, label0);
			append(wmgPlayerJSTest_11, t8);
			append(wmgPlayerJSTest_11, wmgPlayerJSTest_10);
			append(wmgPlayerJSTest_10, wmgPlayerJSTest_9);
			append(wmgPlayerJSTest_17, t10);
			append(wmgPlayerJSTest_17, wmgPlayerJSTest_13);
			append(wmgPlayerJSTest_17, t12);
			append(wmgPlayerJSTest_17, wmgPlayerJSTest_16);
			append(wmgPlayerJSTest_16, button2);
			append(wmgPlayerJSTest_16, t13);
			append(wmgPlayerJSTest_16, wmgPlayerJSTest_15);
			append(wmgPlayerJSTest_15, wmgPlayerJSTest_14);
			append(wmgPlayerJSTest_46, t15);
			append(wmgPlayerJSTest_46, wmgPlayerJSTest_38);
			if (if_block0) if_block0.m(wmgPlayerJSTest_38, null);
			append(wmgPlayerJSTest_38, t16);
			append(wmgPlayerJSTest_38, wmgPlayerJSTest_19);
			append(wmgPlayerJSTest_38, t17);
			append(wmgPlayerJSTest_38, wmgPlayerJSTest_28);
			append(wmgPlayerJSTest_28, img0);
			append(wmgPlayerJSTest_28, t18);
			if (if_block1) if_block1.m(wmgPlayerJSTest_28, null);
			append(wmgPlayerJSTest_28, t19);
			append(wmgPlayerJSTest_28, wmgPlayerJSTest_24);
			append(wmgPlayerJSTest_24, wmgPlayerJSTest_22);
			append(wmgPlayerJSTest_22, wmgPlayerJSTest_21);
			append(wmgPlayerJSTest_21, wmgPlayerJSTest_20);
			wmgPlayerJSTest_20.innerHTML = raw_value;
			append(wmgPlayerJSTest_22, t20);
			if (if_block2) if_block2.m(wmgPlayerJSTest_22, null);
			append(wmgPlayerJSTest_24, t21);
			append(wmgPlayerJSTest_24, wmgPlayerJSTest_23);
			append(wmgPlayerJSTest_23, button3);
			append(button3, t22);
			append(wmgPlayerJSTest_23, t23);
			append(wmgPlayerJSTest_23, button4);
			append(button4, t24);
			append(wmgPlayerJSTest_28, t25);
			if (if_block3) if_block3.m(wmgPlayerJSTest_28, null);
			append(wmgPlayerJSTest_28, t26);
			append(wmgPlayerJSTest_28, wmgPlayerJSTest_27);
			append(wmgPlayerJSTest_38, t27);
			append(wmgPlayerJSTest_38, button5);
			append(wmgPlayerJSTest_38, t28);
			append(wmgPlayerJSTest_38, button6);
			append(wmgPlayerJSTest_38, t29);
			append(wmgPlayerJSTest_38, wmgPlayerJSTest_33);
			append(wmgPlayerJSTest_38, t32);
			append(wmgPlayerJSTest_38, wmgPlayerJSTest_37);
			append(wmgPlayerJSTest_46, t38);
			append(wmgPlayerJSTest_46, wmgPlayerJSTest_43);
			append(wmgPlayerJSTest_46, t41);
			append(wmgPlayerJSTest_46, wmgPlayerJSTest_45);

			if (!mounted) {
				dispose = [
					listen(wmgPlayerJSTest_1, "click", /*zoomin*/ ctx[23]),
					listen(wmgPlayerJSTest_5, "click", /*zoomout*/ ctx[24]),
					listen(img0, "load", /*onImageLoad*/ ctx[21]),
					listen(button4, "click", /*closeShowMe*/ ctx[22])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*showFocusWrapper*/ 512 && wmgPlayerJSTest_1_class_value !== (wmgPlayerJSTest_1_class_value = "mgPlayerJSTest_zoom mgPlayerJSTest_cursor-pointer mgPlayerJSTest_focus-controls-wrapper " + (/*showFocusWrapper*/ ctx[9] ? '' : 'mgPlayerJSTest_display-none'))) {
				attr(wmgPlayerJSTest_1, "class", wmgPlayerJSTest_1_class_value);
			}

			if (dirty[0] & /*showFocusWrapper*/ 512 && wmgPlayerJSTest_5_class_value !== (wmgPlayerJSTest_5_class_value = "mgPlayerJSTest_zoom mgPlayerJSTest_cursor-pointer mgPlayerJSTest_focus-controls-wrapper " + (/*showFocusWrapper*/ ctx[9] ? '' : 'mgPlayerJSTest_display-none'))) {
				attr(wmgPlayerJSTest_5, "class", wmgPlayerJSTest_5_class_value);
			}

			if (/*showZoomInError*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.m(wmgPlayerJSTest_38, t16);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*notScaleStep*/ 524288 && img0_class_value !== (img0_class_value = "" + (null_to_empty(`${/*notScaleStep*/ ctx[19]
			? 'mgPlayerJSTest_slideshow-step-img'
			: 'mgPlayerJSTest_slideshow-step-img-inline'}`) + " svelte-n59gq7"))) {
				attr(img0, "class", img0_class_value);
			}

			if (dirty[0] & /*notScaleStep, scale, minScale, removeImageStyle*/ 1572993 && img0_style_value !== (img0_style_value = /*notScaleStep*/ ctx[19]
			? 'top: 50%; transform: translate(-50%, -50%);'
			: `transition: ${/*scale*/ ctx[0] > /*minScale*/ ctx[7] ? '1s' : 'unset'}; z-index: -1; transform-origin: 0px 0px; transform: translate(${/*removeImageStyle*/ ctx[20]
				? '0,0'
				: `calc(-50% * ${/*scale*/ ctx[0]}), 0`}) scale(${/*scale*/ ctx[0]}); left: ${/*removeImageStyle*/ ctx[20] ? '0' : '50%'}`)) {
				attr(img0, "style", img0_style_value);
			}

			if (dirty[0] & /*slideImgURL*/ 262144 && !src_url_equal(img0.src, img0_src_value = /*slideImgURL*/ ctx[18])) {
				attr(img0, "src", img0_src_value);
			}

			if (/*showZoomOutError*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					if_block1.m(wmgPlayerJSTest_28, t19);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*stepData*/ 256 && raw_value !== (raw_value = /*stepData*/ ctx[8]?.step_title + "")) wmgPlayerJSTest_20.innerHTML = raw_value;
			if (dirty[0] & /*stepTitleStyle*/ 8192) {
				attr(wmgPlayerJSTest_20, "style", /*stepTitleStyle*/ ctx[13]);
			}

			if (/*stepData*/ ctx[8]?.step_description && /*stepData*/ ctx[8].step_description != '') {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					if_block2.m(wmgPlayerJSTest_22, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty[0] & /*stepData*/ 256) {
				set_style(wmgPlayerJSTest_22, "height", /*stepData*/ ctx[8]?.step_description && /*stepData*/ ctx[8].step_description != ''
				? '80px'
				: '56px');
			}

			if (dirty[0] & /*prevStyle*/ 131072) {
				attr(button3, "style", /*prevStyle*/ ctx[17]);
			}

			if (dirty[0] & /*prevPopupButton*/ 2048 && button3_hidden_value !== (button3_hidden_value = !/*prevPopupButton*/ ctx[11])) {
				button3.hidden = button3_hidden_value;
			}

			if (dirty[0] & /*nextPopupButton*/ 4096 && t24_value !== (t24_value = (/*nextPopupButton*/ ctx[12] === false
			? GmCXt.label.close
			: GmCXt.label.next) + "")) set_data(t24, t24_value);

			if (dirty[0] & /*nextStyle*/ 65536) {
				attr(button4, "style", /*nextStyle*/ ctx[16]);
			}

			if (dirty[0] & /*tooltipAlignment*/ 1024 && wmgPlayerJSTest_24_class_value !== (wmgPlayerJSTest_24_class_value = "mgPlayerJSTest_preview-step-popup-container " + /*tooltipAlignment*/ ctx[10] + " svelte-n59gq7")) {
				attr(wmgPlayerJSTest_24, "class", wmgPlayerJSTest_24_class_value);
			}

			if (dirty[0] & /*mainarea*/ 32768) {
				attr(wmgPlayerJSTest_24, "style", /*mainarea*/ ctx[15]);
			}

			if (/*elementX*/ ctx[3] && /*elementY*/ ctx[4] && /*elementLength*/ ctx[6] && /*elementHeight*/ ctx[5]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block(ctx);
					if_block3.c();
					if_block3.m(wmgPlayerJSTest_28, t26);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (dirty[0] & /*notScaleStep*/ 524288 && wmgPlayerJSTest_28_class_value !== (wmgPlayerJSTest_28_class_value = "" + (null_to_empty(`mgPlayerJSTest_slideshow-step-img-div mgPlayerJSTest_position-center ${/*notScaleStep*/ ctx[19]
			? ''
			: 'mgPlayerJSTest_overflow mgPlayerJSTest_scrollbar-thin'} `) + " svelte-n59gq7"))) {
				attr(wmgPlayerJSTest_28, "class", wmgPlayerJSTest_28_class_value);
			}

			if (dirty[0] & /*notScaleStep*/ 524288 && wmgPlayerJSTest_28_style_value !== (wmgPlayerJSTest_28_style_value = `${/*notScaleStep*/ ctx[19]
			? 'overflow: unset; transition: unset;'
			: ''}`)) {
				attr(wmgPlayerJSTest_28, "style", wmgPlayerJSTest_28_style_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(wmgPlayerJSTest_46);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

const DEFAULT_SCALE = 1;
const MAX_SCALE_RATIO = 4;
const DEFAULT_MIN_SCALE = 1;
const DEFAULT_MAX_SCALE = 2;

function instance($$self, $$props, $$invalidate) {
	let scrollLeft = 0;

	//Image related variables
	let elementX;

	let elementY;
	let elementHeight;
	let elementLength;
	let scale = DEFAULT_SCALE;
	let tempScale = undefined; //Playing a inline or how to step after a message step, this is a temp placeholder for the prev. scale
	let scrollRegWidth = undefined;
	let scrollRegHeight = undefined;
	let minScale = DEFAULT_MIN_SCALE;
	let maxScale = DEFAULT_MAX_SCALE;
	let showZoomInError = false;
	let showZoomOutError = false;
	let stepData;
	let showFocusWrapper = false;
	let tooltipAlignment = 'center';
	let prevPopupButton = true;
	let nextPopupButton = true;
	let appSettings = GmCXt.getAppSetting();
	appSettings?.popupDesign?.type;
	let popupWidth = appSettings.stepPopupWidth;
	let popupDesign = appSettings?.popupDesign?.current;
	let stepTitleStyle = '';
	let stepDescStyle = '';
	let mainarea = '';
	let nextStyle = '';
	let prevStyle = '';
	let slideImgURL = '';
	let notScaleStep = false;
	let imageLoaded = false;
	let removeImageStyle = false;

	// React to store updates
	Gm.slideState.subscribe(state => {
		if (state.isImageUpdated) {
			$$invalidate(8, stepData = state.step);

			if (stepData.step_type === GmCXt.STEP_TYPE_IMAGE || stepData.step_type === GmCXt.STEP_TYPE_MESSAGE && stepData.thumbnail_url.includes('default_icon')) {
				$$invalidate(19, notScaleStep = true);
			} else {
				$$invalidate(19, notScaleStep = false);
			}

			$$invalidate(9, showFocusWrapper = stepData?.step_type && (stepData?.step_type === GmCXt.STEP_TYPE_WEB_INLINE || stepData?.step_type === GmCXt.STEP_TYPE_INLINE));
			$$invalidate(18, slideImgURL = state.slideImgURL);
		} else {
			$$invalidate(18, slideImgURL = '');
		}
	});

	function processImage() {
		$$invalidate(26, imageLoaded = true);
		$$invalidate(20, removeImageStyle = false);
		tempScale = undefined;
		recalculateScale();

		setTimeout(
			() => {
				getCoordinates();
				getPopup();
			},
			500
		);
	}

	function onImageLoad() {
		mg$('#mgPlayerJSTest_spinner').removeClass('show');

		if (!stepData.step_settings.inlineBranch && stepData.step_type === GmCXt.STEP_TYPE_INLINE || (stepData.step_type === GmCXt.STEP_TYPE_MESSAGE || stepData.step_type === GmCXt.STEP_TYPE_IMAGE) && !stepData.thumbnail_url.includes('default_icon')) {
			processImage();
		} else {
			return;
		}
	}

	function recalculateScale() {
		//** Recalculate scale, set min and max scale
		//Get width and height of visible region
		const imageScrollregion = document.querySelector('#mgPlayerJSTest_image_scroll');

		scrollRegWidth = imageScrollregion.clientWidth;
		scrollRegHeight = imageScrollregion.clientHeight;

		//Get Image width and height
		const imageRegion = document.querySelector('#mgPlayerJSTest_slide-img');

		const imageWidth = imageRegion.clientWidth;
		const imageHeight = imageRegion.clientHeight;
		const widthScale = scrollRegWidth / imageWidth;
		const heightScale = scrollRegHeight / imageHeight;
		$$invalidate(7, minScale = widthScale > heightScale ? heightScale : widthScale);
		maxScale = (widthScale > heightScale ? widthScale : heightScale) * MAX_SCALE_RATIO;

		//By default zoom out completely for the image to fit
		$$invalidate(0, scale = minScale);

		//If how to video or inline step scale the image
		if (elementX && elementY) {
			//If User has a choosen scale, respect that. Skip for message step
			if (tempScale) $$invalidate(0, scale = tempScale); else $$invalidate(0, scale = minScale * DEFAULT_SCALE);

			//Check if the element can fit completely on the new scale, elze zoom out
			while (scrollRegWidth < elementLength * scale || scrollRegHeight < elementHeight * scale) {
				$$invalidate(0, scale -= 0.2);
			}
		}
	}

	function getCoordinates(step) {
		let data = stepData;
		$$invalidate(3, elementX = 0);
		$$invalidate(4, elementY = 0);
		$$invalidate(6, elementLength = 0);
		$$invalidate(5, elementHeight = 0);

		if (data != undefined && data.hasOwnProperty('step_settings') && (stepData.step_type !== GmCXt.STEP_TYPE_MESSAGE || stepData.step_type !== GmCXt.STEP_TYPE_IMAGE)) {
			let data_settings = typeof data.step_settings === 'string'
			? JSON.parse(data.step_settings)
			: data.step_settings;

			if (data_settings.hasOwnProperty('coordinates')) {
				$$invalidate(3, elementX = JSON.parse(data_settings.coordinates).x);
				$$invalidate(4, elementY = JSON.parse(data_settings.coordinates).y);
			} else {
				if (data_settings.elementBounds && Object.keys(data_settings.elementBounds).length > 0) {
					$$invalidate(3, elementX = data_settings.elementBounds.cx * data_settings.dpr || 1);
					$$invalidate(4, elementY = data_settings.elementBounds.cy * data_settings.dpr || 1);
					$$invalidate(6, elementLength = data_settings.elementBounds.cw * data_settings.dpr || 1);
					$$invalidate(5, elementHeight = data_settings.elementBounds.ch * data_settings.dpr || 1);
				} else if (data_settings.hasOwnProperty('highlightedArea') && data_settings.highlightedArea && data_settings.highlightedArea.length > 0) {
					//Changes for web
					const imageRegion = document.querySelector('#mgPlayerJSTest_slide-img');

					const imageWidth = imageRegion.clientWidth * scale;
					const imageHeight = imageRegion.clientHeight * scale;
					const highlightedArea = data_settings.highlightedArea[0];
					const { windowWidth, windowHeight, origTop, top, left, width, height } = highlightedArea;
					let scaleX = imageWidth / windowWidth;
					let scaleY = imageHeight / windowHeight;
					$$invalidate(3, elementX = left * scaleX);

					$$invalidate(4, elementY = origTop > windowHeight || !origTop
					? top * scaleY
					: origTop * scaleY);

					$$invalidate(6, elementLength = width * scaleX);
					$$invalidate(5, elementHeight = height * scaleY);
				}
			}
		} else {
			$$invalidate(3, elementX = 0);
			$$invalidate(4, elementY = 0);
		}

		recalculateScale();
	}

	function getPopup() {
		if (GmCXt.isEmpty(stepData.step_title.trim()) && GmCXt.isEmpty(stepData.step_description.trim())) return;
		appSettings = GmCXt.getAppSetting();
		appSettings?.popupDesign?.type;
		popupWidth = appSettings.stepPopupWidth;
		popupDesign = appSettings?.popupDesign?.current;
		$$invalidate(13, stepTitleStyle = `color:${popupDesign.stepTitleColor}; font-size: ${popupDesign.stepTitleFontSize}; font-weight:${popupDesign.stepTitleFontWeight}; font-family:${popupDesign.stepTitleFontFamily}; transform: scale(0.8); transform-origin: left top; min-width: 125%; `);
		$$invalidate(14, stepDescStyle = `color:${popupDesign.stepDescColor}; font-size: ${popupDesign.stepDesFontSize}; font-family:${popupDesign.stepDesFontFamily}; transform: scale(0.75); transform-origin: left top; min-width: 135%; padding: 0 10px;`);
		$$invalidate(15, mainarea = `background-color:${popupDesign.bgColor}; width:${popupWidth * 0.8}px;  border:${popupDesign.borderWidth}px solid ${popupDesign.borderColor}; border-radius: ${popupDesign.borderRadius}px`);
		$$invalidate(16, nextStyle = `background-color:${popupDesign.nextBtnBackground}; color:${popupDesign.nextBtnColor}`);
		$$invalidate(17, prevStyle = `background-color:${popupDesign.prevBtnBackground}; color:${popupDesign.prevBtnColor}`);
		setPrevNextPopupButtons(stepData);

		if (stepData.step_type === GmCXt.STEP_TYPE_MESSAGE || stepData.step_type === GmCXt.STEP_TYPE_IMAGE || elementX == undefined && elementY == undefined) {
			createMessagePopup();
			return;
		}

		//popup
		let _elementX = elementX;

		let _elementY = elementY;
		let _elementLength = 0;
		let _elementHeight = 0;

		if (elementLength && elementHeight) {
			_elementHeight = elementHeight;
			_elementLength = elementLength;
		} else {
			const howtoCircle = document.getElementById('mgPlayerJSTest_howto-circle');

			if (howtoCircle) {
				_elementX -= howtoCircle.clientWidth / 2;
				_elementY -= howtoCircle.clientHeight / 2;
				_elementHeight = howtoCircle.clientHeight;
				_elementLength = howtoCircle.clientWidth;
			}
		}

		let bounds = {
			cx: _elementX,
			cy: _elementY,
			cw: _elementLength,
			ch: _elementHeight
		};

		let sliderImg = document.getElementById('mgPlayerJSTest_image_scroll');
		let image = document.getElementById('mgPlayerJSTest_slide-img');
		let renderedImgHeight = image.clientHeight * scale;
		let renderedImgWidth = image.clientWidth * scale;
		if (!sliderImg) return;
		let currWidth = sliderImg.clientWidth;
		let currHeight = sliderImg.clientHeight;
		let stepAlignment = stepData.step_settings.alignment;

		let alignment = elementY + 120 > renderedImgHeight
		? stepAlignment
		: 'bottom-middle';

		const options = {
			elementBounds: bounds,
			dimensions: { width: currWidth, height: currHeight },
			stepType: stepData && stepData.step_type || 'inline',
			popup: mg$('#mgPlayerJSTest_tooltipPopup'),
			doNotApplyArrow: true,
			alignment,
			dynamicPopupHeight: true
		};

		let top, left, alignmentResult;
		const result = alignPopup(options);
		({ top, left, alignmentResult } = result.start());
		const availablePositions = result.getAvailablePositions();
		const popupPos = availablePositions[alignment];

		if (popupPos) {
			options.alignment = alignment;
		} else {
			options.alignment = Object.keys(availablePositions).find(key => availablePositions[key] === true);
			const result = alignPopup(options);
			({ top, left, alignmentResult } = result.start());
		}

		const parentWidth = sliderImg.offsetWidth;
		const parentHeight = sliderImg.offsetHeight;
		const leftOffset = renderedImgWidth < parentWidth && (parentWidth - renderedImgWidth) / 2 || 0;
		const topOffset = renderedImgHeight < parentHeight && (parentHeight - renderedImgHeight) / 2 || 0;

		if (renderedImgWidth > parentWidth) {
			$$invalidate(20, removeImageStyle = true);
		} else {
			$$invalidate(20, removeImageStyle = false);
		}

		const element = document.getElementById('mgPlayerJSTest_tooltipPopup');

		if (element && left && left > 0 && top && top > 0) {
			element.style.left = left + leftOffset + 'px';
			element.style.top = top + topOffset + 'px';
			$$invalidate(15, mainarea += ` ;top:${top + topOffset}px; left:${left + leftOffset}px;`);
		}

		document.getElementById('mgPlayerJSTest_tooltipPopup').style.display = 'block';

		if (document.getElementById('mgPlayerJSTest_howto-circle')) {
			document.getElementById('mgPlayerJSTest_howto-circle').style.display = 'block';
		}

		$$invalidate(10, tooltipAlignment = options.alignment);

		GmCXt.timeout(
			function () {
				element.style.setProperty('--tooltip-border-right-color', popupDesign.bgColor);
			},
			10
		);
	}

	function setPrevNextPopupButtons(step) {
		if (!GmCXt.playerI) {
			return;
		}

		$$invalidate(12, nextPopupButton = true);
		$$invalidate(11, prevPopupButton = true);

		if (step.step_type === GmCXt.STEP_TYPE_BRANCH) {
			$$invalidate(12, nextPopupButton = false);
		}

		let prevStepId = GmCXt.getPreviousStepId(parseInt(GmCXt.playerI.currentStepId));
		let prevStep = GmCXt.getStepFromPlayerI(prevStepId);

		if (GmCXt.isFirstNonAutomationStep() || prevStep && (prevStep.step_type === GmCXt.STEP_TYPE_SURVEY || prevStep.step_type === GmCXt.STEP_TYPE_ERROR_HANDLER) && GmCXt.isFirstNonAutomationStep(prevStep.step_id)) {
			$$invalidate(11, prevPopupButton = false);
		}

		let nxtStepID = GmCXt.getTail(step.step_id, GmCXt.playerI.playStructure);
		let nxtStep = GmCXt.getStepFromPlayerI(nxtStepID);

		if (GmCXt.isLastStep(step.step_id, GmCXt.playerI.playStructure) || nxtStep && nxtStep.step_type === GmCXt.STEP_TYPE_SURVEY && nxtStep.step_type === GmCXt.STEP_TYPE_ERROR_HANDLER && GmCXt.isLastStep(nxtStep.step_id, GmCXt.playerI.playStructure)) {
			$$invalidate(12, nextPopupButton = false);

			if (GmCXt.isFirstNonAutomationStep()) {
				$$invalidate(11, prevPopupButton = false);
			}
		}
	}

	function closeShowMe() {
		if (nextPopupButton === false) {
			closeSlideshow();
			const slideshowIns = get(Gm.slideshowInstance);

			// Clean up existing instance if it exists
			if (!GmCXt.isEmpty(slideshowIns)) {
				slideshowIns.$destroy();
			}

			// Clear the container
			const container = mg$('#mgPlayerJSTest_slideshow-panel');

			container.empty();
		}
	}

	function focusToView() {
		scrollElementToView();
	}

	function zoomin() {
		$$invalidate(1, showZoomInError = false);
		$$invalidate(2, showZoomOutError = false);

		if (scale + 0.2 > maxScale) {
			$$invalidate(1, showZoomInError = true);
			return; //Max reached
		}

		$$invalidate(0, scale += 0.2);
		tempScale = scale;
		getPopup();
		focusToView();
	}

	function zoomout() {
		$$invalidate(1, showZoomInError = false);

		if (scale - 0.2 < minScale) {
			$$invalidate(2, showZoomOutError = true);
			return; //Max reached
		}

		$$invalidate(0, scale -= 0.2);
		tempScale = scale;
		getPopup();
		focusToView();
	}

	function closeErrorAlert() {
		$$invalidate(2, showZoomOutError = false);
		$$invalidate(1, showZoomInError = false);
	}

	function scrollElementToView() {
		setTimeout(
			() => {
				const element = document.querySelector('#mgPlayerJSTest_howto-circle');

				if (element) {
					element.scrollIntoView({
						behavior: 'smooth',
						block: 'center',
						inline: 'center'
					});
				}
			},
			100
		);

		let scrollContainer = document.querySelector('#mgPlayerJSTest_thumbnail-preview-wrapper');

		if (scrollContainer) {
			let activeStepIndex = findThumbIndex();
			scrollLeft = activeStepIndex * 190;
			scrollContainer.scrollTo(scrollLeft, 0);
		}
	}

	function createMessagePopup() {
		let step_settings, top, left;
		let sliderImg = document.getElementById('mgPlayerJSTest_image_scroll');
		if (!sliderImg) return;
		let currWidth = sliderImg.clientWidth;
		let currHeight = sliderImg.clientHeight;
		let dimensions = { width: currWidth, height: currHeight };
		if (typeof stepData.step_settings === 'string') step_settings = JSON.parse(stepData.step_settings); else step_settings = stepData.step_settings;

		const position = step_settings.hasOwnProperty('alignment')
		? step_settings.alignment
		: 'center';

		const popup = '#mgPlayerJSTest_tooltipPopup';
		$$invalidate(10, tooltipAlignment = 'none');
		document.getElementById('mgPlayerJSTest_tooltipPopup').style.display = 'block';
		({ left, top } = alignImageStepPreview(popup, dimensions, position, false, step_settings));
		const element = document.getElementById('mgPlayerJSTest_tooltipPopup');

		if (element && left && left > 0 && top && top > 0) {
			element.style.left = left + 'px';
			element.style.top = top + 'px';
			$$invalidate(15, mainarea += ` ;top:${top}px; left:${left}px;`);
		}
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*showZoomInError, showZoomOutError*/ 6) {
			//Remove the zoom toast after 5 seconds
			if (showZoomInError || showZoomOutError) {
				setTimeout(
					() => {
						$$invalidate(1, showZoomInError = false);
						$$invalidate(2, showZoomOutError = false);
					},
					5000
				);
			}
		}

		if ($$self.$$.dirty[0] & /*imageLoaded, scale*/ 67108865) {
			{
				if (imageLoaded && scale) {
					getCoordinates();
					getPopup();
				}
			}
		}
	};

	return [
		scale,
		showZoomInError,
		showZoomOutError,
		elementX,
		elementY,
		elementHeight,
		elementLength,
		minScale,
		stepData,
		showFocusWrapper,
		tooltipAlignment,
		prevPopupButton,
		nextPopupButton,
		stepTitleStyle,
		stepDescStyle,
		mainarea,
		nextStyle,
		prevStyle,
		slideImgURL,
		notScaleStep,
		removeImageStyle,
		onImageLoad,
		closeShowMe,
		zoomin,
		zoomout,
		closeErrorAlert,
		imageLoaded
	];
}

class SlideShow extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {}, add_css, [-1, -1]);
	}
}

let commonUpdate = {};
commonUpdate.updateTour = function(t, currentAppId, updatedOrder) {
    let params = {
        tour_id: t.tour_id,
        category_id: t.category_id
    };

    let cb = function(_t) {

        if (GmCXt.inPlayer) {
            if (currentAppId) {
                rootScope.updateTourToStorage(true, _t, false, currentAppId);
            } else {
                //pub.updateScope(_t);
                rootScope.playerSyncCount--;
            }

            delete rootScope.toursModifiedTime[t.tour_id];
            GmCXt.saveToStorage('toursModifiedTime', rootScope.toursModifiedTime);

        }

        if (GmCXt.FT.creatorApp) {
            commonUpdate.updateTourInTourList(_t);
        }

    };

    let ecb = function() {
        rootScope.toursModifiedTime[t.tour_id] = t;
        GmCXt.saveToStorage('toursModifiedTime', rootScope.toursModifiedTime);

        rootScope.removeTour(params.category_id, t.tour_id, currentAppId);
        //pub.updateScope(t);
    };

    // If updateOrder -  directly call CB and return;
    if (updatedOrder) {
        cb(updatedOrder);
        return;
    }

    let lang = GmCXt.getLXPLang() ? GmCXt.getLXPLang() : rootScope.language;

    if (!GmCXt.checkDefaultLangForTour(t, lang)) {
        params.language = lang;
    }

    api.getTour(params, cb, ecb);
};

commonUpdate.updateTourInTourList = function(tour) {
    let tours = get_store_value(Gm.categoryTours);
    tours = tours.map(function(t) {
        if (t.tour_id === tour.tour_id){
            return tour;
        } else {
            return t;
        }
    });
    Gm.categoryTours.set(tours);
};

commonUpdate.updateCat = function(c, appId) {

    return new Promise(function(resolve, reject) {

        let cb = function(_c) {
            resolve(_c);
        };

        let forceApiCall = GmCXt.inPlayer ? true : false;

        rootScope.getCategoryApi(c.category_id, cb, forceApiCall, appId);
    });

};

commonUpdate.categoryUpdateCb = function(c) {
    delete rootScope.subCategoryStore['cat_' + c.category_id];

    delete rootScope.allTourList['cat_' + c.category_id];

};

/*global GmCXt*/

let pService = {};

function checkTourDelete(tours, allTours, appId) {
    /* check update for Each tour in Published tour. 
		*  if Published tour not found in tours, that means the tour has been unpublished. 
		*/

    let checkTourExisit = function(ptour) {
        let t = tours.filter(function(t) {
            return t.tour_id === parseInt(ptour.tour_id);
        });

        return t;
    };

    allTours = allTours || rootScope.publishedTours;

    for (let i = 0; i < allTours.length; i++) {
        let ptour = allTours[i];

        let tourFound = ptour ? checkTourExisit(ptour) : false;

        if (GmCXt.isEmpty(tourFound)) { //i.e. tour deleted
            rootScope.playerSyncCount++;
            rootScope.removeTour(ptour.category_id, ptour.tour_id, appId);
            //commonUpdate.updateScope(ptour);
        }
    }
}

function checkIfValidTourSegment(t) {
    let isValid = false;
    if (rootScope.guideSegmentation && t.tour_segment && t.tour_segment.length) {
        let segments = [];
        for (let k = 0; k < t.tour_segment.length; k++) {
            for (let l = 0; l < t.tour_segment[k].length; l++) {
                segments.push(t.tour_segment[k][l]);
            }
        }

        if (GmCXt.areUserSegmentsValid(segments)) {
            isValid = true;
        }
    } else {
        isValid = true;
    }
    return isValid;
}

function checkTourUpdates(toursUpdate) {
    for (let i = 0; i < toursUpdate.length; i++) {

        let t = toursUpdate[i];
        let guideInStore = rootScope.allTourList['cat_' + t.category_id] ? rootScope.allTourList['cat_' + t.category_id]['tour_' + t.tour_id] : false;

        if (!guideInStore) {
            guideInStore = rootScope.toursModifiedTime[t.tour_id] ? rootScope.toursModifiedTime[t.tour_id] : false;
        }

        if (checkIfValidTourSegment(t)) {
            if (guideInStore) {
                if (parseInt(t.modification_date) - parseInt(guideInStore.modification_date) > 0) {
                    rootScope.playerSyncCount++;
                    commonUpdate.updateTour(t);
                } else if (parseInt(t.tour_order) !== parseInt(guideInStore.tour_order)) {
                    rootScope.playerSyncCount++;
                    guideInStore.tour_order = t.tour_order;
                    commonUpdate.updateTour(t, "", guideInStore); //update only tour order in local data (No API call)
                }

            } else {
                rootScope.playerSyncCount++;
                commonUpdate.updateTour(t);
            }
        }

    }

    checkTourDelete(toursUpdate);
}

function deleteAllCategories() {

    for (let i = 0; i < rootScope.allCategories.length; i++) {
        rootScope.playerSyncCount++;
        rootScope.removeCategory(rootScope.allCategories[i], true);
        GmCXt.appList["app:" + appId].categories = [];
    }
}

function checkCatDelete(catUpdates, allCats, appId) {

    /* check update for Each cat in allCategories  . 
		*  if exisintg category not found in categories in timetamp.json, that means the cat has been removed. 
		*/

    GmCXt.log(70, 'CHECK CATEGORY DELETE');

    allCats = allCats || rootScope.allCategories;

    Object.keys(allCats).forEach(function(catId) {

        let pCat = allCats[catId];

        let catFound = catUpdates.filter(function(c) {
            return parseInt(c.category_id) === parseInt(pCat.category_id);
        });

        if (GmCXt.isEmpty(catFound)) { //i.e. category removed
            rootScope.playerSyncCount++;

            GmCXt.log(70, 'Category update not found. Delete ' + GmCXt.categoryLog(pCat));
            if (!appId) {

                GmCXt.log(70, 'REMOVE CAT from GLOBLE' + GmCXt.categoryLog(pCat));
                rootScope.removeCategory(pCat);
            }

            rootScope.updateCategoryInStorgae(pCat, true, appId);

        }

    });
}

function checkCatUpdates$1(catUpdates, currentAppId) {

    GmCXt.log(70, 'CATEGORY UPDATES for CURRENT APP');

    let tourCb = function(c) {
        //commonUpdate.updateScope(c);
        if (c && c.length) {
            c.forEach(function(tour) {
                rootScope.playerSyncCount++;
                rootScope.updateTourToStorage(true, tour);
            });
        }
    };

    let fetchTour = function(newCat) {
        rootScope.updateCategoryInStorgae(newCat, false, currentAppId);
        if (newCat.has_tour) {
            GmCXt.log(70, 'FETCH TOURS FOR: ' + GmCXt.categoryLog(newCat));
            rootScope.fetchToursForCategory(newCat.category_id, tourCb, true);
        }
    };


    let catCb = function(uc) {
        rootScope.updateCategoryInStorgae(uc, false, currentAppId);
    };

    for (let i = 0; i < catUpdates.length; i++) {
        let c = catUpdates[i];

        let catFound = rootScope.getCategory(c.category_id); // cat in current app

        if (catFound) { // exising category updated
            if (parseInt(c.modification_date) - parseInt(catFound.modification_date) > 0) {
                rootScope.playerSyncCount++;
                GmCXt.log(70, 'UPDATE: ' + GmCXt.categoryLog(catFound));
                commonUpdate.updateCat(c).then(catCb);
            } else if (parseInt(c.category_order) !== parseInt(catFound.category_order)) {
                rootScope.playerSyncCount++;
                catFound.category_order = c.category_order;
                catCb(catFound);
            }

        } else { //get new category
            rootScope.playerSyncCount++;
            GmCXt.log(70, 'ADD: ' + GmCXt.categoryLog(catFound));
            commonUpdate.updateCat(c).then(fetchTour);
        }
    }

    checkCatDelete(catUpdates);

}

function updateApp(a) {

    api.getAppJson(a.application_id).then(function(app) {

        app = GmCXt.validateDataModel(app, GmCXt.model.application);
		
        let categories = GmCXt.createDeepCopy(GmCXt.appList["app:" + app.application_id].categories);

        app.categories = categories;

        GmCXt.appList["app:" + app.application_id] = app;

        rootScope.syncApps(GmCXt.appList);
        GmCXt.saveToDapStorage('appData', GmCXt.appList);

        rootScope.playerSyncCount--;
    });
}

function updateNonActiveCategories(cats, catUpdates, currentAppId) {

    let fetchTour = function(newCat) {

        let updateTourInStore = function(tlist) {
            rootScope.updateToursInCategoryStorage(newCat.category_id, tlist, remove, currentAppId);
        };

        rootScope.updateCategoryInStorgae(newCat, false, currentAppId);

        if (newCat.has_tour) {
            rootScope.fetchToursForCategory(newCat.category_id, updateTourInStore, true, currentAppId);
        }
    };

    let updateCatStore = function(c) {
        rootScope.updateCategoryInStorgae(c, false, currentAppId);
    };

    catUpdates.forEach(function(uc) {
        let isCat = cats['cat_' + uc.category_id];

        if (isCat) {
            if (parseInt(uc.modification_date) - parseInt(isCat.modification_date) > 0) { //category found
                rootScope.playerSyncCount++;
                commonUpdate.updateCat(uc, currentAppId).then(updateCatStore);
            } else if (parseInt(uc.category_order) !== parseInt(isCat.category_order)) {
                rootScope.playerSyncCount++;
                isCat.category_order = uc.category_order;
                updateCatStore(isCat);
            }
        } else {
            rootScope.playerSyncCount++;
            commonUpdate.updateCat(uc, currentAppId).then(fetchTour);
        }
    });

    checkCatDelete(catUpdates, cats, currentAppId);
}

function updateNonActiveTours(appData, toursUpdate, currentAppId) {

    toursUpdate.forEach(function(ut) {
        let isTour = appData.tours['tour_' + ut.tour_id];
        if (checkIfValidTourSegment(ut)) {
            if (isTour) {
                if (parseInt(ut.modification_date) - parseInt(isTour.modification_date) > 0) {
                    rootScope.playerSyncCount++;
                    commonUpdate.updateTour(ut, currentAppId);
                } else if (parseInt(ut.tour_order) !== parseInt(isTour.tour_order)) {
                    rootScope.playerSyncCount++;
                    isTour.tour_order = ut.tour_order;
                    commonUpdate.updateTour(ut, currentAppId, isTour); //update only tour order in local data (No API call)
                }
            } else {
                rootScope.playerSyncCount++;
                commonUpdate.updateTour(ut, currentAppId);
            }
        }
    });

    checkTourDelete(toursUpdate, appData.tours, currentAppId);
}

function updateRefreshTime(d, isFirst) {
    if (rootScope.playerSyncCount <= 0) {
        rootScope.refreshTime = d.last_updated_time;
        GmCXt.saveToStorage('refreshTime', rootScope.refreshTime);
    } else if (isFirst) {
        GmCXt.timeout(function() {
            updateRefreshTime(d);
        }, 5000);
    } else {
        GmCXt.log(70, 'Process Update Failed' + rootScope.playerSyncCount);
    }
}

function processNonActiveAppData(d) {

    Object.keys(GmCXt.appList).forEach(function(key) {
        let app = GmCXt.appList[key];

        if (parseInt(app.application_id) === parseInt(GmCXt.activeAppId)) {
            return;
        }

        //checkAppUpdate is received
        let appFound = d.applications[app.application_id];

        if (app && app.categories && app.categories.length) {
            let appData = rootScope.processAppData(app);

            //update cat data
            updateNonActiveCategories(appData.categories, appFound.categories, app.application_id);

            //update tour data
            updateNonActiveTours(appData, appFound.tours, app.application_id);
        }

    });
}

pService.processUpdates = function(d) { // d is timestamp.json response 
    rootScope.playerSyncCount = 0;

    let orgRefresh = d.modification_date;
    let org = GmCXt.organization;
    if (parseInt(orgRefresh) - parseInt(org.modification_date)) {
        GmCXt.log(70, 'GET ORG');

        api.getOrgJson().then(function(r) {
            GmCXt.saveToStorage('organization', r);
            GmCXt.updateGlobalOrg(r);
            GmCXt.organization = r;
        });
    }

    if (d.applications) {

        let appAccess = [];
        for (let i = 0; i < GmCXt.user.app_access.length; i++) {
            let appAccessId = GmCXt.user.app_access[i];
            if (!GmCXt.isEmpty(d.applications[appAccessId]) && !GmCXt.inArray(appAccessId, appAccess)) {
                appAccess.push(appAccessId);
            }
        }

        GmCXt.user.app_access = appAccess;

        if (GmCXt.user && GmCXt.user.app_access.length && (GmCXt.user.app_access.length !== Object.keys(GmCXt.appList).length)) {
            rootScope.refreshAllData();

            return;
        }

        let activeAppData;

        Object.keys(d.applications).forEach(function(a) {

            let appUpdate = d.applications[a];

            let app = GmCXt.appList['app:' + appUpdate.application_id];
            if (!app) {
                return;
            }
            if (appUpdate && parseInt(appUpdate.modification_date) - parseInt(app.modification_date) > 0) {
                rootScope.playerSyncCount++;
                updateApp(app);
            }

            if (app.application_id === GmCXt.activeAppId) {
                activeAppData = {
                    categories: appUpdate.categories,
                    tours: appUpdate.tours
                };
            }

        });

        if (activeAppData.categories) {
            checkCatUpdates$1(activeAppData.categories, activeAppData.application_id);

            if (activeAppData.tours.length) {
                checkTourUpdates(activeAppData.tours);
            }
        } else {
            deleteAllCategories();
        }

        processNonActiveAppData(d);

    } else {
        rootScope.refreshAllData();
    }
    updateRefreshTime(d, true);
};

const service = {};
service.main = () => {
    // This listener is only in Guide iframe
    window.addEventListener('message', winListener);
    if (GmCXt.isExtension()) {
        if (GmCXt.browserApp === 'chrome') {
            chrome.runtime.onMessage.addListener(appListener);
        } else {
            browser.runtime.onMessage.addListener(appListener);
        }
    }
};

function updateUser(data) {

    if (data.accesstoken) {
        let user = GmCXt.user;
        if (user) {
            user.accesstoken = data.accesstoken;
            user.refreshtoken = data.refreshtoken;

            if (GmCXt.isDefined(data.app_access)) {
                user.app_access = data.app_access;
            }

            rootScope.saveUser(user);
        }
    }
}

function refreshPlayer(d) {
    rootScope.maintenance = d.maintenance_mode;

    rootScope.lastTimeStampSync = GmCXt.getCurrentTimeInSec();
    GmCXt.saveToStorage('lastTimeStampSync', rootScope.lastTimeStampSync);

    if (d.maintenance_mode) ; else {
        pService.processUpdates(d);
    }

    if (GmCXt.inPlayer || GmCXt.onPrem()) {

        let msg = {
            action: "mgPlayerJSTest_action:update_player_sync_time",
            data: {
                refreshTime: d.last_updated_time,
                lastTimeStampSync: GmCXt.getCurrentTimeInSec()
            }
        };
        
        if (GmCXt.isClientJs()) {
            GmCXt.refreshTime = d.last_updated_time;
		    GmCXt.lastTimeStampSync = GmCXt.getCurrentTimeInSec();
        } else {
            GmCXt.sendMessageToBackgroundService(msg);
        }
    }
}

function winListener(event) {

    let m = GmCXt.parseMsg(event);
    if (!m) return;
    if (!m.action || m.action.indexOf('mgPlayerJSTest_action:') !== 0) {
        return;
    }
    m = GmCXt.convertMgdata(m);
    if (m.data && m.data.config) {
        GmCXt.conf = m.data.config;
    }
    msgAction(m);
}

function createStepComplete(m) {

    GmCXt.log(54, "Step Created", m.data);

    try {

        let step = m.data.step;

        rootScope.pendingStepCount = m.data.pendingCount;

        let t = rootScope.allTourList['cat_' + step.category_id]['tour_' + step.tour_id];

        if (!t) {
            t = m.data.tour;
        }

        let tour = GmCXt.createDeepCopy(t);
        let updatedTour = m.data.tour;
        updatedTour.steps = tour.steps;

        if (step.step_type === GmCXt.STEP_TYPE_BRANCH || step.step_type === GmCXt.STEP_TYPE_ERROR_HANDLER) {
            rootScope.branchGuideDownloadOpts(updatedTour.tour_settings.downloadGuideFiles);
        }

        if (!rootScope.isTrackingGuide(updatedTour)) {
            if (m.data.prevStepData && m.data.prevStepData.tour) {
                updatedTour.tour_settings = m.data.prevStepData.tour.tour_settings;
            }

            updatedTour.steps.forEach(function(s, key) {
                if (step.creation_id && step.creation_id === s.creation_id) {
                    updatedTour.steps[key] = step;
                }
            });

            if (GmCXt.checkForBranchVariationSteps(step)) {
                rootScope.branchGuideDownloadOpts(updatedTour.tour_settings.downloadGuideFiles);
            }

            rootScope.setTour(updatedTour);

            m.data.tour = updatedTour;
        }


        if (step.tour_id === rootScope.currentTour.tour_id && get_store_value(Gm.CurrentPage) === 'stepview') {
            rootScope.routeToStepContainer("createStepCompleted", m.data);
        }
        Gm.statusBar.set('createStepComplete');

    } catch (e) {
        GmCXt.log(54, "Step Creation Error ", e);
    }
}

function tourUpdateSuccess(t) {
    Gm.loading.set(false);
    rootScope.decrementPendingStepCount();
}

function updateTour(data) {
    let dataToUpdate = {};

    dataToUpdate.prevStepData = rootScope.prevStepData;
    dataToUpdate.step = data.step;

    dataToUpdate = GmCXt.updateTourPlayStructure(dataToUpdate);

    if (dataToUpdate) {
        let prevStepData = dataToUpdate.prevStepData;

        let tour = prevStepData.tour;
        let catId = tour.category_id;
        let tourId = tour.tour_id;

        rootScope.allTourList["cat_" + catId]["tour_" + tourId].steps = tour.steps.splice(data.step.step_order - 1, 0, data.step);

        if (get_store_value(Gm.currentTour).tour_id === tourId) {
            Gm.currentTour.set(rootScope.allTourList["cat_" + catId]["tour_" + tourId]);
        }

        let tourObj = prevStepData.tour;

        const dataObj = {
            category_id: tourObj.category_id,
            tour_title: tourObj.tour_title,
            tour_description: tourObj.tour_description,
            tour_image: tourObj.tour_image,
            tour_settings: tourObj.tour_settings,
            tour_type: tourObj.tour_type,
            tour_url: tourObj.tour_url,
            tour_id: tourObj.tour_id,
            is_locked: tourObj.is_locked,
            keywords: tourObj.keywords
        };

        api.tourUpdate(dataObj, function() {}, function() {}, tourUpdateSuccess);
    }
}

function syncCreatorChanges(request) {

    rootScope.refreshTime = request.data.refreshTime;
    GmCXt.saveToStorage('refreshTime', rootScope.refreshTime);

    GmCXt.getFromDapStorage('serverUpdates').then(function(res) {
        rootScope.serverUpdates = res || {};
        if (request.data.updates.length) {
            request.data.updates.forEach(function(d) {
                if (d.action === "update") {
                    rootScope.serverUpdates[d.object_type + '_' + d.object_id] = parseInt(d.modified_time);
                } else if (d.action === "delete") {
                    if (d.object_type === "category") {
                        rootScope.deleteCategoryServerUpdate(d.object_id);
                        rootScope.serverDeletes.categories.push(d.object_id);
                    } else if (d.object_type === "tour") {
                        rootScope.deleteTourServerUpdate(d.object_id);
                        rootScope.serverDeletes.tours.push(d.object_id);
                    }
                }
            });

        }

        GmCXt.saveToDapStorage('serverUpdates', rootScope.serverUpdates);
        GmCXt.saveToDapStorage('serverDeletes', rootScope.serverDeletes);

        rootScope.checkCurrentViewForUpdate(true);
        GmCXt.log(61, "Updates from Server", rootScope.serverUpdates);
    });
}

function saveVideoStep(m) {
    function onSuccess(response) {

        if (response.data) {
            let data = response.data;

            rootScope.uploadProgressBar = false;
            rootScope.updateVideoInProgressList('remove', data.step.tour_id);

            // if (AuthLogin.isSession()) {
            rootScope.videoUploadMessage = true;
            // }


            if (rootScope.videoUploadMessage) {
                setTimeout(rootScope.closeNotification, 5000);
            }

            let d = new Date();
            rootScope.lastVideoStepCreated = {
                id: data.step.step_id,
                time: d.getTime()
            };
            let currentPage = get_store_value(Gm.CurrentPage);
            if (currentPage === "stepview" && rootScope.currentTour.tour_id === data.step.tour_id) {
                rootScope.routeToStepContainer("refreshStep", data);
            } else {
                updateTour(data);
            }
            // var viewPageScope = angular.element("#mgPlayerJSTest_tour-view-page-container").scope();
            // if (viewPageScope) {
            //     rootScope.$broadcast("refreshStep", {
            //         step: data.step
            //     });
            // } else {

            // }

        } else {
            GmCXt.saveToStorage('videosInProgress', []);
        }

    }

    GmCXt.updateStepRequest(m.data);
    if (m.data.step_id) {
        api.stepUpdate(m.data, onSuccess);
    } else {
        api.stepCreate(m.data, onSuccess);
    }
}

function createStepJobsPreview(m) {
    rootScope.uploadStepProgressBar = true;
    Gm.statusBar.set('createStepJobsPreview');
}

function updateStepComplete(m) {
    rootScope.decrementPendingStepCount();

    if (m.data.code === 1005) {
        rootScope.triggerError(m.data);

        GmCXt.log(54, "ERROR: Failed to update step", m.data);

        rootScope.routeToStepContainer("updateStepFailed", m.data);

    } else {

        GmCXt.log(54, "Step updated", m.data);

        let step = m.data.step;

        let _tour = rootScope.allTourList['cat_' + step.category_id] && rootScope.allTourList['cat_' + step.category_id]['tour_' + step.tour_id] && rootScope.allTourList['cat_' + step.category_id]['tour_' + step.tour_id] || {};
        let tour = !GmCXt.isEmpty(_tour) ? _tour : rootScope.currentTour;

        tour.steps.forEach(function(s, key) {
            if (step.step_type === GmCXt.STEP_TYPE_TAG) {
                if (step.step_id === s.step_id) {
                    m.data.stepIndex = key;
                    tour.steps[key] = step;
                }
            } else {
                if ((step.creation_id === s.creation_id) ||
                    (m.data.langUpdated && step.step_id === s.step_id)) {
                    tour.steps[key] = step;
                }
            }
        });

        if (m.data.tour) tour.tour_settings = m.data.tour.tour_settings;

        rootScope.setTour(tour, '', GmCXt.isEmpty(_tour));
        rootScope.routeToStepContainer("updateStepCompleted", m.data);
    }
}


function updateStepFail(m) {
    rootScope.decrementPendingStepCount();

    rootScope.routeToStepContainer("updateStepFailed", m.data);
    if (m.data.code) {
        rootScope.triggerError(m.data);
    }
}

function createStepFail(m) {

    GmCXt.log(54, "ERROR: Failed to create step", m.data);

    let step = GmCXt.parseJSON(m.data.step);


    if (rootScope.allTourList.length) {
        stepFailCb(m, step);
    } else {
        GmCXt.getFromDapStorage('allTourList').then(function(res) {
            rootScope.allTourList = res;
            stepFailCb(m, step);
        }).catch(function(e) {
            console.log('Error in getting all tour list', e);
        });
    }
}

function stepFailCb(m, step) {

    let tour = rootScope.allTourList['cat_' + step.category_id]['tour_' + step.tour_id];

    tour.steps.forEach(function(s, key) {
        if (step.creation_id && step.creation_id === s.creation_id) {
            tour.steps.splice(key, 1);
        }
    });

    rootScope.setTour(tour);
    Gm.currentTour.set(tour);

    if (step.tour_id === rootScope.currentTour.tour_id) {
        Gm.loading.set(false);
        rootScope.decrementPendingStepCount();
    }

    if (m.data.code) {
        rootScope.triggerError(m.data);
    }

    Gm.statusBar.set('createStepFailed');
}

function refreshTourView(request) {
    rootScope.uploadInProgress = false;

    if (request.data.error) {
        mgError.on({
            code: request.data.result.code
        });
    } else {
        rootScope.videoUploadMessage = true;
        setTimeout(rootScope.closeNotification, 5000);
        rootScope.setTour(request.data.tour);
        rootScope.refreshPageView();
    }

}

let msgAction = function(message) {

    if (GmCXt.FT.creatorApp) {
        commonCases(message);
    }

    switch (message.action) {

    case 'mgPlayerJSTest_action:maintenance':
        rootScope.goToMaintenance();
        break;

    case 'mgPlayerJSTest_action:update_access_token':
        updateUser(message.data);
        break;

    case 'mgPlayerJSTest_action:refresh_player':
        refreshPlayer(message.data);
        break;

    case 'mgPlayerJSTest_action:update_timestamp_sync_time':
        console.log("received in msgAction");
        rootScope.lastTimeStampSync = GmCXt.getCurrentTimeInSec();
        GmCXt.saveToStorage('lastTimeStampSync', rootScope.lastTimeStampSync);
        break;

    case 'mgPlayerJSTest_action:get_cdn_signature_from_app':
        rootScope.getNewCdnSignature();
        break;

    case 'mgPlayerJSTest_action:logout_user':
        rootScope.clearSession();
        break;

    case 'mgPlayerJSTest_action:signin_from_console':
        rootScope.loginFromConsole(message.data);
        break;

    case 'mgPlayerJSTest_action:update_registration_secret':
        rootScope.trackerSecrets = {};
        rootScope.registerClientInsights();
        break;
    }
};

let appListener = function(request, sender, sendResponse) {

    request = GmCXt.parseJSON(request);
    request = GmCXt.convertMgdata(request);

    if (GmCXt.FT.creatorApp) {
        commonCases(request);
    }

    switch (request.action) {

    case 'mgPlayerJSTest_action:get_cdn_signature_from_app':
        rootScope.getNewCdnSignature();
        break;

    case 'mgPlayerJSTest_action:update_access_token':
        updateUser(request.data);
        break;

    case 'mgPlayerJSTest_action:refresh_player':
        refreshPlayer(request.data);
        break;

    case 'mgPlayerJSTest_action:update_timestamp_sync_time':
        console.log("received in appListener");
        rootScope.lastTimeStampSync = GmCXt.getCurrentTimeInSec();
        GmCXt.saveToStorage('lastTimeStampSync', rootScope.lastTimeStampSync);
        break;

    case 'mgPlayerJSTest_action:fetch_user':
        let user = GmCXt.user;
        if (!GmCXt.isEmpty(user)) {
            rootScope.syncUser();
        } else {
            rootScope.clearSession();
        }

        break;

    case 'mgPlayerJSTest_action:update_registration_secret':
        rootScope.trackerSecrets = {};
        rootScope.registerClientInsights();
        break;

    case 'mgPlayerJSTest_action:logout_user':
        rootScope.clearSession();
        break;

    case 'mgPlayerJSTest_action:get_data_from_panel':
        var m = {
            action: "mgPlayerJSTest_action:get_data_from_panel_response",
            data: {
                user: GmCXt.user,
                organization: GmCXt.organization
            }
        };
        GmCXt.sendMessageToBackgroundService(m);

        break;

    case 'mgPlayerJSTest_action:save_image_done':
        Gm.routeAction.set({
            action: "save_image_done",
            data: request.data
        });
        break;
    }

    return true;
};

function commonCases(message) {
    switch (message.action) {

    case 'mgPlayerJSTest_action:capture_step_completed,type:inline':
        rootScope.routeToStepContainer('mgPlayerJSTest_action:capture_step_completed,type:inline', message.data);
        break;
    case 'mgPlayerJSTest_action:capture_step_completed,type:message':
        rootScope.routeToStepContainer('mgPlayerJSTest_action:capture_step_completed,type:message', message.data);
        break;
    case 'mgPlayerJSTest_action:capture_step_completed,type:tag':
        rootScope.routeToStepContainer('mgPlayerJSTest_action:capture_step_completed,type:tag', message.data);
        break;
    case 'mgPlayerJSTest_action:capture_step_image_upload_completed,type:inline':
    case 'mgPlayerJSTest_action:capture_step_image_upload_completed,type:message':
    case 'mgPlayerJSTest_action:capture_step_image_upload_completed,type:image':
        rootScope.routeToStepContainer(message.action, message.data);
        break;

    case 'mgPlayerJSTest_action:open_image_step_editor_view':
        rootScope.routeToStepContainer('mgPlayerJSTest_action:open_image_step_editor_view', message.data);
        break;

    case 'mgPlayerJSTest_action:update_capture_image_src':
        rootScope.routeToStepContainer('mgPlayerJSTest_action:update_capture_image_src', message.data);
        break;

    case 'mgPlayerJSTest_action:create_step_jobs':
        createStepJobsPreview(message.data);
        break;

    case 'mgPlayerJSTest_action:update_video_progress_bar':
        rootScope.updateStatusProgressBar(message);
        break;

    case 'mgPlayerJSTest_action:update_save_video_progress':
        rootScope.updatedInProgressVariable(message);
        break;

    case 'mgPlayerJSTest_action:create_step_completed':
    case 'mgPlayerJSTest_action:create_tag_completed':
        createStepComplete(message);
        break;

    case 'mgPlayerJSTest_action:create_step_failed':
        createStepFail(message);
        break;

    case 'mgPlayerJSTest_action:create_bulk_step_failed':
        rootScope.routeToStepContainer("mgPlayerJSTest_action:create_bulk_step_failed", message.data.message);
        break;

    case 'mgPlayerJSTest_action:create_bulk_step_success':
        rootScope.showStepCreatedSuccessMsg = true;
        rootScope.pendingStepCount = 0;
        if (message.data.data.tour_id === get_store_value(Gm.currentTour).tour_id) {
            rootScope.routeToStepContainer("refreshView", true);
        }
        break;

    case 'mgPlayerJSTest_action:hide_progress_bar':
        rootScope.setStepPendinCount();
        rootScope.hideProgressBar();
        break;

    case 'mgPlayerJSTest_action:updated_step_completed':
    case 'mgPlayerJSTest_action:updated_tag_completed':
        updateStepComplete(message);
        break;

    case 'mgPlayerJSTest_action:updated_step_failed':
        updateStepFail(message);
        break;

    case 'mgPlayerJSTest_action:close_tag_completed':
        Gm.loading.set(false);
        break;

    case 'mgPlayerJSTest_action:creator_updates':
        syncCreatorChanges(message);
        break;

    case 'mgPlayerJSTest_action:refresh_tour_view':
        refreshTourView(message);
        break;

    case 'mgPlayerJSTest_action:console_errors_from_background':
        if (message.data.errStack) {
            console.error(message.data.errStack);
        }
        break;

    case 'mgPlayerJSTest_action:save_video_step':
        saveVideoStep(message);
        break;

    case 'mgPlayerJSTest_action:create_video_step':
        GmCXt.openAppPanel(true);

        let stepId = 0;
        $state.go('video-step-add', {
            tourId: message.data.tourId,
            stepId: stepId,
            videoUrl: message.data.videoUrl,
            type: "videoScreencast",
            order: message.data.order
        });

        break;

    case "mgPlayerJSTest_action:save_video_in_background;task:upload_video;completed":
        // Clear the video loading indicator when upload is complete
        GmCXt.removeVidImageLoader();

        // Construct the complete video URL with authentication signature and call the callback
        const completeVideoUrl = message.data.videoUrl + GmCXt.user.cdn_signature;
        const videoMetadata = { alt: '' };
        GmCXt.videoReturnListenerCb(completeVideoUrl, videoMetadata);

        // Clean up the callback reference to prevent memory leaks
        GmCXt.videoReturnListenerCb = null;
        break;

    case 'mgPlayerJSTest_action:show_message_video_step_failed':
        rootScope.uploadProgressBar = false;
        rootScope.videoUploadMessage = false;
        Gm.statusBar.set(video_step_failed);
        mg$('.mgPlayerJSTest_video-upload-progress-bar-wrapper').find('.mgPlayerJSTest_progress-bar-close-button').show();
        modal.open(rootScope.labels.videoSubmitFailedMessage, 'alert', videoErrClose);
        rootScope.uploadInProgress = false;
        rootScope.updateVideoInProgressList('remove', message.data.tour_id);
        break;

    case 'mgPlayerJSTest_action:create_image_steps_failed':
        rootScope.uploadProgressBar = false;
        rootScope.videoUploadMessage = false;
        Gm.statusBar.set("image_steps_failed");
        mg$('.mgPlayerJSTest_video-upload-progress-bar-wrapper').find('.mgPlayerJSTest_progress-bar-percentage').html('1%');
        mg$('.mgPlayerJSTest_video-upload-progress-bar-wrapper').find('.mgPlayerJSTest_progress-bar-percentage').css('width', '1%');

        if (message.data.code) {
            rootScope.triggerError(message.data);
        }

        rootScope.uploadInProgress = false;
        break;
    }
}

GmCXt.onUserSignin = function(data) {
    const user = data.data.user;
    const forceLogin = data.forceLogin;
    
    if ((!GmCXt.user || GmCXt.isEmpty(GmCXt.user)) && !forceLogin) {
        rootScope.onUserSignin(user, false);
    } else if (forceLogin) {
        rootScope.onUserSignin(user, true);
    }
};

GmCXt.sidePanelMsgAction = msgAction;
GmCXt.sidePanelAppListener = appListener;

let playerSvgConst = {
    iconBack: '<svg class="mgPlayerJSTest_position-center" width="8" height="14" viewBox="0 0 8 14" fill="none">' +
			'<path fill-rule="evenodd" clip-rule="evenodd" d="M0.233044 7.05301C0.233044 7.03801 0.236044 7.02501 0.237044 7.01001C0.245778 6.81309 0.327814 6.62654 0.467044 6.48701L0.469044 6.48401L6.11604 0.837007C6.19033 0.762217 6.27864 0.702806 6.37591 0.662173C6.47318 0.62154 6.57751 0.600484 6.68292 0.600205C6.78834 0.599927 6.89277 0.620432 6.99026 0.66055C7.08774 0.700668 7.17636 0.75961 7.25104 0.834006L7.53304 1.11701C7.68312 1.26767 7.76722 1.47177 7.76684 1.68442C7.76647 1.89708 7.68165 2.10088 7.53104 2.25101L2.72904 7.05201L7.52904 11.853C7.6039 11.9272 7.66339 12.0155 7.70411 12.1127C7.74482 12.21 7.76598 12.3143 7.76635 12.4197C7.76672 12.5251 7.7463 12.6295 7.70627 12.7271C7.66624 12.8246 7.60737 12.9133 7.53304 12.988L7.25004 13.271C7.09912 13.4208 6.89487 13.5046 6.68222 13.5038C6.46956 13.5031 6.26591 13.4179 6.11604 13.267L0.749043 7.90101L0.466043 7.61801C0.316043 7.46801 0.240044 7.27301 0.235044 7.07501L0.233044 7.05301Z" fill="#555555"/>' +
			'</svg>',

    iconSearchClose: '<svg version="1.1" id="Capa_1" x="0px" y="0px"' +
		'viewBox="0 0 50 50" style="enable-background:new 0 0 50 50;" xml:space="preserve">' +
		'<g>' +
		'<g>' +
		'<path d="M46,4C44.9,3,43.2,3,42.1,4L25,21.2L7.9,4C6.8,3,5.1,3,4,4S3,6.8,4,7.9L21.2,25L4,42.1C3,43.2,3,44.9,4,46' +
		'c0.5,0.5,1.2,0.8,1.9,0.8s1.4-0.3,1.9-0.8L25,28.8L42.1,46c0.5,0.5,1.2,0.8,1.9,0.8c0.7,0,1.4-0.3,1.9-0.8c1.1-1.1,1.1-2.8,0-3.8' +
		'L28.8,25L46,7.9C47,6.8,47,5.1,46,4z"/>' +
		'</g>' +
		'</g>' +
		'</svg>',

    no_guides_image: '<svg viewBox="0 0 101 124" fill="none">' +
		'<path d="M98.809 22.612L78.174 1.824C77.024 0.664999 75.428 0 73.795 0H6.57C3.169 0 0.401001 2.768 0.401001 6.169V117.83C0.401001 121.232 3.169 124 6.57 124H94.429C97.831 124 100.599 121.232 100.599 117.83V26.958C100.599 25.319 99.963 23.776 98.809 22.612ZM76.754 3.232L97.389 24.02C97.928 24.563 98.286 25.233 98.464 25.958H77.727C76.618 25.958 75.574 25.527 74.787 24.744C73.995 23.955 73.558 22.905 73.558 21.788V2H73.795C74.915 2 75.966 2.438 76.754 3.232ZM94.429 122H6.57C4.271 122 2.401 120.129 2.401 117.83V6.169C2.401 3.87 4.271 2 6.57 2H71.558V21.788C71.558 23.441 72.204 24.995 73.375 26.161C74.54 27.32 76.084 27.958 77.722 27.958H98.599V117.83C98.599 120.129 96.728 122 94.429 122Z" fill="#8D8D8D"/>' +
		'</svg>',

    folder: '<svg  width="40" height="40" viewBox="0 0 40 40" fill="none">' +
		'<rect x="0.7" y="0.7" width="38.6" height="38.6" rx="19.3" fill="#f8f8fb" stroke="#acadc1" stroke-width="1.4"/>' +
		'<path d="M28.2 15.6733V18.4667H11.8V13.0067C11.8 12.9091 11.8669 12.8667 11.906 12.8667H18.5C18.539 12.8667 18.606 12.9092 18.606 13.0067V15.3333V15.5333H18.806H28.094C28.1331 15.5333 28.2 15.5758 28.2 15.6733ZM28.094 14.4667H19.606V13.0067C19.606 12.3616 19.1296 11.8 18.5 11.8H11.906C11.2764 11.8 10.8 12.3612 10.8 13.0067V18.6667V19.3333V27.66C10.8 28.3051 11.2764 28.8667 11.906 28.8667H28.094C28.7232 28.8667 29.2 28.3055 29.2 27.66V19.3333V18.6667V15.6733C29.2 15.0279 28.7236 14.4667 28.094 14.4667ZM28.2 27.66C28.2 27.7576 28.1331 27.8 28.094 27.8H11.906C11.8669 27.8 11.8 27.7576 11.8 27.66V19.5333H28.2V27.66Z" fill="#acadc1" stroke="#acadc1" stroke-width="0.4"/>' +
		'</svg>',

    guide_category_title: '<svg width="28" height="22" viewBox="0 0 28 22" fill="none" >' +
		'<path d="M0.305981 9.84855L2.80027 19.8175C2.81263 20.5627 3.36591 21.2 4.08726 21.2H23.5129C24.2341 21.2 24.788 20.5626 24.7999 19.8165L27.1945 9.84671L27.2373 9.66829L27.0632 9.61026L24.8001 8.85585V5.408C24.8001 4.65149 24.2424 4 23.5129 4H13.2873V2.208C13.2873 1.45193 12.7296 0.8 12.0001 0.8H4.08726C3.35774 0.8 2.80006 1.45149 2.80006 2.208V8.85401L0.439046 9.60952L0.260472 9.66666L0.305981 9.84855ZM3.91408 19.7435L1.47621 10H26.0263L23.6856 19.7453L23.6801 19.7683V19.792C23.6801 19.9271 23.5858 20 23.5129 20H4.08726C4.01434 20 3.92006 19.9271 3.92006 19.792V19.7674L3.91408 19.7435ZM23.6801 5.408V8.8H3.92006V2.208C3.92006 2.07291 4.01434 2 4.08726 2H12.0001C12.0727 2 12.1673 2.07305 12.1673 2.208V5V5.2H12.3673H23.5129C23.5858 5.2 23.6801 5.27291 23.6801 5.408Z" fill="#b2b2b2" stroke="#b2b2b2" stroke-width="0.6" />' +
		'</svg>',

    iconBreadcrumArrow: '<svg width="6px" height="14px" viewBox="0 0 6 14" version="1.1"  >' +
		'<defs></defs>' +
		'<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" fill-opacity="0.555338542">' +
		'<g id="01--Breadcrumb-GuideMe" transform="translate(-1139.000000, -186.000000)" fill-rule="nonzero" fill="#757575">' +
		'<g id="right-arrow-copy-2" transform="translate(1139.000000, 186.000000)">' +
		'<polygon class="shape" points="0.257105882 0 0.0240470588 0.313588202 4.68407059 6.58823529 0.0240470588 12.8628824 0.257105882 13.1764706 5.15002353 6.58823529"></polygon>' +
		'<polygon id="Shape-Copy" points="0.257105882 0 0.0240470588 0.313588202 4.68407059 6.58823529 0.0240470588 12.8628824 0.257105882 13.1764706 5.15002353 6.58823529"></polygon>' +
		'</g>' +
		'</g>' +
		'</g>' +
		'</svg>',

    popupInfo: '<svg width="44" height="44" viewBox="0 0 44 44" fill="none">' +
		'<path d="M22 43.3333C16.342 43.3333 10.9158 41.0857 6.91502 37.085C2.91424 33.0842 0.666626 27.658 0.666626 22C0.666626 16.3421 2.91424 10.9158 6.91502 6.91506C10.9158 2.91428 16.342 0.666672 22 0.666672C27.6579 0.666672 33.0841 2.91428 37.0849 6.91506C41.0857 10.9158 43.3333 16.3421 43.3333 22C43.3333 27.658 41.0857 33.0842 37.0849 37.085C33.0841 41.0857 27.6579 43.3333 22 43.3333ZM22 11.3333C21.4342 11.3333 20.8915 11.5581 20.4915 11.9582C20.0914 12.3583 19.8666 12.9009 19.8666 13.4667C19.8666 14.0325 20.0914 14.5751 20.4915 14.9752C20.8915 15.3752 21.4342 15.6 22 15.6C22.5658 15.6 23.1084 15.3752 23.5085 14.9752C23.9085 14.5751 24.1333 14.0325 24.1333 13.4667C24.1333 12.9009 23.9085 12.3583 23.5085 11.9582C23.1084 11.5581 22.5658 11.3333 22 11.3333ZM24.1333 19.8667C24.1333 19.3009 23.9085 18.7583 23.5085 18.3582C23.1084 17.9581 22.5658 17.7333 22 17.7333C21.4342 17.7333 20.8915 17.9581 20.4915 18.3582C20.0914 18.7583 19.8666 19.3009 19.8666 19.8667V30.5333C19.8666 31.0991 20.0914 31.6418 20.4915 32.0418C20.8915 32.4419 21.4342 32.6667 22 32.6667C22.5658 32.6667 23.1084 32.4419 23.5085 32.0418C23.9085 31.6418 24.1333 31.0991 24.1333 30.5333V19.8667Z" fill="#005BF0"/>' +
		'</svg>',

    popupClose: '<svg  width="14" height="14" viewBox="0 0 14 14" fill="none">' +
		'<path opacity="0.7" d="M13.8586 1.41L8.33929 6.92929L8.26858 7L8.33929 7.07071L13.8586 12.59L12.59 13.8586L7.07071 8.33929L7 8.26858L6.92929 8.33929L1.41 13.8586L0.141422 12.59L5.66071 7.07071L5.73142 7L5.66071 6.92929L0.141421 1.41L1.41 0.141421L6.92929 5.66071L7 5.73142L7.07071 5.66071L12.59 0.141422L13.8586 1.41Z" fill="black" stroke="black" stroke-width="0.2"/>' +
		'</svg>',

    popupWarning: '<svg width="44" height="40" viewBox="0 0 44 40" fill="none">' +
		'<path fill-rule="evenodd" clip-rule="evenodd" d="M37.9337 38.9261L5.9348 39.0691C1.22227 39.0904 -0.681735 35.8019 1.682 31.7251L17.8431 3.85201C20.2068 -0.224788 24.0244 -0.216255 26.3711 3.87121L42.2196 31.4872C44.5652 35.5747 42.6463 38.9048 37.9337 38.9261ZM21.9071 28.4408C20.7284 28.4408 19.7737 29.3965 19.7737 30.5741C19.7737 31.7517 20.7295 32.7075 21.9071 32.7075C23.0847 32.7075 24.0404 31.7517 24.0404 30.5741C24.0404 29.3965 23.0847 28.4408 21.9071 28.4408ZM21.9071 26.3075C23.0847 26.3075 24.0404 25.3517 24.0404 24.1741V15.6408C24.0404 14.4632 23.0847 13.5075 21.9071 13.5075C20.7295 13.5075 19.7737 14.4632 19.7737 15.6408V24.1741C19.7737 25.3528 20.7295 26.3075 21.9071 26.3075Z" fill="#FFAB00"/>' +
		'</svg>',

    popupError: '<svg width="44" height="40" viewBox="0 0 44 40" fill="none">' +
		'<path fill-rule="evenodd" clip-rule="evenodd" d="M37.9337 38.9261L5.93477 39.0691C1.22223 39.0904 -0.681765 35.8019 1.68197 31.7251L17.843 3.85201C20.2068 -0.224788 24.0244 -0.216255 26.371 3.87121L42.2196 31.4872C44.5652 35.5747 42.6462 38.9048 37.9337 38.9261ZM21.907 28.4408C20.7284 28.4408 19.7737 29.3965 19.7737 30.5741C19.7737 31.7517 20.7294 32.7075 21.907 32.7075C23.0846 32.7075 24.0404 31.7517 24.0404 30.5741C24.0404 29.3965 23.0846 28.4408 21.907 28.4408ZM21.907 26.3075C23.0846 26.3075 24.0404 25.3517 24.0404 24.1741V15.6408C24.0404 14.4632 23.0846 13.5075 21.907 13.5075C20.7294 13.5075 19.7737 14.4632 19.7737 15.6408V24.1741C19.7737 25.3528 20.7294 26.3075 21.907 26.3075Z" fill="#DE350B"/>' +
		'</svg>',

    popupSuccess: '<svg width="44" height="43" viewBox="0 0 44 43" fill="none">' +
		'<path fill-rule="evenodd" clip-rule="evenodd" d="M22.3387 42.68C19.5162 42.7116 16.7155 42.1829 14.0987 41.1246C11.482 40.0663 9.10113 38.4995 7.09409 36.5147C5.08704 34.53 3.49365 32.1668 2.40619 29.562C1.31872 26.9573 0.758774 24.1627 0.758774 21.34C0.758774 18.5173 1.31872 15.7227 2.40619 13.118C3.49365 10.5132 5.08704 8.15003 7.09409 6.1653C9.10113 4.18056 11.482 2.61369 14.0987 1.55541C16.7155 0.497126 19.5162 -0.0315459 22.3387 5.92438e-06C27.9571 0.0628127 33.324 2.33878 37.2748 6.33398C41.2256 10.3292 43.4414 15.7213 43.4414 21.34C43.4414 26.9588 41.2256 32.3508 37.2748 36.346C33.324 40.3412 27.9571 42.6172 22.3387 42.68ZM19.2027 26.4267L13.6347 21.552L11 24.5653L19.6533 32.1333L34.2987 14.56L31.224 12L19.2027 26.4267Z" fill="#14B872"/>' +
		'</svg>',

    refresh: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="0 0 31 25" fill="none" >' +
		'<path fill-rule="evenodd" clip-rule="evenodd" d="M15.4902 22.7C21.1235 22.7 25.6902 18.1333 25.6902 12.5C25.6902 12.1626 25.6739 11.829 25.6418 11.5H27.9508C27.9769 11.8299 27.9902 12.1634 27.9902 12.5C27.9902 19.4036 22.3938 25 15.4902 25C12.548 25 9.84315 23.9835 7.70781 22.2824L9.34699 20.6432C11.0557 21.9343 13.1836 22.7 15.4902 22.7ZM5.33863 13.5C5.30662 13.171 5.29023 12.8374 5.29023 12.5C5.29023 6.8667 9.85693 2.3 15.4902 2.3C17.9291 2.3 20.1681 3.15598 21.9231 4.5839L21.9902 4.5L23.5474 2.94285C21.3716 1.10668 18.5602 0 15.4902 0C8.58668 0 2.99023 5.59644 2.99023 12.5C2.99023 12.8366 3.00354 13.1701 3.02965 13.5H5.33863Z" fill="#454560" />' +
		'<path d="M26.8099 7.97679L23.1062 11.9319C23.0671 11.9829 23.0637 12.0485 23.0965 12.1021C23.1298 12.1559 23.1941 12.189 23.2641 12.1881L30.7904 12.0969C30.8604 12.096 30.9241 12.0613 30.956 12.0068C30.97 11.9826 30.9768 11.9561 30.9765 11.93C30.9761 11.8972 30.9644 11.8648 30.9421 11.8369L27.1196 7.97303C27.0838 7.92885 27.0258 7.90305 26.9639 7.9038C26.902 7.90455 26.8445 7.93192 26.8099 7.97679Z" fill="#454560" />' +
		'<path d="M4.16431 17.1151L7.8721 13.1638C7.91124 13.1128 7.91465 13.0472 7.88187 12.9936C7.84872 12.9398 7.78437 12.9066 7.71438 12.9074L0.188057 12.9909C0.118062 12.9917 0.0542772 13.0263 0.0223269 13.0808C0.00829369 13.105 0.00143566 13.1314 0.00172616 13.1576C0.00208975 13.1904 0.0137412 13.2228 0.0360681 13.2507L3.8546 17.1185C3.89028 17.1627 3.94834 17.1886 4.01025 17.1879C4.07215 17.1872 4.12962 17.1599 4.16431 17.1151Z" fill="#454560" />' +
		'</svg>',

    close_panel: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="0 0 18 18" fill="none">' +
		'<path fill-rule="evenodd" clip-rule="evenodd" d="M10.7133 8.54133L17.3653 15.1933C17.5729 15.4009 17.6895 15.6824 17.6895 15.976C17.6895 16.2696 17.5729 16.5511 17.3653 16.7587C17.1577 16.9662 16.8762 17.0829 16.5826 17.0829C16.2891 17.0829 16.0076 16.9662 15.8 16.7587L9.14798 10.1053L2.49731 16.7573C2.39453 16.8601 2.27251 16.9416 2.13822 16.9973C2.00393 17.0529 1.86 17.0815 1.71465 17.0815C1.56929 17.0815 1.42536 17.0529 1.29107 16.9973C1.15678 16.9416 1.03476 16.8601 0.931979 16.7573C0.829198 16.6546 0.747667 16.5325 0.692043 16.3982C0.636418 16.2639 0.607788 16.12 0.607788 15.9747C0.607788 15.8293 0.636418 15.6854 0.692043 15.5511C0.747667 15.4168 0.829198 15.2948 0.931979 15.192L7.58265 8.54133L0.931979 1.88933C0.724403 1.68176 0.607788 1.40022 0.607788 1.10667C0.607788 0.81311 0.724403 0.531577 0.931979 0.324001C1.13956 0.116425 1.42109 -0.000190733 1.71465 -0.000190735C2.0082 -0.000190737 2.28974 0.116425 2.49731 0.324001L9.14798 6.97733L15.8 0.324001C16.0076 0.116425 16.2891 -0.000190735 16.5826 -0.000190735C16.8762 -0.000190735 17.1577 0.116425 17.3653 0.324001C17.5729 0.531577 17.6895 0.81311 17.6895 1.10667C17.6895 1.40022 17.5729 1.68176 17.3653 1.88933L10.7133 8.54133Z" fill="#555555"/>' +
		'</svg>',

    subfolder: '<svg  width="40" height="40" viewBox="0 0 40 40" fill="none">' +
		'<rect x="0.7" y="0.7" width="38.6" height="38.6" rx="19.3" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4"/>' +
		'<path d="M28.2 15.6733V18.4667H11.8V13.0067C11.8 12.9091 11.8669 12.8667 11.906 12.8667H18.5C18.539 12.8667 18.606 12.9092 18.606 13.0067V15.3333V15.5333H18.806H28.094C28.1331 15.5333 28.2 15.5758 28.2 15.6733ZM28.094 14.4667H19.606V13.0067C19.606 12.3616 19.1296 11.8 18.5 11.8H11.906C11.2764 11.8 10.8 12.3612 10.8 13.0067V18.6667V19.3333V27.66C10.8 28.3051 11.2764 28.8667 11.906 28.8667H28.094C28.7232 28.8667 29.2 28.3055 29.2 27.66V19.3333V18.6667V15.6733C29.2 15.0279 28.7236 14.4667 28.094 14.4667ZM28.2 27.66C28.2 27.7576 28.1331 27.8 28.094 27.8H11.906C11.8669 27.8 11.8 27.7576 11.8 27.66V19.5333H28.2V27.66Z" fill="#ACADC1" stroke="#ACADC1" stroke-width="0.4"/>' +
		'<path d="M19.5667 24.36V24.2H30.433C30.4332 24.2011 30.4333 24.2025 30.4333 24.204V24.36H19.5667ZM30.4463 23.4H24.337V22.604C24.337 22.1773 24.0153 21.8 23.5833 21.8H19.5537C19.1218 21.8 18.8 22.1771 18.8 22.604V26V26.4V31.396C18.8 31.8227 19.1217 32.2 19.5537 32.2H30.4463C30.878 32.2 31.2 31.823 31.2 31.396V26.4V26V24.204C31.2 23.7771 30.8783 23.4 30.4463 23.4Z" fill="#ACADC1" stroke="#ACADC1" stroke-width="0.4"/>' +
		'</svg>',

    search: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="0 0 18 19" fill="none" >' +
		'<path d="M12.8812 11.6585L12.5653 12.0625H13.0781H13.6512C13.8108 12.0625 13.9614 12.1247 14.072 12.2354L17.5762 15.7395C17.5763 15.7397 17.5765 15.7398 17.5767 15.74C17.8066 15.9729 17.8064 16.3494 17.5736 16.5822L16.5787 17.5771L16.5777 17.5781C16.3492 17.8091 15.9738 17.8105 15.7404 17.5771L12.2354 14.0721C12.1247 13.9614 12.0625 13.8108 12.0625 13.6512V13.0781V12.5653L11.6585 12.8812C10.46 13.8182 8.95292 14.375 7.3125 14.375C3.41112 14.375 0.25 11.2139 0.25 7.3125C0.25 3.41112 3.41112 0.25 7.3125 0.25C11.2139 0.25 14.375 3.41112 14.375 7.3125C14.375 8.95292 13.8182 10.46 12.8812 11.6585ZM2.5625 7.3125C2.5625 9.93976 4.68901 12.0625 7.3125 12.0625C9.93976 12.0625 12.0625 9.93599 12.0625 7.3125C12.0625 4.68524 9.93599 2.5625 7.3125 2.5625C4.68524 2.5625 2.5625 4.68901 2.5625 7.3125Z" fill="#6f708b" stroke="#acadc1" stroke-width="0.5"/>' +
		'</svg>',

    search_close: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="0 0 14 14" fill="none" >' +
		'<path d="M14 1.41L12.59 0L7 5.59L1.41 0L0 1.41L5.59 7L0 12.59L1.41 14L7 8.41L12.59 14L14 12.59L8.41 7L14 1.41Z" fill="black" fill-opacity="0.7" />' +
		'<path d="M8.37464 7.03536L13.9293 12.59L12.59 13.9293L7.03536 8.37464L7 8.33929L6.96464 8.37464L1.41 13.9293L0.0707109 12.59L5.62536 7.03536L5.66071 7L5.62536 6.96464L0.0707107 1.41L1.41 0.0707107L6.96464 5.62536L7 5.66071L7.03536 5.62536L12.59 0.0707109L13.9293 1.41L8.37464 6.96464L8.33929 7L8.37464 7.03536Z" stroke="black" stroke-opacity="0.7" stroke-width="0.1" />' +
		'</svg>',

    unpublish: '<svg width="18" height="18" viewBox="0 0 18 18" fill="none" >' +
		'<rect x="1" y="4" width="16" height="1.5" fill="#FFFFFF"/>' +
		'<path d="M13.0699 13.1582L13.143 13.0868L13.0699 13.0153L12.3342 12.2955L12.2643 12.2271L12.1944 12.2955L9.62021 14.8139V8V7.9H9.52021L8.47979 7.9H8.37979V8V14.8139L5.80564 12.2955L5.73571 12.2271L5.66577 12.2955L4.93007 13.0153L4.857 13.0868L4.93007 13.1582L8.93007 17.0715L9 17.1399L9.06993 17.0715L13.0699 13.1582Z" fill="#FFFFFF" stroke="#FFFFFF" stroke-width="0.2"/>' +
		'<path fill-rule="evenodd" clip-rule="evenodd" d="M2 1.5H16C16.2761 1.5 16.5 1.72386 16.5 2V14C16.5 14.2761 16.2761 14.5 16 14.5H14V16H16C17.1046 16 18 15.1046 18 14V2C18 0.895431 17.1046 0 16 0H2C0.895431 0 0 0.895431 0 2V14C0 15.1046 0.89543 16 2 16H4V14.5H2C1.72386 14.5 1.5 14.2761 1.5 14V2C1.5 1.72386 1.72386 1.5 2 1.5Z" fill="#FFFFFF"/>' +
		'</svg>',

    publish: '<svg width="18" height="18" viewBox="0 0 18 18" fill="none" >' +
		'<path d="M4.93007 11.8418L4.857 11.9132L4.93007 11.9847L5.66577 12.7045L5.73571 12.7729L5.80564 12.7045L8.37979 10.1861V17V17.1H8.47979H9.52021H9.62021V17V10.1861L12.1944 12.7045L12.2643 12.7729L12.3342 12.7045L13.0699 11.9847L13.143 11.9132L13.0699 11.8418L9.06993 7.92852L9 7.8601L8.93007 7.92852L4.93007 11.8418Z" fill="#FFFFFF" stroke="#FFFFFF" stroke-width="0.2"/>' +
		'<rect x="1" y="4" width="16" height="1.5" fill="#FFFFFF"/>' +
		'<path fill-rule="evenodd" clip-rule="evenodd" d="M2 1.5H16C16.2761 1.5 16.5 1.72386 16.5 2V14C16.5 14.2761 16.2761 14.5 16 14.5H14V16H16C17.1046 16 18 15.1046 18 14V2C18 0.895431 17.1046 0 16 0H2C0.895431 0 0 0.895431 0 2V14C0 15.1046 0.89543 16 2 16H4V14.5H2C1.72386 14.5 1.5 14.2761 1.5 14V2C1.5 1.72386 1.72386 1.5 2 1.5Z" fill="#FFFFFF"/>' +
		'</svg>',

    help_center: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" overflow="visible" preserveAspectRatio="none" viewBox="0 0 514 514">' +
		'<g transform="translate(1, 1)">' +
		'<path d="M256 340c-15.464 0-28 12.536-28 28s12.536 28 28 28 28-12.536 28-28-12.536-28-28-28zm7.67-24h-16c-6.627 0-12-5.373-12-12v-.381c0-70.343 77.44-63.619 77.44-107.408 0-20.016-17.761-40.211-57.44-40.211-29.144 0-44.265 9.649-59.211 28.692-3.908 4.98-11.054 5.995-16.248 2.376l-13.134-9.15c-5.625-3.919-6.86-11.771-2.645-17.177C185.658 133.514 210.842 116 255.67 116c52.32 0 97.44 29.751 97.44 80.211 0 67.414-77.44 63.849-77.44 107.408V304c0 6.627-5.373 12-12 12zM256 40c118.621 0 216 96.075 216 216 0 119.291-96.61 216-216 216-119.244 0-216-96.562-216-216 0-119.203 96.602-216 216-216m0-32C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8z" vector-effect="non-scaling-stroke" fill="#454560" />' +
		'</g>' +
		'</svg>',

    navbar: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100"  width="23" height="17" viewBox="0 0 23 17" fill="none">' +
		'<path fill-rule="evenodd" clip-rule="evenodd" d="M1.25 2.5C0.559644 2.5 0 1.94036 0 1.25C0 0.559644 0.559645 0 1.25 0H21.25C21.9404 0 22.5 0.559644 22.5 1.25C22.5 1.94036 21.9404 2.5 21.25 2.5H1.25ZM0 8.5C0 9.19036 0.559645 9.75 1.25 9.75H21.25C21.9404 9.75 22.5 9.19036 22.5 8.5C22.5 7.80964 21.9404 7.25 21.25 7.25H1.25C0.559644 7.25 0 7.80964 0 8.5ZM0 15.75C0 16.4404 0.559645 17 1.25 17H21.25C21.9404 17 22.5 16.4404 22.5 15.75C22.5 15.0596 21.9404 14.5 21.25 14.5H1.25C0.559644 14.5 0 15.0596 0 15.75Z" fill="#454560"></path>' +
		'</svg>',

    filter_mplayer: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" width="32" height="32" viewBox="0 0 32 32" fill="none">' +
		'<rect class="mgPlayerJSTest_icon-bg" width="32" height="32" rx="4" />' +
		'<path d="M6.57328 10.28H7.99995C8.20163 10.8289 8.61116 11.2764 9.14005 11.5259C9.66895 11.7753 10.2748 11.8068 10.8266 11.6133C11.1338 11.5038 11.4128 11.3273 11.6434 11.0967C11.874 10.8661 12.0504 10.5871 12.1599 10.28H25.3733C25.5726 10.28 25.7639 10.2018 25.906 10.0621C26.0482 9.92244 26.1298 9.73254 26.1333 9.53329C26.1299 9.3328 26.0487 9.14148 25.9069 8.99968C25.7651 8.85789 25.5738 8.77672 25.3733 8.77329H12.2266C12.131 8.48997 11.9796 8.22867 11.7813 8.0048C11.5831 7.78092 11.3421 7.599 11.0724 7.46976C10.8027 7.34053 10.5099 7.26659 10.2112 7.25231C9.91256 7.23803 9.61404 7.2837 9.33328 7.38663C9.02836 7.50015 8.75146 7.678 8.52139 7.90807C8.29132 8.13814 8.11347 8.41504 7.99995 8.71996H6.57328C6.37404 8.72346 6.18414 8.80507 6.04448 8.94722C5.90482 9.08937 5.82658 9.28068 5.82661 9.47996C5.81928 9.58241 5.83316 9.68526 5.86738 9.7821C5.9016 9.87894 5.95544 9.96768 6.02552 10.0428C6.0956 10.1178 6.18042 10.1777 6.27467 10.2185C6.36892 10.2593 6.47057 10.2802 6.57328 10.28ZM10.1066 8.77329C10.3071 8.77672 10.4984 8.85789 10.6402 8.99968C10.782 9.14148 10.8632 9.3328 10.8666 9.53329C10.8631 9.73254 10.7815 9.92244 10.6394 10.0621C10.4972 10.2018 10.3059 10.28 10.1066 10.28C10.0063 10.2835 9.90637 10.2669 9.81268 10.231C9.71899 10.195 9.6335 10.1406 9.56132 10.0709C9.48913 10.0012 9.43174 9.9177 9.39256 9.82533C9.35338 9.73295 9.33322 9.63363 9.33328 9.53329C9.33327 9.43236 9.35336 9.33243 9.39238 9.23934C9.43141 9.14625 9.48858 9.06187 9.56057 8.99112C9.63256 8.92037 9.71793 8.86467 9.81168 8.82727C9.90543 8.78987 10.0057 8.77152 10.1066 8.77329ZM25.4266 15.2533H23.9999C23.8012 14.7022 23.392 14.2524 22.8622 14.0025C22.3323 13.7525 21.725 13.7229 21.1733 13.92C20.8652 14.0278 20.5853 14.2037 20.3545 14.4345C20.1237 14.6653 19.9478 14.9452 19.8399 15.2533H6.57328C6.37525 15.2533 6.18534 15.332 6.04531 15.472C5.90528 15.612 5.82661 15.8019 5.82661 16C5.82661 16.198 5.90528 16.3879 6.04531 16.5279C6.18534 16.668 6.37525 16.7466 6.57328 16.7466H19.7866C19.937 17.1859 20.2209 17.5672 20.5986 17.8371C20.9763 18.1071 21.429 18.2522 21.8933 18.2522C22.3576 18.2522 22.8102 18.1071 23.188 17.8371C23.5657 17.5672 23.8496 17.1859 23.9999 16.7466H25.4266C25.6246 16.7466 25.8146 16.668 25.9546 16.5279C26.0946 16.3879 26.1733 16.198 26.1733 16C26.1733 15.8019 26.0946 15.612 25.9546 15.472C25.8146 15.332 25.6246 15.2533 25.4266 15.2533ZM21.8933 16.7466C21.6953 16.7466 21.5053 16.668 21.3653 16.5279C21.2253 16.3879 21.1466 16.198 21.1466 16C21.1466 15.8019 21.2253 15.612 21.3653 15.472C21.5053 15.332 21.6953 15.2533 21.8933 15.2533C22.0913 15.2533 22.2812 15.332 22.4213 15.472C22.5613 15.612 22.6399 15.8019 22.6399 16C22.6399 16.198 22.5613 16.3879 22.4213 16.5279C22.2812 16.668 22.0913 16.7466 21.8933 16.7466ZM25.4266 21.72H15.2266C15.0728 21.2822 14.7869 20.9031 14.4083 20.6348C14.0298 20.3666 13.5772 20.2225 13.1133 20.2225C12.6493 20.2225 12.1968 20.3666 11.8182 20.6348C11.4397 20.9031 11.1538 21.2822 10.9999 21.72H6.57328C6.37525 21.72 6.18534 21.7986 6.04531 21.9387C5.90528 22.0787 5.82661 22.2686 5.82661 22.4666C5.82661 22.6647 5.90528 22.8546 6.04531 22.9946C6.18534 23.1346 6.37525 23.2133 6.57328 23.2133H10.9999C11.1436 23.6591 11.4249 24.0478 11.8035 24.3235C12.182 24.5992 12.6383 24.7478 13.1066 24.7478C13.5749 24.7478 14.0312 24.5992 14.4098 24.3235C14.7883 24.0478 15.0696 23.6591 15.2133 23.2133H25.4266C25.6246 23.2133 25.8146 23.1346 25.9546 22.9946C26.0946 22.8546 26.1733 22.6647 26.1733 22.4666C26.1733 22.2686 26.0946 22.0787 25.9546 21.9387C25.8146 21.7986 25.6246 21.72 25.4266 21.72ZM13.1066 23.2133C12.9086 23.2133 12.7187 23.1346 12.5786 22.9946C12.4386 22.8546 12.3599 22.6647 12.3599 22.4666C12.3599 22.2686 12.4386 22.0787 12.5786 21.9387C12.7187 21.7986 12.9086 21.72 13.1066 21.72C13.3059 21.7199 13.4972 21.7982 13.6394 21.9378C13.7815 22.0775 13.8631 22.2674 13.8666 22.4666C13.8631 22.6659 13.7815 22.8558 13.6394 22.9954C13.4972 23.1351 13.3059 23.2133 13.1066 23.2133Z" fill="#555555"/>' +
		'</svg>',

    replay_guide: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="0 0 423.73 390">' +
		'<g id="Layer_2" data-name="Layer 2">' +
		'<g id="transport">' +
		'<path d="M228.73,0C126.33,0,42.11,79.35,34.32,179.79H8.4a8.38,8.38,0,0,0-7,13l37.91,56.86a8.38,8.38,0,0,0,14,0l37.91-56.86a8.38,8.38,0,0,0-7-13H54.4C62.14,90.39,137.37,20,228.73,20c96.5,0,175,78.5,175,175s-78.5,175-175,175a174.75,174.75,0,0,1-133.9-62.32,10,10,0,1,0-15.3,12.88A194.71,194.71,0,0,0,228.73,390c107.53,0,195-87.48,195-195S336.26,0,228.73,0Z" />' +
		'<path d="M205.82,259.06,292,201.58a8.38,8.38,0,0,0,0-14l-86.22-57.48a8.38,8.38,0,0,0-13,7v115A8.38,8.38,0,0,0,205.82,259.06Z" />' +
		'</g>' +
		'</g>' +
		'</svg>',

    resume_guide: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" overflow="visible" preserveAspectRatio="none" viewBox="0 0 9.890675 10.000010000000001" width="9.890675" height="10.000010000000001">' +
		'<g transform="translate(0, 0)">' +
		'<g transform="translate(0, 0) rotate(0)">' +
		'<path d="M0.81549,0c-0.45038,0 -0.81549,0.36511 -0.81549,0.81549v8.36903c0,0.45038 0.36511,0.81549 0.81549,0.81549v0c0.45038,0 0.81549,-0.36511 0.81549,-0.81549v-8.36903c0,-0.45038 -0.36511,-0.81549 -0.81549,-0.81549zM4.82496,1.06482c-0.86323,-0.58808 -1.56302,-0.21807 -1.56302,0.82644v6.21747c0,1.04452 0.69979,1.41453 1.56302,0.82644l4.56323,-3.10874c0.66998,-0.45643 0.66998,-1.19645 0,-1.65289z" vector-effect="non-scaling-stroke" />' +
		'</g>' +
		'<defs>' +
		'<path id="path-1665396819818175" d="M0.81549,0c-0.45038,0 -0.81549,0.36511 -0.81549,0.81549v8.36903c0,0.45038 0.36511,0.81549 0.81549,0.81549v0c0.45038,0 0.81549,-0.36511 0.81549,-0.81549v-8.36903c0,-0.45038 -0.36511,-0.81549 -0.81549,-0.81549zM4.82496,1.06482c-0.86323,-0.58808 -1.56302,-0.21807 -1.56302,0.82644v6.21747c0,1.04452 0.69979,1.41453 1.56302,0.82644l4.56323,-3.10874c0.66998,-0.45643 0.66998,-1.19645 0,-1.65289z" vector-effect="non-scaling-stroke" />' +
		'</defs>' +
		'</g>' +
		'</svg>',

    branch_head_icon: '<svg width="26px" height="19px" viewBox="0 0 26 19" version="1.1" xmlns="https://www.w3.org/2000/svg" xmlns:xlink="https://www.w3.org/1999/xlink"><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" opacity="0.5"><g id="02-branching-Steps-in-Slideshow" transform="translate(-708.000000, -287.000000)" fill="#FFFFFF" fill-rule="nonzero"><g id="Group-17" transform="translate(721.000000, 296.375000) scale(1, -1) rotate(90.000000) translate(-721.000000, -296.375000) translate(712.000000, 284.000000)"><path d="M17.9743355,3.54499151 C17.9743355,5.50285655 16.387209,7.08998302 14.429344,7.08998302 C12.4714789,7.08998302 10.8843525,5.50285655 10.8843525,3.54499151 C10.8843525,1.58714746 12.4714885,-1.50990331e-14 14.429344,-1.50990331e-14 C16.3871994,-1.50990331e-14 17.9743355,1.58714746 17.9743355,3.54499151 Z M16.7519246,3.54499151 C16.7519246,2.26226437 15.7120786,1.22241087 14.429344,1.22241087 C13.1466093,1.22241087 12.1067633,2.26226437 12.1067633,3.54499151 C12.1067633,4.82773767 13.1465978,5.86757216 14.429344,5.86757216 C15.7120901,5.86757216 16.7519246,4.82773767 16.7519246,3.54499151 Z" id="Stroke-1"></path><polygon id="Stroke-3" points="2.93378608 6.47877759 4.15619694 6.47877759 4.15619694 18.2444822 2.93378608 18.2444822"></polygon><path d="M7.08998302,3.54499151 C7.08998302,5.50285655 5.50285655,7.08998302 3.54499151,7.08998302 C1.58712647,7.08998302 -1.03828057e-12,5.50285655 -1.03828057e-12,3.54499151 C-1.03828057e-12,1.58714746 1.58713604,-1.50990331e-14 3.54499151,-1.50990331e-14 C5.50284698,-1.50990331e-14 7.08998302,1.58714746 7.08998302,3.54499151 Z M5.86757216,3.54499151 C5.86757216,2.26226437 4.82772614,1.22241087 3.54499151,1.22241087 C2.26225689,1.22241087 1.22241087,2.26226437 1.22241087,3.54499151 C1.22241087,4.82773767 2.26224535,5.86757216 3.54499151,5.86757216 C4.82773767,5.86757216 5.86757216,4.82773767 5.86757216,3.54499151 Z" id="Stroke-5"></path><path d="M7.08998302,21.1782835 C7.08998302,23.1361276 5.50284698,24.723275 3.54499151,24.723275 C1.58713604,24.723275 -1.03828057e-12,23.1361276 -1.03828057e-12,21.1782835 C-1.03828057e-12,19.2204185 1.58712647,17.633292 3.54499151,17.633292 C5.50285655,17.633292 7.08998302,19.2204185 7.08998302,21.1782835 Z M5.86757216,21.1782835 C5.86757216,19.8955374 4.82773767,18.8557029 3.54499151,18.8557029 C2.26224535,18.8557029 1.22241087,19.8955374 1.22241087,21.1782835 C1.22241087,22.4610107 2.26225689,23.5008642 3.54499151,23.5008642 C4.82772614,23.5008642 5.86757216,22.4610107 5.86757216,21.1782835 Z" id="Stroke-7"></path><path d="M13.8181385,8.63838031 L13.8181385,6.47877759 L15.0405494,6.47877759 L15.0405494,8.63838031 C15.0405494,10.5962244 13.4534134,12.1833718 11.4955579,12.1833718 L6.4787837,12.1833718 L6.4787837,10.960961 L11.4955579,10.960961 C12.7782925,10.960961 13.8181385,9.92110745 13.8181385,8.63838031 Z M6.47877759,10.960961 L6.47877759,12.1833718 C5.19603143,12.1833718 4.15619694,13.2232063 4.15619694,14.5059525 L2.93378608,14.5059525 C2.93378608,12.5480874 4.52091255,10.960961 6.47877759,10.960961 Z" id="Combined-Shape"></path></g></g></g></svg>',
    down_arrow_icon: '<svg width="10px" height="10px" version="1.1" class="Layer_1" x="0px" y="0px" viewBox="0 0 386.257 386.257" style="enable-background:new 0 0 386.257 386.257;" xml:space="preserve">' +
		'<polygon points="0,96.879 193.129,289.379 386.257,96.879 "></polygon>' +
		'</svg>',

    captureEvents: '<svg version="1.2" overflow="visible" preserveAspectRatio="none" viewBox="0 0 514 514" width="14" height="14">' +
		'<g transform="translate(1, 1)">' +
		'<path d="M432 352H320c-26.5 0-48-21.5-48-48s21.5-48 48-48h96s96-107 96-160-43-96-96-96-96 43-96 96c0 34.6 40.9 92.2 69.3 128H320c-44.1 0-80 35.9-80 80s35.9 80 80 80h112c26.5 0 48 21.5 48 48s-21.5 48-48 48H122.7c28.4-35.8 69.3-93.4 69.3-128 0-53-43-96-96-96S0 299 0 352s96 160 96 160h336c44.1 0 80-35.9 80-80s-35.9-80-80-80zM352 96c0-35.3 28.7-64 64-64s64 28.7 64 64c0 20.4-30.1 68-64 110.4-34-42.6-64-90.6-64-110.4zM32 352c0-35.3 28.7-64 64-64s64 28.7 64 64c0 20.4-30.1 68-64 110.4-34-42.6-64-90.6-64-110.4zm64-16c-21.2 0-21.1 32 0 32 21.2 0 21.1-32 0-32zM416 80c-21.2 0-21.1 32 0 32 21.2 0 21.1-32 0-32z" vector-effect="non-scaling-stroke" />' +
		'</g>' +
		'</svg>',

    guide_bot_icon: '<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">' +
		'<rect x="0.7" y="0.7" width="38.6" height="38.6" rx="19.3" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4"></rect>' +
		'<path d="M18.034 24.483H17.9981L17.9704 24.5059L16.2745 25.9068V24.583V24.483H16.1745H14.234C13.3191 24.483 12.5553 23.7192 12.5553 22.8043V14.234C12.5553 13.3133 13.3247 12.4745 14.234 12.4745H22.7234C23.6355 12.4745 24.4021 13.2353 24.4021 14.234V15.8511V15.9511H24.5021H25.8766H25.9766V15.8511V14.234C25.9766 12.4001 24.4765 10.9 22.6426 10.9H14.234C12.4001 10.9 10.9 12.4001 10.9 14.234V22.7234C10.9 24.5557 12.399 26.0588 14.2363 25.9766H14.7V28.8681V29.0733L14.8616 28.9468L16.7212 27.4915L18.5536 26.0574H19.2468H19.3945L19.3397 25.9203C19.1823 25.5269 19.1043 25.1353 19.1043 24.7447V24.583V24.483H19.0043H18.9234H18.034Z" fill="#ACADC1" stroke="#ACADC1" stroke-width="0.2"/>' +
		'<path d="M27.8168 16.7404H21.9955C20.7827 16.7404 19.8125 17.7106 19.8125 18.9234V24.7447C19.8125 25.9574 20.7827 26.9277 21.9955 26.9277H24.9061L26.1189 27.8979L27.4125 28.9489V26.9277H27.8168C29.0295 26.9277 29.9997 25.9574 29.9997 24.7447V18.9234C29.9189 17.7106 28.9487 16.7404 27.8168 16.7404Z" fill="#ACADC1"/>' +
		'</svg>',

    guide_onboarding: '<svg width="40" height="40" viewBox="0 0 40 40" fill="none">' +
		'<rect x="0.7" y="0.7" width="38.6" height="38.6" rx="19.3" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4" />' +
		'<path d="M28.1938 12.9166C27.8336 12.7648 26.0037 11.9831 24.0812 12.0003C21.9125 12.0453 20.4312 12.8737 20 13.1451C19.5688 12.8737 18.0875 12.0453 15.9187 12.0024C14.0544 11.9684 12.1531 12.7723 11.8063 12.9187C11.325 13.1237 11 13.6593 11 14.2592V25.9072C11 26.6535 11.6312 27.2241 12.2887 26.9942C13.3156 26.6306 14.2787 26.4916 15.1519 26.4916C17.9612 26.4916 19.8331 27.9306 19.8575 27.9492C19.9461 28.0177 20.0557 28.0162 20.1417 27.9492C20.1662 27.9301 22.0379 26.4916 24.8473 26.4916C25.7204 26.4916 26.6836 26.6306 27.7104 26.9942C28.3188 27.2284 29 26.6499 29 25.9072V14.2592C29 13.6593 28.675 13.1237 28.1938 12.9166ZM19.5 26.4428C18.5981 25.9605 17.0963 25.348 15.1525 25.348C14.0938 25.348 13.0306 25.5343 12 25.9063V14.2592C12 14.1386 12.0629 14.0281 12.1538 13.9899C13.4688 13.4379 14.75 13.1451 15.9062 13.1451C17.825 13.1808 19.1313 13.9021 19.5 14.1378V26.4428ZM28 25.9072C26.9694 25.5352 25.9069 25.3489 24.8475 25.3489C22.9031 25.3489 21.4012 25.9613 20.5 26.4437V14.1378C20.8687 13.9021 22.175 13.1808 24.0938 13.1451C25.2463 13.1451 26.5325 13.4375 27.8444 13.9907C27.8813 14.0306 28 14.1378 28 14.2592V25.9072Z" fill="#ACADC1" stroke-width="0.2" />' +
		'</svg>',

    guide_beacon: '<svg width="12px" height="12px" viewBox="0 0 12 12" version="1.1"  >' +
		'<g class="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">' +
		'<g class="02-Guide-list-along-with-beacon_sample-2" transform="translate(-407.000000, -242.000000)">' +
		'<g class="Group" transform="translate(408.000000, 243.000000)">' +
		'<circle class="combined-shape" fill="#9476c9" cx="5" cy="5" r="4.375"></circle>' +
		'<circle class="Oval" stroke="#FFFFFF" stroke-width="2" cx="5" cy="5" r="5"></circle>' +
		'</g>' +
		'</g>' +
		'</g>' +
		'</svg>',

    play_teachme: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="0 0 17 17" version="1.1">' +
		'<g fill="#005BF0">' +
		'<path d="M2 3C2 3.39556 2.1173 3.78224 2.33706 4.11114C2.55683 4.44004 2.86918 4.69638 3.23463 4.84776C3.60009 4.99914 4.00222 5.03874 4.39018 4.96157C4.77814 4.8844 5.13451 4.69392 5.41421 4.41421C5.69392 4.13451 5.8844 3.77814 5.96157 3.39018C6.03874 3.00222 5.99914 2.60009 5.84776 2.23463C5.69638 1.86918 5.44004 1.55683 5.11114 1.33706C4.78225 1.1173 4.39556 1 4 1C3.46971 1.00045 2.96126 1.2113 2.58628 1.58628C2.21131 1.96125 2.00045 2.46971 2 3ZM5.15541 3C5.15541 3.22852 5.08764 3.4519 4.96069 3.64191C4.83373 3.83191 4.65328 3.98001 4.44216 4.06746C4.23103 4.15491 3.99872 4.17778 3.77459 4.13321C3.55046 4.08863 3.34459 3.97858 3.18301 3.817C3.02142 3.65541 2.91138 3.44954 2.8668 3.22541C2.82222 3.00128 2.8451 2.76897 2.93255 2.55785C3.02 2.34672 3.16809 2.16627 3.35809 2.03931C3.5481 1.91236 3.77148 1.84459 4 1.84459C4.30629 1.84504 4.59992 1.96692 4.8165 2.1835C5.03308 2.40008 5.15496 2.69371 5.15541 3Z" fill="#005BF0" />' +
		'<path d="M2 3C2 3.39556 2.1173 3.78224 2.33706 4.11114C2.55683 4.44004 2.86918 4.69638 3.23463 4.84776C3.60009 4.99914 4.00222 5.03874 4.39018 4.96157C4.77814 4.8844 5.13451 4.69392 5.41421 4.41421C5.69392 4.13451 5.8844 3.77814 5.96157 3.39018C6.03874 3.00222 5.99914 2.60009 5.84776 2.23463C5.69638 1.86918 5.44004 1.55683 5.11114 1.33706C4.78225 1.1173 4.39556 1 4 1C3.46971 1.00045 2.96126 1.2113 2.58628 1.58628C2.21131 1.96125 2.00045 2.46971 2 3ZM5.15541 3C5.15541 3.22852 5.08764 3.4519 4.96069 3.64191C4.83373 3.83191 4.65328 3.98001 4.44216 4.06746C4.23103 4.15491 3.99872 4.17778 3.77459 4.13321C3.55046 4.08863 3.34459 3.97858 3.18301 3.817C3.02142 3.65541 2.91138 3.44954 2.8668 3.22541C2.82222 3.00128 2.8451 2.76897 2.93255 2.55785C3.02 2.34672 3.16809 2.16627 3.35809 2.03931C3.5481 1.91236 3.77148 1.84459 4 1.84459C4.30629 1.84504 4.59992 1.96692 4.8165 2.1835C5.03308 2.40008 5.15496 2.69371 5.15541 3Z" stroke="#005BF0" stroke-width="0.2" />' +
		'<path d="M1.35428 9.68552C1.37787 9.91784 1.45201 10.1407 1.57056 10.3356C1.6891 10.5306 1.84865 10.692 2.03598 10.8066L2.58986 15.214C2.61253 15.4302 2.70756 15.6298 2.85684 15.7748C3.00613 15.9197 3.19924 15.9999 3.39938 16H4.31968C4.52004 15.9998 4.71333 15.9195 4.86265 15.7742C5.01196 15.6289 5.10686 15.4289 5.12919 15.2124L5.40187 12.5115L5.94439 8.00227L6.55222 8.5474C6.72459 8.70216 6.94046 8.78807 7.16396 8.79087C7.38746 8.79368 7.60512 8.7132 7.7807 8.56284L9.61277 6.99232C9.80497 6.83121 9.93637 6.59922 9.98213 6.3401C10.0279 6.08096 9.98497 5.81257 9.8613 5.5855C9.78924 5.45726 9.69293 5.34708 9.57884 5.26224C9.46475 5.17739 9.33541 5.11979 9.19933 5.09324C9.06331 5.06668 8.9236 5.07178 8.78947 5.10818C8.65534 5.14458 8.52983 5.21147 8.42121 5.30444L7.18847 6.36072L5.94439 5.24421C5.7693 5.08697 5.54943 5.00072 5.32234 5.00022H4.75426C4.69118 4.99808 4.62849 5.01156 4.57091 5.03966C4.51334 5.06775 4.46239 5.10971 4.42193 5.16237L3.85385 5.92523L3.29997 5.17009C3.26139 5.11692 3.21218 5.07399 3.15608 5.04455C3.09998 5.01512 3.03845 4.99996 2.97616 5.00022H2.54016C2.32264 5.00034 2.10761 5.05053 1.90922 5.14749C1.71082 5.24445 1.53355 5.38598 1.38907 5.56278C1.24458 5.73958 1.13616 5.94763 1.07093 6.17326C1.00569 6.39889 0.985132 6.63697 1.01059 6.87187L1.35428 9.68552ZM1.92237 6.07503C1.99938 5.97815 2.09467 5.90043 2.20176 5.84714C2.30885 5.79385 2.42523 5.76623 2.543 5.76617H2.83556L3.47181 6.62942C3.5185 6.69314 3.5778 6.74456 3.64529 6.7799C3.71279 6.81531 3.78674 6.83367 3.86166 6.83367C3.93658 6.83367 4.01053 6.81531 4.07803 6.7799C4.14552 6.74456 4.20481 6.69314 4.25151 6.62942L4.88918 5.76463H5.32376C5.38599 5.76425 5.44635 5.78777 5.49419 5.83103L6.96408 7.15447C7.02725 7.20989 7.10594 7.24009 7.18705 7.24009C7.26822 7.24009 7.34691 7.20989 7.41003 7.15447L8.86858 5.90516C8.91592 5.86468 8.97452 5.8429 9.03474 5.84339C9.08098 5.84343 9.12637 5.85638 9.16667 5.88099C9.20696 5.90559 9.24078 5.94103 9.26482 5.98392C9.29753 6.04987 9.307 6.12649 9.29159 6.19949C9.27618 6.27251 9.23689 6.33694 9.18103 6.38079L7.34044 7.95594C7.29236 7.99661 7.23313 8.01874 7.17217 8.01874C7.1112 8.01874 7.05198 7.99661 7.00385 7.95594L5.90179 6.96607C5.85291 6.9222 5.79413 6.89332 5.73154 6.88251C5.66895 6.8717 5.60483 6.87925 5.54585 6.90447C5.48686 6.9297 5.43516 6.97162 5.39611 7.0259C5.35705 7.08018 5.33207 7.14481 5.32376 7.21315L4.69177 12.4204L4.42477 15.1275C4.42198 15.1553 4.40989 15.1811 4.39077 15.1999C4.37166 15.2187 4.34686 15.2292 4.3211 15.2294H3.39938C3.37244 15.2287 3.34671 15.2171 3.32726 15.1968C3.30782 15.1765 3.29605 15.149 3.29429 15.1198L2.71342 10.4947C2.70455 10.4256 2.67861 10.3603 2.63835 10.3059C2.59808 10.2515 2.545 10.21 2.48477 10.1859C2.36972 10.1404 2.26874 10.0608 2.19339 9.95593C2.11804 9.85104 2.07137 9.72521 2.05871 9.59286L1.70934 6.77767C1.69619 6.65064 1.70827 6.52206 1.74478 6.40057C1.78129 6.27909 1.84136 6.16755 1.92095 6.07348L1.92237 6.07503Z" fill="#005BF0" />' +
		'<path d="M1.35428 9.68552C1.37787 9.91784 1.45201 10.1407 1.57056 10.3356C1.6891 10.5306 1.84865 10.692 2.03598 10.8066L2.58986 15.214C2.61253 15.4302 2.70756 15.6298 2.85684 15.7748C3.00613 15.9197 3.19924 15.9999 3.39938 16H4.31968C4.52004 15.9998 4.71333 15.9195 4.86265 15.7742C5.01196 15.6289 5.10686 15.4289 5.12919 15.2124L5.40187 12.5115L5.94439 8.00227L6.55222 8.5474C6.72459 8.70216 6.94046 8.78807 7.16396 8.79087C7.38746 8.79368 7.60512 8.7132 7.7807 8.56284L9.61277 6.99232C9.80497 6.83121 9.93637 6.59922 9.98213 6.3401C10.0279 6.08096 9.98497 5.81257 9.8613 5.5855C9.78924 5.45726 9.69293 5.34708 9.57884 5.26224C9.46475 5.17739 9.33541 5.11979 9.19933 5.09324C9.06331 5.06668 8.9236 5.07178 8.78947 5.10818C8.65534 5.14458 8.52983 5.21147 8.42121 5.30444L7.18847 6.36072L5.94439 5.24421C5.7693 5.08697 5.54943 5.00072 5.32234 5.00022H4.75426C4.69118 4.99808 4.62849 5.01156 4.57091 5.03966C4.51334 5.06775 4.46239 5.10971 4.42193 5.16237L3.85385 5.92523L3.29997 5.17009C3.26139 5.11692 3.21218 5.07399 3.15608 5.04455C3.09998 5.01512 3.03845 4.99996 2.97616 5.00022H2.54016C2.32264 5.00034 2.10761 5.05053 1.90922 5.14749C1.71082 5.24445 1.53355 5.38598 1.38907 5.56278C1.24458 5.73958 1.13616 5.94763 1.07093 6.17326C1.00569 6.39889 0.985132 6.63697 1.01059 6.87187L1.35428 9.68552ZM1.92237 6.07503C1.99938 5.97815 2.09467 5.90043 2.20176 5.84714C2.30885 5.79385 2.42523 5.76623 2.543 5.76617H2.83556L3.47181 6.62942C3.5185 6.69314 3.5778 6.74456 3.64529 6.7799C3.71279 6.81531 3.78674 6.83367 3.86166 6.83367C3.93658 6.83367 4.01053 6.81531 4.07803 6.7799C4.14552 6.74456 4.20481 6.69314 4.25151 6.62942L4.88918 5.76463H5.32376C5.38599 5.76425 5.44635 5.78777 5.49419 5.83103L6.96408 7.15447C7.02725 7.20989 7.10594 7.24009 7.18705 7.24009C7.26822 7.24009 7.34691 7.20989 7.41003 7.15447L8.86858 5.90516C8.91592 5.86468 8.97452 5.8429 9.03474 5.84339C9.08098 5.84343 9.12637 5.85638 9.16667 5.88099C9.20696 5.90559 9.24078 5.94103 9.26482 5.98392C9.29753 6.04987 9.307 6.12649 9.29159 6.19949C9.27618 6.27251 9.23689 6.33694 9.18103 6.38079L7.34044 7.95594C7.29236 7.99661 7.23313 8.01874 7.17217 8.01874C7.1112 8.01874 7.05198 7.99661 7.00385 7.95594L5.90179 6.96607C5.85291 6.9222 5.79413 6.89332 5.73154 6.88251C5.66895 6.8717 5.60483 6.87925 5.54585 6.90447C5.48686 6.9297 5.43516 6.97162 5.39611 7.0259C5.35705 7.08018 5.33207 7.14481 5.32376 7.21315L4.69177 12.4204L4.42477 15.1275C4.42198 15.1553 4.40989 15.1811 4.39077 15.1999C4.37166 15.2187 4.34686 15.2292 4.3211 15.2294H3.39938C3.37244 15.2287 3.34671 15.2171 3.32726 15.1968C3.30782 15.1765 3.29605 15.149 3.29429 15.1198L2.71342 10.4947C2.70455 10.4256 2.67861 10.3603 2.63835 10.3059C2.59808 10.2515 2.545 10.21 2.48477 10.1859C2.36972 10.1404 2.26874 10.0608 2.19339 9.95593C2.11804 9.85104 2.07137 9.72521 2.05871 9.59286L1.70934 6.77767C1.69619 6.65064 1.70827 6.52206 1.74478 6.40057C1.78129 6.27909 1.84136 6.16755 1.92095 6.07348L1.92237 6.07503Z" stroke="#005BF0" stroke-width="0.2" />' +
		'<path d="M7 2.35418V4.9043C7 4.99823 7.03947 5.08832 7.10976 5.15474C7.18005 5.22116 7.27537 5.25848 7.37475 5.25848C7.47413 5.25848 7.56945 5.22116 7.63974 5.15474C7.71003 5.08832 7.7495 4.99823 7.7495 4.9043V2.70695H15.2565V9.6617H7.37475C7.27537 9.6617 7.18005 9.699 7.10976 9.76543C7.03947 9.83186 7 9.9219 7 10.0159C7 10.1098 7.03947 10.1999 7.10976 10.2663C7.18005 10.3328 7.27537 10.3701 7.37475 10.3701H11.1223V12.7275H8.78081C8.68116 12.7275 8.58339 12.7532 8.49806 12.8019C8.41272 12.8506 8.34305 12.9204 8.29664 13.0038L7.46169 14.48C7.43865 14.5211 7.42444 14.5661 7.41978 14.6124C7.41517 14.6587 7.42022 14.7055 7.43471 14.7499C7.4492 14.7944 7.4728 14.8357 7.50416 14.8716C7.53553 14.9074 7.57412 14.9371 7.61759 14.9589C7.66111 14.9806 7.70869 14.9941 7.75772 14.9984C7.80674 15.0028 7.85615 14.998 7.90323 14.9844C7.95026 14.9707 7.994 14.9484 8.03192 14.9187C8.06984 14.889 8.10121 14.8526 8.12425 14.8115L8.89474 13.4373H14.1038L14.8742 14.8115C14.8973 14.8526 14.9287 14.889 14.9666 14.9187C15.0045 14.9484 15.0482 14.9707 15.0953 14.9844C15.1423 14.998 15.1918 15.0028 15.2408 14.9984C15.2898 14.9941 15.3374 14.9806 15.3809 14.9589C15.4244 14.9371 15.463 14.9074 15.4943 14.8716C15.5257 14.8357 15.5493 14.7944 15.5638 14.7499C15.5783 14.7055 15.5833 14.6587 15.5787 14.6124C15.5741 14.5661 15.5598 14.5211 15.5368 14.48L14.7094 13.0038C14.6629 12.9204 14.5933 12.8506 14.508 12.8019C14.4227 12.7532 14.3248 12.7275 14.2252 12.7275H11.8777V10.3701H15.6252C15.7246 10.3701 15.82 10.3328 15.8902 10.2663C15.9605 10.1999 16 10.1098 16 10.0159V2.35418C16 2.26025 15.9605 2.17016 15.8902 2.10374C15.82 2.03732 15.7246 2 15.6252 2H7.37475C7.27537 2 7.18005 2.03732 7.10976 2.10374C7.03947 2.17016 7 2.26025 7 2.35418Z" fill="#005BF0" />' +
		'<path d="M7 2.35418V4.9043C7 4.99823 7.03947 5.08832 7.10976 5.15474C7.18005 5.22116 7.27537 5.25848 7.37475 5.25848C7.47413 5.25848 7.56945 5.22116 7.63974 5.15474C7.71003 5.08832 7.7495 4.99823 7.7495 4.9043V2.70695H15.2565V9.6617H7.37475C7.27537 9.6617 7.18005 9.699 7.10976 9.76543C7.03947 9.83186 7 9.9219 7 10.0159C7 10.1098 7.03947 10.1999 7.10976 10.2663C7.18005 10.3328 7.27537 10.3701 7.37475 10.3701H11.1223V12.7275H8.78081C8.68116 12.7275 8.58339 12.7532 8.49806 12.8019C8.41272 12.8506 8.34305 12.9204 8.29664 13.0038L7.46169 14.48C7.43865 14.5211 7.42444 14.5661 7.41978 14.6124C7.41517 14.6587 7.42022 14.7055 7.43471 14.7499C7.4492 14.7944 7.4728 14.8357 7.50416 14.8716C7.53553 14.9074 7.57412 14.9371 7.61759 14.9589C7.66111 14.9806 7.70869 14.9941 7.75772 14.9984C7.80674 15.0028 7.85615 14.998 7.90323 14.9844C7.95026 14.9707 7.994 14.9484 8.03192 14.9187C8.06984 14.889 8.10121 14.8526 8.12425 14.8115L8.89474 13.4373H14.1038L14.8742 14.8115C14.8973 14.8526 14.9287 14.889 14.9666 14.9187C15.0045 14.9484 15.0482 14.9707 15.0953 14.9844C15.1423 14.998 15.1918 15.0028 15.2408 14.9984C15.2898 14.9941 15.3374 14.9806 15.3809 14.9589C15.4244 14.9371 15.463 14.9074 15.4943 14.8716C15.5257 14.8357 15.5493 14.7944 15.5638 14.7499C15.5783 14.7055 15.5833 14.6587 15.5787 14.6124C15.5741 14.5661 15.5598 14.5211 15.5368 14.48L14.7094 13.0038C14.6629 12.9204 14.5933 12.8506 14.508 12.8019C14.4227 12.7532 14.3248 12.7275 14.2252 12.7275H11.8777V10.3701H15.6252C15.7246 10.3701 15.82 10.3328 15.8902 10.2663C15.9605 10.1999 16 10.1098 16 10.0159V2.35418C16 2.26025 15.9605 2.17016 15.8902 2.10374C15.82 2.03732 15.7246 2 15.6252 2H7.37475C7.27537 2 7.18005 2.03732 7.10976 2.10374C7.03947 2.17016 7 2.26025 7 2.35418Z" stroke="#005BF0" stroke-width="0.2" />' +
		'</g>' +
		'</svg>',

    play_testme: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="0 0 20 26" fill="none">' +
		'<path d="M1.54651 21.1221V5.72034H3.75581V6.61319C3.75581 7.05962 4.08721 7.39444 4.52907 7.39444H12.0407C12.4826 7.39444 12.814 7.05962 12.814 6.61319V5.72034H15.0233V12.0819V14.3141H16.5698V12.64V5.05069C16.5698 4.60426 16.2384 4.26944 15.7965 4.26944H12.814V3.37659C12.814 2.93016 12.4826 2.59534 12.0407 2.59534H11.157C10.936 0.921228 9.5 -0.194843 7.84302 0.0283712C6.51744 0.139978 5.52326 1.25605 5.30232 2.59534H4.52907C4.08721 2.59534 3.75581 2.93016 3.75581 3.37659V4.26944H0.773256C0.331395 4.26944 0 4.60426 0 5.05069V21.9034C0 22.3498 0.331395 22.6846 0.773256 22.6846H9.38953V21.1221H6.73837H1.54651ZM8.28488 1.47926C8.94767 1.47926 9.5 1.92569 9.72093 2.59534H6.84884C6.9593 1.92569 7.62209 1.47926 8.28488 1.47926ZM5.19186 4.15784H11.2674V5.83194H5.19186V4.15784Z" fill="#005BF0" />' +
		'<circle cx="12.5" cy="18.5" r="6.7" fill="white" stroke="#005BF0" stroke-width="1.6" />' +
		'<path d="M11.6804 20.9037C11.6136 20.9655 11.5224 21 11.4277 21C11.333 21 11.2419 20.9655 11.1751 20.9037L9.15707 19.047C8.94764 18.8544 8.94764 18.542 9.15707 18.3497L9.40975 18.1172C9.61924 17.9246 9.95844 17.9246 10.1679 18.1172L11.4277 19.2762L14.8321 16.1445C15.0416 15.9518 15.3812 15.9518 15.5902 16.1445L15.8429 16.377C16.0524 16.5696 16.0524 16.882 15.8429 17.0743L11.6804 20.9037Z" fill="#005BF0" />' +
		'</svg>',

    play_showme: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100"  viewBox="0 0 20 20">' +
		'<path class="mgPlayerJSTest_showme-path" fill="#005BF0" fill-rule="nonzero" d="M4.305 7.133a3.81 3.81 0 1 1 .095 7.619 3.81 3.81 0 0 1-.095-7.619zm0 6.667v.029a2.857 2.857 0 0 0 2.857-2.886A2.857 2.857 0 1 0 4.305 13.8zm11.39-6.667a3.857 3.857 0 0 1 3.81 3.81 3.81 3.81 0 1 1-3.81-3.81zm0 6.667v.029a2.857 2.857 0 0 0 2.857-2.886 2.857 2.857 0 1 0-2.857 2.857zM10 8.638a.838.838 0 1 1 0-1.676.838.838 0 0 1 0 1.676zm3.429-1.152A4.162 4.162 0 0 0 11.505 11c0 .512.098 1.02.285 1.495a2.181 2.181 0 0 0-3.58 0 4.143 4.143 0 0 0-1.639-5.01h1.277a2.181 2.181 0 0 1 4.304 0h1.277zM10 8.97c.61-.05 1.078-.56 1.076-1.171v-.095a.162.162 0 0 1 0-.067v-.076-.076a1.171 1.171 0 0 0-2.247 0v.152a.162.162 0 0 1 0 .067V7.8c0 .647.524 1.171 1.171 1.171z"/>' +
		'</svg>',

    default_guide: '<svg width="40" height="40" viewBox="0 0 40 40" fill="none">' +
		'<rect x="0.7" y="0.7" width="38.6" height="38.6" rx="19.3" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4"></rect>' +
		'<path d="M12 27.555C12 27.555 20.838 24.372 22.606 22.606C24.374 20.838 27.555 12 27.555 12C27.555 12 18.717 15.183 16.95 16.95C15.183 18.717 12 27.555 12 27.555ZM18.364 18.364L21.192 21.192C21.899 21.899 14.829 24.727 14.829 24.727C14.829 24.727 17.657 17.657 18.364 18.364Z" fill="#ACADC1" stroke="#ACADC1" stroke-width="0" />' +
		'</svg>',

    bell: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" width="18" height="21" viewBox="0 0 18 21" fill="none">' +
		'<path fill-rule="evenodd" clip-rule="evenodd" d="M14.868 17.08H3.34796V8.44001C3.34796 6.91236 3.95481 5.44728 5.03502 4.36707C6.11523 3.28686 7.58031 2.68001 9.10796 2.68001C10.6356 2.68001 12.1007 3.28686 13.1809 4.36707C14.2611 5.44728 14.868 6.91236 14.868 8.44001V17.08ZM16.788 17.08V8.44001C16.788 6.40315 15.9788 4.44971 14.5385 3.00943C13.0983 1.56915 11.1448 0.76001 9.10796 0.76001C7.07109 0.76001 5.11766 1.56915 3.67738 3.00943C2.2371 4.44971 1.42796 6.40315 1.42796 8.44001V17.08C1.17335 17.08 0.929169 17.1812 0.749134 17.3612C0.569099 17.5412 0.467957 17.7854 0.467957 18.04C0.467957 18.2946 0.569099 18.5388 0.749134 18.7188C0.929169 18.8989 1.17335 19 1.42796 19H7.18796C7.18796 19.2521 7.23762 19.5018 7.33411 19.7348C7.4306 19.9677 7.57202 20.1794 7.75031 20.3577C7.9286 20.5359 8.14026 20.6774 8.3732 20.7739C8.60615 20.8703 8.85582 20.92 9.10796 20.92C9.3601 20.92 9.60976 20.8703 9.84271 20.7739C10.0757 20.6774 10.2873 20.5359 10.4656 20.3577C10.6439 20.1794 10.7853 19.9677 10.8818 19.7348C10.9783 19.5018 11.028 19.2521 11.028 19H16.788C17.0426 19 17.2867 18.8989 17.4668 18.7188C17.6468 18.5388 17.748 18.2946 17.748 18.04C17.748 17.7854 17.6468 17.5412 17.4668 17.3612C17.2867 17.1812 17.0426 17.08 16.788 17.08Z" fill="#555555"/>' +
		'</svg>',

    close_push: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100"  viewBox="0 0 15 15" fill="none">' +
		'<path d="M15 1.51071L13.4893 0L7.5 5.98929L1.51071 0L0 1.51071L5.98929 7.5L0 13.4893L1.51071 15L7.5 9.01071L13.4893 15L15 13.4893L9.01071 7.5L15 1.51071Z" fill="#757575" />' +
		'</svg>',

    iconTaskList: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" width="33" height="32" viewBox="0 0 33 32" fill="none">' +
		'<rect x="0.5" width="32" height="32" rx="4" fill="#005BF0"/>' +
		'<path d="M10.6813 24.3808V10.6864H12.6546V11.4803C12.6546 11.8772 12.9506 12.1749 13.3453 12.1749H20.0546C20.4493 12.1749 20.7453 11.8772 20.7453 11.4803V10.6864H22.7187V16.3427V25.6832H23.7558C23.9459 25.6832 24.1 25.5291 24.1 25.339V16.839V10.0909C24.1 9.69401 23.804 9.39629 23.4093 9.39629H20.7453V8.60239C20.7453 8.20547 20.4493 7.90775 20.0546 7.90775H19.2653C19.0679 6.41922 17.7853 5.42688 16.3053 5.62532C15.1213 5.72458 14.2333 6.71694 14.036 7.90775H13.3453C12.9506 7.90775 12.6546 8.20547 12.6546 8.60239V9.39629H9.99063C9.59599 9.39629 9.29999 9.69401 9.29999 10.0909V25.0755C9.29999 25.4725 9.59599 25.7701 9.99063 25.7701H23.6473C23.8374 25.7701 23.9915 25.6161 23.9915 25.4259V24.3808H15.3186H10.6813ZM16.7 6.91539C17.292 6.91539 17.7853 7.31238 17.9826 7.90775H15.4173C15.516 7.31238 16.108 6.91539 16.7 6.91539ZM13.9373 9.29709H19.3639V10.7856H13.9373V9.29709Z" fill="white"/>' +
		'<path d="M12.4525 14.6216H20.8589V15.3904H12.4525V14.6216Z" fill="white" stroke="white" stroke-width="0.5"/>' +
		'<path d="M12.4525 17.7742H20.8589V18.5431H12.4525V17.7742Z" fill="white" stroke="white" stroke-width="0.5"/>' +
		'<path d="M12.4525 20.9265H20.8589V21.6954H12.4525V20.9265Z" fill="white" stroke="white" stroke-width="0.5"/>' +
		'</svg>',

    accessibility: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="0 0 27 26" fill="none">' +
		'<path d="M1.85718 13C1.85718 14.5759 2.16757 16.1363 2.77062 17.5922C3.37368 19.0481 4.25759 20.371 5.3719 21.4853C6.4862 22.5996 7.80907 23.4835 9.26498 24.0866C10.7209 24.6896 12.2813 25 13.8572 25C15.433 25 16.9935 24.6896 18.4494 24.0866C19.9053 23.4835 21.2282 22.5996 22.3425 21.4853C23.4568 20.371 24.3407 19.0481 24.9437 17.5922C25.5468 16.1363 25.8572 14.5759 25.8572 13C25.8572 11.4241 25.5468 9.86371 24.9437 8.4078C24.3407 6.95189 23.4568 5.62902 22.3425 4.51472C21.2282 3.40042 19.9053 2.5165 18.4494 1.91345C16.9935 1.31039 15.433 1 13.8572 1C12.2813 1 10.7209 1.31039 9.26498 1.91345C7.80907 2.5165 6.4862 3.40042 5.3719 4.51472C4.25759 5.62902 3.37368 6.95189 2.77062 8.4078C2.16757 9.86371 1.85718 11.4241 1.85718 13Z" stroke="#555555" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>' +
		'<path d="M11.1905 19L13.8572 15M13.8572 15L16.5238 19M13.8572 15V12.3333M13.8572 12.3333L17.8572 11M13.8572 12.3333L9.85718 11" stroke="#555555" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>' +
		'<path d="M13.8572 7.66658C14.2254 7.66658 14.5239 7.36811 14.5239 6.99992C14.5239 6.63173 14.2254 6.33325 13.8572 6.33325C13.489 6.33325 13.1906 6.63173 13.1906 6.99992C13.1906 7.36811 13.489 7.66658 13.8572 7.66658Z" fill="#555555" stroke="#555555" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>' +
		'</svg>',

    iconDownArrow: '<svg width="16" height="10" viewBox="0 0 16 10" fill="none" >' +
		'<path d="M7.77408 4.13342L7.63281 3.99247L7.49155 4.13342L1.89547 9.71731L0.415655 8.2375L7.63281 1.02034L14.85 8.2375L13.3702 9.71731L7.77408 4.13342Z" fill="black" stroke="white" stroke-width="0.4"/>' +
		'</svg>',

    iconUpArrow: '<svg width="16" height="10" viewBox="0 0 16 10" fill="none" >' +
		'<path d="M7.49155 6.60486L7.63281 6.74582L7.77408 6.60486L13.3702 1.02097L14.85 2.50078L7.63281 9.71794L0.415655 2.50078L1.89547 1.02097L7.49155 6.60486Z" fill="black" fill-opacity="0.7" stroke="white" stroke-width="0.4"/>' +
		'</svg>',

    tasklist:' <svg width="40" height="40" viewBox="0 0 58 58" fill="none" >'+
		'<g filter="url(#filter0_d_task_list_guide)">'+
		'<circle cx="29" cy="25" r="25" fill="#005BF0"/>'+
		'</g>'+
		'<path d="M20.0067 37.2828V17.3888H22.8733V18.5421C22.8733 19.1187 23.3033 19.5512 23.8767 19.5512H33.6233C34.1967 19.5512 34.6267 19.1187 34.6267 18.5421V17.3888H37.4934V25.6058V39.1747H39C39.2761 39.1747 39.5 38.9509 39.5 38.6747V26.3267V16.5238C39.5 15.9472 39.07 15.5147 38.4966 15.5147H34.6267V14.3614C34.6267 13.7848 34.1967 13.3523 33.6233 13.3523H32.4767C32.1899 11.1899 30.3266 9.74833 28.1766 10.0366C26.4566 10.1808 25.1667 11.6224 24.88 13.3523H23.8767C23.3033 13.3523 22.8733 13.7848 22.8733 14.3614V15.5147H19.0033C18.43 15.5147 18 15.9472 18 16.5238V38.292C18 38.8686 18.43 39.301 19.0033 39.301H38.8424C39.1186 39.301 39.3424 39.0772 39.3424 38.801V37.2828H26.7433H20.0067ZM28.75 11.9107C29.61 11.9107 30.3266 12.4874 30.6133 13.3523H26.8867C27.03 12.4874 27.89 11.9107 28.75 11.9107ZM24.7367 15.3706H32.6199V17.5329H24.7367V15.3706Z" fill="white"/>'+
		'<path d="M22.5796 23.1057H34.7917V24.2226H22.5796V23.1057Z" fill="white" stroke="white" stroke-width="0.5"/>'+
		'<path d="M22.5796 27.6852H34.7917V28.8022H22.5796V27.6852Z" fill="white" stroke="white" stroke-width="0.5"/>'+
		'<path d="M22.5796 32.2648H34.7917V33.3817H22.5796V32.2648Z" fill="white" stroke="white" stroke-width="0.5"/>'+
		'<defs>'+
		'<filter id="filter0_d_task_list_guide" x="0" y="0" width="58" height="58" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">'+
		'<feFlood flood-opacity="0" result="BackgroundImageFix"/>'+
		'<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"/>'+
		'<feOffset dy="4"/>'+
		'<feGaussianBlur stdDeviation="2"/>'+
		'<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>'+
		'<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>'+
		'<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow" result="shape"/>'+
		'</filter>'+
		'</defs>'+
		'</svg>',

    guideShowMe: '<svg width="40" height="40" viewBox="0 0 40 40" fill="none">' +
		'<rect x="0.7" y="0.7" width="38.6" height="38.6" rx="19.3" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4"></rect>' +
		'<path d="M25.1375 15.9427H23.1482C22.5161 15.359 21.3251 15 19.9999 15C18.6747 15 17.4837 15.359 16.8516 15.9427H14.8623C12.1812 15.9427 10 18.1985 10 20.9713C10 23.7441 12.1812 26 14.8623 26C17.5434 26 19.7246 23.7441 19.7246 20.9713C19.7246 20.9346 19.7242 20.8979 19.7235 20.8611H20.2764C20.2756 20.8979 20.2753 20.9346 20.2753 20.9713C20.2753 23.7441 22.4566 26 25.1377 26C27.8188 26 30 23.7441 30 20.9713C29.9999 18.1985 27.8186 15.9427 25.1375 15.9427ZM14.8623 23.9552C13.2715 23.9552 11.9772 22.6166 11.9772 20.9713C11.9772 19.3261 13.2715 17.9875 14.8623 17.9875C16.4532 17.9875 17.7475 19.3261 17.7475 20.9713C17.7475 22.6166 16.4532 23.9552 14.8623 23.9552ZM21.3065 17.89H18.6926C18.3824 17.89 18.1303 17.6286 18.1303 17.3077C18.1303 16.9869 18.3824 16.7254 18.6926 16.7254H21.3065C21.6173 16.7254 21.8695 16.9869 21.8695 17.3077C21.8695 17.6285 21.6173 17.89 21.3065 17.89ZM25.1375 23.9552C23.5466 23.9552 22.2523 22.6166 22.2523 20.9713C22.2523 19.3261 23.5466 17.9875 25.1375 17.9875C26.7282 17.9875 28.0226 19.3261 28.0226 20.9713C28.0226 22.6166 26.7283 23.9552 25.1375 23.9552Z" fill="#ACADC1" stroke-width="0" />' +
		'</svg>',

    guideDoItForMe: '<svg width="40" height="40" viewBox="0 0 40 40" fill="none">' +
		'<rect x="0.7" y="0.7" width="38.6" height="38.6" rx="19.3" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4"></rect>' +
		'<path d="M15.8441 24.4972C14.4834 24.4972 13.3803 25.652 13.3803 27.0765V29H14.6452V27.6678C14.6452 26.5993 15.4726 25.7332 16.4931 25.7332H23.5081C24.5287 25.7332 25.356 26.5993 25.356 27.6678V29H26.6211V27.0765C26.6211 25.652 25.518 24.4972 24.1573 24.4972H15.8441Z" fill="#ACADC1" stroke-width="0" />' +
		'<path d="M12 18.8136C12 18.1065 12.5475 17.5333 13.2229 17.5333H13.6867V20.0938H13.2229C12.5475 20.0938 12 19.5206 12 18.8136Z" fill="#ACADC1" stroke-width="0" />' +
		'<path d="M28 18.8136C28 18.1065 27.4525 17.5333 26.7771 17.5333H26.3133V20.0938H26.7771C27.4525 20.0938 28 19.5206 28 18.8136Z" fill="#ACADC1" stroke-width="0" />' +
		'<path d="M19.7887 18.8136C19.7887 19.5206 19.2412 20.0938 18.5659 20.0938C17.8905 20.0938 17.343 19.5206 17.343 18.8136C17.343 18.1065 17.8905 17.5333 18.5659 17.5333C19.2412 17.5333 19.7887 18.1065 19.7887 18.8136Z" fill="#ACADC1" stroke-width="0" />' +
		'<path d="M22.7414 18.8136C22.7414 19.5206 22.1939 20.0938 21.5186 20.0938C20.8432 20.0938 20.2957 19.5206 20.2957 18.8136C20.2957 18.1065 20.8432 17.5333 21.5186 17.5333C22.1939 17.5333 22.7414 18.1065 22.7414 18.8136Z" fill="#ACADC1" stroke-width="0" />' +
		'<path d="M19.494 13.1606C19.494 13.0894 19.5492 13.0317 19.6172 13.0317H20.7202C20.7882 13.0317 20.8434 13.0894 20.8434 13.1606V15.6804H19.494V13.1606Z" fill="#ACADC1" stroke-width="0" />' +
		'<path d="M18.4948 14.6198H17.279C15.9182 14.6198 14.8151 15.7746 14.8151 17.1992V20.5163C14.8151 21.9409 15.9182 23.0957 17.279 23.0957H22.7247C24.0855 23.0957 25.1886 21.9409 25.1886 20.5163V17.1992C25.1886 15.7746 24.0855 14.6198 22.7247 14.6198H21.8448V15.592H22.2026C23.2232 15.592 24.0505 16.4581 24.0505 17.5265V20.191C24.0505 21.2594 23.2232 22.1255 22.2026 22.1255H17.802C16.7815 22.1255 15.9541 21.2594 15.9541 20.191V17.5265C15.9541 16.4581 16.7815 15.592 17.802 15.592H18.4948V14.6198Z" fill="#ACADC1" stroke-width="0" />' +
		'<path d="M20.8434 11.7063C20.8434 12.0964 20.5413 12.4127 20.1687 12.4127C19.7961 12.4127 19.494 12.0964 19.494 11.7063C19.494 11.3162 19.7961 11 20.1687 11C20.5413 11 20.8434 11.3162 20.8434 11.7063Z" fill="#ACADC1" stroke-width="0" />' +
		'</svg>',

    guideTeachMe: '<svg width="40" height="40" viewBox="0 0 40 40" fill="none">' +
		'<rect x="0.7" y="0.7" width="38.6" height="38.6" rx="19.3" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4"></rect>' +
		'<path d="M13 15C13 15.3956 13.1173 15.7822 13.3371 16.1111C13.5568 16.44 13.8692 16.6964 14.2346 16.8478C14.6001 16.9991 15.0022 17.0387 15.3902 16.9616C15.7781 16.8844 16.1345 16.6939 16.4142 16.4142C16.6939 16.1345 16.8844 15.7781 16.9616 15.3902C17.0387 15.0022 16.9991 14.6001 16.8478 14.2346C16.6964 13.8692 16.44 13.5568 16.1111 13.3371C15.7822 13.1173 15.3956 13 15 13C14.4697 13.0004 13.9613 13.2113 13.5863 13.5863C13.2113 13.9613 13.0005 14.4697 13 15ZM16.1554 15C16.1554 15.2285 16.0876 15.4519 15.9607 15.6419C15.8337 15.8319 15.6533 15.98 15.4422 16.0675C15.231 16.1549 14.9987 16.1778 14.7746 16.1332C14.5505 16.0886 14.3446 15.9786 14.183 15.817C14.0214 15.6554 13.9114 15.4495 13.8668 15.2254C13.8222 15.0013 13.8451 14.769 13.9325 14.5578C14.02 14.3467 14.1681 14.1663 14.3581 14.0393C14.5481 13.9124 14.7715 13.8446 15 13.8446C15.3063 13.845 15.5999 13.9669 15.8165 14.1835C16.0331 14.4001 16.155 14.6937 16.1554 15Z" fill="#ACADC1" stroke-width="0.2" />' +
		'<path d="M13 15C13 15.3956 13.1173 15.7822 13.3371 16.1111C13.5568 16.44 13.8692 16.6964 14.2346 16.8478C14.6001 16.9991 15.0022 17.0387 15.3902 16.9616C15.7781 16.8844 16.1345 16.6939 16.4142 16.4142C16.6939 16.1345 16.8844 15.7781 16.9616 15.3902C17.0387 15.0022 16.9991 14.6001 16.8478 14.2346C16.6964 13.8692 16.44 13.5568 16.1111 13.3371C15.7822 13.1173 15.3956 13 15 13C14.4697 13.0004 13.9613 13.2113 13.5863 13.5863C13.2113 13.9613 13.0005 14.4697 13 15ZM16.1554 15C16.1554 15.2285 16.0876 15.4519 15.9607 15.6419C15.8337 15.8319 15.6533 15.98 15.4422 16.0675C15.231 16.1549 14.9987 16.1778 14.7746 16.1332C14.5505 16.0886 14.3446 15.9786 14.183 15.817C14.0214 15.6554 13.9114 15.4495 13.8668 15.2254C13.8222 15.0013 13.8451 14.769 13.9325 14.5578C14.02 14.3467 14.1681 14.1663 14.3581 14.0393C14.5481 13.9124 14.7715 13.8446 15 13.8446C15.3063 13.845 15.5999 13.9669 15.8165 14.1835C16.0331 14.4001 16.155 14.6937 16.1554 15Z" stroke="#ACADC1" stroke-width="0.2" />' +
		'<path d="M12.3543 21.6855C12.3779 21.9178 12.452 22.1407 12.5706 22.3356C12.6891 22.5306 12.8486 22.692 13.036 22.8066L13.5899 27.214C13.6125 27.4302 13.7076 27.6298 13.8568 27.7748C14.0061 27.9197 14.1992 27.9999 14.3994 28H15.3197C15.52 27.9998 15.7133 27.9195 15.8626 27.7742C16.012 27.6289 16.1069 27.4289 16.1292 27.2124L16.4019 24.5115L16.9444 20.0023L17.5522 20.5474C17.7246 20.7022 17.9405 20.7881 18.164 20.7909C18.3875 20.7937 18.6051 20.7132 18.7807 20.5628L20.6128 18.9923C20.805 18.8312 20.9364 18.5992 20.9821 18.3401C21.0279 18.081 20.985 17.8126 20.8613 17.5855C20.7892 17.4573 20.6929 17.3471 20.5788 17.2622C20.4648 17.1774 20.3354 17.1198 20.1993 17.0932C20.0633 17.0667 19.9236 17.0718 19.7895 17.1082C19.6553 17.1446 19.5298 17.2115 19.4212 17.3044L18.1885 18.3607L16.9444 17.2442C16.7693 17.087 16.5494 17.0007 16.3223 17.0002H15.7543C15.6912 16.9981 15.6285 17.0116 15.5709 17.0397C15.5133 17.0677 15.4624 17.1097 15.4219 17.1624L14.8538 17.9252L14.3 17.1701C14.2614 17.1169 14.2122 17.074 14.1561 17.0446C14.1 17.0151 14.0384 17 13.9762 17.0002H13.5402C13.3226 17.0003 13.1076 17.0505 12.9092 17.1475C12.7108 17.2444 12.5336 17.386 12.3891 17.5628C12.2446 17.7396 12.1362 17.9476 12.0709 18.1733C12.0057 18.3989 11.9851 18.637 12.0106 18.8719L12.3543 21.6855ZM12.9224 18.075C12.9994 17.9782 13.0947 17.9004 13.2018 17.8471C13.3088 17.7938 13.4252 17.7662 13.543 17.7662H13.8356L14.4718 18.6294C14.5185 18.6931 14.5778 18.7446 14.6453 18.7799C14.7128 18.8153 14.7867 18.8337 14.8617 18.8337C14.9366 18.8337 15.0105 18.8153 15.078 18.7799C15.1455 18.7446 15.2048 18.6931 15.2515 18.6294L15.8892 17.7646H16.3238C16.386 17.7642 16.4463 17.7878 16.4942 17.831L17.9641 19.1545C18.0273 19.2099 18.1059 19.2401 18.1871 19.2401C18.2682 19.2401 18.3469 19.2099 18.41 19.1545L19.8686 17.9052C19.9159 17.8647 19.9745 17.8429 20.0347 17.8434C20.081 17.8434 20.1264 17.8564 20.1667 17.881C20.207 17.9056 20.2408 17.941 20.2648 17.9839C20.2975 18.0499 20.307 18.1265 20.2916 18.1995C20.2762 18.2725 20.2369 18.3369 20.181 18.3808L18.3404 19.9559C18.2924 19.9966 18.2331 20.0187 18.1722 20.0187C18.1112 20.0187 18.052 19.9966 18.0038 19.9559L16.9018 18.9661C16.8529 18.9222 16.7941 18.8933 16.7315 18.8825C16.6689 18.8717 16.6048 18.8792 16.5458 18.9045C16.4869 18.9297 16.4352 18.9716 16.3961 19.0259C16.3571 19.0802 16.3321 19.1448 16.3238 19.2132L15.6918 24.4204L15.4248 27.1275C15.422 27.1553 15.4099 27.1811 15.3908 27.1999C15.3717 27.2187 15.3469 27.2292 15.3211 27.2294H14.3994C14.3724 27.2287 14.3467 27.2171 14.3273 27.1968C14.3078 27.1765 14.296 27.149 14.2943 27.1198L13.7134 22.4947C13.7046 22.4256 13.6786 22.3603 13.6383 22.3059C13.5981 22.2515 13.545 22.21 13.4848 22.1859C13.3697 22.1404 13.2687 22.0608 13.1934 21.9559C13.118 21.851 13.0714 21.7252 13.0587 21.5929L12.7093 18.7777C12.6962 18.6506 12.7083 18.5221 12.7448 18.4006C12.7813 18.2791 12.8414 18.1675 12.9209 18.0735L12.9224 18.075Z" fill="#ACADC1" stroke-width="0.2" />' +
		'<path d="M12.3543 21.6855C12.3779 21.9178 12.452 22.1407 12.5706 22.3356C12.6891 22.5306 12.8486 22.692 13.036 22.8066L13.5899 27.214C13.6125 27.4302 13.7076 27.6298 13.8568 27.7748C14.0061 27.9197 14.1992 27.9999 14.3994 28H15.3197C15.52 27.9998 15.7133 27.9195 15.8626 27.7742C16.012 27.6289 16.1069 27.4289 16.1292 27.2124L16.4019 24.5115L16.9444 20.0023L17.5522 20.5474C17.7246 20.7022 17.9405 20.7881 18.164 20.7909C18.3875 20.7937 18.6051 20.7132 18.7807 20.5628L20.6128 18.9923C20.805 18.8312 20.9364 18.5992 20.9821 18.3401C21.0279 18.081 20.985 17.8126 20.8613 17.5855C20.7892 17.4573 20.6929 17.3471 20.5788 17.2622C20.4648 17.1774 20.3354 17.1198 20.1993 17.0932C20.0633 17.0667 19.9236 17.0718 19.7895 17.1082C19.6553 17.1446 19.5298 17.2115 19.4212 17.3044L18.1885 18.3607L16.9444 17.2442C16.7693 17.087 16.5494 17.0007 16.3223 17.0002H15.7543C15.6912 16.9981 15.6285 17.0116 15.5709 17.0397C15.5133 17.0677 15.4624 17.1097 15.4219 17.1624L14.8538 17.9252L14.3 17.1701C14.2614 17.1169 14.2122 17.074 14.1561 17.0446C14.1 17.0151 14.0384 17 13.9762 17.0002H13.5402C13.3226 17.0003 13.1076 17.0505 12.9092 17.1475C12.7108 17.2444 12.5336 17.386 12.3891 17.5628C12.2446 17.7396 12.1362 17.9476 12.0709 18.1733C12.0057 18.3989 11.9851 18.637 12.0106 18.8719L12.3543 21.6855ZM12.9224 18.075C12.9994 17.9782 13.0947 17.9004 13.2018 17.8471C13.3088 17.7938 13.4252 17.7662 13.543 17.7662H13.8356L14.4718 18.6294C14.5185 18.6931 14.5778 18.7446 14.6453 18.7799C14.7128 18.8153 14.7867 18.8337 14.8617 18.8337C14.9366 18.8337 15.0105 18.8153 15.078 18.7799C15.1455 18.7446 15.2048 18.6931 15.2515 18.6294L15.8892 17.7646H16.3238C16.386 17.7642 16.4463 17.7878 16.4942 17.831L17.9641 19.1545C18.0273 19.2099 18.1059 19.2401 18.1871 19.2401C18.2682 19.2401 18.3469 19.2099 18.41 19.1545L19.8686 17.9052C19.9159 17.8647 19.9745 17.8429 20.0347 17.8434C20.081 17.8434 20.1264 17.8564 20.1667 17.881C20.207 17.9056 20.2408 17.941 20.2648 17.9839C20.2975 18.0499 20.307 18.1265 20.2916 18.1995C20.2762 18.2725 20.2369 18.3369 20.181 18.3808L18.3404 19.9559C18.2924 19.9966 18.2331 20.0187 18.1722 20.0187C18.1112 20.0187 18.052 19.9966 18.0038 19.9559L16.9018 18.9661C16.8529 18.9222 16.7941 18.8933 16.7315 18.8825C16.6689 18.8717 16.6048 18.8792 16.5458 18.9045C16.4869 18.9297 16.4352 18.9716 16.3961 19.0259C16.3571 19.0802 16.3321 19.1448 16.3238 19.2132L15.6918 24.4204L15.4248 27.1275C15.422 27.1553 15.4099 27.1811 15.3908 27.1999C15.3717 27.2187 15.3469 27.2292 15.3211 27.2294H14.3994C14.3724 27.2287 14.3467 27.2171 14.3273 27.1968C14.3078 27.1765 14.296 27.149 14.2943 27.1198L13.7134 22.4947C13.7046 22.4256 13.6786 22.3603 13.6383 22.3059C13.5981 22.2515 13.545 22.21 13.4848 22.1859C13.3697 22.1404 13.2687 22.0608 13.1934 21.9559C13.118 21.851 13.0714 21.7252 13.0587 21.5929L12.7093 18.7777C12.6962 18.6506 12.7083 18.5221 12.7448 18.4006C12.7813 18.2791 12.8414 18.1675 12.9209 18.0735L12.9224 18.075Z" stroke="#ACADC1" stroke-width="0.2" />' +
		'<path d="M18 14.3542V16.9043C18 16.9982 18.0395 17.0883 18.1098 17.1547C18.18 17.2212 18.2754 17.2585 18.3747 17.2585C18.4741 17.2585 18.5695 17.2212 18.6397 17.1547C18.71 17.0883 18.7495 16.9982 18.7495 16.9043V14.707H26.2565V21.6617H18.3747C18.2754 21.6617 18.18 21.699 18.1098 21.7654C18.0395 21.8319 18 21.9219 18 22.0159C18 22.1098 18.0395 22.1999 18.1098 22.2663C18.18 22.3328 18.2754 22.3701 18.3747 22.3701H22.1223V24.7275H19.7808C19.6812 24.7275 19.5834 24.7532 19.4981 24.8019C19.4127 24.8506 19.343 24.9204 19.2966 25.0038L18.4617 26.48C18.4387 26.5211 18.4244 26.5661 18.4198 26.6124C18.4152 26.6587 18.4202 26.7055 18.4347 26.7499C18.4492 26.7944 18.4728 26.8357 18.5042 26.8716C18.5355 26.9074 18.5741 26.9371 18.6176 26.9589C18.6611 26.9806 18.7087 26.9941 18.7577 26.9984C18.8067 27.0028 18.8562 26.998 18.9032 26.9844C18.9503 26.9707 18.994 26.9484 19.0319 26.9187C19.0698 26.889 19.1012 26.8526 19.1243 26.8115L19.8947 25.4373H25.1038L25.8742 26.8115C25.8973 26.8526 25.9287 26.889 25.9666 26.9187C26.0045 26.9484 26.0482 26.9707 26.0953 26.9844C26.1423 26.998 26.1918 27.0028 26.2408 26.9984C26.2898 26.9941 26.3374 26.9806 26.3809 26.9589C26.4244 26.9371 26.463 26.9074 26.4943 26.8716C26.5257 26.8357 26.5493 26.7944 26.5638 26.7499C26.5783 26.7055 26.5833 26.6587 26.5787 26.6124C26.5741 26.5661 26.5598 26.5211 26.5368 26.48L25.7094 25.0038C25.6629 24.9204 25.5933 24.8506 25.508 24.8019C25.4227 24.7532 25.3248 24.7275 25.2252 24.7275H22.8777V22.3701H26.6252C26.7246 22.3701 26.82 22.3328 26.8902 22.2663C26.9605 22.1999 27 22.1098 27 22.0159V14.3542C27 14.2602 26.9605 14.1702 26.8902 14.1037C26.82 14.0373 26.7246 14 26.6252 14H18.3747C18.2754 14 18.18 14.0373 18.1098 14.1037C18.0395 14.1702 18 14.2602 18 14.3542Z" fill="#ACADC1" stroke-width="0.2" />' +
		'<path d="M18 14.3542V16.9043C18 16.9982 18.0395 17.0883 18.1098 17.1547C18.18 17.2212 18.2754 17.2585 18.3747 17.2585C18.4741 17.2585 18.5695 17.2212 18.6397 17.1547C18.71 17.0883 18.7495 16.9982 18.7495 16.9043V14.707H26.2565V21.6617H18.3747C18.2754 21.6617 18.18 21.699 18.1098 21.7654C18.0395 21.8319 18 21.9219 18 22.0159C18 22.1098 18.0395 22.1999 18.1098 22.2663C18.18 22.3328 18.2754 22.3701 18.3747 22.3701H22.1223V24.7275H19.7808C19.6812 24.7275 19.5834 24.7532 19.4981 24.8019C19.4127 24.8506 19.343 24.9204 19.2966 25.0038L18.4617 26.48C18.4387 26.5211 18.4244 26.5661 18.4198 26.6124C18.4152 26.6587 18.4202 26.7055 18.4347 26.7499C18.4492 26.7944 18.4728 26.8357 18.5042 26.8716C18.5355 26.9074 18.5741 26.9371 18.6176 26.9589C18.6611 26.9806 18.7087 26.9941 18.7577 26.9984C18.8067 27.0028 18.8562 26.998 18.9032 26.9844C18.9503 26.9707 18.994 26.9484 19.0319 26.9187C19.0698 26.889 19.1012 26.8526 19.1243 26.8115L19.8947 25.4373H25.1038L25.8742 26.8115C25.8973 26.8526 25.9287 26.889 25.9666 26.9187C26.0045 26.9484 26.0482 26.9707 26.0953 26.9844C26.1423 26.998 26.1918 27.0028 26.2408 26.9984C26.2898 26.9941 26.3374 26.9806 26.3809 26.9589C26.4244 26.9371 26.463 26.9074 26.4943 26.8716C26.5257 26.8357 26.5493 26.7944 26.5638 26.7499C26.5783 26.7055 26.5833 26.6587 26.5787 26.6124C26.5741 26.5661 26.5598 26.5211 26.5368 26.48L25.7094 25.0038C25.6629 24.9204 25.5933 24.8506 25.508 24.8019C25.4227 24.7532 25.3248 24.7275 25.2252 24.7275H22.8777V22.3701H26.6252C26.7246 22.3701 26.82 22.3328 26.8902 22.2663C26.9605 22.1999 27 22.1098 27 22.0159V14.3542C27 14.2602 26.9605 14.1702 26.8902 14.1037C26.82 14.0373 26.7246 14 26.6252 14H18.3747C18.2754 14 18.18 14.0373 18.1098 14.1037C18.0395 14.1702 18 14.2602 18 14.3542Z" stroke="#ACADC1" stroke-width="0.2" />' +
		'</svg>',

    btnBackBreadcrumb: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" version="1.1" class="Capa_1" x="0px" y="0px" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50;" xml:space="preserve">' +
		'<path class="st0" d="M23,3.1c0.9-0.9,2.3-0.9,3.2,0c0.9,0.9,0.9,2.3,0,3.2L9.8,22.7h35.9c1.3,0,2.3,1,2.3,2.3s-1,2.3-2.3,2.3H9.8l16.4,16.4c0.9,0.9,0.9,2.4,0,3.2c-0.9,0.9-2.3,0.9-3.2,0L2.7,26.6c-0.9-0.9-0.9-2.3,0-3.2L23,3.1z"></path>' +
		'</svg>',

    guideViewDownload: '<svg  height="512pt" viewBox="0 0 512 512" width="512pt"><path d="m448 512h-384c-35.285156 0-64-28.714844-64-64v-85.332031c0-11.777344 9.558594-21.335938 21.332031-21.335938 11.777344 0 21.335938 9.558594 21.335938 21.335938v85.332031c0 11.753906 9.578125 21.332031 21.332031 21.332031h384c11.753906 0 21.332031-9.578125 21.332031-21.332031v-85.332031c0-11.777344 9.558594-21.335938 21.335938-21.335938 11.773437 0 21.332031 9.558594 21.332031 21.335938v85.332031c0 35.285156-28.714844 64-64 64zm0 0"/><path d="m356.414062 271.082031-85.332031 85.332031c-8.339843 8.34375-21.824219 8.34375-30.164062 0l-85.332031-85.332031c-6.101563-6.101562-7.9375-15.273437-4.632813-23.253906 3.308594-7.957031 11.09375-13.160156 19.714844-13.160156h64v-213.335938c0-11.773437 9.554687-21.332031 21.332031-21.332031s21.332031 9.558594 21.332031 21.332031v213.335938h64c8.621094 0 16.40625 5.203125 19.714844 13.160156 3.304687 7.980469 1.46875 17.152344-4.632813 23.253906zm0 0"/></svg>',
    noStep: '<svg width="349" height="264" viewBox="0 0 349 264" fill="none">' +
		'<path d="M236 84.4294C236 99.0289 224.123 110.906 209.523 110.906H154.078C142.455 110.906 133 101.451 133 89.8286C133 78.4008 142.141 69.0679 153.496 68.7589C151.915 54.2263 163.814 40.0938 179.828 40.0938C191.412 40.0938 201.5 47.5847 205 58.338C221.283 55.5334 236 68.1293 236 84.4294Z" fill="#F5FAFD"/>' +
		'<g clip-path="url(#clip0)">' +
		'<path d="M138 31.7742C138 36.3099 134.31 40 129.774 40H112.548C108.938 40 106 37.0625 106 33.4516C106 29.9012 108.84 27.0017 112.368 26.9057C111.876 22.3907 115.573 18 120.548 18C124.147 18 127.281 20.3273 128.369 23.6681C133.428 22.7968 138 26.7101 138 31.7742Z" fill="#F5FAFD"/>' +
		'</g>' +
		'<g clip-path="url(#clip1)">' +
		'<path d="M258 12.9073C258 16.0256 255.463 18.5625 252.345 18.5625H240.502C238.02 18.5625 236 16.5429 236 14.0605C236 11.6196 237.953 9.62615 240.378 9.56015C240.04 6.45611 242.582 3.4375 246.002 3.4375C248.476 3.4375 250.631 5.03751 251.379 7.33434C254.857 6.73528 258 9.42567 258 12.9073Z" fill="#F5FAFD"/>' +
		'</g>' +
		'<path opacity="0.2" d="M301.093 261.757C300.945 262.037 300.772 262.304 300.576 262.554C298.855 261.342 297.104 260.156 295.324 258.994C295.36 258.919 295.399 258.842 295.441 258.764C295.853 257.968 296.473 257.297 297.234 256.822C298.218 256.225 299.327 256.082 300.224 256.565C301.12 257.048 301.646 258.036 301.7 259.182C301.732 260.079 301.522 260.968 301.093 261.757V261.757Z" fill="#3F3D56"/>' +
		'<path opacity="0.2" d="M303.5 257.26C304.583 255.219 304.195 252.896 302.634 252.071C301.073 251.246 298.93 252.231 297.847 254.271C296.764 256.311 297.152 258.634 298.713 259.459C300.274 260.285 302.417 259.3 303.5 257.26Z" fill="#3F3D56"/>' +
		'<path opacity="0.2" d="M305.896 252.745C306.979 250.705 306.591 248.382 305.03 247.556C303.469 246.731 301.326 247.716 300.243 249.756C299.161 251.796 299.549 254.119 301.11 254.945C302.671 255.77 304.814 254.785 305.896 252.745Z" fill="#3F3D56"/>' +
		'<path opacity="0.2" d="M308.293 248.226C309.376 246.186 308.988 243.863 307.427 243.038C305.866 242.212 303.723 243.197 302.64 245.238C301.557 247.278 301.945 249.601 303.506 250.426C305.067 251.251 307.21 250.267 308.293 248.226Z" fill="#3F3D56"/>' +
		'<path opacity="0.2" d="M310.689 243.709C311.772 241.669 311.384 239.346 309.823 238.52C308.262 237.695 306.119 238.68 305.036 240.72C303.954 242.76 304.342 245.083 305.903 245.909C307.464 246.734 309.607 245.749 310.689 243.709Z" fill="#3F3D56"/>' +
		'<path d="M313.663 205.69C313.538 205 313.46 204.302 313.429 203.601L321.5 206.31L313.429 202.133C313.547 200.045 314.091 198.003 315.028 196.133C315.965 194.262 317.276 192.603 318.879 191.257L326.699 202.539L320.628 189.986C322.411 188.873 324.406 188.14 326.486 187.83C328.566 187.52 330.688 187.641 332.72 188.185C334.751 188.728 336.649 189.684 338.294 190.991C339.94 192.299 341.299 193.93 342.285 195.784C343.272 197.639 343.866 199.676 344.03 201.769C344.195 203.862 343.925 205.966 343.24 207.951C342.554 209.936 341.467 211.759 340.045 213.306C338.623 214.853 336.898 216.092 334.976 216.945C335.174 218.027 335.254 219.128 335.215 220.227L322.914 220.129L335.027 222.119C334.618 224.632 333.589 227.003 332.031 229.019C330.474 231.034 328.438 232.631 326.107 233.663C326.62 236.489 326.327 239.402 325.26 242.068C324.193 244.735 322.396 247.049 320.075 248.744C317.753 250.44 315 251.449 312.13 251.656C309.261 251.863 306.391 251.26 303.849 249.916C301.307 248.572 299.195 246.541 297.755 244.055C296.314 241.569 295.604 238.729 295.705 235.859C295.805 232.989 296.713 230.206 298.324 227.826C299.935 225.447 302.184 223.569 304.814 222.405C304.203 219.031 304.745 215.549 306.354 212.519C307.962 209.489 310.543 207.086 313.684 205.696L313.663 205.69Z" fill="#F5FAFD"/>' +
		'<path d="M333.42 226.839C331.814 229.873 329.231 232.278 326.087 233.666C326.601 236.492 326.307 239.404 325.241 242.071C324.174 244.738 322.377 247.052 320.055 248.747C317.733 250.443 314.98 251.452 312.111 251.659C309.242 251.866 306.372 251.263 303.829 249.919C301.287 248.575 299.175 246.544 297.735 244.058C296.295 241.572 295.584 238.732 295.685 235.862C295.786 232.992 296.694 230.208 298.305 227.829C299.916 225.45 302.165 223.571 304.795 222.408C304.2 219.15 334.227 225.32 333.42 226.839Z" fill="#F5FAFD"/>' +
		'<path opacity="0.2" d="M291.489 171.503C291.303 171.981 291.078 172.443 290.816 172.885C287.803 171.283 284.753 169.726 281.666 168.212C281.708 168.084 281.756 167.952 281.807 167.821C282.309 166.462 283.166 165.261 284.288 164.342C285.743 163.178 287.498 162.74 289.07 163.333C290.643 163.927 291.647 165.422 291.961 167.248C292.188 168.683 292.025 170.152 291.489 171.503Z" fill="#3F3D56"/>' +
		'<path opacity="0.2" d="M294.445 163.778C295.778 160.283 294.691 156.627 292.017 155.611C289.343 154.595 286.095 156.604 284.763 160.098C283.43 163.593 284.517 167.249 287.191 168.265C289.865 169.281 293.113 167.272 294.445 163.778Z" fill="#3F3D56"/>' +
		'<path opacity="0.2" d="M297.395 156.045C298.727 152.551 297.64 148.894 294.966 147.878C292.292 146.862 289.044 148.871 287.712 152.366C286.379 155.86 287.466 159.517 290.14 160.533C292.814 161.549 296.062 159.54 297.395 156.045Z" fill="#3F3D56"/>' +
		'<path opacity="0.2" d="M300.344 148.31C301.677 144.815 300.589 141.159 297.915 140.143C295.242 139.127 291.994 141.136 290.661 144.631C289.328 148.125 290.416 151.782 293.09 152.798C295.763 153.814 299.011 151.804 300.344 148.31Z" fill="#3F3D56"/>' +
		'<path opacity="0.2" d="M303.291 140.577C304.624 137.083 303.537 133.426 300.863 132.41C298.189 131.394 294.941 133.404 293.608 136.898C292.276 140.393 293.363 144.049 296.037 145.065C298.711 146.081 301.959 144.072 303.291 140.577Z" fill="#3F3D56"/>' +
		'<path d="M300.494 78.9265C300.153 77.835 299.889 76.7214 299.702 75.5935L313.219 78.3417L299.421 73.2154C299.194 69.8492 299.658 66.4724 300.785 63.2914C301.911 60.1104 303.675 57.1923 305.97 54.7156L320.785 71.267L308.529 52.3076C311.174 50.1753 314.23 48.6084 317.507 47.7041C320.783 46.7997 324.212 46.5773 327.578 47.0506C330.945 47.524 334.178 48.6829 337.077 50.4555C339.976 52.2281 342.48 54.5766 344.432 57.3551C346.384 60.1337 347.743 63.2831 348.424 66.6078C349.106 69.9326 349.096 73.3617 348.395 76.6825C347.694 80.0032 346.316 83.1446 344.348 85.9118C342.38 88.679 339.863 91.0128 336.954 92.7686C337.485 94.4692 337.831 96.2218 337.988 97.9963L318.208 100.285L338.066 101.076C337.911 105.194 336.73 109.209 334.63 112.756C332.53 116.304 329.576 119.274 326.037 121.396C327.423 125.831 327.531 130.567 326.349 135.061C325.166 139.555 322.741 143.627 319.35 146.81C315.96 149.994 311.74 152.161 307.174 153.064C302.608 153.967 297.879 153.57 293.529 151.917C289.178 150.265 285.381 147.424 282.571 143.719C279.761 140.015 278.052 135.596 277.639 130.968C277.226 126.34 278.125 121.689 280.235 117.547C282.344 113.405 285.579 109.939 289.568 107.545C287.908 102.242 288.081 96.5364 290.061 91.3443C292.041 86.1523 295.712 81.7755 300.485 78.9175L300.494 78.9265Z" fill="#F5FAFD"/>' +
		'<path opacity="0.1" d="M336.454 108.977C334.48 114.17 330.809 118.546 326.033 121.396C327.419 125.831 327.527 130.567 326.345 135.061C325.162 139.555 322.737 143.627 319.346 146.81C315.956 149.994 311.736 152.161 307.17 153.064C302.604 153.967 297.875 153.57 293.525 151.917C289.174 150.265 285.377 147.424 282.567 143.72C279.757 140.015 278.048 135.596 277.635 130.968C277.222 126.34 278.122 121.689 280.231 117.547C282.341 113.405 285.575 109.939 289.564 107.545C287.971 102.433 337.446 106.378 336.454 108.977Z" fill="#F5FAFD"/>' +
		'<g opacity="0.2">' +
		'<path opacity="0.2" d="M53.3216 197.226C53.4734 197.819 53.6733 198.397 53.9194 198.957C57.7058 197.507 61.535 196.114 65.4071 194.78C65.3742 194.622 65.3413 194.46 65.2995 194.296C64.9089 192.617 64.0761 191.071 62.8872 189.821C61.3387 188.233 59.333 187.457 57.4049 187.929C55.4768 188.4 54.0569 190.017 53.4143 192.121C52.9267 193.784 52.8947 195.547 53.3216 197.226V197.226Z" fill="#3F3D56"/>' +
		'<path opacity="0.2" d="M58.8947 194.022C62.2001 193.216 64.0233 189.062 62.9669 184.742C61.9105 180.423 58.3745 177.575 55.069 178.38C51.7636 179.186 49.9404 183.34 50.9968 187.66C52.0532 191.979 55.5892 194.827 58.8947 194.022Z" fill="#3F3D56"/>' +
		'<path opacity="0.2" d="M56.5548 184.461C59.8603 183.656 61.6835 179.501 60.627 175.182C59.5706 170.863 56.0346 168.014 52.7292 168.82C49.4237 169.625 47.6005 173.78 48.657 178.099C49.7134 182.418 53.2494 185.267 56.5548 184.461Z" fill="#3F3D56"/>' +
		'<path opacity="0.2" d="M54.2228 174.904C57.5283 174.098 59.3514 169.944 58.295 165.624C57.2386 161.305 53.7026 158.457 50.3971 159.262C47.0917 160.068 45.2685 164.222 46.3249 168.541C47.3814 172.861 50.9174 175.709 54.2228 174.904Z" fill="#3F3D56"/>' +
		'<path opacity="0.2" d="M51.8849 165.346C55.1904 164.54 57.0136 160.386 55.9571 156.067C54.9007 151.747 51.3647 148.899 48.0593 149.705C44.7538 150.51 42.9306 154.665 43.987 158.984C45.0435 163.303 48.5795 166.151 51.8849 165.346Z" fill="#3F3D56"/>' +
		'<path opacity="0.2" d="M56.371 86.6637C56.9363 85.4266 57.4138 84.1513 57.7998 82.8473L41.4457 84.0975L58.4844 80.0783C59.2509 76.1378 59.2033 72.0825 58.3444 68.161C57.4855 64.2396 55.8334 60.5344 53.4894 57.2728L33.5571 74.6507L50.8259 54.083C48.0216 51.168 44.6464 48.8602 40.9102 47.3032C37.1741 45.7462 33.1569 44.9732 29.1086 45.0325C25.0603 45.0917 21.0675 45.9818 17.3787 47.6475C13.6898 49.3131 10.3838 51.7187 7.66629 54.7144C4.94877 57.7102 2.87789 61.2321 1.58249 65.0611C0.287087 68.8901 -0.205124 72.9442 0.136476 76.9712C0.478076 80.9982 1.64618 84.9119 3.56812 88.4689C5.49005 92.026 8.12471 95.1502 11.3082 97.6472C10.4296 99.5742 9.76118 101.59 9.31435 103.66L32.3166 109.275L8.76731 107.282C8.34053 112.164 9.14014 117.076 11.0938 121.572C13.0474 126.068 16.0934 130.007 19.956 133.033C17.6617 138.064 16.832 143.638 17.5618 149.118C18.2916 154.598 20.5514 159.762 24.083 164.02C27.6145 168.278 32.2752 171.459 37.5321 173.198C42.789 174.936 48.4301 175.164 53.8102 173.853C59.1904 172.542 64.0925 169.747 67.9561 165.787C71.8197 161.826 74.4889 156.86 75.6585 151.457C76.828 146.054 76.4507 140.431 74.5698 135.231C72.6888 130.032 69.3801 125.466 65.0219 122.055C67.7611 116.041 68.3957 109.282 66.8235 102.865C65.2513 96.447 61.5637 90.7433 56.3531 86.6696L56.371 86.6637Z" fill="#0078D4"/>' +
		'<path opacity="0.1" d="M9.494 116.83C11.0532 123.253 14.7398 128.962 19.9563 133.032C17.662 138.064 16.8323 143.638 17.5621 149.118C18.2919 154.597 20.5517 159.762 24.0833 164.02C27.6148 168.278 32.2755 171.458 37.5324 173.197C42.7893 174.936 48.4304 175.163 53.8105 173.853C59.1907 172.542 64.0928 169.747 67.9564 165.786C71.82 161.826 74.4892 156.86 75.6588 151.457C76.8283 146.053 76.451 140.43 74.5701 135.231C72.6891 130.032 69.3804 125.466 65.0222 122.055C67.6766 116.242 8.71381 113.616 9.494 116.83Z" fill="#F5FAFD"/>' +
		'</g>' +
		'<path d="M315.753 78.9326H26.1735C25.8343 78.933 25.4985 79.0001 25.1853 79.13C24.8721 79.2599 24.5877 79.4501 24.3481 79.6898C24.1086 79.9295 23.9186 80.2139 23.7892 80.5268C23.6598 80.8398 23.5934 81.1751 23.5938 81.5136V258.423C23.5926 259.106 23.7262 259.782 23.9869 260.414C24.2477 261.045 24.6305 261.619 25.1135 262.103C25.5964 262.587 26.1702 262.971 26.8018 263.233C27.4335 263.496 28.1108 263.632 28.795 263.633H313.132C313.816 263.632 314.493 263.496 315.125 263.233C315.757 262.971 316.33 262.587 316.813 262.103C317.296 261.619 317.679 261.045 317.94 260.414C318.201 259.782 318.334 259.106 318.333 258.423V81.5136C318.333 81.1751 318.267 80.8398 318.138 80.5268C318.008 80.2139 317.818 79.9295 317.579 79.6898C317.339 79.4501 317.055 79.2599 316.741 79.13C316.428 79.0001 316.092 78.933 315.753 78.9326V78.9326Z" fill="url(#paint0_linear)"/>' +
		'<path d="M317.162 89.916V257.381C317.162 258.747 316.619 260.056 315.652 261.022C314.685 261.988 313.374 262.531 312.006 262.532H29.9739C28.6055 262.532 27.2932 261.989 26.3256 261.023C25.358 260.057 24.8145 258.747 24.8145 257.381V89.916H317.162Z" fill="white"/>' +
		'<path d="M259 88V263H310.835C312.47 263 314.038 262.456 315.194 261.489C316.35 260.521 317 259.208 317 257.839V88.015L259 88Z" fill="#F0F0F5"/>' +
		'<path d="M317.162 82.4741V89.9158H24.8145V82.4741C24.8145 81.7967 25.084 81.147 25.5639 80.668C26.0438 80.189 26.6946 79.9199 27.3732 79.9199H314.604C315.282 79.9199 315.933 80.189 316.413 80.668C316.893 81.147 317.162 81.7967 317.162 82.4741Z" fill="#EDEDF4"/>' +
		'<path opacity="0.8" d="M29.4476 86.0336C30.108 86.0336 30.6433 85.4992 30.6433 84.84C30.6433 84.1809 30.108 83.6465 29.4476 83.6465C28.7873 83.6465 28.252 84.1809 28.252 84.84C28.252 85.4992 28.7873 86.0336 29.4476 86.0336Z" fill="#FA5959"/>' +
		'<path opacity="0.8" d="M32.7348 86.0336C33.3951 86.0336 33.9305 85.4992 33.9305 84.84C33.9305 84.1809 33.3951 83.6465 32.7348 83.6465C32.0744 83.6465 31.5391 84.1809 31.5391 84.84C31.5391 85.4992 32.0744 86.0336 32.7348 86.0336Z" fill="#FED253"/>' +
		'<path opacity="0.8" d="M36.0238 86.0336C36.6842 86.0336 37.2195 85.4992 37.2195 84.84C37.2195 84.1809 36.6842 83.6465 36.0238 83.6465C35.3635 83.6465 34.8281 84.1809 34.8281 84.84C34.8281 85.4992 35.3635 86.0336 36.0238 86.0336Z" fill="#8CCF4D"/>' +
		'<path d="M268 105H312V114H268V105Z" fill="white"/>' +
		'<path d="M268 124H312V133H268V124Z" fill="white"/>' +
		'<path d="M268 143H312V153H268V143Z" fill="white"/>' +
		'<path d="M268 163H312V172H268V163Z" fill="white"/>' +
		'<path d="M268 182H312V191H268V182Z" fill="white"/>' +
		'<path d="M188 75.6506V74.457H186.206V75.6506H188Z" fill="url(#paint1_linear)"/>' +
		'<path opacity="0.1" d="M67.0273 210.016C67.1284 209.995 67.2329 209.996 67.3333 210.02C67.4337 210.045 67.5274 210.091 67.6073 210.156C67.7839 210.338 67.9132 210.561 67.9839 210.804C68.2904 211.564 68.7445 212.255 69.3201 212.839" fill="black"/>' +
		'<path d="M82 118H239V130H82V118Z" fill="#F0F0F5"/>' +
		'<path d="M82 155H239V167H82V155Z" fill="#F0F0F5"/>' +
		'<rect x="38" y="239" width="221" height="5" fill="#F0F0F5"/>' +
		'<path fill-rule="evenodd" clip-rule="evenodd" d="M184.678 192C184.678 190.343 183.335 189 181.678 189H116C114.343 189 113 190.343 113 192V226.959C113 228.616 114.343 229.959 116 229.959H142.581C143.377 229.959 144.14 230.275 144.702 230.838L147.744 233.879C148.915 235.051 150.815 235.051 151.986 233.879L155.028 230.838C155.591 230.275 156.354 229.959 157.149 229.959H181.678C183.335 229.959 184.678 228.616 184.678 226.959V192Z" fill="#F0F0F5"/>' +
		'<rect x="45.7" y="110.7" width="25.6" height="25.6" rx="12.8" stroke="#F0F0F5" stroke-width="1.4"/>' +
		'<path d="M53 129C53 129 59.25 126.749 60.5002 125.5C61.7505 124.25 64 118 64 118C64 118 57.75 120.251 56.5005 121.5C55.2509 122.75 53 129 53 129ZM57.5004 122.5L59.5003 124.5C60.0003 125 55.0006 127 55.0006 127C55.0006 127 57.0005 122 57.5004 122.5Z" fill="#F0F0F5"/>' +
		'<path d="M53 166C53 166 59.25 163.749 60.5002 162.5C61.7505 161.25 64 155 64 155C64 155 57.75 157.251 56.5005 158.5C55.2509 159.75 53 166 53 166ZM57.5004 159.5L59.5003 161.5C60.0003 162 55.0006 164 55.0006 164C55.0006 164 57.0005 159 57.5004 159.5Z" fill="#F0F0F5"/>' +
		'<path d="M143 215C143 215 149.25 212.749 150.5 211.5C151.75 210.25 154 204 154 204C154 204 147.75 206.251 146.5 207.5C145.251 208.75 143 215 143 215ZM147.5 208.5L149.5 210.5C150 211 145.001 213 145.001 213C145.001 213 147 208 147.5 208.5Z" fill="white"/>' +
		'<rect x="45.7" y="147.7" width="25.6" height="25.6" rx="12.8" stroke="#F0F0F5" stroke-width="1.4"/>' +
		'<rect x="135.7" y="196.7" width="25.6" height="25.6" rx="12.8" stroke="white" stroke-width="1.4"/>' +
		'<defs>' +
		'<linearGradient class="paint0_linear" x1="170.963" y1="263.633" x2="170.963" y2="78.9326" gradientUnits="userSpaceOnUse">' +
		'<stop stop-color="#808080" stop-opacity="0.25"/>' +
		'<stop offset="0.54" stop-color="#808080" stop-opacity="0.12"/>' +
		'<stop offset="1" stop-color="#808080" stop-opacity="0.1"/>' +
		'</linearGradient>' +
		'<linearGradient class="paint1_linear" x1="-1628.22" y1="775.14" x2="-1617.45" y2="775.14" gradientUnits="userSpaceOnUse">' +
		'<stop stop-color="#808080" stop-opacity="0.25"/>' +
		'<stop offset="0.54" stop-color="#808080" stop-opacity="0.12"/>' +
		'<stop offset="1" stop-color="#808080" stop-opacity="0.1"/>' +
		'</linearGradient>' +
		'<clipPath class="clip0">' +
		'<rect x="106" y="13" width="32" height="32" fill="white"/>' +
		'</clipPath>' +
		'<clipPath class="clip1">' +
		'<rect x="236" width="22" height="22" fill="white"/>' +
		'</clipPath>' +
		'</defs>' +
		'</svg>',

    fullscreen: '<svg version="1.1" class="Capa_1" x="0px" y="0px" viewBox="0 0 28.361 28.361" style="enable-background:new 0 0 28.361 28.361;" xml:space="preserve">' +
		'<g>' +
		'<g class="c115_arrows">' +
		'<path d="M28.36,19.595c0-0.868-0.665-1.57-1.491-1.57c-0.819,0.002-1.492,0.702-1.492,1.57v3.25l-6.018-6.021' +
		'c-0.582-0.583-1.524-0.583-2.106,0c-0.582,0.582-0.582,1.527,0,2.109l5.989,5.987h-3.235c-0.881,0.002-1.591,0.669-1.591,1.491' +
		'c0,0.824,0.71,1.49,1.591,1.49h6.761c0.881,0,1.59-0.665,1.593-1.49c-0.003-0.022-0.006-0.039-0.009-0.061' +
		'c0.003-0.028,0.009-0.058,0.009-0.087v-6.668H28.36z"/>' +
		'<path d="M9,16.824l-6.015,6.021v-3.25c0-0.868-0.672-1.568-1.493-1.57c-0.824,0-1.49,0.702-1.49,1.57L0,26.264' +
		'c0,0.029,0.008,0.059,0.01,0.087c-0.002,0.021-0.006,0.038-0.008,0.061c0.002,0.825,0.712,1.49,1.592,1.49h6.762' +
		'c0.879,0,1.59-0.666,1.59-1.49c0-0.822-0.711-1.489-1.59-1.491H5.121l5.989-5.987c0.58-0.582,0.58-1.527,0-2.109' +
		'C10.527,16.241,9.584,16.241,9,16.824z"/>' +
		'<path d="M19.359,11.535l6.018-6.017v3.25c0,0.865,0.673,1.565,1.492,1.568c0.826,0,1.491-0.703,1.491-1.568V2.097' +
		'c0-0.029-0.006-0.059-0.009-0.085c0.003-0.021,0.006-0.041,0.009-0.062c-0.003-0.826-0.712-1.491-1.592-1.491h-6.761' +
		'c-0.881,0-1.591,0.665-1.591,1.491c0,0.821,0.71,1.49,1.591,1.492h3.235l-5.989,5.987c-0.582,0.581-0.582,1.524,0,2.105' +
		'C17.835,12.12,18.777,12.12,19.359,11.535z"/>' +
		'<path d="M5.121,3.442h3.234c0.879-0.002,1.59-0.671,1.59-1.492c0-0.826-0.711-1.491-1.59-1.491H1.594' +
		'c-0.88,0-1.59,0.665-1.592,1.491C0.004,1.971,0.008,1.991,0.01,2.012C0.008,2.038,0,2.067,0,2.097l0.002,6.672' +
		'c0,0.865,0.666,1.568,1.49,1.568c0.821-0.003,1.493-0.703,1.493-1.568v-3.25L9,11.535c0.584,0.585,1.527,0.585,2.11,0' +
		'c0.58-0.581,0.58-1.524,0-2.105L5.121,3.442z"/>' +
		'</g>' +
		'<g class="Capa_1_253_">' +
		'</g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'</svg>',

    smallscreenIcon: '<svg version="1.1" class="Capa_1" x="0px" y="0px" viewBox="0 0 28.359 28.359" style="enable-background:new 0 0 28.359 28.359;" xml:space="preserve">' +
		'<g>' +
		'<g class="c116_arrows">' +
		'<path d="M21.935,19.368h3.235c0.878-0.003,1.589-0.67,1.589-1.492c0-0.824-0.711-1.492-1.589-1.492h-6.764' +
		'c-0.879,0-1.59,0.668-1.591,1.492c0.001,0.019,0.007,0.041,0.007,0.061c0,0.027-0.007,0.057-0.007,0.086v6.673' +
		'c0,0.864,0.666,1.566,1.49,1.566c0.822-0.002,1.492-0.702,1.492-1.566v-3.252l6.018,6.02c0.582,0.583,1.525,0.583,2.108,0' +
		'c0.58-0.582,0.58-1.526,0-2.108L21.935,19.368z"/>' +
		'<path d="M11.543,17.876c-0.002-0.824-0.712-1.492-1.592-1.492H3.189c-0.877,0-1.593,0.668-1.593,1.492' +
		'c0,0.822,0.716,1.489,1.593,1.492h3.235l-5.991,5.986c-0.577,0.582-0.577,1.526,0,2.108c0.584,0.583,1.527,0.583,2.108,0' +
		'l6.019-6.02v3.252c0,0.864,0.67,1.564,1.491,1.566c0.826,0,1.491-0.702,1.491-1.566v-6.673c0-0.029-0.008-0.059-0.008-0.086' +
		'C11.535,17.917,11.541,17.895,11.543,17.876z"/>' +
		'<path d="M16.815,10.479c0.001,0.824,0.712,1.491,1.591,1.491h6.764c0.878,0,1.589-0.667,1.589-1.491' +
		'c0-0.822-0.711-1.487-1.589-1.489h-3.235l5.989-5.987c0.58-0.584,0.58-1.528,0-2.109c-0.583-0.582-1.526-0.582-2.108,0' +
		'l-6.018,6.02V3.662c0-0.867-0.67-1.568-1.492-1.568c-0.824,0-1.49,0.701-1.49,1.568v6.671c0,0.03,0.007,0.057,0.007,0.087' +
		'C16.822,10.44,16.816,10.456,16.815,10.479z"/>' +
		'<path d="M10.052,2.094c-0.821,0-1.491,0.701-1.491,1.568v3.251l-6.019-6.02c-0.581-0.582-1.524-0.582-2.108,0' +
		'c-0.577,0.581-0.577,1.525,0,2.109l5.991,5.987H3.189c-0.876,0.003-1.592,0.668-1.592,1.49c0,0.824,0.716,1.491,1.593,1.491h6.761' +
		'c0.88,0,1.59-0.667,1.592-1.491c-0.002-0.023-0.008-0.039-0.008-0.06c0-0.03,0.008-0.057,0.008-0.087v-6.67' +
		'C11.543,2.795,10.878,2.094,10.052,2.094z"/>' +
		'</g>' +
		'<g class="Capa_1_156_">' +
		'</g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'<g>' +
		'</g>' +
		'</svg>',

    myGuide: '<svg  width="16" height="16" viewBox="0 0 16 16" fill="none">' +
			'<path d="M0 15.555C0 15.555 8.838 12.372 10.606 10.606C12.374 8.838 15.555 0 15.555 0C15.555 0 6.717 3.183 4.95 4.95C3.183 6.717 0 15.555 0 15.555ZM6.364 6.364L9.192 9.192C9.899 9.899 2.829 12.727 2.829 12.727C2.829 12.727 5.657 5.657 6.364 6.364Z" fill="#6f708b" />' +
		'</svg>',

    myShow: '<svg  width="20" height="11" viewBox="0 0 20 11" fill="none">' +
			'<path d="M13.0465 1.05294L13.0896 1.09273H13.1482H15.1375C17.731 1.09273 19.8499 3.27659 19.85 5.97134C19.85 8.66605 17.7312 10.85 15.1377 10.85C12.5442 10.85 10.4253 8.66604 10.4253 5.97134C10.4253 5.93554 10.4256 5.89996 10.4264 5.86449L10.4299 5.71111H10.2764H9.72347H9.57026L9.5735 5.86429C9.57426 5.90007 9.57464 5.93568 9.57464 5.97134C9.57464 8.66605 7.45583 10.85 4.86234 10.85C2.26881 10.85 0.15 8.66605 0.15 5.97134C0.15 3.27659 2.2688 1.09273 4.86234 1.09273H6.85159H6.91026L6.95335 1.05293C7.5463 0.50539 8.69319 0.15 9.9999 0.15C11.3066 0.15 12.4535 0.505438 13.0465 1.05294ZM1.82725 5.97134C1.82725 7.69467 3.18397 9.10517 4.86234 9.10517C6.54076 9.10517 7.89749 7.69467 7.89749 5.97134C7.89749 4.24802 6.54077 2.83746 4.86234 2.83746C3.18392 2.83746 1.82725 4.24802 1.82725 5.97134ZM8.69265 3.04H11.3065C11.705 3.04 12.0195 2.70646 12.0195 2.30772C12.0195 1.90897 11.705 1.57544 11.3065 1.57544H8.69265C8.29462 1.57544 7.98026 1.9091 7.98026 2.30772C7.98026 2.70639 8.29463 3.04 8.69265 3.04ZM12.1023 5.97134C12.1023 7.69467 13.459 9.10517 15.1375 9.10517C16.8159 9.10517 18.1726 7.69466 18.1726 5.97134C18.1726 4.24802 16.8157 2.83746 15.1375 2.83746C13.459 2.83746 12.1023 4.24802 12.1023 5.97134Z" fill="#6f708b" stroke="#cfd0dd" stroke-width="0.3" />' +
		'</svg>',

    myBot: '<svg  width="22" height="23" viewBox="0 0 22 23" fill="none">' +
			'<path d="M5.14433 17.2464C3.32333 17.2464 1.84711 18.722 1.84711 20.5422V23H3.53993V21.2977C3.53993 19.9325 4.6471 18.8258 6.01285 18.8258H15.4006C16.7663 18.8258 17.8735 19.9325 17.8735 21.2977V23H19.5665V20.5422C19.5665 18.722 18.0903 17.2464 16.2693 17.2464H5.14433Z" fill="#6f708b" />' +
			'<path d="M0 9.98398C0 9.08054 0.73269 8.34815 1.63651 8.34815H2.25725V11.6198H1.63651C0.732691 11.6198 0 10.8874 0 9.98398Z" fill="#6f708b" />' +
			'<path d="M21.4118 9.98398C21.4118 9.08054 20.6791 8.34815 19.7753 8.34815H19.1545V11.6198H19.7753C20.6791 11.6198 21.4118 10.8874 21.4118 9.98398Z" fill="#6f708b" />' +
			'<path d="M10.4232 9.98398C10.4232 10.8874 9.69048 11.6198 8.78666 11.6198C7.88285 11.6198 7.15016 10.8874 7.15016 9.98398C7.15016 9.08054 7.88285 8.34815 8.78666 8.34815C9.69048 8.34815 10.4232 9.08054 10.4232 9.98398Z" fill="#6f708b" />' +
			'<path d="M14.3746 9.98398C14.3746 10.8874 13.6419 11.6198 12.7381 11.6198C11.8342 11.6198 11.1016 10.8874 11.1016 9.98398C11.1016 9.08054 11.8342 8.34815 12.7381 8.34815C13.6419 8.34815 14.3746 9.08054 14.3746 9.98398Z" fill="#6f708b" />' +
			'<path d="M10.0287 2.76082C10.0287 2.6698 10.1025 2.59602 10.1936 2.59602H11.6697C11.7607 2.59602 11.8345 2.6698 11.8345 2.76082V5.98051H10.0287V2.76082Z" fill="#6f708b" />' +
			'<path d="M8.69162 4.62529H7.06454C5.24354 4.62529 3.76732 6.1009 3.76732 7.92116V12.1598C3.76732 13.98 5.24354 15.4557 7.06455 15.4557H14.3522C16.1732 15.4557 17.6494 13.98 17.6494 12.1598V7.92116C17.6494 6.1009 16.1732 4.62529 14.3522 4.62529H13.1746V5.86756H13.6535C15.0192 5.86756 16.1264 6.97427 16.1264 8.33946V11.7441C16.1264 13.1093 15.0192 14.216 13.6535 14.216H7.7645C6.39874 14.216 5.29158 13.1093 5.29158 11.7441V8.33946C5.29158 6.97426 6.39874 5.86756 7.7645 5.86756H8.69162V4.62529Z" fill="#6f708b" />' +
			'<path d="M11.8345 0.90253C11.8345 1.40098 11.4303 1.80506 10.9316 1.80506C10.433 1.80506 10.0287 1.40098 10.0287 0.90253C10.0287 0.404077 10.433 0 10.9316 0C11.4303 0 11.8345 0.404077 11.8345 0.90253Z" fill="#6f708b" />' +
		'</svg>',

    myTest: '<svg  width="20" height="26" viewBox="0 0 20 26" fill="none">' +
			'<path d="M1.54651 21.1221V5.72034H3.75581V6.61319C3.75581 7.05962 4.08721 7.39444 4.52907 7.39444H12.0407C12.4826 7.39444 12.814 7.05962 12.814 6.61319V5.72034H15.0233V12.0819V14.3141H16.5698V12.64V5.05069C16.5698 4.60426 16.2384 4.26944 15.7965 4.26944H12.814V3.37659C12.814 2.93016 12.4826 2.59534 12.0407 2.59534H11.157C10.936 0.921228 9.5 -0.194843 7.84302 0.0283712C6.51744 0.139978 5.52326 1.25605 5.30232 2.59534H4.52907C4.08721 2.59534 3.75581 2.93016 3.75581 3.37659V4.26944H0.773256C0.331395 4.26944 0 4.60426 0 5.05069V21.9034C0 22.3498 0.331395 22.6846 0.773256 22.6846H9.38953V21.1221H6.73837H1.54651ZM8.28488 1.47926C8.94767 1.47926 9.5 1.92569 9.72093 2.59534H6.84884C6.9593 1.92569 7.62209 1.47926 8.28488 1.47926ZM5.19186 4.15784H11.2674V5.83194H5.19186V4.15784Z" fill="#6f708b" />' +
			'<circle cx="12.5" cy="18.5" r="6.7" fill="white" stroke="#6f708b" stroke-width="1.6" />' +
			'<path d="M11.6804 20.9037C11.6136 20.9655 11.5224 21 11.4277 21C11.333 21 11.2419 20.9655 11.1751 20.9037L9.15707 19.047C8.94764 18.8544 8.94764 18.542 9.15707 18.3497L9.40975 18.1172C9.61924 17.9246 9.95844 17.9246 10.1679 18.1172L11.4277 19.2762L14.8321 16.1445C15.0416 15.9518 15.3812 15.9518 15.5902 16.1445L15.8429 16.377C16.0524 16.5696 16.0524 16.882 15.8429 17.0743L11.6804 20.9037Z" fill="#6f708b" />' +
		'</svg>',

    copyGuideIcon: '<svg version="1.2" overflow="visible" preserveAspectRatio="none" viewBox="0 0 450 514" width="14" height="16">' +
			'<g transform="translate(1, 1)">' +
				'<path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM352 32.491a15.88 15.88 0 0 1 7.431 4.195l51.882 51.883A15.885 15.885 0 0 1 415.508 96H352V32.491zM288 464c0 8.822-7.178 16-16 16H48c-8.822 0-16-7.178-16-16V144c0-8.822 7.178-16 16-16h80v240c0 26.51 21.49 48 48 48h112v48zm128-96c0 8.822-7.178 16-16 16H176c-8.822 0-16-7.178-16-16V48c0-8.822 7.178-16 16-16h144v72c0 13.2 10.8 24 24 24h72v240z" vector-effect="non-scaling-stroke" />' +
			'</g>' +
		'</svg>',

    historyIcon: '<svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1"  >' +
			'<g class="3.-Style" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">' +
				'<g class="UI-Icons" transform="translate(-571.000000, -535.000000)" fill="#4D4D4D">' +
					'<g class="Group" transform="translate(571.000000, 535.000000)">' +
						'<path d="M7.66676667,0 C4.76476667,0 2.06576667,1.60966667 0.666766667,4.13233333 L0.666766667,0.666666667 C0.666766667,0.482333333 0.517766667,0.333333333 0.333433333,0.333333333 C0.1491,0.333333333 0.0001,0.482333333 0.0001,0.666666667 L0.0001,5 C0.0001,5.18433333 0.1491,5.33333333 0.333433333,5.33333333 L4.66676667,5.33333333 C4.8511,5.33333333 5.0001,5.18433333 5.0001,5 C5.0001,4.81566667 4.8511,4.66666667 4.66676667,4.66666667 L1.1381,4.66666667 C2.3841,2.23266667 4.92643333,0.666666667 7.66676667,0.666666667 C11.7104333,0.666666667 15.0001,3.95633333 15.0001,8 C15.0001,12.0436667 11.7104333,15.3333333 7.66676667,15.3333333 C4.57776667,15.3333333 1.6281,13.009 0.652433333,9.80666667 C0.598766667,9.63066667 0.4131,9.53133333 0.236433333,9.58466667 C0.0604333333,9.63833333 -0.0389,9.82466667 0.0144333333,10.0006667 C1.07376667,13.477 4.29176667,16 7.66676667,16 C12.0777667,16 15.6667667,12.411 15.6667667,8 C15.6667667,3.589 12.0777667,0 7.66676667,0" class="Fill-6">' +'</path>' +
						'<path d="M7.64922281,2.33333333 C7.47459123,2.33333333 7.33343333,2.47449123 7.33343333,2.64912281 L7.33343333,8.01754386 C7.33343333,8.19217544 7.47459123,8.33333333 7.64922281,8.33333333 L11.4386965,8.33333333 C11.6133281,8.33333333 11.754486,8.19217544 11.754486,8.01754386 C11.754486,7.84291228 11.6133281,7.70175439 11.4386965,7.70175439 L7.96501228,7.70175439 L7.96501228,2.64912281 C7.96501228,2.47449123 7.82385439,2.33333333 7.64922281,2.33333333" class="Fill-8">' +'</path>' +
					'</g>' +
				'</g>' +
			'</g>' +
		'</svg>',

    pdfIcon: '<svg class="Layer_1" data-name="Layer 1"  viewBox="0 0 200 200"><defs><style>.cls-1,.cls-3,.cls-4{fill:#005BF0;}.cls-1{opacity:0.3;}.cls-2{fill:#218e79;}.cls-4{font-size:31.1px;font-family:NotoSerif-Bold, Noto Serif;font-weight:700;}</style></defs><path class="cls-1" d="M44.73,184.74H155.27a7.37,7.37,0,0,0,7.37-7.37V52.1L125.79,15.26H44.73a7.37,7.37,0,0,0-7.37,7.37V177.37A7.37,7.37,0,0,0,44.73,184.74Z"/><path class="cls-2" d="M125.79,15.26V44.73a7.37,7.37,0,0,0,7.37,7.37h29.48Z"/><path class="cls-3" d="M163.51,52.05a.85.85,0,0,0,0-.23l0-.09a.87.87,0,0,0-.18-.26L126.42,14.63a.83.83,0,0,0-.26-.17l-.08,0a1,1,0,0,0-.23,0H44.73a8.26,8.26,0,0,0-8.25,8.26V177.37a8.26,8.26,0,0,0,8.25,8.26H155.27a8.26,8.26,0,0,0,8.25-8.26V52.1A.09.09,0,0,0,163.51,52.05ZM126.68,17.4l33.81,33.81H133.16a6.48,6.48,0,0,1-6.48-6.48Zm-82-1.25H124.9V44.73A8.27,8.27,0,0,0,133.16,53h28.59V161.73a.87.87,0,0,0-.39-.1H38.25v-139A6.48,6.48,0,0,1,44.73,16.15Zm110.54,167.7H44.73a6.48,6.48,0,0,1-6.48-6.48v-14H161.36a.87.87,0,0,0,.39-.1v14.07A6.48,6.48,0,0,1,155.27,183.85Z"/><text class="cls-4" transform="translate(69.78 109.96)">PDF</text></svg>',

    guidePlayIconShowme: '<svg  width="9" height="13" viewBox="0 0 9 13" fill="none">' +
			'<path opacity="0.3" d="M0 0L9 6.5L0 13V0Z" fill="black" />' +
		'</svg>',

    dragStep: '<svg class="mgPlayerJSTest_width-height-100" width="32" height="32" viewBox="0 0 32 32" fill="none">' +
		'<path fill-rule="evenodd" clip-rule="evenodd" d="M9.91309 22.0492C9.91309 20.9442 10.8221 20.0492 11.9421 20.0492C13.0631 20.0492 13.9711 20.9442 13.9711 22.0492C13.9711 23.1532 13.0631 24.0492 11.9421 24.0492C10.8221 24.0492 9.91309 23.1532 9.91309 22.0492ZM9.91309 15.9992C9.91309 14.8942 10.8221 13.9992 11.9421 13.9992C13.0631 13.9992 13.9711 14.8942 13.9711 15.9992C13.9711 17.1032 13.0631 17.9992 11.9421 17.9992C10.8221 17.9992 9.91309 17.1032 9.91309 15.9992ZM20.0581 20.0492C21.1791 20.0492 22.0871 20.9442 22.0871 22.0492C22.0871 23.1532 21.1791 24.0492 20.0581 24.0492C18.9381 24.0492 18.0291 23.1532 18.0291 22.0492C18.0291 20.9442 18.9381 20.0492 20.0581 20.0492ZM20.0581 13.9992C21.1791 13.9992 22.0871 14.8942 22.0871 15.9992C22.0871 17.1032 21.1791 17.9992 20.0581 17.9992C18.9381 17.9992 18.0291 17.1032 18.0291 15.9992C18.0291 14.8942 18.9381 13.9992 20.0581 13.9992ZM11.9421 7.94922C13.0631 7.94922 13.9711 8.84422 13.9711 9.94922C13.9711 11.0532 13.0631 11.9492 11.9421 11.9492C10.8221 11.9492 9.91309 11.0532 9.91309 9.94922C9.91309 8.84422 10.8221 7.94922 11.9421 7.94922ZM20.0581 7.94922C21.1791 7.94922 22.0871 8.84422 22.0871 9.94922C22.0871 11.0532 21.1791 11.9492 20.0581 11.9492C18.9381 11.9492 18.0291 11.0532 18.0291 9.94922C18.0291 8.84422 18.9381 7.94922 20.0581 7.94922Z" fill="#555555"/>' +
	'</svg>',

    startPoint: '<svg version="1.2" overflow="visible" preserveAspectRatio="none" viewBox="0 0 16.00001480672206 30.000002376293313" width="16.00001480672206" height="20.000002376293313" style="padding-right:5px;"><g transform="translate(0, 0)"><g transform="translate(0.000007403361028701504, 0.000002376293311883793) rotate(0)"><path d="M8,18.21576c-0.67536,0 -1.33571,-0.08038 -1.99605,-0.25723v10.96433c0.01501,0.59484 0.45024,1.06106 1.00553,1.07714h1.99605c0.55529,-0.01608 0.99052,-0.4823 1.00553,-1.07714v-10.96433c-0.66035,0.17684 -1.33571,0.25723 -2.01106,0.25723zM8,0.00083c-2.13113,-0.03215 -4.1722,0.86814 -5.65799,2.50797c-1.53081,1.5916 -2.37125,3.77803 -2.34124,6.06093c-0.03002,2.28289 0.81043,4.46933 2.34124,6.06093c1.48578,1.63983 3.52686,2.54012 5.65799,2.50797c2.13113,0.03215 4.1722,-0.86814 5.65799,-2.50797c1.53081,-1.5916 2.37125,-3.77803 2.34124,-6.06093c0.03002,-2.28289 -0.81043,-4.46933 -2.34124,-6.06093c-1.48578,-1.63983 -3.52686,-2.54012 -5.65799,-2.50797zM8,3.74671c-2.49132,0 -4.50238,2.15428 -4.50238,4.82302c0,0.30546 -0.22512,0.54661 -0.51027,0.54661c-0.28515,0 -0.49526,-0.24115 -0.49526,-0.54661c0,-3.2475 2.4613,-5.88408 5.4929,-5.88408h0.01501c0.27014,0 0.49526,0.24115 0.49526,0.53053c0,0.28938 -0.22512,0.53053 -0.49526,0.53053z" style="stroke-width: 0; stroke-linecap: butt; stroke-linejoin: miter; fill: rgb(122, 98, 171);" vector-effect="non-scaling-stroke"/></g><defs><path class="path-1636604223336103" d="M8,18.21576c-0.67536,0 -1.33571,-0.08038 -1.99605,-0.25723v10.96433c0.01501,0.59484 0.45024,1.06106 1.00553,1.07714h1.99605c0.55529,-0.01608 0.99052,-0.4823 1.00553,-1.07714v-10.96433c-0.66035,0.17684 -1.33571,0.25723 -2.01106,0.25723zM8,0.00083c-2.13113,-0.03215 -4.1722,0.86814 -5.65799,2.50797c-1.53081,1.5916 -2.37125,3.77803 -2.34124,6.06093c-0.03002,2.28289 0.81043,4.46933 2.34124,6.06093c1.48578,1.63983 3.52686,2.54012 5.65799,2.50797c2.13113,0.03215 4.1722,-0.86814 5.65799,-2.50797c1.53081,-1.5916 2.37125,-3.77803 2.34124,-6.06093c0.03002,-2.28289 -0.81043,-4.46933 -2.34124,-6.06093c-1.48578,-1.63983 -3.52686,-2.54012 -5.65799,-2.50797zM8,3.74671c-2.49132,0 -4.50238,2.15428 -4.50238,4.82302c0,0.30546 -0.22512,0.54661 -0.51027,0.54661c-0.28515,0 -0.49526,-0.24115 -0.49526,-0.54661c0,-3.2475 2.4613,-5.88408 5.4929,-5.88408h0.01501c0.27014,0 0.49526,0.24115 0.49526,0.53053c0,0.28938 -0.22512,0.53053 -0.49526,0.53053z" vector-effect="non-scaling-stroke"/></defs></g></svg>',

    guide: '<svg class="mgPlayerJSTest_guide-icon-{{tour.tour_id}}" width="40" height="40" viewBox="0 0 40 40" fill="none" ng-bind-html="createSvgElmnt() | unsafe"></svg>',

    mobileGuide: '<svg width="40" height="40" viewBox="0 0 40 40" fill="none" >' +
			'<rect x="0.7" y="0.7" width="38.6" height="38.6" rx="19.3" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4"/>' +
			'<rect x="13.8" y="10.8" width="12.4" height="20.4" rx="1.2" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.6"/>' +
			'<rect x="14" y="25" width="12" height="0.5" fill="#ACADC1" stroke="#ACADC1"/>' +
			'<circle class="mgPlayerJSTest_mobile-circle" cx="20" cy="28.5" r="1" fill="#ACADC1"/>' +
		'</svg>',

    insight: '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">' +
			'<defs>' +
				'<style>.cls-1 { fill: #ffffff; stroke: #ACADC1; stroke-miterlimit: 10; stroke-width: 1.4;}' +
				'.cls-2 { fill: #8e8fa6; stroke-width: 0; } </style>' +
			'</defs>' +
			'<circle class="cls-1" cx="24" cy="24" r="22.75" />' +
			'<path class="cls-2" d="M31.15,14.74a9.73,9.73,0,0,1,1.35,5.18c0,2.13-.82,3.72-2.65,5.95-.16.19-.32.37-.54.59l-.47.48a3.21,3.21,0,0,0-.5.62,6.39,6.39,0,0,0-.41.91,10.62,10.62,0,0,0-.41,1.62c0-.08-.16,1-.21,1.11a.62.62,0,0,1-.1.22.67.67,0,0,1-.6.33h-5a.68.68,0,0,1-.66-.5h0v0l0-.11-.11-.38c-.13-.41-.26-.83-.39-1.23a12,12,0,0,0-.81-2.09,13,13,0,0,0-1.46-1.77l-.38-.43c-.2-.23-.37-.44-.54-.66a7.67,7.67,0,0,1-1.68-5.61,9,9,0,0,1,2.19-5.24A7.8,7.8,0,0,1,23.77,11a9,9,0,0,1,5.62,1.76l-1.05,1a7.77,7.77,0,0,0-4.57-1.31,6.43,6.43,0,0,0-5,2.22A7.57,7.57,0,0,0,16.91,19a6.29,6.29,0,0,0,1.39,4.64c.15.2.3.38.48.59l.36.4a14.73,14.73,0,0,1,1.58,1.92,11.66,11.66,0,0,1,1,2.46c.14.41.27.84.4,1.25v.05h3.95l.09-.51A12.19,12.19,0,0,1,26.63,28a9,9,0,0,1,.51-1.13,5.24,5.24,0,0,1,.71-.9l.49-.5a6,6,0,0,0,.45-.49c1.64-2,2.33-3.33,2.33-5a8.5,8.5,0,0,0-1-4.22Zm-7.89-1.62.26.93a5.64,5.64,0,0,0-2.14.61l-.63-.72A6.4,6.4,0,0,1,23.26,13.12Zm.95,0a7.39,7.39,0,0,1,2.64.59l-.36.87a6.74,6.74,0,0,0-2-.5ZM20,14.47l.62.7-.35.29a5.82,5.82,0,0,0-1.48,2l-.86-.32a6.46,6.46,0,0,1,1.73-2.41C19.74,14.66,19.85,14.56,20,14.47Zm-2.36,3.6.87.32A6.13,6.13,0,0,0,18.36,20l-.92,0a6.81,6.81,0,0,1,.17-2Zm3.5,15h6a.79.79,0,0,1,0,1.57h-6a.79.79,0,0,1,0-1.57Zm.47,2.36H26.8v.31A1.24,1.24,0,0,1,25.57,37H22.81a1.24,1.24,0,0,1-1.23-1.26ZM24.29,18.6h.07q.41,0,7.23-6.88l-6.37,7.74a1.12,1.12,0,0,1,0,.32,1.15,1.15,0,1,1-1.15-1.18Z" />' +
		'</svg>',

    tooltipIcon: '<svg width="40" height="40" viewBox="0 0 40 40" fill="none" >' +
			'<rect x="0.7" y="0.7" width="38.6" height="38.6" rx="19.3" fill="#F8F8FB" stroke="#ACADC1" stroke-width="1.4" />' +
			'<path d="M21.625 30.75C21.625 31.6475 20.8975 32.375 20 32.375C19.1025 32.375 18.375 31.6475 18.375 30.75C18.375 29.8525 19.1025 29.125 20 29.125C20.8975 29.125 21.625 29.8525 21.625 30.75Z" fill="#ACADC1" stroke="#ACADC1" stroke-width="0.5" />' +
			'<path d="M21.4375 23.5681L21.25 23.6165V23.8102V26.25C21.25 26.9404 20.6904 27.5 20 27.5C19.3096 27.5 18.75 26.9404 18.75 26.25V22.5C18.75 21.8096 19.3096 21.25 20 21.25C21.7923 21.25 23.25 19.7923 23.25 18C23.25 16.2077 21.7923 14.75 20 14.75C18.2077 14.75 16.75 16.2077 16.75 18C16.75 18.6904 16.1904 19.25 15.5 19.25C14.8096 19.25 14.25 18.6904 14.25 18C14.25 14.8297 16.8297 12.25 20 12.25C23.1703 12.25 25.75 14.8297 25.75 18C25.75 20.6737 23.915 22.9281 21.4375 23.5681Z" fill="#ACADC1" stroke="#ACADC1" stroke-width="0.5" />' +
		'</svg>',

    guidePlayIcon: '<svg class="mgPlayerJSTest_position-center" width="16" height="16" viewBox="0 0 16 16" fill="none">' +
			'<path d="M0 15.555C0 15.555 8.838 12.372 10.606 10.606C12.374 8.838 15.555 0 15.555 0C15.555 0 6.717 3.183 4.95 4.95C3.183 6.717 0 15.555 0 15.555ZM6.364 6.364L9.192 9.192C9.899 9.899 2.829 12.727 2.829 12.727C2.829 12.727 5.657 5.657 6.364 6.364Z" fill="#6f708b"/>' +
		'</svg>',

    doItForMeIcon: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="0 0 16 18">' +
			'<path d="M3.84412 13.4972C2.48336 13.4972 1.38026 14.652 1.38026 16.0765V18H2.64522V16.6678C2.64522 15.5993 3.47256 14.7332 4.49312 14.7332H11.5081C12.5287 14.7332 13.356 15.5993 13.356 16.6678V18H14.6211V16.0765C14.6211 14.652 13.518 13.4972 12.1573 13.4972H3.84412Z" fill="#005BF0" />' +
			'<path d="M0 7.81355C0 7.10651 0.547505 6.53333 1.22289 6.53333H1.68674V9.09377H1.22289C0.547505 9.09377 0 8.5206 0 7.81355Z" fill="#005BF0" />' +
			'<path d="M16 7.81355C16 7.10651 15.4525 6.53333 14.7771 6.53333H14.3133V9.09377H14.7771C15.4525 9.09377 16 8.5206 16 7.81355Z" fill="#005BF0" />' +
			'<path d="M7.78874 7.81355C7.78874 8.5206 7.24124 9.09377 6.56586 9.09377C5.89048 9.09377 5.34297 8.5206 5.34297 7.81355C5.34297 7.10651 5.89048 6.53333 6.56586 6.53333C7.24124 6.53333 7.78874 7.10651 7.78874 7.81355Z" fill="#005BF0" />' +
			'<path d="M10.7414 7.81355C10.7414 8.5206 10.1939 9.09377 9.51855 9.09377C8.84317 9.09377 8.29567 8.5206 8.29567 7.81355C8.29567 7.10651 8.84317 6.53333 9.51855 6.53333C10.1939 6.53333 10.7414 7.10651 10.7414 7.81355Z" fill="#005BF0" />' +
			'<path d="M7.494 2.16064C7.494 2.08941 7.54915 2.03167 7.61719 2.03167H8.72019C8.78823 2.03167 8.84339 2.08941 8.84339 2.16064V4.6804H7.494V2.16064Z" fill="#005BF0" />' +
			'<path d="M6.49483 3.61979H5.279C3.91825 3.61979 2.81514 4.77462 2.81514 6.19917V9.51635C2.81514 10.9409 3.91825 12.0957 5.279 12.0957H10.7247C12.0855 12.0957 13.1886 10.9409 13.1886 9.51635V6.19917C13.1886 4.77462 12.0855 3.61979 10.7247 3.61979H9.84475V4.592H10.2026C11.2232 4.592 12.0505 5.45812 12.0505 6.52654V9.191C12.0505 10.2594 11.2232 11.1255 10.2026 11.1255H5.80204C4.78148 11.1255 3.95415 10.2594 3.95415 9.191V6.52653C3.95415 5.45812 4.78148 4.592 5.80204 4.592H6.49483V3.61979Z" fill="#005BF0" />' +
			'<path d="M8.84339 0.706328C8.84339 1.09642 8.54131 1.41266 8.16869 1.41266C7.79607 1.41266 7.494 1.09642 7.494 0.706328C7.494 0.316234 7.79607 0 8.16869 0C8.54131 0 8.84339 0.316234 8.84339 0.706328Z" fill="#005BF0" />' +
		'</svg>',

    navBar: '<svg width="24" height="16" viewBox="0 0 24 16" fill="none">' +
			'<path d="M22.935 13.717H10.452C10.1868 13.717 9.9324 13.8223 9.74487 14.0099C9.55733 14.1974 9.45197 14.4517 9.45197 14.717C9.45197 14.9822 9.55733 15.2365 9.74487 15.4241C9.9324 15.6116 10.1868 15.717 10.452 15.717H22.935C23.2002 15.717 23.4545 15.6116 23.6421 15.4241C23.8296 15.2365 23.935 14.9822 23.935 14.717C23.935 14.4517 23.8296 14.1974 23.6421 14.0099C23.4545 13.8223 23.2002 13.717 22.935 13.717ZM22.935 7.24996H10.452C10.1868 7.24996 9.9324 7.35532 9.74487 7.54285C9.55733 7.73039 9.45197 7.98474 9.45197 8.24996C9.45197 8.51518 9.55733 8.76953 9.74487 8.95707C9.9324 9.1446 10.1868 9.24996 10.452 9.24996H22.935C23.2002 9.24996 23.4545 9.1446 23.6421 8.95707C23.8296 8.76953 23.935 8.51518 23.935 8.24996C23.935 7.98474 23.8296 7.73039 23.6421 7.54285C23.4545 7.35532 23.2002 7.24996 22.935 7.24996ZM10.452 2.78296H22.935C23.2002 2.78296 23.4545 2.6776 23.6421 2.49007C23.8296 2.30253 23.935 2.04818 23.935 1.78296C23.935 1.51774 23.8296 1.26339 23.6421 1.07585C23.4545 0.888316 23.2002 0.782959 22.935 0.782959H10.452C10.1868 0.782959 9.9324 0.888316 9.74487 1.07585C9.55733 1.26339 9.45197 1.51774 9.45197 1.78296C9.45197 2.04818 9.55733 2.30253 9.74487 2.49007C9.9324 2.6776 10.1868 2.78296 10.452 2.78296ZM5.73897 3.57496C5.55144 3.38749 5.29714 3.28217 5.03197 3.28217C4.76681 3.28217 4.5125 3.38749 4.32497 3.57496L0.357972 7.54296C0.170501 7.73049 0.0651855 7.98479 0.0651855 8.24996C0.0651855 8.51512 0.170501 8.76943 0.357972 8.95696L4.32497 12.925C4.51357 13.1071 4.76618 13.2079 5.02837 13.2056C5.29057 13.2034 5.54138 13.0982 5.72679 12.9128C5.9122 12.7274 6.01737 12.4766 6.01965 12.2144C6.02192 11.9522 5.92113 11.6996 5.73897 11.511L2.47897 8.24996L5.73897 4.98896C5.92644 4.80143 6.03176 4.54712 6.03176 4.28196C6.03176 4.01679 5.92644 3.76249 5.73897 3.57496Z" fill="#555555"/>' +
		'</svg>',

    settings: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="4 3 20 20" fill="none">' +
			'<g clip-path="url(#clip0_3195_94)">' +
				'<path fill-rule="evenodd" clip-rule="evenodd" d="M18.608 14.08C18.4413 14.7777 18.1645 15.4444 17.788 16.055C18.0254 16.3613 18.1432 16.7437 18.1192 17.1305C18.0953 17.5173 17.9314 17.8822 17.658 18.157C17.3834 18.4305 17.0185 18.5947 16.6317 18.6188C16.2449 18.6429 15.8625 18.5253 15.556 18.288C14.9449 18.6649 14.2775 18.9417 13.579 19.108C13.5297 19.4922 13.3423 19.8453 13.0517 20.1015C12.7612 20.3576 12.3873 20.4993 12 20.5C11.6125 20.4995 11.2384 20.358 10.9476 20.1018C10.6569 19.8456 10.4693 19.4924 10.42 19.108C9.72228 18.9413 9.05558 18.6645 8.445 18.288C8.13865 18.5254 7.75633 18.6432 7.36949 18.6192C6.98265 18.5953 6.61776 18.4314 6.343 18.158C6.06949 17.8834 5.90535 17.5185 5.88124 17.1317C5.85713 16.7449 5.97471 16.3625 6.212 16.056C5.83522 15.4448 5.5584 14.7774 5.392 14.079C5.00781 14.0297 4.65469 13.8423 4.39854 13.5517C4.1424 13.2612 4.00074 12.8873 4 12.5C4 11.688 4.608 11.024 5.392 10.92C5.55866 10.222 5.83547 9.55494 6.212 8.944C5.97513 8.6378 5.85771 8.25591 5.88163 7.86952C5.90555 7.48314 6.06918 7.11865 6.342 6.844C6.61651 6.57035 6.98127 6.40602 7.36811 6.38172C7.75496 6.35743 8.13742 6.47484 8.444 6.712C9.05481 6.33521 9.72188 6.05839 10.42 5.892C10.4695 5.50773 10.6571 5.15459 10.9479 4.89846C11.2386 4.64233 11.6125 4.50071 12 4.5C12.812 4.5 13.476 5.108 13.579 5.892C14.288 6.061 14.952 6.34 15.555 6.712C15.8615 6.47471 16.2439 6.35713 16.6307 6.38124C17.0175 6.40535 17.3824 6.56949 17.657 6.843C18.232 7.418 18.271 8.318 17.788 8.945C18.16 9.548 18.439 10.212 18.608 10.921C18.9922 10.9703 19.3453 11.1577 19.6015 11.4483C19.8576 11.7388 19.9993 12.1127 20 12.5C20 13.312 19.392 13.976 18.608 14.08ZM17.6 11.7H17.134C17.0068 10.8809 16.6844 10.1043 16.194 9.436L16.525 9.106C16.6024 9.03245 16.6643 8.94415 16.7071 8.8463C16.7498 8.74845 16.7725 8.64303 16.7739 8.53626C16.7753 8.42949 16.7553 8.32352 16.715 8.22461C16.6748 8.1257 16.6152 8.03584 16.5397 7.96033C16.4642 7.88483 16.3743 7.8252 16.2754 7.78497C16.1765 7.74474 16.0705 7.72472 15.9637 7.72608C15.857 7.72745 15.7515 7.75018 15.6537 7.79293C15.5559 7.83568 15.4675 7.89759 15.394 7.975L15.064 8.305C14.3952 7.8159 13.6188 7.49456 12.8 7.368V6.9C12.8 6.68783 12.7157 6.48434 12.5657 6.33431C12.4157 6.18429 12.2122 6.1 12 6.1C11.7878 6.1 11.5843 6.18429 11.4343 6.33431C11.2843 6.48434 11.2 6.68783 11.2 6.9V7.368C10.3812 7.49441 9.60468 7.81576 8.936 8.305L8.606 7.975C8.45488 7.83117 8.25355 7.75206 8.04493 7.75454C7.83632 7.75703 7.63693 7.84091 7.48928 7.9883C7.34162 8.13569 7.25739 8.33493 7.25454 8.54354C7.25168 8.75215 7.33043 8.95362 7.474 9.105L7.804 9.436C7.31458 10.1047 6.99289 10.8811 6.866 11.7H6.4C6.18783 11.7 5.98434 11.7843 5.83431 11.9343C5.68429 12.0843 5.6 12.2878 5.6 12.5C5.6 12.7122 5.68429 12.9157 5.83431 13.0657C5.98434 13.2157 6.18783 13.3 6.4 13.3H6.866C6.996 14.138 7.326 14.909 7.805 15.564L7.475 15.894C7.39759 15.9675 7.33568 16.0559 7.29293 16.1537C7.25018 16.2515 7.22745 16.357 7.22608 16.4637C7.22472 16.5705 7.24474 16.6765 7.28497 16.7754C7.3252 16.8743 7.38483 16.9642 7.46033 17.0397C7.53584 17.1152 7.6257 17.1748 7.72461 17.215C7.82352 17.2553 7.92949 17.2753 8.03626 17.2739C8.14303 17.2725 8.24845 17.2498 8.3463 17.2071C8.44415 17.1643 8.53245 17.1024 8.606 17.025L8.936 16.695C9.60474 17.1841 10.3812 17.5055 11.2 17.632V18.1C11.2 18.3122 11.2843 18.5157 11.4343 18.6657C11.5843 18.8157 11.7878 18.9 12 18.9C12.2122 18.9 12.4157 18.8157 12.5657 18.6657C12.7157 18.5157 12.8 18.3122 12.8 18.1V17.632C13.6189 17.5056 14.3953 17.1843 15.064 16.695L15.394 17.025C15.4675 17.1025 15.5557 17.1645 15.6535 17.2073C15.7514 17.2501 15.8567 17.273 15.9635 17.2744C16.0703 17.2759 16.1763 17.2559 16.2752 17.2158C16.3742 17.1757 16.4641 17.1161 16.5396 17.0407C16.6152 16.9652 16.6749 16.8754 16.7152 16.7766C16.7556 16.6777 16.7757 16.5717 16.7744 16.465C16.7731 16.3582 16.7505 16.2527 16.7078 16.1549C16.6652 16.057 16.6033 15.9686 16.526 15.895L16.196 15.564C16.674 14.909 17.004 14.138 17.134 13.3H17.6C17.8122 13.3 18.0157 13.2157 18.1657 13.0657C18.3157 12.9157 18.4 12.7122 18.4 12.5C18.4 12.2878 18.3157 12.0843 18.1657 11.9343C18.0157 11.7843 17.8122 11.7 17.6 11.7ZM12 15.7C11.1513 15.7 10.3374 15.3629 9.73726 14.7627C9.13714 14.1626 8.8 13.3487 8.8 12.5C8.8 11.6513 9.13714 10.8374 9.73726 10.2373C10.3374 9.63714 11.1513 9.3 12 9.3C12.8487 9.3 13.6626 9.63714 14.2627 10.2373C14.8629 10.8374 15.2 11.6513 15.2 12.5C15.2 13.3487 14.8629 14.1626 14.2627 14.7627C13.6626 15.3629 12.8487 15.7 12 15.7ZM12 10.9C11.7899 10.9 11.5818 10.9414 11.3877 11.0218C11.1936 11.1022 11.0172 11.2201 10.8686 11.3686C10.7201 11.5172 10.6022 11.6936 10.5218 11.8877C10.4414 12.0818 10.4 12.2899 10.4 12.5C10.4 12.7101 10.4414 12.9182 10.5218 13.1123C10.6022 13.3064 10.7201 13.4828 10.8686 13.6314C11.0172 13.7799 11.1936 13.8978 11.3877 13.9782C11.5818 14.0586 11.7899 14.1 12 14.1C12.4243 14.1 12.8313 13.9314 13.1314 13.6314C13.4314 13.3313 13.6 12.9243 13.6 12.5C13.6 12.0757 13.4314 11.6687 13.1314 11.3686C12.8313 11.0686 12.4243 10.9 12 10.9Z" stroke-width=".01" fill="#555555"/>' +
			'</g>' +
			'<defs>' +
			'<clipPath id="clip0_3195_94">' +
			'<rect width="24" height="24" fill="white" transform="translate(0 0.5)"/>' +
			'</clipPath>' +
			'</defs>' +
		'</svg>',


    edit: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50;" xml:space="preserve">' +
			'<g>' +
			'<g>' +
			'<g>' +
			'<path d="M43.1,29c-1.1,0-2,0.9-2,2v12.1c0,1.4-1.1,2.5-2.5,2.5H6.9c-1.4,0-2.5-1.1-2.5-2.5V11.5c0-1.4,1.1-2.5,2.5-2.5H19' +
			'c1.1,0,2-0.9,2-2s-0.9-2-2-2H6.9c-3.6,0-6.5,2.9-6.5,6.5v31.6c0,3.6,2.9,6.5,6.5,6.5h31.6c3.6,0,6.5-2.9,6.5-6.5V31' +
			'C45.1,29.9,44.2,29,43.1,29z"/>' +
			'</g>' +
			'</g>' +
			'<g>' +
			'<g>' +
			'<path d="M49,10l-9-9c-0.8-0.8-2-0.8-2.8,0L14.6,23.6C14.2,24,14,24.5,14,25v9c0,1.1,0.9,2,2,2h9c0.5,0,1-0.2,1.4-0.6L49,12.9' +
			'c0.4-0.4,0.6-0.9,0.6-1.4C49.6,10.9,49.4,10.4,49,10z M24.2,32H18v-6.2L38.5,5.2l6.2,6.2L24.2,32z"/>' +
			'</g>' +
			'</g>' +
			'</g>' +
		'</svg>',

    playStore: '<svg width="30" height="30" viewBox="0 0 30 30" fill="none" >' +
		'<path opacity="0.802967" d="M15 30C23.2843 30 30 23.2843 30 15C30 6.71573 23.2843 0 15 0C6.71573 0 0 6.71573 0 15C0 23.2843 6.71573 30 15 30Z" fill="#666666"/>' +
		'<path d="M11.874 7.19116C11.4876 6.95854 11.0271 6.93774 10.6254 7.1314L17.3599 13.8803L19.5619 11.6681L11.874 7.19116ZM10.0066 7.75601C9.92168 7.9359 9.87598 8.136 9.87598 8.34196V20.6872C9.87598 20.894 9.92197 21.0912 10.0078 21.2673L16.7397 14.5034L10.0066 7.75601ZM17.3608 15.1257L10.6371 21.8813C10.8156 21.964 11.0054 22 11.195 22C11.429 22 11.6625 21.944 11.8741 21.8169L19.5634 17.3333L17.3608 15.1257ZM22.4899 13.3732C22.4873 13.3714 22.4843 13.3696 22.4817 13.3682L20.3471 12.1251L17.9808 14.5026L20.3486 16.8753C20.3486 16.8753 22.4873 15.6285 22.4899 15.627C22.8869 15.3859 23.1239 14.9646 23.1239 14.4999C23.1239 14.0353 22.8869 13.614 22.4899 13.3732Z" fill="white"/>' +
		'</svg>',

    desktop: '<svg width="30" height="30" viewBox="0 0 30 30" fill="none" >' +
		'<path opacity="0.802967" d="M15 30C23.2843 30 30 23.2843 30 15C30 6.71573 23.2843 0 15 0C6.71573 0 0 6.71573 0 15C0 23.2843 6.71573 30 15 30Z" fill="#666666"/>' +
		'<path d="M20.239 9.30719C20.0343 9.10247 19.7883 9 19.5007 9H9.04552C8.75801 9 8.51195 9.10247 8.30708 9.30719C8.10233 9.51199 8 9.75803 8 10.0456V18.2816C8 18.5692 8.10233 18.8153 8.30708 19.0201C8.51195 19.2248 8.75801 19.3271 9.04552 19.3271H12.6003C12.6003 19.4926 12.5655 19.6627 12.4958 19.8368C12.4261 20.0111 12.3564 20.1635 12.2867 20.2941C12.217 20.4249 12.1822 20.5206 12.1822 20.5816C12.1822 20.6948 12.2235 20.7931 12.3063 20.8756C12.3891 20.9585 12.4871 21 12.6003 21H15.946C16.0593 21 16.1573 20.9585 16.2401 20.8756C16.3229 20.7931 16.3643 20.6948 16.3643 20.5816C16.3643 20.5251 16.3293 20.4303 16.2597 20.2974C16.1899 20.1647 16.1202 20.0098 16.0506 19.8336C15.9809 19.6571 15.946 19.4883 15.946 19.3271H19.5009C19.7883 19.3271 20.0343 19.2248 20.2391 19.0201C20.4439 18.8153 20.5463 18.5693 20.5463 18.2816V10.0456C20.5463 9.75803 20.4439 9.51199 20.239 9.30719ZM19.7098 16.6088C19.7098 16.6654 19.6892 16.7144 19.6478 16.7558C19.6063 16.7971 19.5573 16.8178 19.5007 16.8178H9.04552C8.98892 16.8178 8.93989 16.7971 8.89851 16.7558C8.85716 16.7142 8.83644 16.6654 8.83644 16.6088V10.0456C8.83644 9.98892 8.85709 9.93994 8.89851 9.89856C8.93992 9.85725 8.98894 9.83649 9.04552 9.83649H19.5008C19.5574 9.83649 19.6065 9.85718 19.6478 9.89856C19.6892 9.93996 19.7098 9.98894 19.7098 10.0456V16.6088Z" fill="white" stroke="white" stroke-width="0.5"/>' +
		'</svg>',

    apple: '<svg width="30" height="30" viewBox="0 0 30 30" fill="none" >' +
		'<path opacity="0.802967" d="M15 30C23.2843 30 30 23.2843 30 15C30 6.71573 23.2843 0 15 0C6.71573 0 0 6.71573 0 15C0 23.2843 6.71573 30 15 30Z" fill="#666666"/>' +
		'<path fill-rule="evenodd" clip-rule="evenodd" d="M20.9686 17.6609C20.8849 17.9033 20.7972 18.1347 20.7041 18.3566C20.4766 18.881 20.2081 19.3635 19.897 19.8065C19.4737 20.4114 19.1263 20.8299 18.8585 21.0621C18.444 21.4435 17.9994 21.6394 17.5232 21.6496C17.1812 21.6496 16.7698 21.5525 16.2897 21.3559C15.8087 21.1592 15.3665 21.0621 14.9622 21.0621C14.5381 21.0621 14.0833 21.1592 13.5968 21.3559C13.1096 21.5525 12.7171 21.6559 12.417 21.6654C11.9606 21.6852 11.5057 21.4846 11.0516 21.0621C10.7618 20.8094 10.3993 20.3758 9.96501 19.7623C9.49909 19.1068 9.11608 18.3463 8.816 17.4792C8.49459 16.5435 8.3335 15.6369 8.3335 14.7595C8.3335 13.7543 8.55066 12.8872 8.98578 12.1607C9.32772 11.5771 9.78259 11.1167 10.352 10.7787C10.9213 10.4407 11.5365 10.2685 12.1991 10.2575C12.5615 10.2575 13.0369 10.3696 13.6276 10.59C14.2167 10.8111 14.595 10.9232 14.7608 10.9232C14.8848 10.9232 15.3049 10.7921 16.0172 10.5307C16.6908 10.2883 17.2594 10.188 17.7253 10.2275C18.9873 10.3294 19.9349 10.8269 20.5659 11.7232C19.4374 12.407 18.8791 13.3649 18.8901 14.5937C18.9004 15.5508 19.2471 16.3476 19.9294 16.9802C20.2389 17.2731 20.5848 17.4998 20.9686 17.6609ZM17.794 6.66675C17.8043 6.76704 17.809 6.86733 17.809 6.96683C17.809 7.71704 17.535 8.4175 16.9893 9.06584C16.3299 9.83658 15.5324 10.282 14.6676 10.2117C14.6566 10.1217 14.6503 10.0269 14.6503 9.9274C14.6503 9.2072 14.9638 8.43645 15.5205 7.80628C15.7985 7.48724 16.1523 7.2219 16.5803 7.01027C17.0083 6.80179 17.4134 6.68649 17.794 6.66675Z" fill="white"/>' +
		'</svg>',


    langExpand: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="0 0 15 10" fill="none" >' +
			'<path d="M0.557617 2.5576L2.20262 0.912598L7.55762 6.25593L12.9126 0.912598L14.5576 2.5576L7.55762 9.5576L0.557617 2.5576Z" fill="black" fill-opacity="0.7"/>' +
		'</svg>',

    langSelect: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="0 0 16 12" fill="none" >' +
			'<path d="M5.45455 9.36111L2.14899 6.05555L2.11364 6.0202L2.07828 6.05555L0.964645 7.16919L0.929289 7.20455L0.964645 7.2399L5.41919 11.6944L5.45455 11.7298L5.4899 11.6944L15.0354 2.14899L15.0707 2.11364L15.0354 2.07828L13.9217 0.964645L13.8864 0.929289L13.851 0.964645L5.45455 9.36111Z" fill="#005BF0" stroke="#005BF0" stroke-width="0.1"/>' +
		'</svg>',

    manageAccount: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="0 0 24 20" fill="none" >' +
			'<path fill-rule="evenodd" clip-rule="evenodd" d="M14.8939 9.14809C14.8939 9.14809 15.9901 7.67638 15.9901 6.06451C15.9901 4.97077 15.9901 3.60968 15.378 2.39577C14.8261 1.3025 13.5928 0 10.8519 0C8.11032 0 6.87704 1.3025 6.3258 2.39562C5.71283 3.60968 5.71283 4.97061 5.71283 6.06436C5.71283 7.67685 6.48205 9.51778 7.80923 11.1479C7.49173 11.4476 6.18533 12.1007 5.40033 12.4925C3.84362 13.2712 2.85581 13.7864 2.26503 14.3767C0.957376 15.6853 0.858471 17.8807 0.851752 18.3079C0.845033 18.7535 1.01722 19.1843 1.33097 19.5029C1.64347 19.8202 2.07206 19.9998 2.51768 19.9998H14.1847V18.7499H2.51768C2.40722 18.7499 2.29925 18.7048 2.22159 18.6254C2.14409 18.5467 2.10019 18.4381 2.10128 18.327C2.10487 18.1176 2.16237 16.2481 3.14893 15.2612C3.6044 14.8059 4.55783 14.3121 5.95955 13.6107C7.45579 12.8631 8.28548 12.4175 8.66766 12.0562L9.51125 11.2586L8.77876 10.3589C7.62501 8.94169 6.96267 7.37607 6.96267 6.06451C6.96267 5.05311 6.96267 3.90749 7.44126 2.95905C8.01438 1.82499 9.16079 1.25 10.8519 1.25C12.5416 1.25 13.6892 1.82499 14.2619 2.95843C14.7405 3.90749 14.7405 5.05311 14.7405 6.06451C14.6742 6.4601 14.6529 6.7087 14.6374 6.88973C14.5966 7.36559 14.5958 7.37448 13.9236 8.35887L13.1911 9.25918L14.0348 10.0564C14.8939 9.5 14.8939 9.14809 14.8939 9.14809ZM22.5496 13.8889H23.4852C23.7691 13.8889 24 14.1198 24 14.4037V15.5961C24 15.88 23.7691 16.1111 23.4852 16.1111H22.5496C22.3993 16.1111 22.2752 16.1939 22.2178 16.3328C22.1604 16.4717 22.1894 16.618 22.2956 16.7243L22.957 17.3856C23.0543 17.483 23.1078 17.6122 23.1078 17.7496C23.1078 17.8872 23.0543 18.0167 22.957 18.1139L22.1139 18.957C21.9194 19.1515 21.5804 19.1519 21.3856 18.957L20.7243 18.2957C20.6363 18.208 20.5394 18.1894 20.4739 18.1894C20.2956 18.1894 20.1109 18.3241 20.1109 18.5496V19.485C20.1109 19.7689 19.88 20 19.5961 20H18.4037C18.1198 20 17.8889 19.7689 17.8891 19.485V18.5496C17.8891 18.3243 17.7044 18.1894 17.5261 18.1894C17.4604 18.1894 17.3637 18.2078 17.2757 18.2957L16.6144 18.957C16.4196 19.152 16.0807 19.1517 15.8861 18.957L15.043 18.1139C14.9457 18.0165 14.8922 17.8872 14.8922 17.7496C14.8922 17.6122 14.9457 17.4828 15.043 17.3856L15.7044 16.7243C15.8106 16.618 15.8398 16.4717 15.7822 16.3328C15.7246 16.1939 15.6007 16.1111 15.4504 16.1111H14.5148C14.2309 16.1111 14 15.88 14 15.5959V14.4037C14 14.1198 14.2309 13.8889 14.5148 13.8889H15.4504C15.6007 13.8889 15.7246 13.8061 15.782 13.6672C15.8394 13.5283 15.8104 13.382 15.7043 13.2757L15.0428 12.6144C14.9456 12.517 14.892 12.3878 14.892 12.2504C14.892 12.1128 14.9456 11.9833 15.0428 11.8861L15.8859 11.043C16.0804 10.8485 16.4194 10.8481 16.6143 11.043L17.2756 11.7043C17.3635 11.792 17.4602 11.8106 17.5257 11.8106C17.7043 11.8106 17.8889 11.6759 17.8889 11.4504V10.5148C17.8889 10.2309 18.1198 10 18.4037 10H19.5963C19.8802 10 20.1111 10.2309 20.1111 10.5148V11.4504C20.1111 11.5804 20.1711 11.6637 20.2213 11.7107C20.2893 11.7743 20.3813 11.8106 20.4739 11.8106C20.5396 11.8106 20.6363 11.7922 20.7243 11.7043L21.3856 11.043C21.5804 10.8481 21.9194 10.8485 22.1139 11.043L22.957 11.8861C23.0543 11.9835 23.1078 12.1128 23.1078 12.2504C23.1078 12.3878 23.0543 12.5172 22.957 12.6144L22.2956 13.2757C22.1894 13.382 22.1602 13.5283 22.2178 13.6672C22.2754 13.8061 22.3993 13.8889 22.5496 13.8889ZM19 16.2963C19.7146 16.2963 20.2963 15.7146 20.2963 15C20.2963 14.2854 19.7146 13.7037 19 13.7037C18.2854 13.7037 17.7037 14.2854 17.7037 15C17.7037 15.7146 18.2854 16.2963 19 16.2963Z" fill="#666666" />' +
		'</svg>',

    externalLink: '<svg class="mgPlayerJSTest_position-center mgPlayerJSTest_width-height-100" viewBox="0 0 24 25" fill="none">' +
			'<path fill-rule="evenodd" clip-rule="evenodd" d="M19.3521 5.68455C19.3891 5.77155 19.4091 5.91455 19.4091 5.91455H19.3901V10.8506C19.3901 11.2506 19.0761 11.4736 18.6751 11.4736H18.6851C18.2841 11.4736 17.9411 11.2506 17.9411 10.8506V7.76755L11.6751 14.0686C11.3921 14.3526 10.9331 14.3456 10.6921 14.0626V14.0496C10.4501 13.7666 10.3851 13.2816 10.6691 12.9996L16.9531 6.63955H13.8701C13.4701 6.63955 13.1081 6.34155 13.1081 5.94055V5.96655C13.1081 5.56655 13.4701 5.19055 13.8701 5.19055H18.7021H18.6661V5.24055C18.9071 5.24055 19.2421 5.42355 19.3521 5.68455ZM16.1901 12.3766L17.6401 13.8266V18.3996C17.6401 19.1996 17.0101 19.8096 16.2101 19.8096H6.05906C5.25906 19.8096 4.59106 19.1996 4.59106 18.3996V8.25055C4.59106 7.45055 5.25906 6.76055 6.06006 6.76055H10.6321L12.0821 8.21055H6.04206V18.3605H16.1901V12.3766Z" fill="#555555"/>' +
		'</svg>',

    iconMore: '<svg width="25" height="18" viewBox="0 0 25 18" fill="none" >' +
		'<path d="M17.3473 0.85H2.41024C1.77929 0.85 1.26862 1.36067 1.26862 1.99162V15.9328C1.26862 16.5638 1.77929 17.0744 2.41024 17.0744H17.2825C17.6663 17.0744 18.0181 16.8742 18.2305 16.5634L23.2966 8.95722L18.2305 1.35106C18.0048 1.02022 17.7088 0.85 17.3473 0.85Z" stroke="#666666" stroke-width="1.7"/>' +
		'<circle cx="8" cy="9" r="2" fill="#666666"/>' +
		'<circle cx="14" cy="9" r="2" fill="#666666"/>' +
		'</svg>',

    urlSetting:	'<svg class="mgPlayerJSTest_matching-algorithm-icon" ' +
		'overflow="visible" ' +
		'preserveAspectRatio="none" ' +
		'viewBox="0 0 21 18" ' +
		'width="21" ' +
		'height="21">' +
		'<g class="mgPlayerJSTest_rule-engine-variable" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">' +
			'<g class="mgPlayerJSTest_matching-algorithm-svg" transform="translate(0, 0) rotate(0)" fill="#7A7A7A" stroke="#7A7A7A">' +
			'<path d="M13.01895,14.39189c-0.01254,-0.12894 -0.01895,-0.25966 -0.01895,-0.39189c0,-2.20914 1.79086,-4 4,-4c0.11772,0 0.23426,0.00509 0.3494,0.01505v-6.77181h-16.6988v10.13514c0,0.55975 0.48547,1.01351 1.08434,1.01351zM13.01895,14.39189c0.0202,0.20777 0.0563,0.41088 0.10706,0.60811zM18.00006,10.12603c1.7252,0.44406 2.99994,2.01015 2.99994,3.87397c0,2.20914 -1.79086,4 -4,4c-1.86382,0 -3.42991,-1.27475 -3.87397,-2.99995l-11.39109,-0.00005c-0.95818,0 -1.73494,-0.72602 -1.73494,-1.62162v-11.75676c0,-0.8956 0.77676,-1.62162 1.73494,-1.62162h14.53012c0.95818,0 1.73494,0.72602 1.73494,1.62162v8.5044zM0.6506,2.43243h16.6988v-0.81081c0,-0.55975 -0.48547,-1.01351 -1.08434,-1.01351h-14.53012c-0.59886,0 -1.08434,0.45377 -1.08434,1.01351zM9.08352,6.79157c0.67617,0.2842 1.54621,1.0281 2.66291,2.24836c0.82275,0.73575 1.25358,1.44229 1.25358,2.13334c0,1.03887 -0.96457,1.82674 -2.0587,1.82674c-0.64928,0 -1.43267,-0.35416 -2.40568,-1.04146c-0.22538,-0.1592 -0.26271,-0.45046 -0.08337,-0.65054c0.17934,-0.20008 0.50743,-0.23321 0.73282,-0.07401c0.80277,0.56705 1.40668,0.84007 1.75623,0.84007c0.53657,0 1.01566,-0.39132 1.01566,-0.9008c0,-0.40792 -0.30927,-0.91127 -0.96761,-1.49602l-0.01914,-0.017l-0.01705,-0.01866c-1.03076,-1.12826 -1.82061,-1.80494 -2.31598,-2.01315c-0.39136,-0.16449 -0.86744,-0.07696 -1.48189,0.32473c-0.23193,0.15162 -0.5584,0.10762 -0.72919,-0.09826c-0.17079,-0.20589 -0.12124,-0.4957 0.11069,-0.64732c0.89637,-0.58598 1.76316,-0.74536 2.54673,-0.41602zM6.84152,10.30997c-0.67197,-0.29927 -1.52993,-1.06688 -2.62644,-2.32062c-0.81076,-0.75854 -1.22963,-1.4807 -1.21743,-2.17966c0.01834,-1.05076 0.99799,-1.83078 2.09345,-1.81166c0.65007,0.01135 1.42816,0.38325 2.39021,1.09542c0.22285,0.16496 0.25508,0.46021 0.07199,0.65944c-0.18309,0.19923 -0.51217,0.22701 -0.73501,0.06205c-0.79374,-0.58757 -1.39356,-0.87427 -1.74353,-0.88038c-0.53722,-0.00938 -1.0238,0.37804 -1.03279,0.89335c-0.0072,0.41259 0.29355,0.92711 0.94238,1.53004l0.01886,0.01752l0.01674,0.01917c1.01209,1.15918 1.79096,1.85741 2.28325,2.07665c0.38893,0.17321 0.86713,0.093 1.48942,-0.30255c0.23489,-0.1493 0.56097,-0.0991 0.72834,0.11213c0.16737,0.21123 0.11263,0.50349 -0.12225,0.65279c-0.9078,0.57702 -1.77846,0.72307 -2.55717,0.37627zM17,17.31429c1.83043,0 3.31429,-1.48386 3.31429,-3.31429c0,-1.83043 -1.48386,-3.31429 -3.31429,-3.31429c-1.83043,0 -3.31429,1.48386 -3.31429,3.31429c0,1.83043 1.48386,3.31429 3.31429,3.31429zM16.81064,14.86317c-0.18135,0.18244 -0.47561,0.18244 -0.65688,0l-1.01775,-1.02383c-0.18135,-0.18235 -0.18135,-0.47837 0,-0.66072c0.18127,-0.18244 0.47553,-0.18244 0.65688,0l0.60638,0.60991c0.04578,0.04596 0.12008,0.04596 0.16595,0l1.64189,-1.65171c0.18127,-0.18244 0.47553,-0.18244 0.65688,0c0.08709,0.08761 0.13601,0.20647 0.13601,0.33036c0,0.12388 -0.04893,0.24275 -0.13601,0.33036z" ' +
				'style="stroke-width: 0; stroke-linecap: butt; stroke-linejoin: miter; fill: rgb(115, 115, 148);" vector-effect="non-scaling-stroke" />' +
			'</g>' +
		'</g>' +
		'</svg>'
};

/*global GmCXt*/

let creatorUpdate = {};

creatorUpdate.updateTour = commonUpdate.updateTour;
creatorUpdate.updateCat = commonUpdate.updateCat;

creatorUpdate.addTourList = function(catId, tlist) {

    tlist.forEach(function(t) {

        let cid = catId ? catId : t.category_id;

        let cTag = 'cat_' + cid;

        if (!rootScope.allTourList[cTag]) {
            rootScope.allTourList[cTag] = {};
        }

        rootScope.allTourList[cTag]['tour_' + t.tour_id] = t;
    });

    GmCXt.saveToDapStorage('allTourList', rootScope.allTourList);
};

creatorUpdate.setTour = function(tour, doNotupdate, updateCat) {
    let catId = 'cat_' + tour.category_id;
    let tourId = 'tour_' + tour.tour_id;

    if (!rootScope.allTourList[catId] && !updateCat) {
        rootScope.allTourList[catId] = {};
    }

    if (GmCXt.FT.creatorApp) {
        tour.modification_date = GmCXt.getCurrentTimeInSec();

        if (!doNotupdate) {
            creatorUpdate.updateServerUpdateList(tour.tour_id, "tour");
        }
    }

    if(!updateCat) rootScope.allTourList[catId][tourId] = tour;

    if (!GmCXt.inPlayer) {
        GmCXt.saveToDapStorage('allTourList', rootScope.allTourList);
    }
};

creatorUpdate.deleteTourServerUpdate = function(tid) {

    for (let cat in rootScope.allTourList) {
        let category = rootScope.allTourList[cat];
        for (let tour in category) {
            if ('tour_' + tid === tour) {

                let catId = cat.split('_')[1];

                rootScope.removeTour(catId, tid);
            }
        }
    }
};

function checkParentCat(fromSyncApi, catFoundOnView) {

    let categoryId = get_store_value(Gm.parent).category_id;

    if (categoryId) {
        let isCatUpdateNeeded = rootScope.isUpdateNeeded(categoryId, 'category');

        if (isCatUpdateNeeded) {

            commonUpdate.updateCat({
                category_id: categoryId
            }).then(function(c) {
                commonUpdate.categoryUpdateCb(c);
                rootScope.setCurrentPage('allguides');
            });
        } else if (fromSyncApi) {
            rootScope.catUpdatePending = true;
        }

        let isCatDeleted = rootScope.serverDeletes.categories.indexOf(categoryId) !== -1 ? true : false;

        if (isCatDeleted) {
            rootScope.goBack();
        }
    }
}

function checkCatUpdates(catList, isAllGuides, catId) {

    let foundInView = false;

    catList.forEach(function(c) {
        let updateNeeded = rootScope.isUpdateNeeded(c.category_id, 'category');

        if (updateNeeded) {
            foundInView = true;
            commonUpdate.updateCat(c).then(function(c) {
                rootScope.setCurrentPage('allguides');
            });
        }
    });

    return foundInView;
}

function checkOrgAndAppUpdates() {
    let isUpdateNeeded = rootScope.isUpdateNeeded(GmCXt.organization.organization_id, 'organization');
    if (isUpdateNeeded) {
        rootScope.fetchOrgFromAPI();
    }
    
    isUpdateNeeded = rootScope.isUpdateNeeded(GmCXt.activeAppId, 'application');
    if (isUpdateNeeded) {
        rootScope.fetchApps();
    }
    
}

creatorUpdate.checkCurrentViewForUpdate = function(fromSyncApi) {

    if (GmCXt.isPlayer()) return;

    let currentPage = get_store_value(Gm.CurrentPage);

    if (currentPage) {

        if (currentPage === 'stepview') {
            rootScope.catUpdatePending = true;
            let updateNeeded = rootScope.isUpdateNeeded(get_store_value(Gm.currentTour).tour_id, 'tour');

            if (updateNeeded) {
                rootScope.routeToStepContainer("refreshView", true);
            }

            let isTourDeleted = rootScope.serverDeletes.tours.indexOf(get_store_value(Gm.currentTour).tour_id) >= 0 ? true : false;

            if (isTourDeleted) {
                rootScope.backHandler();
            }
        } else if (currentPage === 'allguides' && !GmCXt.isEmpty(get_store_value(Gm.categoryTours))) {
            get_store_value(Gm.categoryTours).forEach(function(t) {
                let updateNeeded = rootScope.isUpdateNeeded(t.tour_id, 'tour');

                if (updateNeeded) {
                    commonUpdate.updateTour(t);
                }
            });

            checkParentCat(fromSyncApi);

        } else if (currentPage === 'allguides' && !GmCXt.isEmpty(get_store_value(Gm.childCategories))) {

            let cats = get_store_value(Gm.childCategories);
            get_store_value(Gm.parent).category_id;

            rootScope.catUpdatePending = true;

            checkCatUpdates(cats);

            checkParentCat(fromSyncApi);

        } else if (currentPage === 'allguides') {
            let cats = get_store_value(Gm.allCategories);

            rootScope.catUpdatePending = true;

            checkCatUpdates(cats);
        }
    }

    checkOrgAndAppUpdates();
};

let getEntity = function(type, id) {

    let e = {};
    if (type === 'category') {
        e = rootScope.getCategory(id);
    } else if (type === 'tour') {
        e = rootScope.getTourFromId(id);
    } else if (type === 'organization') {
        e = GmCXt.organization;
    } else if (type === 'application') {
        e = GmCXt.appList['app:'+ id];
    }

    return e;
};

creatorUpdate.isUpdateNeeded = function(id, type) {

    // update not needed when no server updates have been received
    if (GmCXt.isEmpty(rootScope.serverUpdates)) return false;

    let e = getEntity(type, id);

    // updated not needed when entity not found in storage
    if (GmCXt.isEmpty(e)) return false;

    let creatorModifiedTime = parseInt(e.modification_date) || 0;
    let serverModifiedTime = rootScope.serverUpdates[type + '_' + id] || 0;

    let updateNeeded = false;
    let diff = serverModifiedTime - creatorModifiedTime;

    if (diff > 2) {
        updateNeeded = true;
    }

    let msg = "isUpdateNeeded: " + type + '_' + id + " .....?" + updateNeeded + "...time difference..." + diff;
    GmCXt.log(61, msg);

    return updateNeeded;
};

creatorUpdate.deleteCategoryServerUpdate = function(catId) {

    let parentCat = rootScope.getCategory(catId).parent_id;

    rootScope.removeCategory({
        category_id: catId
    });

    rootScope.refreshAllGuides = false;

    if (parentCat === '0') {
        rootScope.refreshAllGuides = true;
    }

    //checkCatInView(catId);
};

creatorUpdate.updateServerUpdateList = function(id, type) {
    delete rootScope.serverUpdates[type + '_' + id];
    GmCXt.saveToDapStorage('serverUpdates', rootScope.serverUpdates);
};

creatorUpdate.updateTourProperty = function(tour, value, property) {
    if (GmCXt.isEmpty(tour)) return;

    if (rootScope.allTourList['cat_' + tour.category_id] &&
        rootScope.allTourList['cat_' + tour.category_id]['tour_' + tour.tour_id]) {

        rootScope.allTourList['cat_' + tour.category_id]['tour_' + tour.tour_id][property] = value;

    }

    GmCXt.saveToDapStorage('allTourList', rootScope.allTourList);
};

/*global GmCXt,chrome,browser*/
let gmStorage = GmCXt.storage();

const dapStoreKeys = [
    'appData',
    'categories',
    'pinnedToursList',
    'currentTour',
    'allTourList',
    'languageList',
    'serverUpdates',
    'serverDeletes',
    'taskList',
];

let getExpiry = function(exp) {
    let schedule;
    if (exp && GmCXt.isDefined(exp) && !isNaN(exp)) {
        schedule = Date.now() + exp * 1000;
    } else {
        // Schedule for 24 hours, if expiration time is not set
        schedule = Date.now() + 864000000;
    }
    return schedule;
};

GmCXt.getFromStorage = function(key) {
    let promise = new Promise(function(resolve, reject) {
        try {
            gmStorage.get([key, key + "_time"]).then(function(result) {
                let data = result[key];
                const expiresIn = result[key + "_time"];
			
                //Check expiration time for stored item. If item is expired remove key and return false;
                if (expiresIn && expiresIn !== undefined) {
                    const now = Date.now();
                    if (expiresIn < now) {
                        GmCXt.removeFromStorage(key);
                        resolve(false);
                    }
                } else {
                    resolve(false);
                }

                if (data && data !== undefined) {
                    data = GmCXt.parseJSON(data);
                    if (GmCXt.isDefined(data)) {
                        resolve(data);
                    }
                } else {
                    resolve(false);
                }

            });

        } catch (e) {
            GmCXt.showCookieDisabledPopup();
            reject(false);
        }
    });

    return promise;
};

GmCXt.getFromDapStorage = function(key) {
    return new Promise(function(resolve, reject) {
        let cb = function(res) {
            resolve(res);
        };
        if (GmCXt.isClientJs()) {
            GmCXt.dapStore.getItem(key).then(function(res) {
                resolve(res);
            });
        } else {
            GmCXt.sendMessageToBackgroundService({
                action: "mgPlayerJSTest_action:get_from_dap_storage",
                data: key
            }, cb);
        }
    });
};

GmCXt.getAllFromStorage = function(keys) {
    let data = {};
    return new Promise(function(resolve, reject) {
        const storagePromises = keys.map(function(key) {
            if (dapStoreKeys.indexOf(key) !== -1) {
                return GmCXt.getFromDapStorage(key);
            } else {
                return GmCXt.getFromStorage(key);
            }
        });
        Promise.all(storagePromises).then(function(results) {
            results.forEach(function(result, index) {
                data[keys[index]] = result;
            });
            resolve(data);
        });
    });
};

function saveUser(data) {
    let m = {
        action: "mgPlayerJSTest_action:save_user_info",
        data: data
    };
    GmCXt.updateGlobalUser(data);
    GmCXt.sendMessageToBackgroundService(m);
}

function saveOrg(data) {
    let m = {
        action: "mgPlayerJSTest_action:save_org",
        data: data
    };
    GmCXt.updateGlobalOrg(data);
    GmCXt.sendMessageToBackgroundService(m);
}

GmCXt.saveToStorage = function(key, data, expires) {
    let promise = new Promise(function(resolve, reject) {

        if (key === 'user') {
            saveUser(data);
        } else if (key === 'organization') {
            saveOrg(data);
        }

        data = JSON.stringify(data);
        let obj = {};
        obj[key] = data;
        obj[key + "_time"] = getExpiry(expires);
        gmStorage.set(obj).then(function() {
            resolve(true);
        }).catch(function(err) {
            reject(err);
        });
    });

    return promise;
};

GmCXt.saveToDapStorage = function(key, data) {
    return new Promise(function(resolve, reject) {
        let cb = function() {
            resolve(true);
        };

        if (GmCXt.isClientJs()) {
            GmCXt.dapStore.setItem(key, data).then(function() {
                resolve(true);
            });
        } else {
            GmCXt.sendMessageToBackgroundService({
                action: "mgPlayerJSTest_action:save_to_dap_storage",
                data: {
                    key: key,
                    data: data
                }
            }, cb);
        }
    });
};

GmCXt.removeFromStorage = function(key) {
    let promise = new Promise(function(resolve, reject) {

        if (key === 'user') {
            saveUser(false);
        } else if (key === 'organization') {
            saveOrg(false);
        }

        gmStorage.remove([key, key + "_time"]).then(function() {
            resolve(true);
        }).catch(function(err) {
            reject(err);
        });
    });

    return promise;
};

GmCXt.removeFromDapStorage = function(key) {
    return new Promise(function(resolve, reject) {
        let cb = function() {
            resolve(true);
        };
        if (GmCXt.isClientJs()) {
            GmCXt.dapStore.removeItem(key).then(function() {
                resolve(true);
            });
        } else {
            GmCXt.sendMessageToBackgroundService({
                action: "mgPlayerJSTest_action:remove_from_dap_storage",
                data: key
            }, cb);
        }

    });
};

GmCXt.resetStorage = function() {
    GmCXt.clearIndexedDb();

    let promise = new Promise(function(resolve, reject) {
        saveUser(false);
        saveOrg(false);
        resolve(true);
    });

    return promise;
};

GmCXt.conf.appName + GmCXt.conf.env + 'DB';

if (GmCXt.isLXP() && document.referrer) {
    GmCXt.filterUrlScheme(document.referrer).replaceAll(".", "");
}

GmCXt.clearIndexedDb = function(d) {
    try {
        if (GmCXt.isClientJs()) {
            GmCXt.dapStore.clear();
        } else {
            GmCXt.sendMessageToBackgroundService({
                action: "mgPlayerJSTest_action:clear_dap_storage"
            });
        }
    } catch (e) {
        GmCXt.log(1, "ERROR: IndexedDb not cleared, " + d);
    }
};

/*global GmCXt,mg$*/

GmCXt.stopCapture = stopCapture;

service.main();
//let rootScope = {};

GmCXt.logAll = logAll;
GmCXt.logLog = logLog;
rootScope.playVideoTour = "video";
rootScope.playSlideshow = "slideshow";
rootScope.playGiphy = "giphy";
rootScope.playVLab = "vLab";
rootScope.playAuto = "doitforme";
rootScope.playGuideMe = "guideMe";
rootScope.playTestMe = "testMe";
rootScope.isClientJs = false;
rootScope.contextTours = [];

rootScope.showCaptchaError = false;
rootScope.config = GmCXt.conf;
rootScope.staticContentPath = GmCXt.conf.staticContentPath;
rootScope.webPortalUrl = GmCXt.conf.webPortalUrl;
rootScope.analyticsPortalUrl = GmCXt.conf.analyticsPortalUrl;
rootScope.appConfig = GmCXt.conf.appConfig;
rootScope.appName = GmCXt.conf.appName;
rootScope.appType = GmCXt.conf.appType;
rootScope.brandName = "Cornerstone Guide";
rootScope.appVersion = GmCXt.conf.version;
rootScope.ssoRedirectionUrl = GmCXt.conf.ssoRedirectionUrl;
rootScope.ssoApiUrl = GmCXt.conf.ssoApiUrl;
rootScope.ssoConfigUrl = GmCXt.conf.ssoConfigUrl;
rootScope.ssoId = "";
rootScope.isLXP = GmCXt.isLXP();
rootScope.isWestpac = GmCXt.isWestpac();
rootScope.isMyGuide = GmCXt.isMyGuide();
rootScope.onPrem = GmCXt.onPrem();
rootScope.isMicroPlayer = GmCXt.isMicroPlayer();
rootScope.isClientJs = GmCXt.isClientJs();
rootScope.isElectron = GmCXt.isElectron();
rootScope.checkInsightEnabled = GmCXt.checkInsightEnabled;
rootScope.isScreenRecorderClose = false;
rootScope.taskListApiCalled = false;
rootScope.countLimit = 99;
rootScope.playerSyncCount = 0;

rootScope.languages = [];
rootScope.selectedLanguage = "";
rootScope.userPrefLang = false;
rootScope.tourVideoInProgressArr = [];
rootScope.ssoHitCount = 0;
rootScope.thirtyMinutesInSeconds = 1800;
rootScope.thirtyDaysInSeconds = 2592000;
rootScope.thirtyDaysInMSeconds = 2592000 * 1000;
rootScope.lastCheckBrandLogo = 0;

rootScope.browserApp = GmCXt.browserApp;
rootScope.allowedImageExtensions = ["image/png", "image/jpeg", "image/jpg"];

rootScope.appDomainLimit = 500;

rootScope.showPlayer = false;
rootScope.playerMode = false;
rootScope.isPlayer = GmCXt.isPlayer;
rootScope.browserLang = GmCXt.browserLang;
rootScope.defaultLang = {};


rootScope.maintenance = false;
rootScope.appEnvs = [];
rootScope.categoryDataForAutomation = [];
rootScope.jsonEditor = false;
rootScope.searchFilterDropDownVisible = false;
rootScope.isRefresh = false;
rootScope.isApiCallOn = false;
rootScope.isTaskListActive = false;
rootScope.isAppJsonCalling = false;

rootScope.pendingStepCount = -1;
rootScope.botTourPlayList = [];
rootScope.labels = GmCXt.getAllLabels();
rootScope.allCategories = [];
rootScope.chatLabels = {};

rootScope.toursModifiedTime = 0;
rootScope.refreshTime = 0;
rootScope.isTaskListVisible = false;
rootScope.taskListCount = 0;

rootScope.languageList = [];
rootScope.languages = [];

rootScope.svgs = playerSvgConst;
rootScope.isForwardListenerAttached = false;
rootScope.isBackwardListenerAttached = false;
rootScope.userList = {};

GmCXt.isSidePanelApp = true;


let getStorageAll = [
    'user',
    'userList',
    'accessibility',
    'organization',
    'activeAppId',
    'activeTourId',
    'activeScreenCastTourId',
    'activeTab',
    'activeView',
    'activeLang',
    'activeVoice',
    'userPrefLang',
    'videosInProgress',
    'currentTour',
    'loginTime',
    'trackerSecrets',
    'allTourList',
    'refreshTime',
    'lastTimeStampSync',
    'activeSortFilter',
    'segmentGroupData',
    'currentStep',
    'appData',
    'toursModifiedTime',
    'currentPage',
    'breadCrumb'
];

if (GmCXt.FT.creatorApp) {
    getStorageAll.push('showPlayer');
    getStorageAll.push('serverUpdates');
    getStorageAll.push('serverDeletes');
    getStorageAll.push('category');
    getStorageAll.push('testAuto');
}

rootScope.navBarVisible = false;
rootScope.jsonEditor = false;
rootScope.botGuideCount = 0;

rootScope.orgSecrret = GmCXt.conf.orgSecrret;
rootScope.myGuideOrgKey = "";
rootScope.taskListApiInProcess = false;

rootScope.isUserLoggedIn = function() {
    let user = GmCXt.user;
    if (user && user.accesstoken) return true;
    return false;
};

rootScope.incrementPendingStepCount = function() {
    if (rootScope.pendingStepCount < 0) rootScope.pendingStepCount = 0;
    rootScope.pendingStepCount++;
    Gm.statusBar.set('incrementPendingStepCount');
};

rootScope.decrementPendingStepCount = function() {
    rootScope.pendingStepCount--;
    rootScope.pendingStepCount = rootScope.pendingStepCount > 0 ? rootScope.pendingStepCount : 0;
    Gm.statusBar.set('decrementPendingStepCount');
};

rootScope.setStepPendinCount = function(val) {
    if (val) {
        rootScope.incrementPendingStepCount();
    } else {
        rootScope.decrementPendingStepCount();
    }
};


rootScope.handleError = function(e) {
    if (e && e.name) {
        if (e.name === 'PermissionDeniedError' || e.name === 'NotAllowedError') {
            rootScope.showPopup(rootScope.labels.userDeniedMessage);
        } else if (e.name === 'CameraNotFound') {
            rootScope.cameraDisabled = true;
            rootScope.showPopup(rootScope.labels.noCamera);
        } else {
            mgError.on({
                code: 2200,
                info: e
            });
        }
    }
};
rootScope.reportInitialization = function() {
    GmCXt.log(21, "LOADING side panel, globals initialised");
    GmCXt.handleAppInit();
};

rootScope.hideUserImageDropDown = function() {
    mg$(".mgPlayerJSTest_login-logout-wrapper").slideUp(200);
    mg$(".mgPlayerJSTest_user-image-wrapper").removeClass("active");
};

rootScope.hideStepViewActionDropdown = function() {
    mg$(".mgPlayerJSTest_detail-view-action-options-dropdownn").slideUp(200);
};

rootScope.hideStepActionDropdown = function() {
    mg$(".mgPlayerJSTest_stepaction-menu-options-dropdown-action-menu-options-dropdown").slideUp(200);
};

rootScope.hideStepDownloadActionDropdown = function() {
    mg$(".mgPlayerJSTest_detail-download-action-options-dropdown").slideUp(200);
    rootScope.isMediaFileDropdown = false;
    mg$(".mgPlayerJSTest_tour-item").removeClass("mgPlayerJSTest_z-index mgPlayerJSTest_z-index-10");
    mg$(".mgPlayerJSTest_header-detail-view-tour-download-wrapper").removeClass(
        "mgPlayerJSTest_dropdown-active"
    );
};

rootScope.hideLanguDropdown = function(event) {
    event.stopPropagation();
    rootScope.lanDropDownVisible = false;
    Gm.lanDropDownVisible.set(false);
    mg$('.mgPlayerJSTest_lang-dropdown-wrapper').slideUp(100);
};

rootScope.onBodyClick = function(e) {

    GmCXt.startIdleActivityTimer();
    //hide failed step border
    if (GmCXt.failedStepId) {

        let fStep = mg$('#step-' + GmCXt.failedStepId);

        if (fStep && fStep.hasClass('step-highlight')) {

            fStep.removeClass('step-highlight');

            mg$('.step-not-found').remove();

            mg$('.guide-not-followed').remove();

            GmCXt.failedStepId = 0;
        }
    }

    //Hide User Action dropdown from header bar on body click
    if (!mg$(e.target).hasClass('ege-user-image') && !mg$(e.target).hasClass('mgPlayerJSTest_user-image-wrapper')) {
        rootScope.hideUserImageDropDown();
    }

    //Hide Home page, Category list page and Tour list page Action dropdown on body click
    if (mg$('.mgPlayerJSTest_category-action-dropdown').is(':visible')) {
        if (!mg$(e.target).hasClass('mgPlayerJSTest_category-action-dropdown') && !mg$(e.target).hasClass('mgPlayerJSTest_category-pencil-icon')) {
            rootScope.hideActionDropdown();
        }
    }

    //Hide Home page, Category list page and Tour list page Action dropdown on body click
    if (mg$('.tour-action-dropdown').is(':visible')) {
        if (!mg$(e.target).hasClass('tour-action-dropdown') && !mg$(e.target).hasClass('tour-pencil-icon')) {
            rootScope.hideTourActionDropdown();
        }
    }

    //Hide Export category, filter dropdown on body click
    if (mg$('.mgPlayerJSTest_checkbox-dropdown-wrapper').is(':visible')) {
        if (!mg$(e.target).hasClass('mgPlayerJSTest_checkbox-dropdown-wrapper')) {
            mg$('.mgPlayerJSTest_checkbox-dropdown-wrapper').slideUp(200);
        }
    }

    // Hide dropdown of the survey question
    if (mg$('.mgPlayerJSTest_questions-type-dropdown').is(':visible')) mg$('.mgPlayerJSTest_questions-type-dropdown').slideUp(200);

    //Hide Language Action dropdown on body click
    if (mg$('.mgPlayerJSTest_ege-header-action-dropdown').is(':visible')) {
        if (!mg$(e.target).hasClass('mgPlayerJSTest_ege-header-action-dropdown') && !mg$(e.target).hasClass('tour-pencil-icon')) {
            rootScope.hideTourActionDropdown();
        }
    }

    // Hide Step action dropdown on tour view page on body Click
    if (mg$('.mgPlayerJSTest_stepaction-menu-options-dropdown-action-menu-options-dropdown').is(':visible')) {
        if (!mg$(e.target).hasClass('mgPlayerJSTest_stepaction-menu-options-dropdown-action-menu-options-dropdown') &&
      !mg$(e.target).hasClass('step-pencil-icon') &&
      !mg$(e.target).parents('.step-pencil-icon').length) {
            rootScope.hideStepActionDropdown();
        }
    }

    if (mg$('.mgPlayerJSTest_detail-download-action-options-dropdown').is(':visible')) {
        if (!mg$(e.target).hasClass('mgPlayerJSTest_detail-download-action-options-dropdown') && !mg$(e.target).hasClass('mgPlayerJSTest_header-detail-view-tour-download-wrapper')) {
            rootScope.hideStepDownloadActionDropdown();
        }
    }

    if (mg$('.mgPlayerJSTest_detail-view-action-options-dropdownn').is(':visible')) {
        if (!mg$(e.target).hasClass('mgPlayerJSTest_detail-view-action-options-dropdownn') && !mg$(e.target).hasClass('header-detail-view-tour-options-wrapper')) {
            rootScope.hideStepViewActionDropdown();
        }
    }

    if (mg$('.download-list').length && mg$('.download-list').is(':visible')) {
        mg$('.download-list').slideToggle();
    }

    if (rootScope.hideFiltersDropdown &&
    (!mg$(e.target).hasClass('mgPlayerJSTest_all-guides-search-filters-dropdown-user') ||
      !mg$(e.target).hasClass('mgPlayerJSTest_all-guides-search-filters-dropdown-published') ||
      !mg$(e.target).hasClass('mgPlayerJSTest_all-guides-search-filters-dropdown-assignee') ||
      !mg$(e.target).hasClass('mgPlayerJSTest_all-guides-search-filters-dropdown-sort')) &&
    !mg$(e.target).hasClass('mgPlayerJSTest_all-guides-search-filters')) {
        rootScope.hideFiltersDropdown();
    }

    //Hide LXP Filter dropdown on body click
    if (mg$('.filter-list').is(':visible')) {
        if (!mg$(e.target).hasClass('filter-list') && !mg$(e.target).hasClass('filter-wrapper') && !mg$(e.target).hasClass('selected-filter')) {
            rootScope.hideFilterList();
        }
    }

    //Hide Language dropdown on body click
    if (mg$('.mgPlayerJSTest_lang-dropdown-wrapper').is(':visible')) {
        if (!mg$(e.target).hasClass('mgPlayerJSTest_selected-lang-wrapper') && !mg$(e.target).hasClass('mgPlayerJSTest_lang-dropdown-wrapper')) {
            rootScope.hideLanguDropdown(e);
        }
    }

    //Hide User Preferences dropdown on body click
    if (mg$('.mgPlayerJSTest_setting-dropdown-userPref').is(':visible')) {
        if (!mg$(e.target).hasClass('mgPlayerJSTest_user-pref-scope')) {
            rootScope.hideUserPrefDropdown(e);
        }
    }

    //Hide Manage keywords filters dropdown on body click
    if (mg$('.mgPlayerJSTest_dropdown-list-wrapper').is(':visible')) {
        if (!mg$(e.target).hasClass('mgPlayerJSTest_filter-dropdown-wrapper')) {
            rootScope.hideFiltersDropdownList();
        }
    }

    //Hide Branch dropdown on body click
    if (mg$('.mgPlayerJSTest_branch-dropdown-list-wrapper').is(':visible')) {
        if (!mg$(e.target).hasClass('mgPlayerJSTest_branch-dropdown-wrapper')) {
            mg$('.mgPlayerJSTest_branch-dropdown-list-wrapper').slideUp(200);
        }
    }
};

rootScope.subscribeEvents = function() {
    mg$(document.body).off("click");
    mg$(document.body).click(rootScope.onBodyClick);

    mg$(document.body).off('mousemove keydown mousedown touchstart')
        .on('mousemove keydown mousedown touchstart', function() {
            GmCXt.startIdleActivityTimer();
        });

    window.onkeyup = function(e) {
        if (e && e.keyCode && e.keyCode === 27) {
            if (
                GmCXt.playerI &&
        GmCXt.playerI.mode === "live" &&
        GmCXt.playerI.linkGuidePlayMode &&
        GmCXt.playerI.linkGuidePlayMode === "PDF"
            ) ; else {
                rootScope.closeAppPanel();
            }
        }
    };
};

rootScope.hideActionDropdown = function() {
    mg$(".mgPlayerJSTest_category-action-dropdown").slideUp(200);
};

rootScope.isRawChromeBlob = function(file) {
    return file.indexOf('blob:') !== 0 ? false : true;
};

function readStorage() {
    return new Promise(function(resolve) {
        GmCXt.getAllFromStorage(getStorageAll).then(function(res) {
  
            if (res) {
                if (GmCXt.isEmpty(res.appData)) {
                    GmCXt.logoutUser();
                } else {
                    GmCXt.appList = res.appData;
                    rootScope.syncApps(GmCXt.appList);
                }
                if (res.user) {
                    GmCXt.updateGlobalUser(res.user);
                    GmCXt.user = res.user;
                    rootScope.user = res.user;
                    rootScope.syncUser();
                    if (res.user.organization) rootScope.saveOrganization(res.user.organization);
                } else {
                    GmCXt.user = {};
                    rootScope.user = false;
                }

                if (res.organization) {
                    GmCXt.updateGlobalOrg(res.organization);
                    GmCXt.organization = res.organization;
                } else if (!GmCXt.isEmpty(GmCXt.user)) {
                    if (GmCXt.user.organization) {
                        rootScope.saveOrganization(GmCXt.user.organization);
                    } else {
                        rootScope.fetchOrgFromAPI();
                    }
                } else {
                    GmCXt.organization = {};
                    GmCXt.organization = false;
                }

                rootScope.trackerSecrets = res.trackerSecrets || {};
  			    GmCXt.trackerUtil.secrets = res.trackerSecrets || {};

                if(res.activeAppId) GmCXt.activeAppId = res.activeAppId;

                if (res.userList) rootScope.userList = res.userList;
                if (res.activeView) Gm.activeView.set(res.activeView);
                if (res.currentPage) Gm.CurrentPage.set(res.currentPage);
                if (res.activeSortFilter) Gm.activeSortFilterStore.set(res.activeSortFilter);
                if (res.breadCrumb) Gm.breadCrumb.set(res.breadCrumb);
                if (res.activeScreenCastTourId) rootScope.activeScreenCastTourId = res.activeScreenCastTourId;
                if (res.activeTourId) rootScope.activeTourId = res.activeTourId;
                if(res.videosInProgress) rootScope.tourVideoInProgressArr = res.videosInProgress;
                if (!GmCXt.isFalse(res.activeLang)) {
                    rootScope.language = res.activeLang;
                    GmCXt.language = res.activeLang;
                }
                if (!GmCXt.isFalse(res.activeVoice)) {
                    rootScope.languageVoice = res.activeVoice;
                }
                if (!GmCXt.isFalse(res.userPrefLang)) {
                    rootScope.userPrefLang = res.userPrefLang;
                }

                rootScope.lastTimeStampSync = res.lastTimeStampSync ? res.lastTimeStampSync : 0;
                rootScope.refreshTime = res.refreshTime ? res.refreshTime : 0;
                rootScope.loginTime = res.loginTime || 0;
                rootScope.currentStep = res.currentStep || {};
                rootScope.toursModifiedTime = res.toursModifiedTime || {};

                rootScope.allTourList = res.allTourList || {};
                rootScope.currentTour = res.currentTour || {};
                Gm.currentTour.set(rootScope.currentTour);

                GmCXt.accessibility = res.accessibility || false;
                Gm.accessibility.set(GmCXt.accessibility);

                if (GmCXt.FT.creatorApp) {
                    rootScope.allCategories = res.categories || {};
                    rootScope.processCategories();
                    if (res.testAuto) rootScope.testAuto = res.testAuto;
                    rootScope.serverDeletes = res.serverDeletes || {
                        categories: [],
                        tours: []
                    };
                    rootScope.serverUpdates = res.serverUpdates || {};
                    if (res.playerMode) {
                        rootScope.showPlayer = res.playerMode;
                    } else {
                        rootScope.showPlayer = false;
                    }
                }

                if (res.segmentGroupData) {
                    let expiryTime = res.segmentGroupData.time + GmCXt.t.syncSegment;
                    if (Date.now() < expiryTime) {
                        rootScope.allSegments = res.segmentGroupData.list;
                        rootScope.syncSegmentData();
                    } else {
                        rootScope.allSegments = [];
                    }
                }
            }
            resolve();
        });
    });

}

rootScope.saveUser = function(user) {
    if (user.organization) {
        delete user.organization;
    }

    GmCXt.user = user;
    GmCXt.updateGlobalUser(user);
    rootScope.user = user;
    GmCXt.saveToStorage('user', user);
    rootScope.syncUser();
};

rootScope.saveOrganization = function(org) {
    GmCXt.log(21, "SAVE organization");
    GmCXt.saveToStorage('organization', org);
    GmCXt.orgBucket = org.bucket;
    GmCXt.organization = org;
    rootScope.enableOrgFeatures(org);
    GmCXt.updateGlobalOrg(org);
};

rootScope.updateVideoInProgressList = function(action, tourId) {
    GmCXt.getFromStorage('videosInProgress').then(function(data) {
        let videosInProgress = data;
        switch (action) {
        case 'add':
            if (videosInProgress) {
                videosInProgress.push(tourId);
            } else {
                videosInProgress = [tourId];
            }
            break;
        case 'remove':
            var index = videosInProgress.indexOf(tourId);
            videosInProgress.splice(index, 1);
        }
        rootScope.tourVideoInProgressArr = videosInProgress;
        GmCXt.saveToStorage('videosInProgress', videosInProgress);
    });
};


rootScope.setAccessibility = function() {
    GmCXt.accessibility = !GmCXt.accessibility;
    Gm.accessibility.set(GmCXt.accessibility);
    GmCXt.saveToStorage('accessibility', GmCXt.accessibility);
};

rootScope.syncUser = function() {
    let u = GmCXt.user;
    let m = {
        action: "mgPlayerJSTest_action:sync_user",
        data: {
            user: u,
        },
    };
    GmCXt.sendMessageToBackgroundService(m);
};

function updateCatList(cat, parent_id, remove) {
    let index;

    if (parent_id) {
        if (!rootScope.subCategoryStore["cat_" + parent_id]) {
            rootScope.subCategoryStore["cat_" + parent_id] = [];
        }

        rootScope.subCategoryStore["cat_" + parent_id].forEach(function(c, key) {
            if (c.category_id === cat.category_id) {
                index = key;
            }
        });

        if (index >= 0) {
            if (remove) {
                rootScope.subCategoryStore["cat_" + parent_id].splice(index, 1);
            } else {
                rootScope.subCategoryStore["cat_" + parent_id].splice(index, 1, cat);
            }
        } else if (!remove) {
            rootScope.subCategoryStore["cat_" + parent_id].push(cat);
        }
    } else {
        rootScope.categoryStore.forEach(function(c, key) {
            if (c.category_id === cat.category_id) {
                index = key;
            }
        });

        if (index >= 0) {
            if (remove) {
                rootScope.categoryStore.splice(index, 1);
            } else {
                rootScope.categoryStore.splice(index, 1, cat);
            }
        } else if (!remove) {
            rootScope.categoryStore.push(cat);
        }
    }
}

rootScope.hideTourActionDropdown = function() {
    let stepWrapper = mg$(".mgPlayerJSTest_step-image-wrapper");
    mg$(stepWrapper).removeClass("active");
    mg$(".tour-action-dropdown").slideUp(200);
    mg$(".mgPlayerJSTest_ege-header-action-dropdown").slideUp(200);
    mg$(".tour-action-dropdown-embed-menu").slideUp(100);
    mg$(".tour-action-dropdown-video-step-menu").slideUp(100);
    mg$(".tour-action-dropdown-image-step-menu").slideUp(100);
    mg$(".tour-action-menu-active").removeClass("tour-action-menu-active");
    mg$(".mgPlayerJSTest_tour-item").removeClass("mgPlayerJSTest_z-index mgPlayerJSTest_z-index-max");
};

rootScope.updateLabels = function() {
    let organization = GmCXt.organization;
    if (!rootScope.language && organization && organization.admin_settings &&
    organization.admin_settings.language_settings &&
    organization.admin_settings.language_settings.default) {

        rootScope.language = organization.admin_settings.language_settings.default.language;

        if (GmCXt.browserLang && GmCXt.browserLang !== rootScope.language &&
      GmCXt.checkLangExist(organization.admin_settings.language_settings.translations, GmCXt.browserLang)) {
            rootScope.language = GmCXt.browserLang;
        }
        GmCXt.language = rootScope.language;
        GmCXt.saveToStorage('activeLang', rootScope.language);
    }

    if (!rootScope.language && organization && organization.admin_settings && organization.admin_settings.language_settings &&
    organization.admin_settings.language_settings.default) {
        rootScope.language = organization.admin_settings.language_settings.default.language;
    }
    rootScope.languages.filter(function(item) {
        if (item.language === rootScope.language) {
            rootScope.selectedLanguage = item.name;
        }
    });

    rootScope.labels = GmCXt.getAllLabels(rootScope.language);
    Gm.selectedLang.set(rootScope.language);

    GmCXt.setLangPref(rootScope.lang);

    if (organization && organization.settings) {
        rootScope.updateCustomLabels(organization.settings);
    }
};

rootScope.updateAppLang = function(language) {
    let lang = "";
    rootScope.languages.filter(function(item) {
        if (item.language === language) {
            lang = item;
        }
    });

    if (!lang) {
        lang = rootScope.defaultLang;
    }

    if (GmCXt.isDefined(lang)) {
        rootScope.selectedLanguage = lang.name;
        GmCXt.mgActiveLang = lang.language;
        GmCXt.language = lang.language;
        GmCXt.saveToStorage('activeLang', lang.language);

        rootScope.updateLabels();
    }
};

rootScope.processCategories = function() {
    for (let id in rootScope.allCategories) {
        let cat = rootScope.allCategories[id];
        updateCatList(cat, parseInt(cat.parent_id));
    }
};

rootScope.syncSegmentData = function() {
    GmCXt.allSegments = rootScope.allSegments;
};

rootScope.updatePageUrl = function(d) {
    rootScope.pageUrl = d.url;
    rootScope.urlParts = d.urlParts;

    //GmCXt.urlParts.set(d.urlParts);
    //GmCXt.pageTitle.set(d.title);
    GmCXt.urlParts = d.urlParts;
    GmCXt.pageTitle = d.title;
    GmCXt.elAppName = d.elAppName;

    GmCXt.log(1, "Updated urls and page info in side panel");
};

rootScope.syncTaskList = function(tlist) {
    let expiryTime = tlist.time + GmCXt.t_.hr24;

    if (Date.now() < expiryTime) {
        rootScope.taskList = tlist.list;
        return tlist;
    } else {
        rootScope.taskList = null;
        rootScope.taskList = [];
        GmCXt.removeFromDapStorage('taskList');
        return null;
    }
};

rootScope.setMode = function() {
    if (GmCXt.isPlayer()) {
        rootScope.showPlayer = true;
    } else {
        rootScope.playerMode = true;
    }
};

function updateNotificationTours(t) {
    Object.keys(t).forEach(function(key) {
        if (parseInt(key)) {
            rootScope.notiTourIds.push(parseInt(key));
        }
    });
}

rootScope.showLangErrorPopup = function(l, isBranch) {
    let lname = l.name || l.language;
    let str = rootScope.labels.stepWarningForLanguage.replaceAll('{GUIDE_LANG}', lname);
    if (isBranch) {
        rootScope.alertMessage = str;
        mg$(".mgPlayerJSTest_icon-play-popup").show();
    } else {
        modal.open(str, 'warning');
    }
};

rootScope.getTourCreationLang = function(tour) {
    let language = {};
    let tourSetting = tour.tour_settings;

    if (GmCXt.isDefined(tourSetting.language_settings)) {
        language = tourSetting.language_settings;
    }

    return language;
};

rootScope.prepSingCatLang = function(cat, lang) {
    if (GmCXt.isEmpty(cat)) return;
    let langData = cat.language_data;
    if (langData && langData[lang]) {
        if (langData[lang].category_title) {
            cat.category_title = langData[lang].category_title;
        }
        if (langData[lang].category_description) {
            cat.category_description = langData[lang].category_description;
        }
    }
    return cat;
};

rootScope.prepCatLangJson = function(_categories, lang) {
    if (GmCXt.isEmpty(_categories)) return [];
    let categories = structuredClone(_categories);
    let key = 0;

    categories.forEach((cat) => {
        cat = rootScope.prepSingCatLang(cat, lang);
        categories[key] = cat;
        key++;
    });
    return categories;
};

rootScope.isGuideInOriginalLang = function(t, showError, isBranch) {
    let guideLang = rootScope.getTourCreationLang(t);

    if (rootScope.language && rootScope.enableTranslation && guideLang.language &&
    guideLang.name && guideLang.language !== rootScope.language) {
        if (guideLang.language.indexOf("en-") !== -1 && guideLang.language.substring(0, 3) === rootScope.language.substring(0, 3)) {
            return true;
        } else {
            if (showError) {
                rootScope.showLangErrorPopup(guideLang, isBranch);
            }
            return false;
        }
    } else {
        return true;
    }
};

rootScope.notDefaultLang = function() {
    if (rootScope.language && rootScope.defaultLang &&
    rootScope.defaultLang.language !== rootScope.language) {
        return true;
    } else {
        return false;
    }
};

rootScope.getTranslatedTourAndSteps = function(_tour, lang) {
    let tour = {
        ..._tour,
    };
    let languageData = tour.language_data;
    if (!tour.tour_settings.translationEnable && GmCXt.isGuide(tour)) {
        lang = rootScope.defaultLang;
    }

    if (languageData && languageData[lang] && !rootScope.isGuideInOriginalLang(tour)) {
        let lData = languageData[lang];

        if (lData.tour_title) {
            tour.tour_title = lData.tour_title;
            tour.tour_description = lData.tour_description;
        }

        mg$.each(tour.steps, function(key, step) {
            let stepLangData = step.language_data;
            if (stepLangData && stepLangData[lang] &&
        (stepLangData[lang].step_title || stepLangData[lang].step_description)) {
                let sData = stepLangData[lang];

                tour.steps[key].step_title = sData.step_title;
                if (sData.step_description) {
                    tour.steps[key].step_description = sData.step_description;
                } else {
                    tour.steps[key].step_description = "";
                }
                tour.steps[key].step_audio = sData.step_audio;
                tour.steps[key].step_audio_text = sData.step_audio_text;

                sData.step_settings = GmCXt.parseJSON(sData.step_settings);
                tour.steps[key].step_settings = GmCXt.validateDataModel(
                    sData.step_settings,
                    GmCXt.model.stepSettings
                );
            }
        });
    }
    return tour;
};

rootScope.setNotifTours = function() {
    GmCXt.getAllFromStorage(['toursClosed', 'tourIdArray']).then(function(st) {
        rootScope.notiTourIds = [];
        let u = GmCXt.user;

        let closedTour = GmCXt.parseJSON(st.toursClosed);
        updateNotificationTours(closedTour);

        let viewedGuide = {};
        if (GmCXt.isAnonymousUser()) {
            viewedGuide = st.tourIdArray || {};
        } else {
            viewedGuide = u?.settings?.viewed_guide_notifications || {};
        }

        if (!GmCXt.isEmpty(viewedGuide)) {
            updateNotificationTours(viewedGuide);
        }

        rootScope.processNotificationTours(viewedGuide);
    });
};

function sortNotifTours(tours, viewedGuide) {
    rootScope.resetNotificationData();

    if (tours) {
        tours = GmCXt.sortToursByModifcationDate(tours);
        for (let i = 0, j = tours.length; i < j; i++) {
            let tour = rootScope.notDefaultLang() ?
                rootScope.getTranslatedTourAndSteps(tours[i], rootScope.language) :
                tours[i];

            if (tour && !tour.tour_settings.oneTimeNotification) {
                if (viewedGuide[tour.tour_id]) {
                    rootScope.notifications.doNotShowTour.push({
                        tour_id: tour.tour_id,
                        tour_title: tour.tour_title,
                    });
                } else if (GmCXt.inArray(tour.tour_id, rootScope.notiTourIds)) {
                    rootScope.notifications.snoozeTour.push({
                        tour_id: tour.tour_id,
                        tour_title: tour.tour_title,
                    });
                }
            }
        }
    }
}
rootScope.notiTourIds = [];
rootScope.resetNotificationData = function() {
    rootScope.notifications = {
        snoozeTour: [],
        doNotShowTour: [],
    };
};

rootScope.processNotificationTours = function(viewedGuide) {
    if (rootScope.notiTourIds.length === 0) {
        return false;
    }

    let data = {
        tour_ids: "[" + rootScope.notiTourIds.toString() + "]",
    };

    if (GmCXt.inPlayer) {
        sortNotifTours(rootScope.publishedTours, viewedGuide);
    } else {
        api.getTours(data, function(_t) {
            sortNotifTours(_t, viewedGuide);
        });
    }
};

rootScope.checkAppList = function() {
    return new Promise(function(resolve, reject) {
        Gm.loading.set(true);
        //let appList = get(GmCXt.appList);
        let appList = GmCXt.appList;
        if (!GmCXt.isEmpty(appList)) {
            Gm.loading.set(false);
            resolve();
        } else {
            GmCXt.getFromDapStorage('appData').then(function(r) {
                GmCXt.appList = r;
                rootScope.syncApps(r);
                Gm.loading.set(false);
                resolve();
            });
        }
    });
};

function updateSettingOnAppSwitch() {

    let org = GmCXt.organization;
    if (!GmCXt.isEmpty(org)) {
        rootScope.updateCustomLabels(org.settings);
        rootScope.enableOrgFeatures(org);
    }
}

rootScope.selectLanguage = function(lang) {
    if (rootScope.userPrefLang) {
        if (rootScope.selectedLanguage === lang) {
            return true;
        }
    } else if (!lang) {
        return true;
    }
};

function getAllLanguagesArr(langSett) {
    let langArr = [];
    langArr.push(GmCXt.defaultLang);

    if (langSett.translations) {
        for (let i = 0, j = langSett.translations.length; i < j; i++) {
            if (!GmCXt.isEmpty(langSett.translations[i].language)) {
                langArr.push(langSett.translations[i]);
            }
        }
    } else {
        for (let i = 0, j = langSett.length; i < j; i++) {
            if (!GmCXt.isEmpty(langSett[i].language)) {
                langArr.push(langSett[i]);
            }
        }
    }

    return GmCXt.removeDuplicates(langArr);
}

rootScope.getAppOrgLanguage = function(l) {
    if (rootScope.enableTranslation && GmCXt.organization) {
        let langSett = GmCXt.organization.admin_settings.language_settings;
        rootScope.defaultLang = langSett.default;
        GmCXt.defaultLang = langSett.default;

        let defLanguage = rootScope.language;
        if (!defLanguage) defLanguage = langSett.default.language;

        if (l) {
            rootScope.languages = getAllLanguagesArr(l);
        } else {
            rootScope.languages = getAllLanguagesArr(langSett);
        }

        rootScope.languages.filter(function(item) {
            if (item.language === defLanguage) {
                rootScope.selectedLanguage = item.name;
            }
        });
    } else {
        rootScope.languages = [];
    }
};

rootScope.initAppDetails = function(app, tlist) {
    GmCXt.log(21, "INIT APP:  [" + app.title + ", " + app.application_id + "]");

    GmCXt.saveToStorage('activeAppId', app.application_id);
    GmCXt.activeAppId = app.application_id;
    let activeAppId = GmCXt.activeAppId;
    let appList = GmCXt.appList;
    GmCXt.externalAppId = appList["app:" + activeAppId].external_id;

    updateSettingOnAppSwitch();

    let msg = {
        action: "mgPlayerJSTest_action:app_info_to_background",
        data: {
            activeAppId: activeAppId,
            externalAppId: app.external_id,
        },
    };
    GmCXt.sendMessageToBackgroundService(msg);

    rootScope.appEnvs = [];

    if (GmCXt.isDefined(app.settings.app_env)) {
        for (let env in app.settings.app_env) {
            if (app.settings.app_env[env].checked) {
                app.settings.app_env[env].key = env;
                rootScope.appEnvs.push(app.settings.app_env[env]);
            }
        }

        rootScope.appEnvs = rootScope.appEnvs
            .sort(function(a, b) {
                if (a.order < b.order) {
                    return -1;
                }
                if (a.order > b.order) {
                    return 1;
                }
                return 0;
            })
            .map(function(env) {
                return env.key;
            });
    }

    rootScope.highestEnv = rootScope.appEnvs[rootScope.appEnvs.length - 1];

    if (GmCXt.inPlayer || GmCXt.onPrem()) {
        if (app.categories && app.categories.length) {
            rootScope.processAppDataActiveApp(app);
        } else {
            let app_id = app.application_id;

            rootScope.isAppJsonCalling = true;
            api.getAppJson(app_id).then(function(res) {
                rootScope.isAppJsonCalling = false;

                if (GmCXt.onPrem() || GmCXt.inPlayer) {
                    app.categories = res.categories;
                } else {
                    app.categories = res.data.categories;
                }
                rootScope.processAppDataActiveApp(app);
            });
        }
    }

    rootScope.getLanguageList();

    if (app.settings.enable_application_language_settings &&
    GmCXt.isDefined(app.settings.app_languages) &&
    app.settings.app_languages.length > 0) {
        rootScope.getAppOrgLanguage(app.settings.app_languages);
    } else {
        rootScope.getAppOrgLanguage();
    }

    if (GmCXt.trackerUtil.pageTracking) {
        GmCXt.getInsightPageRules();
    }
    mg$("#mgPlayerJSTest_header-brand-logo").attr("src", GmCXt.brandLogo());
};

rootScope.getLanguageList = function() {
    try {
        let cb = function(response) {
            rootScope.languageList = response;
            if (!GmCXt.isEmpty(response)) {
                rootScope.languageList = response;
                GmCXt.saveToDapStorage('languageList', rootScope.languageList);
            }
        };

        GmCXt.getFromDapStorage('languageList').then(function(llist) {
            if (GmCXt.isEmpty(llist)) {
                api.getAllLanguages().then(cb);
            } else {
                rootScope.languageList = llist;
            }
        });

    } catch (e) {
        console.error(e);
    }
};


rootScope.isDesktopGuide = function(t) {
    if (
        t &&
    t.tour_settings &&
    t.tour_settings.tour_type &&
    t.tour_settings.tour_type.indexOf("desktop") !== -1
    ) {
        return true;
    } else return false;
};

rootScope.isDefaultGuide = function(t) {
    if (
        t &&
    t.tour_settings &&
    t.tour_settings.tour_type &&
    t.tour_settings.tour_type.indexOf("default") !== -1
    ) {
        return true;
    } else return false;
};

rootScope.isUploadTutorial = function(t) {
    if (GmCXt.isOnboarding(t) && t.tour_settings.tutorial_tour_type === 'upload') {
        return true;
    }
    return false;
};

rootScope.getCategory = function(cid) {
    let id = "cat_" + cid;
    let cat = rootScope.allCategories[id] || false;

    return cat;
};

rootScope.removeCategory = function(cat, updateCount) {
    delete rootScope.allCategories["cat_" + cat.category_id];

    updateCatList(cat, parseInt(cat.parent_id), true);
    if (!GmCXt.inPlayer) {
        GmCXt.saveToDapStorage('categories', rootScope.categories);
    }
    if (updateCount) {
        rootScope.playerSyncCount--;
    }
};

rootScope.addCategory = function(cat) {
    if (!cat.category_title) return;

    let id = "cat_" + cat.category_id;

    rootScope.allCategories[id] = cat;

    updateCatList(cat, parseInt(cat.parent_id));

    if (!GmCXt.inPlayer) {
        GmCXt.saveToDapStorage('categories', rootScope.categories);
    }
};

rootScope.addMultiCategory = function(catList) {
    mg$.each(catList, function(index, cat) {
        if (cat[0]) {
            cat = cat[0];
        }

        let id = "cat_" + cat.category_id;
        rootScope.allCategories[id] = cat;

        if (!GmCXt.inPlayer) {
            updateCatList(cat, parseInt(cat.parent_id));
        }
    });

    if (!GmCXt.inPlayer) {
        GmCXt.saveToDapStorage('categories', rootScope.categories);
    }
};

rootScope.draftExists = function(tourId, categoryId, tours) {
    let list = rootScope.allTourList["cat_" + categoryId];
    if (list) {
        for (let tour in list) {
            if (list[tour].parent_tour_id === tourId) {
                return list[tour].tour_id;
            }
        }
    } else if (tours && tours.length) {
        for (let i = 0; i < tours.length; i++) {
            if (
                tours[i].parent_tour_id === tourId &&
        tours[i].category_id === categoryId
            ) {
                return tours[i].tour_id;
            }
        }
    }

    return false;
};

rootScope.filterGuideByEnv = function(tours) {
    if (!GmCXt.isFQDN()) {
        GmCXt.log(1, "SKIP filtering guides to this domain", tours);
        return tours;
    }

    let domainEnv = GmCXt.getAppEnvByDomain();

    let guidesByEnv = [];

    let domainEnvInApp = !rootScope.appEnvs.length || rootScope.appEnvs.indexOf(domainEnv) !== -1;

    if (domainEnvInApp && tours && tours.length > 0) {
        tours.forEach(function(t) {
            let pubEnvs = t.tour_settings.app_publish_env;

            let tourPublishedInDomain = false;

            if (pubEnvs) {
                tourPublishedInDomain = pubEnvs.indexOf(domainEnv) !== -1;

                if (
                    !rootScope.draftExists(t.tour_id, t.category_id, tours) &&
          !tourPublishedInDomain
                ) {
                    if (pubEnvs.length && pubEnvs[0].indexOf("env_") === 0) {
                        let domIndex = rootScope.appEnvs.indexOf(domainEnv);
                        if (guidePublishedInHigherEnv(domIndex, pubEnvs)) {
                            tourPublishedInDomain = true;
                        }
                    }
                }
            }

            if (
                t.is_published &&
        (domainEnv === undefined ||
          pubEnvs === undefined ||
          pubEnvs.length === 0 ||
          tourPublishedInDomain)
            ) {
                guidesByEnv.push(t);
            }
        });
    }

    function guidePublishedInHigherEnv(index, pubEnvs) {
        return rootScope.appEnvs.slice(index).some(function(e) {
            return pubEnvs.indexOf(e) >= 0;
        });
    }

    GmCXt.log(
        21,
        "FILTER GUIDES published to this domain env [" +
    domainEnv +
    "]. Filtered guides ",
        guidesByEnv
    );

    return guidesByEnv;
};

rootScope.getAllPublishedTours = function(tlist) {
    let allTours = [];

    let pushToAllTours = function(index, t) {
        allTours.push(t);
    };

    for (let id in tlist) {
        let tours = tlist[id];

        if (!tours.length) {
            deleteEmpty(id);
        }

        mg$.each(tours, pushToAllTours);
    }

    let pubTours = rootScope.filterGuideByEnv(allTours);
    rootScope.publishedTours = pubTours;

    if (rootScope.getContextToursAfterLogin) {
        GmCXt.getContextGuides("Process Guides");
        rootScope.getContextToursAfterLogin = false;
    }

    Gm.publishedTours.set(pubTours);
    GmCXt.log(21, "ALL PUBLISHED guides", pubTours);
};

rootScope.addTourList = function(catId, tlist) {
    tlist.forEach(function(t) {
        let cid = catId ? catId : t.category_id;

        let cTag = "cat_" + cid;

        if (!rootScope.allTourList[cTag]) {
            rootScope.allTourList[cTag] = {};
        }

        rootScope.allTourList[cTag]["tour_" + t.tour_id] = t;
    });

    GmCXt.saveToDapStorage('allTourList', rootScope.allTourList);
};

rootScope.processAppDataActiveApp = function(app) {
    let categories = [],
        subCategories = {},
        tours = {};

    clearCache();

    GmCXt.log(21, "PROCESS app data", app);

    let updateTours = function(tours, cid, cOrder, subCOrder) {
        tours.forEach(function(t) {
            t = GmCXt.validateDataModel(t, GmCXt.model.guide);
            t.category_order = parseInt(cOrder);

            if (subCOrder) {
                t.subCategory_order = parseInt(subCOrder);
            }
            if (t.tour_order) {
                t.tour_order = parseInt(t.tour_order);
            }

        });

        rootScope.addTourList(cid, tours);

        return tours;
    };

    let processCategory = function(c, catOrder, subCatOrder) {
        c = GmCXt.validateDataModel(c, GmCXt.model.category);
        let cato = catOrder || c.category_order;

        if (c.sub_categories && c.sub_categories.length > 0) {
            subCategories["cat_" + c.category_id] = c.sub_categories;
            mg$.each(c.sub_categories, function(index, subCat) {
                processCategory(subCat, cato, subCat.category_order);
            });
        } else if (c.tours && c.tours.length > 0) {
            tours["cat_" + c.category_id] = updateTours(c.tours, c.category_id, cato, subCatOrder);
        }

        if (c.is_published && !GmCXt.convertType(c.parent_id)) {
            categories.push(c);
        }

        if (GmCXt.convertType(c.parent_id)) ;
    };

    if (app.categories && app.categories.length > 0) {
        app.categories.forEach(function(cat) {
            processCategory(cat);
        });
    }

    let filteredcat = [];
    let filteredSubCat = [];
    let filteredSubCategories = {};

    categories.forEach(function(cat) {
        function segmentCb(t) {
            if (!GmCXt.isEmpty(t)) {
                let pubEnv = t.tour_settings.app_publish_env;
                if (rootScope.isDesktopGuide(t) || GmCXt.checkDomainInPublishedEnv(pubEnv)) {
                    if (mg$.inArray(cat, filteredcat) === -1) filteredcat.push(cat);
                }
            }
        }

        if (cat.tours) {
            GmCXt.checkGuidesBasedOnSegment(cat.tours, segmentCb);
        } else if (cat.sub_categories) {
            let prevlen = filteredSubCat.length;
            checkForSubCategories(cat.sub_categories, filteredSubCat, filteredSubCategories, cat);

            let currlen = filteredSubCat.length;

            if (currlen > prevlen && !filteredcat.includes(cat)) {
                cat.sub_categories = filteredSubCategories["cat_" + cat.category_id];
                filteredcat.push(cat);
            }
        }
    });
    Gm.allCategories.set(filteredcat);

    function pushSubcategories(categories, resultArray = []) {
        categories.forEach((obj) => {
            if (obj.sub_categories && obj.sub_categories.length > 0) {
                // If the object has subcategories, recursively call pushSubcategories
                pushSubcategories(obj.sub_categories, resultArray);
            }
            // Push the object into the resultArray
            resultArray.push(obj);
        });
        return resultArray;
    }

    // Call the function to get all subcategories
    let allSubcategories = pushSubcategories(categories);

    rootScope.categoryStore = categories;
    rootScope.subCategoryStore = filteredSubCategories;

    Gm.subCategories.set(allSubcategories);
    rootScope.addMultiCategory(rootScope.categoryStore);
    rootScope.addMultiCategory(allSubcategories);

    rootScope.getAllPublishedTours(tours);

    rootScope.syncApps(GmCXt.appList);
    GmCXt.saveToDapStorage('appData', GmCXt.appList);

    rootScope.setActivePage("home");
};

function setDefaultOrgFeatures() {
    rootScope.currentPageBeacon = false;
    rootScope.fqdn = false;
    rootScope.guideSegmentation = false;
    rootScope.mediafileCreation = false;
    rootScope.createTooltipMediaFile = false;
    GmCXt.trackerUtil.trackPI = false;
    rootScope.enableGuidemeMode = false;
}

function setDefaultAdminFeature() {
    rootScope.lms = false;
    rootScope.chatBot = false;
    rootScope._doitforme = false;
    rootScope.maintenance = false;
    rootScope.currentPageOnly = false;
    rootScope.showAppSwitcher = false;
    GmCXt.trackerUtil.enableTracking = false;
    GmCXt.trackerUtil.trackPI = false;
    GmCXt.FT.analytics = false;
    rootScope.ruleCheck = false;
    rootScope.displayAcceptCookiePopup = true;
    rootScope.featureTracking = false;
    rootScope.pageTracking = false;
    rootScope.allGuideView = false;
    setDefaultOrgFeatures();
}

rootScope.enableOrgFeatures = function(org) {
    if (!GmCXt.isEmpty(org) && GmCXt.isDefined(org)) {
        let as = org.admin_settings || {};
        let os = org.settings || {};

        GmCXt.log(21, "ENABLE org features", org);

        setDefaultAdminFeature();

        if (!GmCXt.isEmpty(org.bucket)) {
            GmCXt.orgBucket = org.bucket;
        }

        if (as.lms) {
            rootScope.lms = true;
        }

        if (GmCXt.isChatEnable()) {
            rootScope.chatBot = true;
        }

        if (GmCXt.getAppSetting("doitforme")) {
            rootScope._doitforme = true;
        }

        if (GmCXt.getAppSetting("all_guide") && GmCXt.isPlayer()) {
            rootScope.currentPageOnly = true;
        }

        if (
            GmCXt.getAppSetting("defaultGuideView") &&
      !GmCXt.getAppSetting("all_guide")
        ) {
            rootScope.allGuideView = true;
        }

        if (GmCXt.getAppSetting("isMiniPlayer") && GmCXt.isPlayer()) {
            rootScope.isMicroPlayer = true;
            Gm.miniPlayer.set(true);
        }

        if (as.app_switcher) {
            rootScope.showAppSwitcher = as.app_switcher;
        }

        if (!as.display_accept_cookie_popup)
            rootScope.displayAcceptCookiePopup = false;

        if (as.maintenance_mode) rootScope.goToMaintenance();

        if (as.current_page_beacon) rootScope.currentPageBeacon = true;

        if (as.guide_segmentation) rootScope.guideSegmentation = true;

        if (as.mediafile_creation) rootScope.mediafileCreation = true;

        if (as.create_tooltip_media_file) rootScope.createTooltipMediaFile = true;

        if (os.fqdn) {
            rootScope.fqdn = true;
            rootScope.showAppSwitcher = !os.fqdn;
        }

        if (
            as.language_settings &&
      as.language_settings.translations.length &&
      as.guide_translation
        ) {
            rootScope.enableTranslation = true;
            GmCXt.enableTranslation = true;
        } else {
            rootScope.enableTranslation = false;
            GmCXt.enableTranslation = false;
		  GmCXt.removeFromStorage('activeLang');
            GmCXt.removeFromStorage('activeVoice');
            rootScope.language = false;
            GmCXt.language = false;
            rootScope.languageVoice = false;
            rootScope.isDefaultLang = true;
        }

        if (as.insights && as.insights.enabled) {
            if (as.insights.guide) {
                GmCXt.FT.analytics = true;
                GmCXt.trackerUtil.enableTracking = true;
            }

            if (as.insights.app) {
                let ias = as.insights.app[GmCXt.activeAppId];
                if (ias && ias.enable_feature_tracking) {
                    GmCXt.trackerUtil.featureTracking = true;
                    rootScope.featureTracking = true;
                }
                if (ias && ias.enable_page_tracking) {
                    GmCXt.trackerUtil.pageTracking = true;
                    rootScope.pageTracking = true;
                }
            }
        }

        if (as.isPITrackingEnabled) {
            GmCXt.trackerUtil.trackPI = true;
        }

        rootScope.isGuideAutomationEnabled =
      as.myBotEnabled && !rootScope.currentPageOnly;

        if (as.efficient_rule_mode) {
            rootScope.ruleCheck = true;
        }

        if (GmCXt.isTrue(as.enable_guideme_as_secondary_option)) {
            rootScope.enableGuidemeMode = true;
        }

        let msg = {
            action: "mgPlayerJSTest_action:update_tracking_info",
            data: {
                enableTracking: GmCXt.trackerUtil.enableTracking,
                trackPI: GmCXt.trackerUtil.trackPI,
                featureTracking: GmCXt.trackerUtil.featureTracking,
                pageTracking: GmCXt.trackerUtil.pageTracking,
            },
        };

        GmCXt.sendMessageToAllWindows('mgPlayerJSTest_action:update_tracking_info:frames', msg.data);
        GmCXt.sendMessageToBackgroundService(msg);
    }
};

rootScope.displayChatIcon = function() {
    if (rootScope.botGuideCount === 0) {
        GmCXt.removeChatIcon();
    } else {
        GmCXt.showChatIcon();
    }
};

rootScope.getBotGuideCount = function(tours) {
    var guides = rootScope.filterBotGuides(tours);
    if (guides && guides.length) {
        rootScope.botGuideCount = guides.length;
    } else {
        rootScope.botGuideCount = 0;
    }
    rootScope.displayChatIcon();
};

rootScope.refreshCurrentPage = function(event, updateSegmets) {

    if (event !== 'page_click' && updateSegmets && get_store_value(Gm.CurrentPage) !== 'stepview') {
        GmCXt.validatedSegments = {};
    }

    if (get_store_value(Gm.CurrentPage) === "currentpage" && (!event || GmCXt.APP_PANEL_OPEN)) {
    // event check is for page load when rootScope.readLocalCT(rootScope.pageUrl) will be undefined.

        GmCXt.log(30, "REFRESH CURRENT PAGE guides list. Event: ", event);
        rootScope.setCurrentPage('currentpage');
    } else if (GmCXt.isDomainInActiveApp()) {
        let gc = GmCXt.getAppSetting('guide_count_on_widget');
        let hw = GmCXt.getAppSetting('hide_widget_if_noguide');

        if ((gc && !rootScope.isWestpac) || hw) {

            GmCXt.log(30, "REFRESH CURRENT PAGE guide indicator. Event: " + event);

            let res = rootScope.readLocalCT(GmCXt.urlParts.fullUrl, GmCXt.pageTitle);

            if (res && res.length) {
                GmCXt.log(30, "FETCHED tours from CACHE");

                processCPGuides(res);
            } else {
                let param = {
                    url: GmCXt.urlParts.fullUrl,
                };

                // if (GmCXt.getLXPLang()) param.language = GmCXt.getLXPLang();

                GmCXt.log(30, "NOT FOUND IN CACHE. FETCHING tours from API");

                api.getContextualTour(param, function(r) {
                    GmCXt.log(30, "FETCHED tours from API");
                    res = rootScope.processContextualGuide(r, param.url);
                    processCPGuides(res);
                });
            }
        } else {
            GmCXt.showWidget();
        }
    }

    function processCPGuides(res) {
        let guides = rootScope.filterCurrentPageTourTypes(res);
        rootScope.getBotGuideCount(guides);

        if (GmCXt.isEmpty(guides)) {
            GmCXt.log(30, "NO GUIDES");
            // rootScope.hideCurrentPageGuidesIndicator();
        } else {
            let cData = rootScope.validateAllRulesExceptSelectEl(guides, true);

            if (cData.hasURLMatch || cData.hasValidRule) {
                // skip validation, show currentPage indicator

                GmCXt.log(30, 'URLMATCH: ' + cData.hasURLMatch + ', ValidRule: ' + cData.hasValidRule);
                show();
            } else {
                rootScope.validateSelectElRules(cData.tours, event).then(function(val) {
                    if (val) {
                        show();
                    }
                });
            }
        }
    }

    function show() {
        GmCXt.showWidget();
    //Need to implement this
    // let gc = GmCXt.getAppSetting('guide_count_on_widget');
    // let hw = GmCXt.getAppSetting('hide_widget_if_noguide');
    // GmCXt.showWidget();
    // if ((gc && !rootScope.isWestpac) || hw) {
    //     GmCXt.ruleEngine.clearJobs("currentPageIndicator");
    //     rootScope.showCurrentPageGuidesIndicator(true);
    // }
    }
};

rootScope.showCurrentPageGuidesIndicator = function(clearRulesJobs) {
    if (GmCXt.isPlayer()) {
        GmCXt.log(30, "SHOW current page indicator");

        rootScope.msgSentCurrentPageCount = true;
        GmCXt.ifGuidesOnCurrentPage = true;

        if (clearRulesJobs) {
            GmCXt.sendMessageToAllWindows('mgPlayerJSTest_action:clear_rule_jobs', {
                initiator: 'currentPageIndicator',
                trigger: 'guide_indicator'
            });
        }
        GmCXt.showWidget();
    }
};

rootScope.hideCurrentPageGuidesIndicator = function() {
    if (GmCXt.isPlayer()) {
        GmCXt.ifGuidesOnCurrentPage = false;
        GmCXt.hideCurrentPageGuidesIndicator();
    }
};

rootScope.validateAllRulesExceptSelectEl = function(allTours, returnOnAnyValid, url) {
    let d = {
        tours: [],
        hasURLMatch: false,
        hasValidRule: false,
    };
    //let urlParts = get(GmCXt.urlParts);

    let urlParts = GmCXt.urlParts;

    if (url) {
        urlParts = new URL(url);
    }

    if (allTours) {
        let path = urlParts.pathname === "/" ? "" : urlParts.pathname;
        if (path && path.indexOf("/") !== 0) {
            path = "/" + path;
        }
        let currentUrl = GmCXt.getHostnameFromUrl(urlParts.fullUrl) + path;
        currentUrl = currentUrl.toLowerCase();

        let urlTours = [];
        let rulesTours = [];
        let startPointTours = [];

        for (let i = 0; i < allTours.length; i++) {
            let tour = allTours[i];
            let tourSettings = tour.tour_settings;

            let hasRule = tourSettings.rules.length && tourSettings.rules[0].condition;
            let isValidRule = false;

            if (tour.tour_url && !hasRule) {
                let tourUrl = tour.tour_url.toLowerCase();
                let fullPageUrl = urlParts.href ? urlParts.href.toLowerCase() : "";
                if ((tourUrl === currentUrl || tourUrl === fullPageUrl) && tour.is_published) {
                    urlTours.push(tour);

                    d.hasURLMatch = true;

                    if (returnOnAnyValid) {
                        return d;
                    }
                }
            } else if (hasRule) {
                if (GmCXt.ruleEngine.hasRuleType(tourSettings.rules, ["Select Element", "Select Table", "Get Validity", "Variables"])) {
                    isValidRule = true;
                } else {
                    let oldRegEx = false;
                    if (GmCXt.legacyWildChar(tourSettings.version)) {
                        oldRegEx = true;
                    }
                    isValidRule = GmCXt.ruleEngine.evaluateRules(tourSettings.rules, oldRegEx, urlParts);

                    if (isValidRule) {
                        //valid non el rule
                        d.hasValidRule = true;
                        tour.ruleValidated = true;

                        if (returnOnAnyValid) {
                            return d;
                        }
                    }
                }

                if (isValidRule) {
                    rulesTours.push(tour);
                }
            }

            let startPoints = tour.tour_settings.start_point_info;
            if (tour.is_published && startPoints && startPoints.length) {
                for (let j = 0; j < startPoints.length; j++) {
                    let startPoint = startPoints[j];
                    let stepUrl = startPoint.step_url.toLowerCase();
                    if (stepUrl.indexOf(currentUrl) >= 0) {
                        startPointTours.push(tour);
                        break;
                    }
                }
            }
        }

        d.tours = GmCXt.arrayMerge(startPointTours, GmCXt.arrayMerge(urlTours, rulesTours));
    }

    return d;
};

rootScope.validateSelectElRules = function(tours, event) {
    let promise = new Promise(function(resolve, reject) {
        rootScope.msgSentCurrentPageCount = false;
        let toursValidated = 0;

        for (let i = 0; i < tours.length; i++) {
            if (rootScope.msgSentCurrentPageCount) break;

            let tour = tours[i];

            rootScope.queueRuleForCP(
                tour,
                i,
                onContextualRuleMatch,
                event,
                "currentPageIndicator"
            );
        }

        function onContextualRuleMatch(result) {
            if (rootScope.msgSentCurrentPageCount) return;

            toursValidated++;

            if (result.valid) {
                resolve(true);
            } else if (toursValidated === tours.length) {
                resolve(false);
            }
        }
    });

    return promise;
};

rootScope.queueRuleForCP = function(tour, index, cb, event, initiator) {
    let ts = tour.tour_settings;
    let rules = ts.rules && ts.rules.length ? ts.rules : [];

    if ((event === 'page_click' && !rootScope.reEvalRules(tour)) || tour.ruleValidated) {

        GmCXt.log(30, "SKIP RULE CHECK " + initiator + ": " + tour);
        GmCXt.log(30, "SKIP RULE CHECK " + initiator + ": " + GmCXt.tourLog(tour));

        cb({
            tour: tour,
            valid: true
        });

        GmCXt.log(30, "RULE CHECK " + initiator + " :" + GmCXt.tourLog(tour));
    } else {
        GmCXt.log(30, "RULE CHECK " + initiator + " :" + tour);

        let obj = {
            tour: tour,
            rules: rules,
            cb: cb,
            index: index,
            timeoutVal: GmCXt.t.ruleTimeOut15ms,
            timeout: GmCXt.t.ruleTimeOut15ms,
            isTour: true,
            initiator: initiator,
        };

        GmCXt.ruleEngine.queue(obj);
    }
};

rootScope.reEvalRules = function(t) {
    if (!rootScope.ruleCheck) return true;

    if (
        !t.tour_settings.ruleCheckOnClick &&
    !GmCXt.isEmpty(rootScope.cTours) &&
    rootScope.cTours.indexOf(t.tour_id) >= 0
    ) {
        return false;
    }

    return true;
};

rootScope.refreshPageView = function() {
    rootScope.refreshAllGuides = true;
    rootScope.allGuideView = true;


    let currentView = get_store_value(Gm.CurrentPage);
    let isPopupVisible = false;

    if (!currentView || currentView === false) {
        rootScope.setActivePage("home");
    } else {
        if (currentView === "stepview" &&
      mg$(".branching-popup-wrapper").is(":visible") ||
      mg$(".mgPlayerJSTest_error-handler-popup-wrapper").is(":visible") ||
      mg$(".ege-popup-link-guide").is(":visible")) {
            isPopupVisible = true;
        }
        if (!isPopupVisible) rootScope.setCurrentPage(currentView);
    }
};

function checkForSubCategories(
    subcategories,
    filteredsubcat,
    filteredSubCategories,
    cat
) {
    function checkCatIdforSubCat(filteredCat, currentCat) {
        let match = false;
        if (filteredCat.length > 0) {
            filteredCat.forEach(function(subcat) {
                if (subcat.category_id === currentCat.category_id) {
                    match = true;
                }
            });
        }
        return match;
    }

    subcategories.forEach(function(subcat) {
        function segmentCb(t) {
            if (!GmCXt.isEmpty(t)) {
                let pubEnv = t.tour_settings.app_publish_env;

                if (
                    GmCXt.checkDomainInPublishedEnv(pubEnv) ||
          rootScope.isDesktopGuide(t)
                ) {
                    if (!filteredSubCategories["cat_" + cat.category_id]) {
                        filteredSubCategories["cat_" + cat.category_id] = [];
                    }
                    if (
                        !checkCatIdforSubCat(
                            filteredSubCategories["cat_" + cat.category_id],
                            subcat
                        )
                    ) {
                        filteredSubCategories["cat_" + cat.category_id].push(subcat);
                        filteredsubcat.push(subcat);
                    }
                }
            }
        }

        if (subcat.sub_categories) {
            let prevlen = filteredsubcat.length;
            checkForSubCategories(
                subcat.sub_categories,
                filteredsubcat,
                filteredSubCategories,
                subcat
            );
            let currlen = filteredsubcat.length;
            if (currlen > prevlen && !filteredsubcat.includes(subcat)) {
                subcat.sub_categories = filteredSubCategories["cat_" + subcat.category_id];
                filteredsubcat.push(subcat);
                if (!filteredSubCategories["cat_" + cat.category_id]) {
                    filteredSubCategories["cat_" + cat.category_id] = [];
                }
                filteredSubCategories["cat_" + cat.category_id].push(subcat);
            }
        } else if (subcat.tours && subcat.tours.length > 0) {
            GmCXt.checkGuidesBasedOnSegment(subcat.tours, segmentCb);
        }
    });
}

function getCurrentAppObj(apps) {
    return new Promise(function(resolve, reject) {
        Gm.loading.set(true);
        let app = {};

        let processNext = function(appList) {
            if (appList.length > 0) {
                //For possible app switch in onprem
                //let urlPart = get(GmCXt.urlParts)
                let urlPart = GmCXt.urlParts;
                let r = GmCXt.checkDomainInApps(urlPart.fullUrl);

                if (GmCXt.onPrem()) {
                    if (r.appId !== GmCXt.activeAppId) {
                        GmCXt.saveToStorage('activeAppId', r.appId);
                        GmCXt.activeAppId = r.appId;
                    }
                }

                app = appList.filter(function(a) {
                    return (
                        parseInt(a.application_id) === parseInt(GmCXt.activeAppId)
                    );
                })[0] || {};

                if (GmCXt.isEmpty(app)) {
                    if (r.domainMatch) {
                        GmCXt.log(21, "GET APP by domain: " + r.appName);

                        app = appList.filter(function(a) {
                            return parseInt(a.application_id) === parseInt(r.appId);
                        })[0];
                    } else if (GmCXt.FT.creatorApp) {
                        app = appList[0];
                    }
                }
            }

            if (GmCXt.isEmpty(app)) {
                rootScope.goToNoApp();
                Gm.loading.set(false);
                resolve();
            } else {
                rootScope.initAppDetails(app);
                Gm.loading.set(false);
                resolve(app);
            }
        };

        if (!apps) {
            rootScope.checkAppList().then(function() {
                let apps = [];
                for (let key in GmCXt.appList) {
                    apps.push(GmCXt.appList[key]);
                }
                processNext(apps);
            });
        } else {
            processNext(apps);
        }
    });
}

function gotApps(apps) {
    return new Promise(function(resolve, reject) {
        Gm.loading.set(true);
        GmCXt.log(21, "FETCHED apps.", apps);

        getCurrentAppObj(apps).then(function(app) {
            if (!GmCXt.isEmpty(app) && !GmCXt.isExcludeDomain()) {
                if (GmCXt.FT.isPlayer) ; else {
                    rootScope.resetOffset = true;

                    rootScope.refreshPageView();
                    //rootScope.setCacheDataAfterRefresh();

                }
            } else if (GmCXt.isExcludeDomain()) {
                let cb = function(g) {
                    rootScope.goToNoApp();
                };

                modal.open(rootScope.labels.badDomain, 'warning', cb);
                reject();
            }
            Gm.loading.set(false);
            resolve();
        });
    });
}

rootScope.goToSignIn = function() {
    Gm.activeView.set("signin");
};

rootScope.fetchApps = function() {
    return new Promise(function(resolve, reject) {
        GmCXt.log(21, "FETCH apps");

        let data = {
            limit: 50,
            offset: 0,
        };

        api.getAllApps(data, function(apps) {
            if (apps.length > 0) {
                apps = apps.sort(function(a, b) {
                    return parseInt(a.application_id) - parseInt(b.application_id);
                });
                apps = filterAppsBasedOnAccess(apps);
                rootScope.saveApps(apps);

                GmCXt.timeout(function() {
                    gotApps(apps).then(function() {
                        resolve();
                    });
                }, 0);
            } else {
                rootScope.goToNoApp();
            }
        });
    });
};

function updateUserLabels(userLabels) {
    for (let prop in userLabels) {
        if (rootScope.labels.hasOwnProperty(prop)) {
            rootScope.labels[prop] = userLabels[prop] || rootScope.labels[prop];
        }
    }
    return userLabels;
}

function updateChatLabels(chatLabels) {
    for (let prop in chatLabels) {
        if (rootScope.labels.hasOwnProperty(prop)) {
            rootScope.labels[prop] = chatLabels[prop] || rootScope.labels[prop];
        }
    }
    return chatLabels;
}

rootScope.setDefaultChatLabels = function() {
    rootScope.chatLabels = {
        greetingMessage: rootScope.labels.defaultGreetingMessage,
        botEndingMessage: rootScope.labels.defaultBotEndingMessage,
        errorMessage: rootScope.labels.defaultErrorMessage,
    };
};

rootScope.getChatLabels = function(chatLabels) {
    for (let prop in chatLabels) {
        let defaultProp = "default" + GmCXt.capitalizeFirstLetter(prop);
        if (chatLabels[prop] !== "") {
            rootScope.chatLabels[prop] = chatLabels[prop];
        } else {
            rootScope.chatLabels[prop] = rootScope.labels[defaultProp];
        }
    }
};

rootScope.updateCustomLabels = function(settings) {
    let userLabels = settings.userLabels;

    let o = GmCXt.organization;
    let currentApp = GmCXt.appList["app:" + GmCXt.activeAppId];
    let chatLabels = [];
    if (currentApp && currentApp.settings) {
        userLabels = currentApp.settings.userLabels;
        chatLabels = currentApp.settings.chatLabels;
        mg$.extend(userLabels, {
            userNotFollowingGuideMessage: settings.userLabels.userNotFollowingGuideMessage,
            maintenanceMessage: settings.userLabels.maintenanceMessage,
            serviceErrorMessage: settings.userLabels.serviceErrorMessage,
            resumeGuideMessage: settings.userLabels.resumeGuideMessage,
        });
    } else {
        userLabels = o.settings.userLabels;
    }

    userLabels = updateUserLabels(userLabels);
    chatLabels = updateChatLabels(chatLabels);
    GmCXt.label = rootScope.labels;

    let data= {
        userLabels: userLabels,
        chatLabels: chatLabels,
    };
    GmCXt.updateCustomLabels(data);
};

function clearCache() {
    GmCXt.removeFromDapStorage('allTourList');
}

rootScope.isMgAdmin = function() {
    if (rootScope.user.role === "mg_admin") {
        return true;
    } else {
        return false;
    }
};

rootScope.isSuperAdmin = function() {
    if (rootScope.user.role === "superadmin") {
        return true;
    } else {
        return false;
    }
};
rootScope.isOwner = function() {
    if (
        rootScope.user.role === "owner" ||
    rootScope.isSuperAdmin() ||
    rootScope.isMgAdmin() ||
    rootScope.isPartnerAdmin()
    ) {
        return true;
    } else {
        return false;
    }
};

rootScope.isCreator = function() {
    if (rootScope.user.role === "creator") {
        return true;
    } else {
        return false;
    }
};

rootScope.isPartnerAdmin = function() {
    if (rootScope.user.role === "partner_admin") {
        return true;
    } else {
        return false;
    }
};

function filterAppsBasedOnAccess(applications) {
    let apps = [];
    if (rootScope.isOwner()) {
        return applications;
    }

    mg$.each(GmCXt.user.app_access, function(i, appId) {
        let app = applications.filter(function(app) {
            return parseInt(app.application_id) === parseInt(appId);
        });
        if (app.length) apps.push(app[0]);
    });

    return apps;
}

rootScope.getCdnSign = GmCXt.getCdnSign;

rootScope.removeCatFromApplist = function(apps) {
    let appList = JSON.parse(JSON.stringify(apps));
    if (!GmCXt.isEmpty(appList)) {
        Object.keys(appList).forEach(function(key) {
            delete appList[key].categories;
        });
    }
    return appList;
};

rootScope.syncApps = function(apps) {
    rootScope.removeCatFromApplist(apps);
    GmCXt.updateAppListSettingsInAllFrames();
};

rootScope.saveApps = function(apps) {
    GmCXt.appList = {};

    apps.forEach(function(app) {
        if (window.matchMedia("(max-width: 480px)").matches && !GmCXt.isMiniPlayer && app.type !== "guide") {
            if (app.type === "mobile_web") {
                GmCXt.appList["app:" + app.application_id] = app;
            }
        } else {
            if (app.type === "guide" || app.type === "electron") {
                GmCXt.appList["app:" + app.application_id] = app;
            }
        }
    });
    rootScope.syncApps(GmCXt.appList);
    GmCXt.saveToDapStorage('appData', GmCXt.appList);

    rootScope.syncApps(GmCXt.createDeepCopy(GmCXt.appList));

    GmCXt.log(21, "CACHED app details", GmCXt.appList);
};

rootScope.loadJsonPlayer = function() {
    return new Promise(function(resolve, reject) {
        Gm.loading.set(true);
        let org = GmCXt.organization;
        GmCXt.orgBucket = org.bucket;

        GmCXt.log(21, "REFRESHING org JSON");

        function next(_apps) {
            rootScope.updateCustomLabels(org.settings);

            gotApps(_apps).then(function() {
                Gm.loading.set(false);
                resolve();
            });
        }

        // user.app_access is list of applications, accessible to the user
        //if (get(GmCXt.user).app_access.length > 0 || rootScope.isOwner()) {
        if (GmCXt.user.app_access.length > 0 || rootScope.isOwner()) {
            api.getOrgJson().then(function(response) {
                rootScope.refreshTime = GmCXt.getCurrentTimeInSec();
                rootScope.lastTimeStampSync = rootScope.refreshTime;
                GmCXt.saveToStorage('refreshTime', rootScope.refreshTime);
                GmCXt.saveToStorage('lastTimeStampSync', rootScope.lastTimeStampSync);
                clearCache();
                let org = "";
                if (GmCXt.onPrem() || GmCXt.inPlayer) {
                    org = response; //filterRespData(response);
                } else {
                    org = response.data; //filterRespData(response);
                }

                GmCXt.organization = org;
                //GmCXt.organization.set(org);

                org = GmCXt.validateDataModel(org, GmCXt.model.organization);

                //GmCXt.organization.set(org);
                GmCXt.organization = org;

                let apps = GmCXt.createDeepCopy(
                    GmCXt.validateModelArray(
                        org.applications,
                        GmCXt.model.applications._obj
                    )
                );

                apps = filterAppsBasedOnAccess(apps);

                // let appsSize = GmCXt.getletSize(apps);
                // GmCXt.log(21, "After app access filter Apps SIZE: " + appsSize);

                rootScope.saveApps(apps);

                delete org.applications;

                rootScope.saveOrganization(org);

                if (rootScope.guideSegmentation) {
                    rootScope.getSegmentGroupList().then(function() {
                        next(apps);
                    });
                } else {
                    next(apps);
                }
            });
        } else {
            GmCXt.log(21, "NO ACCESS to any apps");
            rootScope.goToNoApp();
        }
    });
};

rootScope.initializeApp = function() {
    GmCXt.log(21, "INITIALISE App");

    return new Promise(function(resolve, reject) {
        function next() {
            rootScope.fetchApps().then(function() {
                resolve(true);
            });
        }

        if (GmCXt.isPlayer()) {
            rootScope.loadJsonPlayer().then(function() {
                //activeView.set('home');
                resolve();
            });
        } else {
            let org = GmCXt.organization;

            if (org && org.organization_id) {
                rootScope.saveOrgSettings(org.settings);

                if (rootScope.guideSegmentation) {
                    rootScope.getSegmentGroupList().then(function() {
                        next();
                    });
                } else {
                    next();
                }
            } else {
                //GmCXt.redirect('#/noorg');
                resolve();
            }
        }
    });
};

rootScope.saveOrgSettings = function(os) {
    if (os) {
        if (GmCXt.organization) {
            GmCXt.organization.settings = os;
            rootScope.saveOrganization(GmCXt.organization);
        }

        mg$(".ege-logo-image").attr("src", GmCXt.brandLogo());

        rootScope.webUrl = os.web_url;

        rootScope.updateCustomLabels(os);
        GmCXt.showWidget();
    }
};

function resetAll() {
    rootScope.contextTours = [];
    GmCXt.removeFromStorage('activeLang');
    rootScope.language = false;
    GmCXt.language = false;
}

function hideCloseBtn() {
    GmCXt.hidePanelCloseBtn();
}

rootScope.sortOrderCategory = function() {
    if (!GmCXt.isPlayer()) {
        rootScope.sortType = "";
        rootScope.descOrder = false;
    }
};

rootScope.filterPublished = function(data) {

    let publishedData = data.filter(function(d) {
        return d.is_published;
    });

    return publishedData;
};

rootScope.filterUnpublished = function(data) {

    let publishedData = data.filter(function(d) {
        return !d.is_published;
    });

    return publishedData;
};

function isMicroPlayerMode() {
    if (GmCXt.getAppSetting("isMiniPlayer")) {
        Gm.miniPlayer.set(true);
        return true;
    } else {
        Gm.miniPlayer.set(false);
        return false;
    }
}

function updateAppFeatures(doNotSyncOrg) {
    if (rootScope.showPlayer) {
        let flag = isMicroPlayerMode();
        rootScope.isMicroPlayer = flag;

        if (window.matchMedia("(max-width: 480px)").matches) {
            rootScope.isMicroPlayer = false;
        }

        if (flag) {
            hideCloseBtn();
        }
    } else {
        rootScope.isMicroPlayer = false;
        GmCXt.showPanelCloseBtn();
        mg$('.mgPlayerJSTest_ege-panel')[0]?.style?.removeProperty('background');
    }

    GmCXt.initPlayerModeFeatures(
        rootScope.showPlayer,
        rootScope.isMicroPlayer,
        rootScope.playerMode
    );

    if (!doNotSyncOrg) {
        rootScope.enableOrgFeatures(GmCXt.organization);
    }

    rootScope.updateLabels();
}

rootScope.getPlayedStepsInfo = function() {
    GmCXt.getFromStorage('stepsPlayed').then(function(r) {
        if (GmCXt.isAnonymousUser()) {
            rootScope.playedSteps = r.stepsPlayed ? r.stepsPlayed : [];
        } else {
            //let user = get(GmCXt.user);
            let user = GmCXt.user;
            if (!GmCXt.isEmpty(user)) {
                rootScope.playedSteps =
          user &&
          user.settings.guide_view &&
          user.settings.guide_view.playedSteps ?
              user.settings.guide_view.playedSteps : [];
            }
        }
    });
};

rootScope.initPlayerMode = function(doNotSyncOrg) {
    updateAppFeatures(doNotSyncOrg);
    rootScope.getPlayedStepsInfo();

    let msg = {
        action: "mgPlayerJSTest_action:update:player_mode",
        data: {
            showPlayer: rootScope.showPlayer,
            isMiniPlayer: rootScope.isMicroPlayer,
            playerMode: rootScope.playerMode,
        },
    };
  
    GmCXt.handleUpdatePlayerMode(msg.data);
    GmCXt.sendMessageToBackgroundService(msg);
};

rootScope.onMinMaxChaticon = function() {
    rootScope.chatBotMin = true;
};

rootScope.onUserSignin = function(user, sso, ssoSignInTrue) {
    rootScope.user = user;
    //GmCXt.user.set(user);
    GmCXt.user = user;

    GmCXt.log(21, "USER login", user);

    GmCXt.storage().set({
        login_state: true,
    });

    GmCXt.updateGlobalUser(user);

    rootScope.loginTime = new Date().getTime();
    GmCXt.saveToStorage('loginTime', rootScope.loginTime);

    user.signedInWithSso = sso;
    user.ssoSignInTrue = ssoSignInTrue;
    user.region = "US";

    resetAll();
    if (sso) {
        GmCXt.saveToStorage('lastSsoRedirectTime', "");
        GmCXt.saveToStorage('triggerSsoAfterFiveMins', false);
    }

    rootScope.setMode();
    rootScope.saveUser(user);

    rootScope.setNotifTours();

    rootScope.registerClientInsights();

    GmCXt.lastTooltipSync = GmCXt.getCurrentTimeInSec();
    GmCXt.storage().set({
        lastTooltipSync: GmCXt.lastTooltipSync,
    });

    rootScope.getContextToursAfterLogin = true;

    rootScope.initializeApp().then(function() {
        rootScope.initPlayerMode();
        rootScope.sendSidePanelInitEvent();

        if (!GmCXt.inPlayer || !GmCXt.onPrem()) {
            rootScope.refreshTime = GmCXt.getCurrentTimeInSec();
            GmCXt.saveToStorage('refreshTime', rootScope.refreshTime);
        }

        GmCXt.showWidget();
    });

    rootScope.onMinMaxChaticon();
};

rootScope.isTrackingGuide = GmCXt.isFeatureTags;

rootScope.getDefaultPlayAction = function(tour) {
    let da = GmCXt.getAppSetting("defaultPlayAction");

    if (GmCXt.isFalse(da)) {
        return da;
    }

    if (tour.tour_settings.defaultPlayAction !== "Default") {
        da = tour.tour_settings.defaultPlayAction;
    }

    if (GmCXt.organization && !GmCXt.getAppSetting(da)) {
        da = GmCXt.model.organization.settings._obj.defaultPlayAction._default;
    }

    return da;
};

rootScope.isCADGuide = function(t) {
    if (
        t &&
    t.tour_type &&
    (t.tour_type.indexOf("desktop") !== -1 ||
      t.tour_type.indexOf("mobile") !== -1)
    ) {
        return true;
    } else return false;
};

rootScope.isDesktopApp = function() {
    let currentApp = GmCXt.appList["app:" + GmCXt.activeAppId];
    if (currentApp && currentApp.type === "electron") {
        return true;
    } else return false;
};

rootScope.clearSession = function(s) {
    logoutServ.clearSession(s);
};

rootScope.showPlayOption = function(type, tour) {
    if (!GmCXt.user) return;

    let showAction = false;
    let defaultPlayAction = rootScope.getDefaultPlayAction(tour);

    if (rootScope.isDesktopApp()) {
        return showAction;
    }

    switch (type) {
    case rootScope.playGuideMe:
        if (
            GmCXt.getAppSetting("guideMeSetting") &&
        defaultPlayAction === rootScope.playSlideshow &&
        rootScope.enableGuidemeMode &&
        !GmCXt.isOnboarding(tour)
        )
            showAction = true;
        break;

    case rootScope.playSlideshow:
        if (
            (GmCXt.getAppSetting("showMeSetting") &&
          defaultPlayAction === rootScope.playGuideMe &&
          GmCXt.FT.showMe) ||
        GmCXt.isOnboarding(tour)
        )
            showAction = true;
        break;

    case rootScope.playTestMe:
        if (
            GmCXt.getAppSetting("testMeSetting") &&
        defaultPlayAction === rootScope.playGuideMe &&
        GmCXt.FT.testme &&
        !GmCXt.isOnboarding(tour)
        )
            showAction = true;
        break;
    }

    return showAction;
};

rootScope.showDomainRedirect = function(tour) {
    let infoMsg = false;
    let msg = rootScope.labels.guideNotExist;
    let ob = GmCXt.checkDomainInApps(tour.tour_url);

    if (ob.domainMatch) {
        infoMsg = rootScope.labels.belongToOtherApp;
        infoMsg = infoMsg.replace(/{TOURURL}/g, '<strong>' + GmCXt.getHostnameFromUrl(tour.tour_url) + '</strong>');
        infoMsg = infoMsg.replace(/{APPNAME}/g, '<strong>' + ob.appName + '</strong>');

    } else if (GmCXt.FT.creatorApp) {
        infoMsg = rootScope.labels.setDomain;
        infoMsg = infoMsg.replace(/{TOURURL}/g, '<strong>' + GmCXt.getHostnameFromUrl(GmCXt.urlParts.host) + '</strong>');
    }

    rootScope.showPopup(msg, null, 'warning', infoMsg);
};

rootScope.guideAction = function(type, step, tour, source, catName, taskObj) {
    if (rootScope.isTooltip(tour)) return true;

    taskObj = taskObj ? taskObj : false;

    if (GmCXt.isOnboarding(tour, taskObj)) {
        rootScope.previewNotification(tour, taskObj, step);
        return true;
    }

    type = type;
    step = step;
    tour = tour;
    source = source;
    catName = catName;

    rootScope.checkAppList().then(async function() {
        if (!GmCXt.isDomainInActiveApp() && type !== rootScope.playSlideshow && !tour.tour_settings.redirectionUrl) {
            rootScope.showDomainRedirect(tour);
            return true;
        }

        if(type === rootScope.playSlideshow) {
      
            const slideshowIns = get_store_value(Gm.slideshowInstance);	
            // Clean up existing instance if it exists
            if (GmCXt.isEmpty(slideshowIns)) {  
                // Create new slideshow instance
                const newSlideshow = new SlideShow({
                    target: document.getElementById('mgPlayerJSTest_slideshow-panel')
                });
        
                // Update the global reference
                Gm.slideshowInstance.update(() => newSlideshow);
            }
        }

        if (tour.step_count === "0" || !tour.step_count) {
            Gm.showModal.set(true);
            Gm.dialogBox.set({
                msg: "There are no steps to play",
                popupType: "info",
                onConfirm: () => {
                    GmCXt.showModal.set(false);
                },
                showCancelButton: false,
            });
            return true;
        }

        let errorCb = function() {
            Gm.showModal.set(true);
            Gm.dialogBox.set({
                msg: labels.tourPlayError,
                popupType: "error",
                onConfirm: () => {
                    GS.showModal.set(false);
                },
                showCancelButton: false,
            });
        };

        let param = {
            tour_id: tour.tour_id,
            category_id: tour.category_id
        };

        if (!GmCXt.checkDefaultLangForTour(tour, rootScope.language)) {
            param.language = rootScope.language;
        }

        if (tour.steps.length) {
            tourCb(type, step, tour, source, catName, taskObj);
        } else {
            Gm.loading.set(true);
            api.getTour(param, function(_tour) {
                Gm.loading.set(false);
                tourCb(type, step, _tour, source, catName, taskObj);
            }, errorCb);
        }
    });
};

rootScope.play = function(tour, resume) {
    rootScope.trackSearchActivity(true);
    rootScope.isResumeGuide = resume;

    GmCXt.log(33, "Play tour" + GmCXt.tourLog(tour));

    if (tour && tour.tour_type === "help_article") {
        window.open(tour.tour_settings.articleUrl, "_blank");
        return;
    }

    if (GmCXt.FT.creatorApp) {
        rootScope.goToTourView(tour);
    } else if (rootScope.isDesktopApp()) {
        rootScope.guideAction(rootScope.playSlideshow, null, tour);
    } else {
        let defaultPlayAction = rootScope.getDefaultPlayAction(tour);
        if (defaultPlayAction === "Default") {
            defaultPlayAction = rootScope.getAppSetting("defaultPlayAction");
        }
        rootScope.guideAction(defaultPlayAction, null, tour, get_store_value(Gm.CurrentPage));
    }
};

rootScope.previewNotification = function(tour, taskObj, step) {
    let tours = [];
    tours.push(tour);
    GmCXt.loadGuideNotifications(tours, true, taskObj, step);
};

rootScope.isOnlySurveyGuide = function(tour) {
    let isSurveyOnly = true;
    if (tour && tour.steps.length > 0) {
        for (let i = 0; i < tour.steps.length; i++) {
            if (tour.steps[i] && tour.steps[i].step_type !== GmCXt.STEP_TYPE_SURVEY) {
                isSurveyOnly = false;
                break;
            }
        }
    } else {
        isSurveyOnly = false;
    }

    return isSurveyOnly;
};

rootScope.displayTaskListWidget = function(cb) {
    if (!GmCXt.isEmpty(rootScope.taskList)) {
        cb(rootScope.taskList);
        rootScope.processTaskListByRules(rootScope.taskList);
    } else {
        rootScope.isTaskListVisible = false;
        Gm.isTaskListVisible.set(rootScope.isTaskListVisible);
    }
};

rootScope.filterCompleatedTasks = function(tl) {
    let filterCompTask = [];

    if (rootScope.taskList) {
        rootScope.taskList.filter(function(t) {
            if (!t.completed) {
                filterCompTask.push(t);
            }
        });
    }

    return filterCompTask;
};

rootScope.closeAppPopup = function() {
    if (rootScope.navBarVisible) return;

    if (mg$(".mgPlayerJSTest_ege-panel-overlay") && mg$(".mgPlayerJSTest_ege-panel-overlay").is(":visible")) {
        rootScope.guideViewFullScreen = false;
        rootScope.toggleGuideViewFullScreen();
        mg$(".mgPlayerJSTest_ege-panel-overlay").css({
            display: "none",
        });
    }
};

rootScope.toggleGuideViewFullScreen = function() {
    if (rootScope.guideViewFullScreen) {
        GmCXt.increaseSidePanelWidth();

        mg$(".mgPlayerJSTest_ege-panel").css({
            width: "90%",
            "max-width": "90%",
            transition: "width 0s",
        });
    } else {
        GmCXt.reduceSidePanelWidth();

        mg$(".mgPlayerJSTest_ege-panel").css({
            width: "500px",
            "max-width": "500px",
            transition: "width 0s",
        });
    }
};

rootScope.closeAppPanel = function() {
    rootScope.closeAppPopup();
    rootScope.applicationDropdown = false;
    rootScope.automationDropdown = false;

    GmCXt.handleCloseApp();

    if (rootScope.currentView === "no-app") {
        if (GmCXt.FT.isPlayer) {
            GmCXt.hideWidgetIcon();
        }
    }

    mg$(".mgPlayerJSTest_ege-panel").removeAttr("style");
};

rootScope.getTranslatedTaskList = function(itemList, lang, itemType) {
    const translatedItems = itemList; //JSON.parse(JSON.stringify(itemList));

    translatedItems.forEach((item, key) => {

        let langData = GmCXt.parseJSON(item.language_data);
        if (langData && lang && langData[lang]) {
            let lData = langData[lang];

            if (lData.title) {
                if (itemType === 'taskList') {
                    translatedItems[key].task_list_title = lData.title;
                } else if (itemType === 'folders') {
                    translatedItems[key].folder_title = lData.title;
                }
            }
            if (itemType === 'guides' && lData.tour_title) {
                translatedItems[key].tour_title = lData.tour_title;
                translatedItems[key].tour_description = lData.tour_description;
            }
        }

        // Translate guides and folders
        if (!GmCXt.isEmpty(item.guides)) {
            translatedItems[key].guides = rootScope.getTranslatedTaskList(item.guides, lang, 'guides'); // Recursion for guides
        }
        if (!GmCXt.isEmpty(item.folders)) {
            translatedItems[key].folders = rootScope.getTranslatedTaskList(item.folders, lang, 'folders'); // Recursion for folders
        }
    });

    return translatedItems;
};

rootScope.getTaskListData = function(cb, taskListSyncTime) {
    if (rootScope.taskList) {
        if (rootScope.language) {
            rootScope.taskList = rootScope.getTranslatedTaskList(rootScope.taskList, rootScope.language, 'taskList');
        }
        rootScope.taskList = rootScope.filterCompleatedTasks(rootScope.taskList);
        if (rootScope.guideSegmentation && GmCXt.inPlayer) {
            rootScope.checkTaskSegmentation(rootScope.taskList, cb);
        } else {
            rootScope.displayTaskListWidget(cb);
        }
    } else if (!GmCXt.onPrem() && !rootScope.taskListApiInProcess && (taskListSyncTime === 0 ||
      (parseInt(GmCXt.appList["app:" + GmCXt.activeAppId].modification_date) > parseInt(taskListSyncTime)))) {
        rootScope.taskListApiInProcess = true;
        api.getTaskList().then(function(res) {
            rootScope.taskList = rootScope.notDefaultLang() ? rootScope.getTranslatedTaskList(res.task_list, rootScope.language, 'taskList') : res.task_list;
            if (!GmCXt.isEmpty(rootScope.taskList)) {
                api.getTaskListDetails().then(function(resp) {
                    let taskDetail = resp.data.task_lists;
                    rootScope.updateDetailInMainTaskList(taskDetail);
                    rootScope.taskList = rootScope.filterCompleatedTasks(rootScope.taskList);
                    let taskListData = {
                        list: rootScope.taskList,
                        time: Date.now(),
                    };

                    GmCXt.saveToDapStorage('taskList', taskListData);
                    rootScope.taskListApiInProcess = false;

                    if (rootScope.guideSegmentation && GmCXt.inPlayer) {
                        rootScope.checkTaskSegmentation(rootScope.taskList, cb);
                    } else {
                        cb(rootScope.taskList);
                        rootScope.processTaskListByRules(rootScope.taskList);
                    }
                });
            }
        })
            .catch(function() {});
    }
};

rootScope.checkTaskSegmentation = function(taskList, cb) {
    let validTaskList = [];
    let segmentTaskList = [];

    function taskSegmentCB(t) {
        if (!GmCXt.isEmpty(t)) {
            if (!validTaskList.includes(t.task)) validTaskList.push(t.task);
            rootScope.taskList = validTaskList;
            rootScope.displayTaskListWidget(cb);
        }
    }

    if (taskList.length > 0) {
        for (let i = 0; i < taskList.length; i++) {
            if (!GmCXt.isEmpty(taskList[i].task_list_setting)) {
                let ts = GmCXt.parseJSON(taskList[i].task_list_setting);
                if (!GmCXt.isEmpty(ts.segment_groups)) {
                    let t = {
                        tour_id: taskList[i].task_list_id,
                        tour_title: taskList[i].task_list_title,
                        tour_settings: ts,
                        task: taskList[i],
                    };
                    segmentTaskList.push(t);
                } else {
                    validTaskList.push(taskList[i]);
                }
            } else {
                validTaskList.push(taskList[i]);
            }
        }

        if (!GmCXt.isEmpty(segmentTaskList)) {
            GmCXt.timeout(function() {
                GmCXt.checkGuidesBasedOnSegment(
                    segmentTaskList,
                    taskSegmentCB,
                    "taskListSeg"
                );
                rootScope.taskList = validTaskList;
                rootScope.displayTaskListWidget(cb);
            }, 0);
        } else {
            rootScope.displayTaskListWidget(cb);
        }
    } else {
        rootScope.processTaskListByRules(taskList);
    }
};

rootScope.getTaskListIndexById = function(taskId) {
    let i = -1;
    if (rootScope.taskList) {
        i = rootScope.taskList.findIndex(function(task) {
            return task.task_list_id === taskId;
        });
    }
    return i;
};

rootScope.updateDetailInMainTaskList = function(taskDetailList) {
    let finalTaskList = rootScope.taskList;
    if (!GmCXt.isEmpty(taskDetailList)) {
        for (let x = 0; x < taskDetailList.length; x++) {
            let tIndex = rootScope.getTaskListIndexById(taskDetailList[x].id);
            if (tIndex !== -1) {
                finalTaskList[tIndex].user_completed_guide_count = parseInt(
                    taskDetailList[x].user_completed_guide_count
                );
                finalTaskList[tIndex].guide_count = parseInt(
                    taskDetailList[x].guide_count
                );
                finalTaskList[tIndex].completed = taskDetailList[x].completed;
            }
        }
    }
    rootScope.taskList = finalTaskList;
};

rootScope.displyTaskList = function() {
    /*let activeAppId = get(GmCXt.activeAppId);
	let appList = get(GmCXt.appList)*/
    let activeAppId = GmCXt.activeAppId;
    let appList = GmCXt.appList;
    if (
        (GmCXt.isPlayer() && !GmCXt.inPlayer) ||
    (GmCXt.inPlayer &&
      activeAppId &&
      !GmCXt.isEmpty(appList) &&
      !GmCXt.isEmpty(appList["app:" + activeAppId]) &&
      !GmCXt.isEmpty(appList["app:" + activeAppId].task_list_count) &&
      parseInt(appList["app:" + activeAppId].task_list_count) > 0)
    ) {
        return true;
    } else {
        return false;
    }
};

rootScope.refreshTaskList = function(event) {
    let taskList = document.getElementsByClassName("mgPlayerJSTest_task-list-container");
    if (taskList.length) {
        rootScope.setActivePage('taskList');
    } else {
        rootScope.sendMessageToShowTaskListWidget();
    }
};

rootScope.sendMessageToShowTaskListWidget = function() {
    if (rootScope.displyTaskList()) {
        let taskListCb = function(taskList) {
            rootScope.processTaskListByRules(taskList);
        };

        if (!GmCXt.isEmpty(GmCXt.user) && GmCXt.isPlayer() && !rootScope.taskListApiInProcess) {
            GmCXt.getFromDapStorage('taskList').then(function(resp) {
                rootScope.taskList = null;
                let taskListSyncTime = 0;
                if (!GmCXt.isEmpty(resp)) {
                    let syncRes = rootScope.syncTaskList(resp);
                    rootScope.taskList = syncRes.list;
                }

                if (!GmCXt.isEmpty(resp) && !GmCXt.isEmpty(resp.time)) {
                    taskListSyncTime = resp.time;
                }

                rootScope.getTaskListData(taskListCb, taskListSyncTime);
            });
        }
    }
};

rootScope.openTaskList = function() {
    if (rootScope.displyTaskList()) {
        if (mg$(".mgPlayerJSTest_push-notification-container").is(":visible")) {
            mg$(".mgPlayerJSTest_ege-panel").css({
                width: "500px",
                right: "-9550px",
            });
        } else {
            mg$(".mgPlayerJSTest_ege-panel").css({
                width: "100%",
            });
            // $state.go("taskList");
            Gm.activeView.set("taskList");
        }
    }
};

rootScope.guideHideForPlayer = function(ts) {
    let flag = false;
    if (ts && ts.guideHideForP && GmCXt.FT.isPlayer) {
        flag = true;
    }
    return flag;
};

rootScope.markTaskGuideComplete = function(data) {
    let obj = {
        task_id: data.taskListId,
        guide_id: data.tourId,
    };

    function markCompleteCB() {
        rootScope.taskList = rootScope.filterCompleatedTasks(rootScope.taskList);
        rootScope.taskListGuidesCount(rootScope.taskList);
        // $state.go("taskList");
        // $state.reload();
        Gm.loading.set(false);
    }

    Gm.loading.set(true);
    api.markTaskGuideComplete(obj, function() {
        let finalTL = rootScope.taskList;
        let tIndex = rootScope.getTaskListIndexById(data.taskListId);
        if (tIndex !== -1) {
            if (
                !GmCXt.isEmpty(data.complete_count) &&
        !GmCXt.isEmpty(data.total_count) &&
        data.complete_count + 1 === data.total_count
            ) {
                finalTL[tIndex].user_completed_guide_count =
          finalTL[tIndex].guide_count;
                finalTL[tIndex].completed = true;
            } else {
                finalTL[tIndex].user_completed_guide_count =
          finalTL[tIndex].user_completed_guide_count + 1;
            }
            rootScope.updateTaskList(finalTL).then(markCompleteCB);
        }
    });
};

rootScope.updateTaskList = function(tl) {
    let promise = new Promise(function(resolve, reject) {
        GmCXt.getFromDapStorage('taskList').then(function(resp) {
            if (!GmCXt.isEmpty(resp)) {
                let syncRes = rootScope.syncTaskList(resp);
                rootScope.taskList = syncRes.list;
                rootScope.taskList = [];
                GmCXt.removeFromDapStorage('taskList');
                resp.list = tl;
                rootScope.taskList = tl;
                let taskListData = {
                    list: tl,
                    time: resp.time,
                };
                GmCXt.saveToDapStorage('taskList', taskListData);
                resolve();
            }
        });
    });
    return promise;
};

rootScope.markTaskGuideCompletePlayedOutside = function(data) {
    if (rootScope.taskList && rootScope.taskList.length > 0) {
        let filteredTask = rootScope.taskList.filter(function(task) {
            if (task.guides && task.guides.some(function(guide) {
                return guide.tour_id.toString() === data.tourId;
            })) {
                return true;
            } else if (task.folders) {
                return (
                    task.folders.filter(function(folder) {
                        return (
                            folder.guides &&
              folder.guides.some(function(guide) {
                  return guide.tour_id.toString() === data.tourId;
              })
                        );
                    }).length > 0
                );
            }
            return false;
        });

        if (filteredTask.length > 0) {
            filteredTask.forEach(function(task) {
                let params = {
                    taskListId: task.task_list_id,
                    tourId: data.tourId,
                    complete_count: task.user_completed_guide_count,
                    total_count: task.guide_count,
                };
                rootScope.markTaskGuideComplete(params);
            });
        }
    }
};

rootScope.processTaskListByRules = function(list) {
    let filteredList = [];

    for (let i = 0; i < list.length; i++) {
        let l = list[i];

        if (l.task_list_setting) {
            l.task_list_setting = GmCXt.parseJSON(l.task_list_setting);
            let rules = l.task_list_setting.rules;

            if (rules && rules.length > 0) {
                if (GmCXt.ruleEngine.evaluateRules(rules)) {
                    filteredList.push(l);
                }
            } else {
                filteredList.push(l);
            }
        } else {
            filteredList.push(l);
        }
    }
    rootScope.taskListGuidesCount(filteredList);

    return filteredList;
};

rootScope.taskListGuidesCount = function(tlst) {
    if (GmCXt.FT.isPlayer) {
        let taskCount = tlst.length || 0;
    
        rootScope.taskListCount = taskCount < 100 ? taskCount : "99+";
        rootScope.isTaskListVisible = taskCount > 0;
        GmCXt.taskListCount = taskCount;

        Gm.allTaskList.set(tlst);
        Gm.isTaskListVisible.set(rootScope.isTaskListVisible);
        Gm.taskListCount.set(taskCount);
    }
};

rootScope.getSegmentGroupList = function() {

    let d = {
        organization_id: GmCXt.organization.organization_id,
    };

    let segmentData = {
        list: [],
        time: Date.now(),
    };

    return new Promise(function(resolve, reject) {
        let cb = function(g) {
            segmentData.list = g;
            rootScope.allSegments = segmentData.list;
            GmCXt.saveToStorage('segmentGroupData', segmentData);
            resolve(segmentData.list);
        };

        if (GmCXt.inPlayer) {
            segmentData.list = GmCXt.organization.segment_groups;
            rootScope.allSegments = segmentData.list;
      
            GmCXt.saveToStorage('segmentGroupData', segmentData);
            resolve(segmentData.list);
        } else {
            GmCXt.api
                .getSegmentGroupList(d)
                .then(function(res) {
                    GmCXt.validateApiResp(
                        cb,
                        "segment/group/list?organization_id=",
                        res.data.groups,
                        GmCXt.model.segmentGroups
                    );
                })
                .catch(function() {
                    resolve(segmentData.list);
                });
        }
    });
};

function checkGuideMeMode(type) {
    if (
        ((type === "Default" || type === "") &&
      GmCXt.getAppSetting("defaultPlayAction") === rootScope.playGuideMe) ||
    type === rootScope.playGuideMe
    ) {
        return true;
    } else {
        return false;
    }
}

function getLastPlayedStep(t) {
    let lastStepId = GmCXt.tourActivity["t:" + t.tour_id];
    return rootScope.getStepFromTour(lastStepId, t);
}

function restartGuide() {
    GmCXt.log(33, "RESTART tour play" + GmCXt.tourLog(rootScope.contTour.tour));
    continuePlay("", null, rootScope.contTour.tour, rootScope.contTour.source);
}

function resumeGuide() {
    GmCXt.log(33, "RESUME tour play" + GmCXt.tourLog(rootScope.contTour.tour));
    continuePlay(
        "",
        rootScope.contTour.step,
        rootScope.contTour.tour,
        rootScope.contTour.source
    );
}

function tourCb(type, step, tour, source, catName, taskObj) {
    tour = GmCXt.checkAndCorrectPS(tour);

    if (type === GmCXt.TOUR_PLAYER_SLIDESHOW) {
        if (rootScope.isOnlySurveyGuide(tour)) {
            return;
        }
        tour.steps = GmCXt.filterOutAutomationSteps(tour.steps);
    }

    if (type === "doitforme") {
        if (rootScope.checkStepsForDoItForMeMode(tour)) {
            const warningModalI = new Modal({
                target: document.body,
                props: {
                    popupType: "warning",
                    msg: labels.doitForMeWarning,
                    onConfirm: () => warningModalI.$destroy(),
                },
            });
            return;
        }
    }

    tour.tour_settings = GmCXt.parseJSON(tour.tour_settings);

    tour.tour_settings.play_structure = GmCXt.getGuidePlayStructure(tour, type);

    //for guide play event
    tour.tour_settings.valid_segments = GmCXt.getTourSegments(tour);

    //if (GmCXt.FT.isPlayer) {
    tour = !rootScope.isGuideInOriginalLang(tour) ? rootScope.getTranslatedTourAndSteps(tour, rootScope.language) : tour;
    //tour = tour;
    //}

    GmCXt.getFromDapStorage('appData').then(function(r) {
        let appList = r;
        GmCXt.appList = r;
        rootScope.syncApps(GmCXt.appList);
        GmCXt.getFromStorage('activeAppId').then((id) => {
            let activeAppId = id;

            GmCXt.activeAppId = id;
            let activeAppData = appList["app:" + activeAppId];
            GmCXt.activeAppData = activeAppData;
            let as = activeAppData.settings;

            if (as && as.domains) {
                tour.allDomains = as.domains;
            } else {
                tour.allDomains = false;
            }

            GmCXt.urlParts.pathname.length > 1 ?
            GmCXt.urlParts.pathname.toLowerCase() :
            null;

            let rules = tour.tour_settings.rules;
            rootScope.resumeFromStartPoint = false;
            let match = true;

            if (!GmCXt.isEmpty(tour.tour_settings.start_point_info)) {
                if (rules.length > 0) {
                    match = GmCXt.ruleEngine.evaluateRules(rules);
                }
                if (match) {
                    rootScope.resumeFromStartPoint = true;
                }
            }

            if (!step && (rootScope.isResumeGuide || rootScope.resumeFromStartPoint)) {
                if (rootScope.isPlayer() && (source === "home" || source === "currentpage" || source === "allguides" ||
            source === "tour-list" || source === "stepview" ||
            (source === "tour-view" && rootScope.resumeFromStartPoint)) && checkGuideMeMode(type)) {
                    let step;
                    if (rootScope.resumeFromStartPoint && !rootScope.isResumeGuide) {
                        for (let i = 0; i < tour.tour_settings.start_point_info.length; i++) {
                            step = GmCXt.getStepFromSteps(tour.tour_settings.start_point_info[i].step_id, tour.steps);
                            break;
                        }
                    } else {
                        step = getLastPlayedStep(tour);
                    }

                    rootScope.contTour = {
                        tour: tour,
                        step: step,
                        source: source,
                    };

                    if (step) {
                        GmCXt.log(
                            33,
                            "Tour was Played " + GmCXt.stepLog(step.step_id, step.tour_id)
                        );

                        rootScope.startPoints = [];
                        for (let i = tour.steps.length - 1; i > -1; i--) {
                            if (tour.steps[i].step_settings.startPoint) {
                                rootScope.resumeFromStartPoint = true;
                                rootScope.startPoints.push(tour.steps[i]);
                            }
                        }

                        if (rootScope.startPoints.length && !rootScope.isResumeGuide) {
                            if (tour.steps[0].step_type === "inline") {
                                rootScope.startPoints.unshift(tour.steps[0]);
                            }
                            rootScope.searching_sp = 0;

                            let data = {
                                tour_id: tour.tour_id,
                                startPoint: rootScope.startPoints[0],
                            };
                            GmCXt.sendMessageToAllWindows('mgPlayerJSTest_action:started;task:search_start_point', data);
              
                        } else if (step.step_type === "inline") {
                            rootScope.stepFound = false;

                            const data = {
                                tour_id: tour.tour_id,
                                requestId: step.step_id,
                                settings: step.step_settings,
                                windowHost: GmCXt.getPageDomain(),
                                task: "findStep",
                                findOnly: true,
                                noOutline: true,
                                timeout: Date.now() + 1000,
                                log_stepInfo: GmCXt.getStepInfoLog(step),
                            };
                            GmCXt.sendMessageToAllWindows('mgPlayerJSTest_action:started;task:search_next_step', data);

                            GmCXt.timeout(function() {
                                if (!rootScope.stepFound) {
                                    let s = rootScope.contTour.step;
                                    GmCXt.log(
                                        33,
                                        "NOT FOUND next step " + GmCXt.stepLog(s.step_id, s.tour_id)
                                    );

                                    restartGuide();
                                }
                            }, 1000);
                        } else {
                            resumeGuide();
                        }
                        return;
                    }
                }
            }

            GmCXt.log(33, "PLAYING " + GmCXt.tourLog(tour));

            continuePlay(type, step, tour, source, catName, taskObj);
        });
    });
}

function continuePlay(type, step, tour, source, catName, taskObj) {
    let firstStepId = "";

    if (!step) {
        firstStepId = tour.tour_settings.play_structure[0].id;
        step = rootScope.getStepFromTour(firstStepId, tour);
    }

    let currentStepId = step.step_id;

    GmCXt.log(33, "PLAY TOUR from " + GmCXt.stepLog(step.step_id, step.tour_id));

    // Video and blog options are available for published tours only.
    // Slideshow option is available irrespective of publish status.


    let data = {
        tour: tour,
        currentStepId: currentStepId,
        language: rootScope.getTourLangInfo(tour),
        isDefaultLang: GmCXt.checkDefaultLangForTour(tour, rootScope.language),
        source: source,
        automate: false,
        taskObj: taskObj,
        activeAppId: GmCXt.activeAppId,
        orgData: GmCXt.organization,
        user: GmCXt.user,
    };
    GmCXt.requestHandler.playGuide(data);

    if (catName) {
        data.tour.category_name = catName;
    }

    rootScope.startGuideAction(data, type, step, tour);
}

rootScope.startGuideAction = function(data, type, step, tour) {
    if (step && rootScope.lastVideoStepCreated) {
        let d = new Date();
        let timeDiff = d.getTime() - rootScope.lastVideoStepCreated.time;

        if (
            rootScope.lastVideoStepCreated.id === step.step_id &&
      timeDiff < 60000
        ) {
            rootScope.showPopup(rootScope.labels.processingVideo);
            return;
        }
    }

    if (tour.is_published) {
        switch (type) {
        case rootScope.playVideoTour:
            if (tour.media_files && tour.media_files[0].video === "0") {
                rootScope.showPopup(rootScope.labels.msgVideoNotFound);
                return;
            } else {
                data.type = rootScope.playVideoTour;
                data.mode = data.type;
            }
            break;

        case rootScope.playGiphy:
            if (tour.media_files[0].gify === "0") {
                rootScope.showPopup(rootScope.labels.msgGiphyNotFound);
                return;
            } else {
                data.type = rootScope.playGiphy;
                data.mode = data.type;
                break;
            }
        }
    }

    if (type === rootScope.playSlideshow) {
        data.type = rootScope.playSlideshow;
        data.mode = data.type;
    }

    let play = function(r) {
        if (r) {
            let data = sortUserData(r);

            data.loops = data.length - 1;
            data.currentLoop = 0;
            data.csvData = data;
        }
        GmCXt.requestHandler.playGuide(data);
    };

    data.origin = rootScope.activeTab;

    if (data.taskObj && data.taskObj.taskId) {
        data.origin = "task_list";
    }


    data.guideOpened = rootScope.currentView === "tour-view" ? true : false;

    if (type === rootScope.playAuto) {
        data.automate = true;
        data.initiator = "doitforme";

        Gloading.set(true);

        checkIfCSV(tour).then(function(r) {
            Gloading.set(false);

            if (r) modal.openDoItPopup(play, "Upload CSV");
            else play();
        });
    } else play();
};

rootScope.getTourLangInfo = function(tour) {
    let language = "";
    let tourSetting = tour.tour_settings;

    if (GmCXt.isDefined(tourSetting.language_settings)) {
        language =
      tourSetting.language_settings.language +
      "-" +
      tourSetting.language_settings.voice;
    }

    if (rootScope.enableTranslation && rootScope.language) {
        language = rootScope.language + "-" + rootScope.languageVoice;
    }

    return language;
};

rootScope.getStepFromTour = function(step_id, tour) {
    if (step_id) {
        for (let i = 0; i < tour.steps.length; i++) {
            if (parseInt(tour.steps[i].step_id) === parseInt(step_id)) {
                return tour.steps[i];
            }
        }
    } else {
        return false;
    }
};

rootScope.existsOrUndefined = function(val) {
    if (val || val === undefined) return true;
    else return false;
};

rootScope.updateStatusProgressBar = function(request) {
    mg$('.mgPlayerJSTest_video-upload-progress-bar-wrapper').find('.mgPlayerJSTest_progress-bar-percentage').html(request.data.percentComplete + '%');
    mg$('.mgPlayerJSTest_video-upload-progress-bar-wrapper').find('.mgPlayerJSTest_progress-bar-percentage').css('width', request.data.percentComplete + '%');

};

rootScope.updatedInProgressVariable = function(request) {
    let status = (request.data && request.data.status) ? true : false;
    rootScope.uploadInProgress = status;

    if (status) {
        rootScope.uploadProgressBar = true;
    }
};

rootScope.hideProgressBar = function() {
    rootScope.uploadProgressBar = false;
    mg$('.mgPlayerJSTest_video-upload-progress-bar-wrapper').hide();
};

function checkIfCSV(tour) {
    return new Promise(function(resolve, reject) {
        let steps = GmCXt.createDeepCopy(tour.steps);

        let isCSV = function(allSteps, count, interval) {
            if (count === 0) {
                clearInterval(interval);

                for (let i = 0; i < allSteps.length; i++) {
                    let auto = allSteps[i].step_settings.automation;

                    if (auto && auto.inputType === "csv" && auto.csvParam) {
                        GmCXt.log(33, "CSV input expected");
                        resolve(true);
                    }
                }

                resolve(false);
            }
        };

        rootScope.checkLinkedGuideStep(steps, isCSV);
    });
}

rootScope.checkLinkedGuideStep = function(steps, intervalCb) {
    let allSteps = steps;
    let count = 0;

    function getTourCb(_tour) {
        let linkedSteps = _tour.steps;
        count--;
        allSteps = GmCXt.arrayMerge(allSteps, linkedSteps);
    }

    steps.forEach(function(step) {
        if (step.step_settings.tour_id) {
            allSteps = allSteps.filter(function(s) {
                return s.step_id !== step.step_id;
            });

            let param = {
                tour_id: step.step_settings.tour_id,
            };

            count++;

            api.getTour(param, getTourCb, getTourCb);
        }
    });

    var interval = setInterval(function() {
        intervalCb(allSteps, count, interval);
    }, 500);
};

rootScope.checkStepsForDoItForMeMode = function(tour) {
    let count = 0;
    let invalidTypes = [
        GmCXt.STEP_TYPE_SURVEY,
        GmCXt.STEP_TYPE_IMAGE,
        GmCXt.STEP_TYPE_VIDEO,
    ];
    let steps = {
        ...tour.steps,
    };

    if (tour && steps.length > 0) {
        for (let i = 0; i < steps.length; i++) {
            if (invalidTypes.includes(steps[i].step_type)) {
                count++;
            }
        }
    } else {
        return false;
    }

    return count === steps.length;
};

rootScope.isBeacon = function(t) {
    if (t && t.tour_type && t.tour_type.indexOf("beacon_tour") !== -1)
        return true;
    else return false;
};

rootScope.checkTourType = function(tour) {
    if (rootScope.isTooltip(tour) || GmCXt.isBotGuide(tour) || GmCXt.isFeatureTags(tour)) {
        return false;
    }

    if (rootScope.isBeacon(tour) && !rootScope.currentPageBeacon) {
        return false;
    }

    return true;
};

rootScope.readLocalCT = function(url, title) {
    if (rootScope.contextTours && rootScope.contextTours[url]) {
        return rootScope.contextTours[url][title];
    } else {
        return false;
    }
};

rootScope.filterAnnouncement = function(tours) {
    let tlist = tours;
    if (GmCXt.isPlayer()) {
        tours = tlist.filter(function(tour) {
            if (!rootScope.isAnnouncement(tour)) return tour;
        });
    }
    return tours;
};

rootScope.filterCurrentPageTourTypes = function(tours) {
    let tlist = tours;
    tours = tlist.filter(function(tour) {
        if (rootScope.checkTourType(tour)) return tour;
    });

    tours = tours.filter(function(tour) {
        if (!rootScope.isAnnouncement(tour)) return tour;
    });

    GmCXt.log(30, "FILTERED current page tours", tours);
    return tours;
};

rootScope.breadCrumbItemsUpdate = function(_cat) {
    let breadCrumb = get_store_value(Gm.breadCrumb);
    Gm.breadCrumb.subscribe((value) => {
        breadCrumb = value;
    });
    _cat.category_id;

    if (_cat.parent_id && _cat.parent_id !== "0") {
    // if (!(_cat.has_child && !(_cat.has_tour))) {
    // rootScope.addCategory(_cat);
    // }
    // If "All Guides" is already in the array, remove it
        const allGuidesIndex = breadCrumb.indexOf("All Guides");
        if (allGuidesIndex !== -1) {
            breadCrumb.splice(allGuidesIndex, 1);
        }
        // Add the new element at the beginning of the array
        breadCrumb.unshift(_cat);
        // Add "All Guides" back at the beginning of the array if it was present
        if (allGuidesIndex !== -1) {
            breadCrumb.unshift("All Guides");
        }
        // breadCrumb.unshift(_cat);
        rootScope.getCategoryApi(_cat.parent_id, rootScope.breadCrumbItemsUpdate);
    } else {
    // If "All Guides" is already in the array, remove it
        const allGuidesIndex = breadCrumb.indexOf("All Guides");
        if (allGuidesIndex !== -1) {
            breadCrumb.splice(allGuidesIndex, 1);
        }
        // Add the new element at the beginning of the array
        breadCrumb.unshift(_cat);
        // Add "All Guides" back at the beginning of the array if it was present
        if (allGuidesIndex !== -1) {
            breadCrumb.unshift("All Guides");
        }
    }
    Gm.breadCrumb.set(breadCrumb);
};

function containsCategoryWithId(category_id) {
    let breadcrumb = get_store_value(Gm.breadCrumb);
    // Iterate through the breadcrumb array starting from the second element
    for (let i = 1; i < breadcrumb.length; i++) {
    // Check if the current element is an object and has a category_id property
        if (typeof breadcrumb[i] === "object" && breadcrumb[i].id === category_id) {
            return true; // Found a category with the specified category_id
        }
    }
    return false; // No category found with the specified category_id
}
rootScope.getBreadcrumsCategories = function(tour, data) {
    let CurrentPage = get_store_value(Gm.CurrentPage);

    if (CurrentPage === "allguidesSearchPage") {
        if (!containsCategoryWithId(tour.category_id)) {
            Gm.breadCrumb.set(["All Guides"]);

            rootScope.getCategoryApi(
                tour.category_id,
                rootScope.breadCrumbItemsUpdate
            );
            get_store_value(Gm.breadCrumb);
            Gm.breadCrumb.subscribe((value) => {
            });
        }
    }
};

rootScope.getCategoryApi = function(_catid, cb, forceApi, appId) {

    if (!_catid) {
        return;
    }

    let params = {
        category_id: _catid,
    };

    if (rootScope.language && !GmCXt.isFalse(rootScope.language))
        params.language = rootScope.language;

    if (GmCXt.getLXPLang()) params.language = GmCXt.getLXPLang();
    //let user = get(GmCXt.user);
    let user = GmCXt.user;
    if (!GmCXt.isEmpty(user) || GmCXt.onPrem()) {
        api.getCategoryDetails(params, cb, appId, forceApi);
    }
};

rootScope.setTour = creatorUpdate.setTour;
rootScope.addTourList = creatorUpdate.addTourList;
rootScope.deleteCategoryServerUpdate = creatorUpdate.deleteCategoryServerUpdate;
rootScope.isUpdateNeeded = creatorUpdate.isUpdateNeeded;
rootScope.checkCurrentViewForUpdate = creatorUpdate.checkCurrentViewForUpdate;
rootScope.updateServerUpdateList = creatorUpdate.updateServerUpdateList;
rootScope.updateTourProperty = creatorUpdate.updateTourProperty;
rootScope.deleteTourServerUpdate = creatorUpdate.deleteTourServerUpdate;

rootScope.getTourFromId = function(tId, cId) {
    let currentTour = {};

    if (cId && rootScope.allTourList["cat_" + cId]) {
        currentTour = rootScope.allTourList["cat_" + cId]["tour_" + tId];
    } else {
        for (let cat in rootScope.allTourList) {
            if (rootScope.allTourList[cat]["tour_" + tId]) {
                currentTour = rootScope.allTourList[cat]["tour_" + tId];
                break;
            }
        }
    }

    return currentTour;
};

rootScope.getTranslatedTours = function(_tours, lang) {
    let tours = [..._tours];
    lang = rootScope.language;

    tours.forEach((tour, key) => {
        let tLangData = tour.language_data;
        if (!tour.tour_settings.translationEnable && GmCXt.isGuide(tour)) {
            lang = rootScope.defaultLang;
        } else {
            lang = rootScope.language;
        }

        if (tLangData && tLangData[lang] && !rootScope.isGuideInOriginalLang(tour)) {
            if (tLangData[lang].tour_title) {
                tour.tour_title = tLangData[lang].tour_title;
            }
            if (tLangData[lang].tour_description) {
                tour.tour_description = tLangData[lang].tour_description;
            }

            let ts = tLangData[lang].tour_settings;
            if (ts) {
                if (ts.beacon) {
                    tour.tour_settings.beacon = ts.beacon;
                }
                if (ts.rules) {
                    tour.tour_settings.rules = ts.rules;
                }
            }
        }

        let category = rootScope.allCategories["cat_" + tour.category_id];
        if (category && category.language_data && category.language_data[lang]) {
            tour.category_title = category.language_data[lang].category_title;
        }
        if (tour.steps) {
            tours[key] = rootScope.getTranslatedTourAndSteps(tour, lang);
        }
    });
    return tours;
};

rootScope.filterKeyInputGuides = function(tours) {
    rootScope.keyInputGuides = tours.filter(function(tour) {
        if (
            tour &&
      tour.tour_settings &&
      !GmCXt.isEmpty(tour.tour_settings.keyboardKeyInput)
        )
            return tour;
    });
  
    GmCXt.keyInputGuides = rootScope.keyInputGuides;
};

rootScope.processContextualGuide = function(r, url) {
    let tours = r;
    if (r.data) {
        tours = r.data.data.tours;
    }

    rootScope.filterKeyInputGuides(tours);

    if (GmCXt.isPlayer() && !GmCXt.isEmpty(tours)) tours = GmCXt.filterScheduleTours(tours);

    if (GmCXt.inPlayer && rootScope.notDefaultLang()) {
        tours = structuredClone(tours);
        tours = rootScope.getTranslatedTours(tours);
    }

    if (rootScope.contextTours && !rootScope.contextTours[url]) {
        rootScope.contextTours[url] = [];
    }

    rootScope.contextTours[url][GmCXt.pageTitle] = tours;

    return tours;
};

rootScope.isUserLogin = function() {
    return new Promise(function(resolve, reject) {
        GmCXt.getFromStorage('user').then(function(user) {
            if (user && !GmCXt.isEmpty(user)) {
                GmCXt.updateGlobalUser(user);
                GmCXt.user = user;
                rootScope.user = user;
                rootScope.syncUser();
                if (user.organization) rootScope.saveOrganization(user.organization);
                if (user.accesstoken) resolve(true);
                resolve(false);
            } else resolve(false);
        });
    });
};

rootScope.goToTourView = function(tour) {

    rootScope.currentTour = tour;
    GmCXt.saveToDapStorage('currentTour',rootScope.currentTour);
    Gm.currentTour.set(tour);
    rootScope.setCurrentPage("stepview");
};


rootScope.trackSearchEvent = function(guideClick) {

    if (rootScope.trackSearch && rootScope.trackSearch.track) {

        rootScope.trackSearch.track = false;

        let object = {
            search_text: rootScope.trackSearch.keyword,
            results_returned: rootScope.trackSearch.results_returned,
            search_result_clicked: guideClick,
            startTime: rootScope.trackSearch.startTime
        };

        GmCXt.trackerV1.trackGuideSearch(object);

        rootScope.trackSearch = {};
    }
};

rootScope.trackCurrentPageSearchEvent = function(guideClick) {

    if (rootScope.trackCurrentPageSearch && rootScope.trackCurrentPageSearch.track) {

        rootScope.trackCurrentPageSearch.track = false;

        let object = {
            search_text: rootScope.trackCurrentPageSearch.keyword,
            results_returned: rootScope.trackCurrentPageSearch.results_returned,
            search_result_clicked: guideClick,
            startTime: rootScope.trackCurrentPageSearch.startTime
        };

        GmCXt.trackerV1.trackGuideSearch(object, rootScope.pageUrl);
    }
};

rootScope.trackSearchActivity = function(guideClick) {
    if (rootScope.searchKeyword) {
        rootScope.trackSearchEvent(guideClick);
    }

    if (rootScope.search) {
        rootScope.trackCurrentPageSearchEvent(guideClick);
    }
};

rootScope.isRefreshView = function() {
    let view = get_store_value(Gm.activeView);

    if (view === "home") return true;
    else return false;
};

rootScope.fetchOrgFromAPI = function() {
    let promise = new Promise(function(resolve, reject) {
        function cb(_org) {
            rootScope.saveOrganization(_org);
            GmCXt.showWidget();
            resolve(true);
        }

        api.getOrganization(cb);
    });

    return promise;
};
rootScope.isFetchingCdn = false;
rootScope.ongoingCdnPromise = null;

rootScope.getNewCdnSignature = function() {
    if (rootScope.isFetchingCdn) {
    // If a network call is already in progress, return the ongoing promise
        return rootScope.ongoingCdnPromise;
    }
    rootScope.isFetchingCdn = true;

    rootScope.ongoingCdnPromise = new Promise(function(resolve, reject) {
        let o = GmCXt.organization;
        if (GmCXt.onPrem()) {
            resolve();
        } else if (o && !GmCXt.isEmpty(o)) {
            var data = {};
            if (o.organization_id) {
                data.organization_id = o.organization_id;
                fetchCdnCall();
            } else {
                rootScope
                    .fetchOrgFromAPI()
                    .then(function(response) {
                        fetchCdnCall();
                    })
                    .catch(function(err) {
                        reject(err);
                    });
            }
        } else {
            rootScope.fetchOrgFromAPI().then(function(response) {
                fetchCdnCall();
            });
        }

        function fetchCdnCall() {
            api.getCdnSignature(data, function(response) {
                cb(response);
                rootScope.isFetchingCdn = false;
                resolve();
            });
        }

        function cb(response) {
            if (!response) return;
            let result = response.data;
            if (result && result.cdn_signature && result.cdn_signature_expiry) {
                //let u = get(GmCXt.user)
                let u = GmCXt.user;
                if (u) {
                    u.cdn_signature = result.cdn_signature;
                    u.cdn_signature_expiry = result.cdn_signature_expiry;

                    rootScope.saveUser(u);
                    GmCXt.handleUpdateCdnSign(rootScope.user);          
                }
            }
        }
    });
    return rootScope.ongoingCdnPromise;
};

rootScope.checkCdnSignature = function() {
    return new Promise(function(resolve, reject) {
    //let user = get(GmCXt.user);
        let user = GmCXt.user;
        if (user && !GmCXt.isEmpty(user)) {
            if (!user.cdn_signature || !user.cdn_signature_expiry) {
                rootScope.getNewCdnSignature().then(resolve).catch(reject);
                return;
            }
            let expiryTime = parseInt(user.cdn_signature_expiry);
            expiryTime = !expiryTime ? 0 : expiryTime * 1000;
            if (expiryTime) expiryTime = expiryTime - (2 * 60 * 1000);
            let currentTime = new Date().getTime();

            if (expiryTime - currentTime <= 0) {
                rootScope.getNewCdnSignature().then(resolve).catch(reject);
                return;
            }
        }
        resolve();
    });
};

function getKeysForTracking() {
    if (!GmCXt.isDefined(rootScope.trackerSecrets)) rootScope.trackerSecrets = {};

    if (
        rootScope.trackerSecrets &&
    GmCXt.isEmpty(rootScope.trackerSecrets.secrets)
    ) {
        rootScope.registerClientInsights();
    }
}

rootScope.setInsightsClientKey = function(secretKey, currentTime) {
    let cb = function(r) {
        GmCXt.log(21, "Insights client key is set");
        let data = {
            registerClientId: secretKey,
            app_client_secret: r.data.app_client_secret,
            app_client_timestamp: currentTime,
        };

        rootScope.trackerSecrets = data;
        GmCXt.trackerUtil.secrets = data;
        GmCXt.saveToStorage("trackerSecrets", data);

        let msg = {
            action: "mgPlayerJSTest_action:update_secrets",
            data: {
                secrets: GmCXt.trackerUtil.secrets
            }
        };

        if (rootScope.isClientJs) {
            GmCXt.sendToParentWindow(msg);
        } else {
            GmCXt.sendMessageToBackgroundService(msg);
        }
    };

    GmCXt.api
        .getClientSecretInsight(secretKey)
        .then(function(result) {
            cb(result);
        })
        .catch(function(err) {
            GmCXt.log(1, "ERROR: failed to get insights client key");
            if (err && err.errorCode === "006-001-002") {
                rootScope.trackerSecrets = {};
                rootScope.registerClientInsights();
            }
        });
};

rootScope.registerClientInsights = function() {
    let date = new Date();
    let currentTime = date.getTime();

    if (!GmCXt.isEmpty(rootScope.trackerSecrets)) {
        var age = parseInt(
            (currentTime - rootScope.trackerSecrets.app_client_timestamp) / 1000
        );
    } else {
        var age = parseInt(currentTime / 1000);
    }

    if (
        GmCXt.isEmpty(rootScope.trackerSecrets) ||
    !rootScope.trackerSecrets.registerClientId
    ) {
        GmCXt.api
            .registerClientInsight()
            .then(function(result) {
                rootScope.setInsightsClientKey(result.data.app_client_id, currentTime);
            })
            .catch(function() {});
    } else if (age > 3600) {
        rootScope.setInsightsClientKey(
            rootScope.trackerSecrets.registerClientId,
            currentTime
        );
    }
};

rootScope.sendUserInfo = function() {
    rootScope.checkCdnSignature().then(function() {
        let org = GmCXt.organization;
        if (GmCXt.inPlayer) {
            GmCXt.orgBucket = org.bucket;
        }

        rootScope.sendSidePanelInitEvent(false, true);
        getKeysForTracking();
    });
};

rootScope.sendSidePanelInitEvent = function(reset, triggerSync) {
    if (!rootScope.maintenance && GmCXt.activeAppId) {
        GmCXt.log(21, "Side panel intialisation completed");


        let al = GmCXt.appList;
        let user = GmCXt.user;
        let org = GmCXt.organization;
        let urlPart = GmCXt.urlParts;
        let appList = rootScope.removeCatFromApplist(al);
        let message = {
            action: "mgPlayerJSTest_action:on_side_panel_init",
            data: {
                user: user,
                activeAppId: GmCXt.activeAppId,
                organization: org,
                userPrefLang: rootScope.userPrefLang,
                appList: appList,
                refreshTime: rootScope.refreshTime,
                lastTimeStampSync: rootScope.lastTimeStampSync,
                url: urlPart.fullUrl,
                reset: reset,
                triggerSync: triggerSync
            },
        };

        Gm.activeView.update((n) => n === "home" ? "" : "home");
        GmCXt.onSidePanelInit(message);
        GmCXt.sendMessageToBackgroundService(message);
    }
};

function checkAppData() {
    return new Promise(function(resolve, reject) {
        rootScope.checkAppList().then(function() {
            //let urlPart = get(GmCXt.urlParts);
            let urlPart = GmCXt.urlParts;

            if (GmCXt.checkDomainInApps(urlPart.fullUrl).domainMatch) {
                if (GmCXt.activeAppId && GmCXt.activeAppId !== GmCXt.checkDomainInApps(urlPart.fullUrl).appId) {
                    resetData();
                }
                if (GmCXt.FT.creatorApp) {
                    autoSwitchApp();
                }
                GmCXt.activeAppId = GmCXt.checkDomainInApps(urlPart.fullUrl).appId;
                let cApp = GmCXt.appList["app:" + GmCXt.activeAppId];

                if (cApp) {
                    rootScope.initAppDetails(cApp);
                }
            } else if (!GmCXt.FT.creatorApp) {
                GmCXt.removeFromStorage('activeAppId');
                GmCXt.activeAppId = false;
            }
            resolve();
        });
    });
}

function goToApp() {
    getCurrentAppObj().then(function(currentApp) {
        if (!GmCXt.isEmpty(currentApp)) {
            rootScope.switchApp(currentApp);
        }
    });
}

function autoSwitchApp(redirectCb) {
    let isAppSwitch = true;
    let r = GmCXt.checkDomainInApps(GmCXt.urlParts.fullUrl);

    updateSettingOnAppSwitch();

    if (!r.appId) {
        return false;
    }

    if (r.appId !== GmCXt.activeAppId) {
        rootScope.resetCreatorData(true);
        if (r.domainMatch) {
            GmCXt.log(21, "SWITCH app for the current domain: " + r.appName);

            GmCXt.saveToStorage('activeAppId', r.appId);
            GmCXt.activeAppId = r.appId;

            if (GmCXt.inPlayer) {
                resetData();
            }
            rootScope.initAppDetails(GmCXt.appList["app:" + r.appId]);

            if (GmCXt.FT.isPlayer) {
                rootScope.setCurrentPage("currentpage");
            } else {
                goToApp();
            }
        } else if (GmCXt.isPlayer()) {
            rootScope.goToNoApp();
            isAppSwitch = false;
        } else if (!GmCXt.isPlayer()) {
            goToApp();
        }
    } else {
        isAppSwitch = false;
    }

    return isAppSwitch;
}

function initCommon() {
    checkAppData().then(function() {

        let isAppSwitch = autoSwitchApp();

        rootScope.syncUser();

        if (isAppSwitch) {
            rootScope.processedAppData = true;
        }
        rootScope.setMode();
        rootScope.setNotifTours();
        rootScope.initPlayerMode();

        GmCXt.showWidget();
        rootScope.sendUserInfo();
    });
}

rootScope.isAllowedDomain = function() {
    let foundDomain = true;
    if (GmCXt.conf.allowedDomains && GmCXt.conf.allowedDomains.length) {
        foundDomain = false;
        for (let i = 0; i < GmCXt.conf.allowedDomains.length; i++) {
            if (GmCXt.urlParts.host.indexOf(GmCXt.conf.allowedDomains[i]) >= 0) {
                foundDomain = true;
                break;
            }
        }
    }

    return foundDomain;
};

function initPlayer() {
    GmCXt.log(21, "LOADED side panel. Initialising Player");

    if (!GmCXt.isEmpty(GmCXt.user)) {
        initCommon();
    } else {
        if ((GmCXt.conf.appConfig.login.SSO || GmCXt.myGuideInternalCustomers() || GmCXt.isMcKesson()) && rootScope.isAllowedDomain()) {
            if (GmCXt.urlParts) {
                rootScope.signInWithSso();
            } else {
                setTimeout(function() {
                    rootScope.signInWithSso();
                }, 1000);
            }
        } else {
            rootScope.clearSession();
        }
    }
}

function initCreator() {
    GmCXt.log(21, "LOADED side panel. Initialising Creator");
    if (!GmCXt.isEmpty(GmCXt.user)) {
        initCommon();
    } else {
        rootScope.clearSession();
    }
}

rootScope.initApp = function() {
    if (GmCXt.onPrem()) initOnPremPlayer();
    else if (GmCXt.isPlayer()) initPlayer();
    else initCreator();
};

rootScope.goToNoApp = function() {
    if (GmCXt.isPlayer()) {
        GmCXt.hideWidgetIcon();
    }

    // Force a store update by resetting the value
    Gm.activeView.update((n) => n === "home" ? "" : "home"); // If value is "home", set it to "" first, then reset to "home"

    // Set the value again after forcing the update
    Gm.activeView.set("home");
    rootScope.setCurrentPage("noapp");
};


rootScope.validateAndMigrateTour = function(t) {
    let tour = GmCXt.validateDataModel(t, GmCXt.model.guide);
    return GmCXt.migrateTour(tour);
};

function getSubCat(catList, catId) {
    let cat = catList.find(function(c) {
        return parseInt(c.category_id) === parseInt(catId);
    });

    if (!cat) {
        catList.forEach(function(c) {
            if (c.sub_categories) {
                cat = getSubCat(c.sub_categories, catId);
            }
        });
    }

    return cat;
}

function updateContextualTourSteps(t) {
    if (GmCXt.isEmpty(rootScope.contextTours)) return;

    let tFound = false;

    let urls = Object.keys(rootScope.contextTours);

    urls.forEach(function(u) {
        if (tFound) return;

        let pageTitles = Object.keys(rootScope.contextTours[u]);

        pageTitles.forEach(function(pt) {
            if (tFound) return;

            let tours = rootScope.contextTours[u][pt];

            for (let i = 0; i < tours.length; i++) {
                if (
                    parseInt(rootScope.contextTours[u][pt][i].tour_id) ===
          parseInt(t.tour_id)
                ) {
                    tFound = true;
                    rootScope.contextTours[u][pt][i] = t;
                    break;
                }
            }
        });
    });
}

rootScope.updateGuideInPublishedTour = function(guide, remove) {
    let found = false;
    rootScope.publishedTours.forEach(function(tour, index) {
        if (parseInt(tour.tour_id) === parseInt(guide.tour_id)) {
            found = true;

            if (remove) {
                rootScope.publishedTours.splice(index, 1);
            } else {
                rootScope.publishedTours[index] = guide;
            }
        }
    });

    if (!found && !remove) {
        rootScope.publishedTours.push(guide);
    }
};

rootScope.updateTourToStorage = function(updateCount, tour, remove, aId) {
    GmCXt.log(70, "UPDATE TOUR: " + GmCXt.tourLog(tour));

    if (!remove && !aId) {
        rootScope.setTour(tour);
        GmCXt.log(70, "UPDATE TOUR: Global updated" + GmCXt.tourLog(tour));
    }

    let appId = aId || GmCXt.activeAppId;
    let catId = tour.category_id;
    let tourId = tour.tour_id;

    let cat = false;

    //update contextTours with the steps
    updateContextualTourSteps(tour);

    if (GmCXt.appList["app:" + appId]) {
        if (GmCXt.appList["app:" + appId].categories) {
            cat = GmCXt.appList["app:" + appId].categories.filter(function(c) {
                return parseInt(c.category_id) === parseInt(catId);
            })[0];
        }

        if (!cat && GmCXt.appList["app:" + appId].categories) {
            let cats = GmCXt.appList["app:" + appId].categories;
            for (let i = 0; i < cats.length; i++) {
                if (cats[i].sub_categories) {
                    cat = getSubCat(cats[i].sub_categories, catId);
                }
                if (cat) break;
            }
        }
    }

    if (!cat) {
        GmCXt.log(70, "UPDATE TOUR: category not found" + GmCXt.tourLog(tour));
        rootScope.playerSyncCount--;
        return;
    }

    //find index of tour in cat
    let indexOfTour;

    if (cat.tours) {
        for (let i = 0; i < cat.tours.length; i++) {
            if (parseInt(cat.tours[i].tour_id) === parseInt(tourId)) {
                indexOfTour = i;
                break;
            }
        }
    }

    //replace updated tour in category
    if (indexOfTour >= 0) {
        if (remove) {
            // delete tour from cat list

            cat.tours.splice(indexOfTour, 1);
            GmCXt.log(70, "UPDATE TOUR: tour REMOVED" + GmCXt.tourLog(tour));
        } else {
            cat.tours.splice(indexOfTour, 1, tour);
            GmCXt.log(70, "UPDATE TOUR: tour UPDATED" + GmCXt.tourLog(tour));
        }
    } else if (!remove) {
        if (!cat.tours) {
            cat.tours = [];
        }
        cat.tours.push(tour);
        GmCXt.log(70, "UPDATE TOUR: tour ADDED" + GmCXt.tourLog(tour));
    }

    rootScope.syncApps(GmCXt.appList);
    GmCXt.saveToDapStorage('appData', GmCXt.appList);

    //update published Tours
    if (!aId) {
        rootScope.updateGuideInPublishedTour(tour, remove);
    }
    if (updateCount) {
        rootScope.playerSyncCount--;
    }
};

GmCXt.storage().get(['screen_recorder_close']).then(function(r) {

    if (r.screen_recorder_close) {
        rootScope.isScreenRecorderClose = r.screen_recorder_close;
        let m = {
            action: "mgPlayerJSTest_action:show_recording_off",
        };
        GmCXt.sendMessageToBackgroundService(m);
    } else {
        rootScope.isScreenRecorderClose = false;
    }
});

rootScope.getSteps = function(options) {
    let promise = new Promise(function(resolve, reject) {
        api.getTour(options, function(_tour) {
            if (rootScope.notDefaultLang()) {
                _tour = rootScope.getTranslatedTourAndSteps(_tour, rootScope.language);
                resolve(_tour);
            }
            resolve(_tour);
        });
    });
    return promise;
};

rootScope.isTooltip = function(t) {
    if (t && t.tour_type && t.tour_type.indexOf("smartTip") !== -1) return true;
    else return false;
};

rootScope.isHelpArticle = function(t) {
    if (t && t.tour_type && t.tour_type.indexOf("help_article") !== -1)
        return true;
    else return false;
};

rootScope.isMobileGuide = function(t) {
    if (
        t &&
    t.tour_settings &&
    t.tour_settings.tour_type &&
    t.tour_settings.tour_type.indexOf("mobile") !== -1
    ) {
        return true;
    } else return false;
};

rootScope.isPlayedTour = function(tour_id) {
    let playedTour = GmCXt.playedTour;
    if (
        GmCXt.isPlayer() &&
    !GmCXt.isEmpty(playedTour) &&
    playedTour.indexOf(tour_id) !== -1
    ) {
        return true;
    }

    return false;
};

rootScope.branchGuideDownloadOpts = function(opts) {
    opts.video_file = false;
    opts.gif_file = false;
    opts.text_file = false;
    opts.word_file = false;
    opts.blog_file = false;
};

rootScope.addPanelOverlay = function() {
    mg$(".mgPlayerJSTest_ege-panel-overlay").remove();
    mg$(".mgPlayerJSTest_ege-panel").append("<wmgPlayerJSTest_ class='mgPlayerJSTest_ege-panel-overlay'></wmgPlayerJSTest_>");
};

rootScope.showPanelOverlay = function() {
    mg$(".mgPlayerJSTest_ege-panel-overlay").css({
        display: "block",
    });
};

rootScope.hidePanelOverlay = function() {
    if (mg$(".mgPlayerJSTest_ege-panel-overlay") && mg$(".mgPlayerJSTest_ege-panel-overlay").is(":visible")) {
        mg$(".mgPlayerJSTest_ege-panel-overlay").css({
            display: "none",
        });
    }
};

rootScope.updateAccessToken = function() {
    GmCXt.updateGlobalUser(GmCXt.user);
};

rootScope.updateAccessTokenCallBack = function(responseObj, cb, apiData) {
    if (responseObj) {
        let user = GmCXt.user;
        user.accesstoken = responseObj.accesstoken;
        user.refreshtoken = responseObj.refreshtoken;

        if (GmCXt.isDefined(responseObj.app_access)) {
            user.app_access = responseObj.app_access;
        }

        rootScope.saveUser(user);

        //authService.loginConfirmed({}, responseObj.accesstoken);

        if (cb) {
            if (apiData) {
                cb(apiData);
            } else {
                cb(user.accesstoken);
            }
        }

        rootScope.updateAccessToken();

        GmCXt.showWidget();

        rootScope.updateLabels();
    } else {
        GmCXt.log(1, "ERROR: failed to get a new accesstoken");
    }
};

rootScope.getAccessTokenFromRefreshToken = function(cb, apiData) {
    function successCb(responseObj) {
        rootScope.updateAccessTokenCallBack(responseObj, cb, apiData);
    }
    api.getAccessToken(successCb);
};

rootScope.getAllSegments = function(isUpdate) {
    return new Promise(function(resolve, reject) {
        if (isUpdate) {
            rootScope.getSegmentGroupList().then(function(data) {
                resolve(data);
            });
        } else {
            GmCXt.getFromStorage('segmentGroupData').then(function(res) {
                let expiryTime = res.time + GmCXt.t.syncSegment;
                if (Date.now() < expiryTime) {
                    rootScope.allSegments = res.list;
                    rootScope.syncSegmentData();
                } else {
                    rootScope.allSegments = [];
                }
                if (rootScope.allSegments.length) {
                    resolve(rootScope.allSegments);
                } else {
                    rootScope.getSegmentGroupList().then(function(data) {
                        resolve(data);
                    });
                }
            });
        }
    });
};

rootScope.resetCreatorData = function(clearStorage) {
    rootScope.allCategories = {};
    if (!GmCXt.inPlayer) {
        rootScope.categoryStore = [];
    }

    rootScope.subCategoryStore = {};

    rootScope.allTourList = {};

    if (clearStorage) {
        if (!GmCXt.inPlayer) {
            GmCXt.removeFromDapStorage('categories');
        }

        rootScope.serverUpdates = {};
        rootScope.serverDeletes = {
            categories: [],
            tours: []
        };
        GmCXt.removeFromDapStorage('allTourList');
        GmCXt.removeFromDapStorage('serverUpdates');
        GmCXt.removeFromDapStorage('serverDeletes');
    }
};

rootScope.resetCreatorData();

rootScope.cancelAutomationSelection = function() {
    rootScope.automationSelectionMode = false;
    rootScope.myGuidesFilter = true;
    rootScope.categoryDataForAutomation = [];
};

function resetData() {
    rootScope.contextTours = {};

    rootScope.applicationDropdown = false;
    rootScope.automationDropdown = false;

    if (GmCXt.FT.creatorApp) {
        GmCXt.removeFromStorage("segmentData");
        rootScope.segmentData = [];
    }

    rootScope.resetCreatorData(true);

    rootScope.allTourList = {};
    GmCXt.saveToDapStorage('allTourList', rootScope.allTourList);

    rootScope.cancelAutomationSelection();

    GmCXt.storage().remove(['insightPageRulesData']);

    if (GmCXt.trackerUtil.pageTracking) {
        GmCXt.getInsightPageRules();
    }
}

function redirectToView() {
    let user = GmCXt.user;
    let org = GmCXt.organization;
    if (user && org.organization_id) {
        rootScope.fetchApps().then(function() {
            rootScope.sendSidePanelInitEvent(true);
        });
    }
}

function onRefreshSettings(org) {
    rootScope.saveOrganization(org);

    rootScope.refreshTime = GmCXt.getCurrentTimeInSec();
    GmCXt.saveToStorage('refreshTime', rootScope.refreshTime);

    if (rootScope.guideSegmentation) {
        Gm.loading.set(true);

        if (GmCXt.conf.appConfig.customer !== "westpac") {
            rootScope.getAllSegments().then(function() {
                redirectToView();
            });
        } else {
            redirectToView();
        }
    } else {
        redirectToView();
    }
}

function gotAccessToken() {
    if (GmCXt.inPlayer) {
        rootScope.loadJsonPlayer().then(function() {
            //rootScope.goToView();

            rootScope.sendSidePanelInitEvent(true);
        });
    } else {
        api.getOrganization(onRefreshSettings, true);
    }
}

rootScope.processActiveRequests = function() {
    if (!rootScope.maintenance) {
        GmCXt.processActiveReq();
    }
};

rootScope.getOnPremOrg = function(forceMode) {
    return new Promise(function(resolve, reject) {
        let org = GmCXt.organization;

        function processOrg(org) {
            rootScope.saveOrgSettings(org.settings);
            rootScope.enableOrgFeatures(org);
            getCurrentAppObj().then(function() {
                rootScope.sendSidePanelInitEvent();
                resolve();
            });
        }

        if (!GmCXt.isEmpty(org) && !forceMode) {
            processOrg(org);
        } else {
            api.getOrgJson().then(function(r) {
                GmCXt.getJsonTimeStamp(GmCXt.getOnPremJsonURL()).then(function(r) {
                    rootScope.refreshTime = r.last_updated_time;
                    GmCXt.saveToStorage('refreshTime', rootScope.refreshTime);
                });
                Gm.loading.set(false);

                let org = r.data;
                let apps = org.applications;

                org = GmCXt.validateDataModel(org, GmCXt.model.organization);
                rootScope.saveOrganization(GmCXt.organization);
                apps = GmCXt.validateModelArray(apps, GmCXt.model.applications._obj);
                rootScope.saveApps(apps);
                processOrg(org);
            });
        }
    });
};

function initOnPremPlayer(forceMode) {
    GmCXt.log(21, "LOADED side panel. Initialising On Prem Player");
    rootScope.getOnPremOrg(forceMode).then(function() {
    //rootScope.goToCurrentPage();
        rootScope.processActiveRequests();
    });
}

rootScope.refreshAllData = function(doNotGetAccessToken) {
    GmCXt.log(21, "REFRESH event");
    Gm.loading.set(true);

    rootScope.isRefresh = true;

    rootScope.taskList = [];
    GmCXt.removeFromDapStorage('taskList');
    GmCXt.removeFromDapStorage('languageList');
    GmCXt.removeFromStorage('segmentGroupData');
    rootScope.allSegments = [];
    rootScope.syncSegmentData();
    resetData();

    if (GmCXt.onPrem()) {
        initOnPremPlayer(true);
    } else if (doNotGetAccessToken) {
        gotAccessToken();
    } else {
        rootScope.getAccessTokenFromRefreshToken(gotAccessToken);
    }
    Gm.loading.set(false);
};

rootScope.showLogoutBtn = function() {
    let user = GmCXt.user;
    if (
        GmCXt.isEmpty(user) ||
    GmCXt.isLXP() ||
    GmCXt.conf.appConfig.login.SSO
    ) {
        return false;
    } else return true;
};

rootScope.resetAppData = function() {
    GmCXt.appList = {};
    GmCXt.removeFromStorage('activeAppId');
    GmCXt.activeAppId = false;
};

function getSSOWindowOpt() {
    let retStr = "width=350,height=300,";
    retStr += "top=" + (screen.width - 100) + ",";
    retStr += "left=" + (screen.height - 100);
    return retStr;
}

function getSsoIdUrl(url) {
    if (GmCXt.isEmpty(rootScope.myGuideOrgKey) && (GmCXt.myGuideInternalCustomers() || GmCXt.isMcKesson())) {
        return url + "" + rootScope.ssoId;
    } else {
        return url;
    }
}

rootScope.triggerSsoInterval = function() {
    clearInterval(rootScope.ssoLoginCheck);

    rootScope.ssoLoginCheck = setInterval(function() {
        if (!rootScope.ssoSuccess && rootScope.ssoHitCount < 30) {
            rootScope.ssoHitCount++;
            rootScope.signInWithSso();
        } else {
            rootScope.clearSsoInterval();
        }
    }, 2000);
};

rootScope.getSsoUserInfo = function() {
    if (rootScope.ssoHitCount < 30) {
        rootScope.ssoHitCount++;
        setTimeout(function() {
            rootScope.signInWithSso();
        }, 2000);
    }
};

rootScope.openSsoTab = function(fiveMinuteCheck, lastSsoRedirectTime, triggerSsoAfterFiveMins) {
    if (GmCXt.isEmpty(rootScope.ssoId) && !rootScope.appConfig.login.SSO) {
        return;
    }

    let currentTime = new Date().getTime();
    if (!triggerSsoAfterFiveMins && !fiveMinuteCheck) {
        GmCXt.saveToStorage('lastSsoRedirectTime', currentTime);
        GmCXt.saveToStorage('triggerSsoAfterFiveMins', false);
    } else if (!lastSsoRedirectTime || currentTime > lastSsoRedirectTime + GmCXt.t.openSso) {
        GmCXt.saveToStorage('lastSsoRedirectTime', currentTime);
    }

    let ssoOptions = getSSOWindowOpt();
    rootScope.ssoTab = window.open(getSsoIdUrl(rootScope.ssoRedirectionUrl), "", ssoOptions);
    rootScope.getSsoUserInfo();
};

function closeTabForSso() {
    if (rootScope.ssoTab) rootScope.ssoTab.close();
}

rootScope.clearSsoInterval = function() {
    clearInterval(rootScope.ssoLoginCheck);
    closeTabForSso();
    rootScope.ssoLoginCheck = "";
};

rootScope.getUserInfoWithSSO = function() {
    return new Promise(async (resolve, reject) => {
        try {
            const currHost = GmCXt.trimAndLowerCaseURL(GmCXt.urlParts.host);
            const url = getSsoIdUrl(rootScope.ssoApiUrl);

            // Fetch request
            const response = await fetch(url, {
                method: 'GET',
                credentials: 'include', // Equivalent to xhrFields: { withCredentials: true }
                headers: {
                    'x-mg-host': currHost,
                    'x-mg-source': GmCXt.conf.appName,
                    'x-mg-orgId': '', // Empty org ID
                    'Content-Type': 'application/json',
                }
            });

            // Check if response is not ok (e.g., 400 or 500 errors)
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }

            const jsonData = await response.json();
            const parsedData = GmCXt.parseJSON(jsonData);

            resolve(parsedData);
        } catch (error) {
            console.error("Error fetching SSO info:", error);
            reject(error);
        }
    });
};

rootScope.getSsoId = function() {
    return new Promise(async (resolve, reject) => {
        try {
            const currHost = GmCXt.trimAndLowerCaseURL(GmCXt.urlParts.host);
            const url = `${GmCXt.conf.ssoConfigUrl}${GmCXt.getMd5(currHost)}.json`;

            const response = await fetch(url, {
                method: "GET",
                credentials: 'omit', // 'omit' means not sending cookies
                headers: {
                    'Content-Type': 'application/json',
                }
            });

            if (!response.ok) {
                reject(new Error('Network response was not ok'));
                return;
            }

            const jsonResponse = await response.json();
            const parsedResponse = GmCXt.parseJSON(jsonResponse);
            rootScope.ssoId = parsedResponse.id;

            resolve(parsedResponse);
        } catch (error) {
            console.error("Error fetching SSO ID:", error);
            reject(error);
        }
    });
};

rootScope.shouldOpenSsoTab = function() {
    let currentTime = new Date().getTime();
    return new Promise(function(resolve) {

        GmCXt.getFromStorage('lastSsoRedirectTime').then(function(lastChecked) {

            GmCXt.getFromStorage('triggerSsoAfterFiveMins').then(function(fiveMinutesChecked) {

                let oneHourPassed = currentTime > lastChecked + GmCXt.t.openSso;

                let fiveMinsPassed = !fiveMinutesChecked && lastChecked && currentTime > lastChecked + GmCXt.t.openSsoAfterFiveMin;

                if (fiveMinsPassed) {
                    GmCXt.saveToStorage('triggerSsoAfterFiveMins', true);
                    GmCXt.saveToStorage('lastSsoRedirectTime', currentTime);
                }

                resolve({
                    flag: !lastChecked || oneHourPassed || (!fiveMinutesChecked && fiveMinsPassed),
                    fiveMinuteCheck: fiveMinsPassed,
                    lastSsoRedirectTime: lastChecked,
                    triggerSsoAfterFiveMins: fiveMinutesChecked
                });
            });
        });

    });
};

rootScope.goToMaintenance = function() {
    Gm.loading.set(false);
    rootScope.maintenance = true;
    rootScope.chatBot = false;

    GmCXt.redirect("#/maintenance");
};

rootScope.signInWithSso = function(forceSSO) {
    function retrySso() {
        let user = GmCXt.user;

        if (!GmCXt.isEmpty(user)) {
            closeTabForSso();
            return;
        }

        rootScope.shouldOpenSsoTab().then(function({
            flag,
            fiveMinuteCheck,
            lastSsoRedirectTime,
            triggerSsoAfterFiveMins
        }) {

            if (flag) {
                rootScope.openSsoTab(fiveMinuteCheck, lastSsoRedirectTime, triggerSsoAfterFiveMins);
            } else {
                rootScope.getSsoUserInfo();
            }
        });
    }

    function getSsoUser() {
        rootScope.getUserInfoWithSSO().then(gotUser)
            .catch(function(err) {
                retrySso();
            });
    }

    function gotUser(r) {
        if (r.error === false) {
            closeTabForSso();
            rootScope.onUserSignin(r.data.user, true, true);
        } else if (r.code === 1001) {
            retrySso();
        } else if (r.code === 1002) {
            // User not available
            closeTabForSso();
            GmCXt.hideWidgetIcon();
        } else if (r.code === 1014) {
            closeTabForSso();
            rootScope.goToMaintenance();
        }
    }

    let shouldFetchSSO = GmCXt.isEmpty(rootScope.myGuideOrgKey) && GmCXt.myGuideInternalCustomers();

    if (shouldFetchSSO || forceSSO) {
        rootScope.getSsoId().then(function(response) {
            if (response && response.id) {
                getSsoUser();
            }
        }).catch(function() {
            GmCXt.log(1, "ERROR: failed to get SSO Id");
            rootScope.clearSession();
        });
    } else {
        getSsoUser();
    }
};

rootScope.goToLogin = function() {
    Gm.activeView.set("signin");
};

rootScope.showPopup = function(label, cb, type, infoMsg) {
    if (!type) {
        type = "info";
    }
    Gm.loading.set(false);
    modal.close();
    modal.open(label, type, cb, false, infoMsg);
};

rootScope.sortTourSteps = function(sortedSteps, originalSteps) {
    let finalSteps = [];
    sortedSteps.forEach(function(sortedStep) {
        for (let i = 0; i < originalSteps.length; i++) {

            if (sortedStep.step_id === originalSteps[i].step_id) {
                originalSteps[i].step_order = sortedStep.step_order.toString();
                finalSteps.push(originalSteps[i]);
            }
        }
    });
    return finalSteps;
};

rootScope.sortDataByActiveFilter = function(array, key, sortOrder) {
    if (GmCXt.isEmpty(array)) {
        return [];
    }

    if (!array.length) {
        return [];
    }

    if (!sortOrder && get_store_value(Gm.CurrentPage) !== "currentpage") {
        return array.sort((a, b) => {
            if (key === "category_title") {
                return a.category_order - b.category_order;
            } else {
                return a.tour_order - b.tour_order;
            }
        });
    }

    if (key && (sortOrder === "atoz" || sortOrder === "ztoa")) {
        if (sortOrder === "atoz") {
            return array.sort((a, b) =>
                a[key].toLowerCase() > b[key].toLowerCase() ? 1 : -1
            );
        } else if (sortOrder === "ztoa") {
            return array.sort((a, b) =>
                b[key].toLowerCase() > a[key].toLowerCase() ? 1 : -1
            );
        } else {
            // Handle invalid sortOrder
            return array;
        }
    } else {
        return array.sort((a, b) => {
            if (sortOrder === "older") {
                return a.modification_date - b.modification_date;
            } else {
                return b.modification_date - a.modification_date;
            }
        });
    }
};

rootScope.isBotTourPlayed = function(tour) {
    let isBotTourExist = false;

    for (let i = 0; i < rootScope.botTourPlayList.length; i++) {
        if (rootScope.botTourPlayList[i].tour_id === tour.tour_id) {
            isBotTourExist = true;
            break;
        }
    }
    return isBotTourExist;
};

rootScope.filterBotGuides = function(tours) {
    tours = tours.filter(function(tour) {
        if (GmCXt.isBotGuide(tour)) {
            return tour;
        } else if (rootScope.botTourPlayList && rootScope.botTourPlayList.length) {
            if (tour.tour_settings.enableBot && !rootScope.isBotTourPlayed(tour)) {
                return tour;
            }
        } else {
            if (tour.tour_settings.enableBot) return tour;
        }
    });
    return tours;
};

rootScope.setPlayedStepsInfo = function(step) {
    rootScope.playedSteps = rootScope.playedSteps ? rootScope.playedSteps : [];

    if (GmCXt.isValueInArray(rootScope.playedSteps, "tId", step.tour_id)) {
        for (let i = 0; i < rootScope.playedSteps.length; i++) {
            if (rootScope.playedSteps[i].tId === step.tour_id) {
                rootScope.playedSteps[i].lastStepid = step.step_id;
                break;
            }
        }
    } else {
        rootScope.playedSteps.push({
            tId: step.tour_id,
            lastStepid: step.step_id,
        });
    }

    GmCXt.saveToStorage("stepsPlayed", rootScope.playedSteps);

    let params = {
        playedSteps: rootScope.playedSteps,
    };

    let user = GmCXt.user;

    if (user && user.settings) {
        user.settings.guide_view = params;
        rootScope.saveUser(user);
    }

    GmCXt.apiUpdateUserGuidevView(params);
};

rootScope.getPlayedStepCount = function(tour) {
    let lastStep = "";

    if (rootScope.playedSteps) {
        for (let i = 0; i < rootScope.playedSteps.length; i++) {
            if (rootScope.playedSteps[i].tId === tour.tour_id) {
                lastStep = rootScope.playedSteps[i].lastStepid;
                break;
            }
        }
    }

    return GmCXt.getStepPosFromPs(tour, lastStep);
};

rootScope.hideMirrorAppCtrl = function() {
    let hide = false;
    if (
        GmCXt.isMirrorApp() &&
    !GmCXt.isEmpty(GmCXt.appList) &&
    GmCXt.activeAppId
    ) {
        let cApp = GmCXt.appList["app:" + GmCXt.activeAppId];
        if (cApp && cApp.base_app_id && parseInt(cApp.base_app_id) !== 0) {
            hide = true;
        }
    }
    return hide;
};

rootScope.triggerError = function(d) {
    mgError.on({
        code: d.code,
        url: d.url,
        params: d.params,
        method_type: d.method_type,
        message: d.errMessage,
    });
};

rootScope.loginFromConsole = function(data) {
    let Userdata = {
        email_id: data.email,
        password: data.password,
        keep_login: 1,
    };

    let onFail = function() {
        rootScope.clearSession();
    };
    let onSuccess = function(_user) {
        rootScope.onUserSignin(_user, data.sso);
    };

    api.userSignIn(Userdata, onSuccess, onFail);
};

rootScope.updateCategoryInStorgae = function(cat, remove, appId) {
    // Log the category update operation
    GmCXt.log(70, "UPDATE CATEGORY IN STORAGE: " + GmCXt.categoryLog(cat));

    // Use provided appId or default to active app
    appId = appId || GmCXt.activeAppId;

    // Exit if no valid appId is available
    if (!appId) return;

    // Get the categories for the specified app
    let parentCats = GmCXt.appList["app:" + appId].categories;

    //find index of cat in app
    let indexOfCat;

    // Flag to track if the category was found
    let catFound = false;

    // Check if this is a top-level category (parent_id is 0)
    if (parentCats.length && !parseInt(cat.parent_id)) {
    // Search for the category in the parent categories
        for (let i = 0; i < parentCats.length; i++) {
            if (parentCats[i].category_id === cat.category_id) {
                indexOfCat = i;
                break;
            }
        }
    } else if (!parentCats.length) {
    // Initialize categories array if it doesn't exist
        GmCXt.appList["app:" + appId].categories = [];
    }

    // Get the updated categories reference
    let cats = GmCXt.appList["app:" + appId].categories;

    // Handle top-level category updates
    if (indexOfCat >= 0) {
    //category found in Parent categories

        GmCXt.log(
            70,
            "UPDATE CATEGORY IN STORAGE: category FOUND" + GmCXt.categoryLog(cat)
        );

        catFound = true;

        if (remove) {
            // Remove the category if requested
            GmCXt.appList["app:" + appId].categories.splice(indexOfCat, 1);
            GmCXt.log(70, "UPDATE CATEGORY IN STORAGE: category REMOVED" + GmCXt.categoryLog(cat));
        } else {
            // Preserve existing tours if needed
            let catTours = GmCXt.appList["app:" + appId].categories[indexOfCat].tours;

            if (catTours && !cat.tours && cat.has_tour) {
                GmCXt.log(70, "UPDATE CATEGORY IN STORAGE: keep category tours" + GmCXt.categoryLog(cat));
                cat.tours = catTours;
            } else {
                // Preserve existing subcategories if needed
                let sc = GmCXt.appList["app:" + appId].categories[indexOfCat].categories;

                if (sc && cat.has_child && !cat.categories) {
                    GmCXt.log(70, "UPDATE CATEGORY IN STORAGE: keep category subcats" + GmCXt.categoryLog(cat));
                    cat.categories = sc;
                }
            }

            // Replace the old category with the updated one
            GmCXt.appList["app:" + appId].categories.splice(indexOfCat, 1, cat);

            GmCXt.log(70, "UPDATE CATEGORY IN STORAGE: category UPDATED" + GmCXt.categoryLog(cat));
        }
    } else if (parseInt(cat.parent_id)) {
    // Handle subcategory updates
        for (let i = 0; i < cats.length; i++) {
            let subcat;
            let parentCat;

            // Check if this category is the parent
            if (parseInt(cats[i].category_id) === parseInt(cat.parent_id)) {
                parentCat = cats[i];
            }

            // Look for subcategories
            if (cats[i].sub_categories) {
                if (!parentCat) {
                    // Try to find parent in subcategories
                    parentCat = getSubCat(cats[i].sub_categories, cat.parent_id);
                }

                if (parentCat && parentCat.sub_categories) {
                    // Try to find the subcategory itself
                    subcat = getSubCat(cats[i].sub_categories, cat.category_id);
                }
            }

            // If parent found but subcategory not found, add it
            if (parentCat && !subcat) {
                parentCat.sub_categories = parentCat.sub_categories || [];
                parentCat.sub_categories.push(cat);
            }

            // If subcategory found, update it
            if (subcat) {
                GmCXt.log(70, "UPDATE TOURS in STORGAE: sub category found. " + cat.category_id);
                catFound = true;

                if (remove) ; else if (subcat.has_tour && subcat.tours) {
                    // Preserve existing tours
                    var st = GmCXt.createDeepCopy(subcat.tours);
                    cat.tours = st;

                    subcat = cat;
                } else if (subcat.has_child && subcat.categories) {
                    // Preserve existing child categories
                    var st = GmCXt.createDeepCopy(subcat.categories);
                    cat.categories = st;

                    subcat = cat;
                }

                break;
            }
        }
    }

    // If category not found and not removing, add it as a top-level category
    if (!catFound && !remove && parseInt(cat.parent_id) === 0) {
        GmCXt.appList["app:" + appId].categories.push(cat);

        GmCXt.log(70, "UPDATE CATEGORY IN STORAGE: category ADD" + GmCXt.categoryLog(cat));
    }

    // Save changes to storage
    rootScope.syncApps(GmCXt.appList);
    GmCXt.saveToDapStorage('appData', GmCXt.appList);

    // Decrement sync counter
    rootScope.playerSyncCount--;
};

rootScope.updateCategory = function(cat, prop, val, updateTime) {
    let cid = "cat_" + cat.category_id;
    let categories = rootScope.allCategories;

    if (!GmCXt.isEmpty(categories) && categories[cid]) {
        categories[cid][prop] = val;

        if (updateTime) {
            categories[cid].modification_date = GmCXt.getCurrentTimeInSec();
        }

        if (!GmCXt.inPlayer) {
            rootScope.allCategories = categories;
            GmCXt.saveToDapStorage('categories', rootScope.categories);
        }
    } else {
        cat[prop] = val;
        if (updateTime) {
            cat.modification_date = GmCXt.getCurrentTimeInSec();
        }
        rootScope.addCategory(cat);
    }

    updateCatList(cat, parseInt(cat.parent_id));
};

rootScope.updateEnvNames = function(envName) {
    if (envName === "qa") {
        return rootScope.labels.qa;
    } else if (envName === "stage") {
        return rootScope.labels.stage;
    } else if (envName === "prod") {
        return rootScope.labels.production;
    } else {
        let currentApp = GmCXt.appList['app:' + GmCXt.activeAppId];
        if (currentApp && currentApp.settings && currentApp.settings.app_env &&
      currentApp.settings.app_env[envName]) {
            return currentApp.settings.app_env[envName].name;
        }
    }
};

rootScope.removeTour = function(catId, tourId, appId) {
    if (!appId) {
        if (rootScope.allTourList["cat_" + catId]["tour_" + tourId]) {
            delete rootScope.allTourList["cat_" + catId]["tour_" + tourId];
        } else {
            return;
        }
    }

    if (GmCXt.inPlayer) {
        rootScope.updateTourToStorage(true, {
            tour_id: tourId,
            category_id: catId,
            application_id: appId,
        },
        true,
        appId
        );
    }

    if (appId) return;

    GmCXt.saveToDapStorage('allTourList', rootScope.allTourList);

    let cat = rootScope.getCategory(catId);

    if (cat && GmCXt.FT.creatorApp) {
        let totalTours = parseInt(cat.total_unpublish_tour);
        totalTours--;
        totalTours = totalTours >= 0 ? totalTours : 0;

        rootScope.updateCategory(
            cat,
            "total_unpublish_tour",
            totalTours.toString()
        );

        if (
            parseInt(cat.total_unpublish_tour) === 0 &&
      parseInt(cat.total_publish_tour) === 0
        ) {
            rootScope.updateCategory(cat, "has_tour", false);
        }
    }
};

rootScope.fetchToursForCategory = function(categoryId, cb, forceApi, appId) {
    let options = {
        limit: 100,
        offset: 0,
        category_id: categoryId,
        organization_id: GmCXt.organization.organization_id,
    };

    if (forceApi) {
        options.published_guides = "1";
    }

    api.getTourList(
        options,
        function(result) {
            cb(result);
        },
        appId
    );
};

rootScope.updateToursInCategoryStorage = function(catId, tours, remove, aId) {
    GmCXt.log(70, "UPDATE TOURS in STORAGE: ", tours);

    if (!aId && !rootScope.getCategory(catId)) {
        GmCXt.log(70, "UPDATE TOURS in STORGAE: category not found. " + catId);
        return;
    }

    let appId = aId || GmCXt.activeAppId;

    let cat = GmCXt.appList["app:" + appId].categories.filter(function(c) {
        return c.category_id === catId;
    })[0];

    if (!cat) {
        let cats = GmCXt.appList["app:" + appId].categories;
        for (let i = 0; i < cats.length; i++) {
            if (cats[i].sub_categories) {
                cat = getSubCat(cats[i].sub_categories, catId);
            }
            if (cat) {
                GmCXt.log(70, "UPDATE TOURS in STORGAE: sub category found. " + catId);
                break;
            }
        }
    } else {
        GmCXt.log(70, "UPDATE TOURS in STORGAE: category found. " + catId);
    }

    if (remove) {
        GmCXt.log(70, "UPDATE TOURS in STORGAE: REMOVED " + catId);
        cat.tours = [];
    } else {
        GmCXt.log(70, "UPDATE TOURS in STORGAE: UPDATED " + catId);
        cat.tours = tours;
    }

    tours.forEach(function(t) {
        rootScope.updateGuideInPublishedTour(t, remove);
    });

    rootScope.syncApps(GmCXt.appList);
    GmCXt.saveToDapStorage('appData', GmCXt.appList);
};

rootScope.processAppData = function(app) {
    let categories = {},
        tours = {};

    GmCXt.log(21, "PROCESS NON ACTIVE app data", app);

    const processTour = function(newTours, t) {
        newTours.forEach(function(nt) {
            t["tour_" + nt.tour_id] = nt;
        });

        return t;
    };

    const processAppCategory = function(c) {
        categories["cat_" + c.category_id] = c;

        if (c.sub_categories && c.sub_categories.length > 0) {
            mg$.each(c.sub_categories, function(index, subCat) {
                processAppCategory(subCat);
            });
        } else if (c.tours && c.tours.length > 0) {
            tours = processTour(c.tours, tours);
        }
    };

    if (app.categories && app.categories.length > 0) {
        app.categories.forEach(function(cat) {
            processAppCategory(cat);
        });
    }

    return {
        categories: categories,
        tours: tours,
    };
};

rootScope.getBasePath = function(i) {
    let url = "";
    if (GmCXt.isExtension()) {
        url = GmCXt.getBrowserUrl(i);
    } else {
        if (GmCXt.isDefined(GmCXt.conf.baseUrl)) {
            url = GmCXt.conf.baseUrl + i;
        } else {
            url = GmCXt.conf.clientJsBaseUrl + i;
        }
    }

    return url;
};

rootScope.getImageURL = function(url, imgStyle, ignoreCdn) {
    if (url) {
        let imgURL = url.split(".png")[0] + imgStyle;
        if (ignoreCdn) {
            return imgURL;
        } else {
            return GmCXt.restoreAssetSrc(imgURL);
        }
    }
};

rootScope.getApiLimit = function(length) {
    let l = Math.ceil(length / 50) || 1;
    return l * 50;
};

rootScope.isAppAdmin = function() {
    if (rootScope.user.role === "app_admin") {
        return true;
    } else {
        return false;
    }
};

rootScope.isOwnerOrAppAdmin = function() {
    if (rootScope.isOwner() || rootScope.isAppAdmin()) {
        return true;
    } else {
        return false;
    }
};

rootScope.hasCreatorAccess = function() {
    let role = rootScope.user.role;

    if (
        GmCXt.FT.creatorApp &&
    (role === "creator" || role === "app_admin" || rootScope.isOwner())
    ) {
        return true;
    } else return false;
};

rootScope.clearSearchInput = function() {
    mg$("#mgPlayerJSTest_search-text-input").val("");
    rootScope.searchKeyword = "";
};

rootScope.redirectBackToCat = function(cat) {
    let data;
    if (cat.has_tour) {
        data = {
            data: cat
        };
        Gm.isTourListRefresh.set(data);
    } else if (!cat.has_tour) {
        Gm.routeAction.set({
            action: "cat_import_compleated",
            data: {
                catId: cat.category_id
            }
        });
    }
    data = {
        detail: {
            parent: cat,
            hasTour: cat.has_tour,
            hasChild: cat.has_child,
            initiator: "goback"
        }
    };
    Gm.routeAction.set({
        action: "forwardTraversal",
        data: data
    });
};

rootScope.goToLevel = function(category, forceRefresh) {
    rootScope.clearSearchInput();

    Gm.loading.set(true);
    let c = rootScope.getCategory(category.category_id);

    let redirect = function(cat) {
        let breadCrumb = [];
        Gm.breadCrumb.set(breadCrumb);
        while (cat.parent_id) {
            let newCat = GmCXt.createDeepCopy(cat);
            breadCrumb.unshift(newCat);
            cat = rootScope.getCategory(cat.parent_id);
        }
        breadCrumb.unshift("All Guides");

        Gm.breadCrumb.set(breadCrumb);
        rootScope.setActivePage('home');
        rootScope.setCurrentPage('allguides');
        //rootScope.setActivePage('home');

        if (!GmCXt.isEmpty(breadCrumb) && breadCrumb.length > 1) {
            rootScope.redirectBackToCat(breadCrumb[breadCrumb.length - 1]);
        }

    };

    if (!c || forceRefresh) {
        ({
            category_id: category.category_id,
        });

        rootScope.getCategoryApi(category.category_id, function(cat) {
            redirect(cat);
        }, true);
    } else {
        redirect(c);
    }
};

rootScope.filterDefaultGuides = function(tours) {
    tours = tours.filter(function(tour) {
        if (window.matchMedia("(max-width: 480px)").matches && !GmCXt.isMiniPlayer) {
            if (rootScope.isDesktopGuide(tour)) return tour;
        } else {
            if (rootScope.isDefaultGuide(tour) || rootScope.isDesktopGuide(tour))
                return tour;
        }
    });
    return tours;
};

rootScope.getCategoryListApi = function(params, cb) {
    if (rootScope.language && !GmCXt.isFalse(rootScope.language))
        params.language = rootScope.language;

    if (GmCXt.getLXPLang()) params.language = GmCXt.getLXPLang();

    if (rootScope.isUserLoggedIn() || GmCXt.onPrem()) {
        api.getCategoryList(params, cb);
    }
};

rootScope.dispatchEvent = function(event) {
    document.dispatchEvent(event);
};

rootScope.isUserRole = function() {
    if (rootScope.user.role === "user") {
        return true;
    } else {
        return false;
    }
};

rootScope.isAnnouncement = function(t) {
    if (t && t.tour_settings && GmCXt.isOnboarding(t) && t.tour_settings.tutorial_tour_type &&
    t.tour_settings.tutorial_tour_type === "announcement") {
        return true;
    } else {
        return false;
    }
};

rootScope.hasTourAccess = function(t) {
    if ((t && !t.is_locked) || (t && rootScope.lockedByUser(t))) return true;
    else return false;
};

rootScope.isLocked = function(t) {
    if (t.is_locked && t.user_id !== rootScope.user.user_id) return true;
    else return false;
};

rootScope.lockedByUser = function(t) {
    if (t && t.is_locked && t.user_id === rootScope.user.user_id)
        return true;
    else
        return false;
};

rootScope.getNode = function(id, playstructure) {
    let PS = playstructure;

    for (let i = 0; i < PS.length; i++) {
        if (PS[i].id === id) {
            return PS[i];
        }
    }
};

rootScope.focusAccessibilityBtn = function() {
    GmCXt.timeout(function() {
        if (GmCXt.APP_PANEL_OPEN) {
            if (mg$(".mgPlayerJSTest_accessibility-btn-wrapper button.mgPlayerJSTest_custom-slider") &&
        mg$(".mgPlayerJSTest_accessibility-btn-wrapper button.mgPlayerJSTest_custom-slider").length) {
                mg$(".mgPlayerJSTest_accessibility-btn-wrapper button.mgPlayerJSTest_custom-slider")[0].focus();
            }
        }
    }, 500);
};

rootScope.routeToStepContainer = function(action, data) {
    Gm.routeAction.set({
        action: action,
        data
    });
    if (get_store_value(Gm.CurrentPage) !== "stepview") {
        rootScope.setCurrentPage("stepview");
    }
};

rootScope.getDefaultSurveyStepIcon = function() {
    return GmCXt.conf.staticContentPath + 'survey_step.png';
};

rootScope.getAutomationSteps = function(steps, currentStep) {
    let automationSteps = [];
    let i = 0;
    if (currentStep) {
        i = parseInt(currentStep.step_order);
    }

    // Check if next step exist. Note - StepOrder start from "1"
    if (steps[i]) {
        while (GmCXt.isAutomationStep(steps[i])) {
            automationSteps.push(steps[i]);
            i++;
        }
    }
    return automationSteps;
};

// Get user list
rootScope.getUserList = function(cb) {
    let param = {
        limit: 100,
        offset: 0,
        owner_creator_filter: 1
    };

    function userListcb(response) {
        let userList = response.data.users;
        rootScope.userList = userList;
        GmCXt.saveToStorage('userList', userList);
        cb(userList);
    }

    GmCXt.getFromStorage('userList').then(function(ulist) {
        if (GmCXt.isEmpty(ulist)) {
            api.getUserList(param, userListcb);
        } else {
            rootScope.userList = ulist;
            cb(ulist);
        }
    });
};

rootScope.checkKeywordLimit = function(tags, e) {
    if (tags.length > 24) {
        GmCXt.toastMsg(rootScope.labels.keywordLimit).show();
        e.preventDefault();
        return (tags.length === 0);
    }
};

rootScope.setCurrentPage = function(newView) {

    // Force a store update by resetting the value
    Gm.CurrentPage.update((currentView) => currentView === newView ? "" : newView); // If value is "home", set it to "" first, then reset to "home"

    // Set the value again after forcing the update
    Gm.CurrentPage.set(newView);
};

rootScope.setActivePage = function(newView) {

    Gm.activeView.update((currentView) => currentView === newView ? "" : newView); // If value is "home", set it to "" first, then reset to "home"

    // Set the value again after forcing the update
    Gm.activeView.set(newView);
};

rootScope.goToActiveView = function() {
    let activeView = get_store_value(Gm.activeView);

    if (activeView !== "home" && activeView != "signin") {
        Gm.activeView.set("home");
    }
};

rootScope.redirectToActiveview = function() {
    rootScope.checkCdnSignature().then(function() {

        if (GmCXt.isPlayer()) {
            getCurrentAppObj().then(function(app) {
                if (!GmCXt.isEmpty(app)) {
                    rootScope.goToActiveView();
                }
            });
        } else {
            rootScope.goToActiveView();
        }
    });
};

rootScope.getTourSteps = function(t, cb) {
    function onGetTourSuccess(data) {
        cb(data);
        Gm.loading.set(false);
    }

    if (rootScope.isAnnouncement(t) && parseInt(t.step_count) !== 0 && GmCXt.isEmpty(t.steps)) {
        let params = {
            tour_id: t.tour_id,
            category_id: t.category_id
        };

        let lang;
        Gm.loading.set(true);
        if (rootScope.enableTranslation) {
            if (GmCXt.getLXPLang()) {
                lang = GmCXt.getLXPLang();
            } else if (rootScope.language) {
                lang = rootScope.language;
            }
        }

        if (!GmCXt.checkDefaultLangForTour(t, lang)) {
            params.language = lang;
        }

        api.getTour(params, onGetTourSuccess, null, true);
    } else {
        cb(t);
        Gm.loading.set(false);
    }
};


rootScope.debounce = function(fn, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            fn.apply(this, args);
        }, delay);
    };
};

rootScope.bindPlayerTheme = function() {
    let pTheme = GmCXt.getAppSetting('playerTheme');

    if (pTheme && !GmCXt.accessibility) {
        const panelFontType = pTheme?.font;
        const bodyBg = pTheme?.body?.background;
        const bodyDescFsize = pTheme?.body?.desc_font_size;
        const bodyTitleFsize = pTheme?.body?.title_font_size;
        const bodyIconColor = pTheme?.body?.icon_color;
        const bodyTextColor = pTheme?.body?.text_color;
        const headerBg = pTheme?.header?.color;
        const headerIconColor = pTheme?.header?.icon_color;
        const headerTextColor = pTheme?.header?.text_color;

        mg$(".mgPlayerJSTest_ege-panel").each(function() {
            if (bodyBg) this.style.setProperty('background', bodyBg, 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel div, .mgPlayerJSTest_ege-panel span, .mgPlayerJSTest_ege-panel button, .mgPlayerJSTest_ege-panel a, .mgPlayerJSTest_ege-panel input").each(function() {
            if (panelFontType) this.style.setProperty('font-family', panelFontType, 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-header .mgPlayerJSTest_panel-header-wrapper").each(function () {
            if (headerBg) {
                this.style.setProperty('background', headerBg, 'important');
            }

            const headerTitle = this.querySelector('.mgPlayerJSTest_theme-mplayer-header-title');
            if (headerTextColor && headerTitle) {
                headerTitle.style.setProperty('color', headerTextColor, 'important');
            }
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-header .mgPlayerJSTest_panel-header-wrapper .mgPlayerJSTest_header-icon svg path").each(function() {
            if (headerIconColor) {
                this.style.setProperty('fill', headerIconColor, 'important');
                this.style.setProperty('stroke', 'none', 'important');
            }
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-header .mgPlayerJSTest_panel-header-wrapper .mgPlayerJSTest_accessibility-btn-wrapper .mgPlayerJSTest_accessibility-btn svg path").each(function() {
            if (headerIconColor) this.style.setProperty('stroke', headerIconColor, 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-header .mgPlayerJSTest_ege-panel-header-detail-view").each(function() {
            if (bodyBg) this.style.setProperty('background', bodyBg, 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container")
            .find(".category-list, .search-list, .list-page-header .list-page-header-wrapper .mgPlayerJSTest_search-bar-container, .list-page-header .list-page-header-wrapper .mgPlayerJSTest_search-bar-container .mgPlayerJSTest_task-list-icon-container, .list-page-header .list-page-header-wrapper .all-guides-filters-tab, .list-page-header .list-page-header-wrapper .mgPlayerJSTest_library-filter-wrapper .mgPlayerJSTest_filter-tab, #mgPlayerJSTest_breadcrums-main-container, .category-list .category-list-item.active")
            .each(function() {
                if (bodyBg) {
                    this.style.setProperty('background', bodyBg, 'important');
                }
            });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .mgPlayerJSTest_chat-page-header").each(function() {
            if (bodyBg) {
                this.style.setProperty('background', bodyBg, 'important');
            }
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container .list-page-header .list-page-header-wrapper .mgPlayerJSTest_search-bar-container").each(function() {
            if (bodyBg) this.style.setProperty('top', '0', 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel .list-page-header .list-page-header-wrapper .mgPlayerJSTest_search-bar-container .mgPlayerJSTest_task-list-icon-container .mgPlayerJSTest_task-list-icon svg rect").each(function() {
            if (bodyIconColor) this.style.setProperty('fill', bodyIconColor, 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel .list-page-header .list-page-header-wrapper .mgPlayerJSTest_search-bar-container .mgPlayerJSTest_task-list-icon-container .mgPlayerJSTest_task-list-icon svg path").each(function() {
            if (bodyBg) this.style.setProperty('fill', bodyBg, 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel .list-page-header .list-page-header-wrapper .mgPlayerJSTest_search-bar-container .mgPlayerJSTest_filter-sorting-wrapper .mgPlayerJSTest_filter-sort-icon").each(function() {
            if (bodyIconColor) {
                this.querySelectorAll('svg path').forEach((path) => {
                    path.style.setProperty('fill', bodyBg, 'important');
                });

                this.querySelectorAll('svg rect').forEach((rect) => {
                    rect.style.setProperty('fill', bodyIconColor, 'important');
                });
            }
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_task-list-container .mgPlayerJSTest_task-list-icon").each(function() {
            if (bodyIconColor) {
                this.querySelectorAll('svg path').forEach((path) => {
                    path.style.setProperty('fill', bodyBg, 'important');
                });

                this.querySelectorAll('svg circle').forEach((circle) => {
                    circle.style.setProperty('fill', bodyIconColor, 'important');
                });
            }
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_task-list-container")
            .find(".mgPlayerJSTest_task-list-header .mgPlayerJSTest_task-list-go-back-container, .mgPlayerJSTest_task-list-header .mgPlayerJSTest_progress-details-container, .mgPlayerJSTest_assign-container")
            .each(function() {
                if (bodyBg) {
                    this.style.setProperty('background', bodyBg, 'important');
                }
            });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container.tour-view-page-container, .mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .category-list").each(function() {
            if (bodyBg) this.style.setProperty('background', bodyBg, 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container .tour-item .tour-title-description-wrapper .mgPlayerJSTest_guide-row-action-wrapper .mgPlayerJSTest_guide-play-action-wrapper, .mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container .tour-item .tour-title-description-wrapper .mgPlayerJSTest_guide-row-action-wrapper .mgPlayerJSTest_guide-row-download-wrapper").each(function () {
            if (bodyBg) this.style.setProperty('background', bodyBg, 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container .tour-item .tour-title-description-wrapper .mgPlayerJSTest_guide-row-action-wrapper .mgPlayerJSTest_guide-play-action-wrapper .mgPlayerJSTest_guide-action-icon-wrapper, .mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container .tour-item .tour-title-description-wrapper .mgPlayerJSTest_guide-row-action-wrapper .mgPlayerJSTest_guide-row-download-wrapper .header-detail-view-tour-download-wrapper").each(function() {
            if (bodyIconColor) {
                this.style.setProperty('background', bodyIconColor, 'important');
            }
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container .tour-item .tour-title-description-wrapper .mgPlayerJSTest_guide-row-action-wrapper .mgPlayerJSTest_guide-play-action-wrapper .mgPlayerJSTest_guide-action-icon-wrapper .mgPlayerJSTest_action-icon svg path, .mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container .tour-item .tour-title-description-wrapper .mgPlayerJSTest_guide-row-action-wrapper .mgPlayerJSTest_guide-row-download-wrapper .header-detail-view-tour-download-wrapper svg path").each(function() {
            if (bodyBg) this.style.setProperty('fill', bodyBg, 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container .tour-item .tour-title-description-wrapper .mgPlayerJSTest_guide-row-action-wrapper .mgPlayerJSTest_guide-play-action-wrapper .mgPlayerJSTest_guide-action-icon-wrapper .mgPlayerJSTest_action-icon svg circle").each(function() {
            if (bodyBg && bodyIconColor) {
                this.style.setProperty('stroke', bodyBg, 'important');
                this.style.setProperty('fill', bodyIconColor, 'important');
            }
        });

        mg$(".mgPlayerJSTest_ege-panel .category-list .tour-item .mgPlayerJSTest_guide-title-wrapper .mgPlayerJSTest_guide-title, .mgPlayerJSTest_ege-panel .category-list .category-list-item .category-list-item-wrapper .category-title-description-wrapper .category-title-wrapper").each(function () {
            if (bodyTitleFsize) {
                this.style.setProperty('font-size', bodyTitleFsize, 'important');
            }

            if (bodyTextColor) {
                this.style.setProperty('color', bodyTextColor, 'important');
            }
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-header-detail-view .header-detail-view-tour-title .mgPlayerJSTest_tour-title-wrapper .mgPlayerJSTest_tour-view-tour-title").each(function() {
            if (bodyTitleFsize) this.style.setProperty('font-size', bodyTitleFsize, 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel .category-list .tour-item .mgPlayerJSTest_guide-desc-wrapper .mgPlayerJSTest_tour-desc, .mgPlayerJSTest_ege-panel .category-list .category-list-item .category-list-item-wrapper .category-title-description-wrapper .category-description-wrapper").each(function () {
            if (bodyTextColor) {
                this.style.setProperty('color', bodyTextColor, 'important');
            }

            if (bodyDescFsize) {
                this.style.setProperty('font-size', bodyDescFsize, 'important');
            }
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container .tour-item .tour-title-description-wrapper .tour-play-action-wrapper .tour-play-icon.published-tour-icon, .mgPlayerJSTest_ege-panel .mgPlayerJSTest_task-list-container .mgPlayerJSTest_assign-container .mgPlayerJSTest_chapter-container .mgPlayerJSTest_chapter-box .mgPlayerJSTest_chapter-content-wrapper .mgPlayerJSTest_guide-play-icon-wrapper .mgPlayerJSTest_published-tour-icon, .mgPlayerJSTest_push-notification-info-wrapper .mgPlayerJSTest_notification-guide-details-wrapper .mgPlayerJSTest_notification-guide-details .mgPlayerJSTest_notification-guide-icon").each(function () {
      
            if (bodyIconColor) {
                this.querySelectorAll('svg circle').forEach(circle => {
                    circle.style.setProperty('stroke', bodyIconColor, 'important');
                    circle.style.setProperty('fill', 'transparent', 'important');
                });

                this.querySelectorAll('svg rect').forEach(rect => {
                    rect.style.setProperty('stroke', bodyIconColor, 'important');
                    rect.style.setProperty('fill', 'transparent', 'important');
                });

                this.querySelectorAll('svg path').forEach(path => {
                    path.style.setProperty('stroke', bodyIconColor, 'important');
                    path.style.setProperty('fill', bodyIconColor, 'important');
                });
            }
        });

        mg$('.mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container .tour-item .tour-title-description-wrapper .tour-play-action-wrapper .tour-play-icon .guide-beacon').each(function () {
            const beacon = mg$(this);

            beacon.find('svg circle.combined-shape').each(function() {
                this.style.setProperty('fill', '#9476c9', 'important');
                this.style.setProperty('stroke', 'none', 'important');
            });

            beacon.find('svg circle.Oval').each(function() {
                this.style.setProperty('fill', 'none', 'important');
                this.style.setProperty('stroke', '#FFFFFF', 'important');
            });
        });
    
        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container .category-list .category-list-item .category-list-item-wrapper .category-image-wrapper .mgPlayerJSTest_category-icon, .mgPlayerJSTest_ege-panel .mgPlayerJSTest_task-list-container .mgPlayerJSTest_assign-container .mgPlayerJSTest_chapter-container .mgPlayerJSTest_chapter-box .mgPlayerJSTest_category-icon").each(function () {
            if (bodyIconColor) {
                this.querySelectorAll('svg rect').forEach(rect => {
                    rect.style.setProperty('stroke', bodyIconColor, 'important');
                    rect.style.setProperty('fill', 'transparent', 'important');
                });

                this.querySelectorAll('svg path').forEach(path => {
                    path.style.setProperty('stroke', bodyIconColor, 'important');
                    path.style.setProperty('fill', bodyIconColor, 'important');
                });
            }
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container .category-list .category-list-item .category-list-item-wrapper .category-image-wrapper .category-image, .mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .tour-list-page-container .tour-item .mgPlayerJSTest_guide-upld-img-wrapper.mgPlayerJSTest_guide-pub-img-border .mgPlayerJSTest_guide-upld-img").each(function() {
            if (bodyIconColor) this.style.setProperty('border-color', bodyIconColor, 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-header-detail-view .header-detail-view-tour-title .mgPlayerJSTest_tour-title-wrapper .mgPlayerJSTest_tour-view-tour-title").each(function() {
            if (bodyTextColor) this.style.setProperty('color', bodyTextColor, 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-header-detail-view .header-detail-view-tour-download-container .header-detail-view-tour-download-wrapper").each(function() {
            if (bodyIconColor) this.style.setProperty('background', bodyIconColor, 'important');
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-header-detail-view .header-detail-view-tour-download-container .header-detail-view-tour-download-wrapper .mgPlayerJSTest_download-icon svg path").each(function() {
            if (bodyBg) {
                this.style.setProperty('fill', bodyBg, 'important');
                this.style.setProperty('stroke', bodyBg, 'important');
            }
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .guide-view-header-panel-container .guide-view-header-panel .guide-view-header-panel-icons").each(function () {
            if (bodyIconColor) {
                this.style.setProperty('background', bodyIconColor, 'important');
                this.style.setProperty('opacity', '0.6', 'important');

                this.querySelectorAll('svg path').forEach((path) => {
                    path.style.setProperty('fill', bodyBg, 'important');
                });

                this.querySelectorAll('svg circle').forEach((circle) => {
                    circle.style.setProperty('fill', bodyIconColor, 'important');
                    circle.style.setProperty('stroke', bodyBg, 'important');
                });

                this.onmouseenter = () => {
                    this.style.setProperty('opacity', '1', 'important');
                };

                this.onmouseleave = () => {
                    this.style.setProperty('opacity', '0.6', 'important');
                };
            }
        });

        mg$(".mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .guide-view-header-panel-container .guide-view-header-panel .mgPlayerJSTest_guide-play-mode-wrapper .guide-view-header-panel-icons.mgPlayerJSTest_active-play-mode").each(function () {
            if (bodyIconColor) {
                this.style.setProperty('background', bodyIconColor, 'important');
                this.style.setProperty('opacity', '1', 'important');

                const svgPath = this.querySelector('svg path');

                if (bodyBg && svgPath) {
                    svgPath.style.setProperty('fill', bodyBg, 'important');
                }

                this.onmouseenter = () => {
                    this.style.setProperty('opacity', '1', 'important');
                };

                this.onmouseleave = () => {
                    this.style.setProperty('opacity', '1', 'important');
                };
            }
        });

        mg$('.mgPlayerJSTest_ege-panel .mgPlayerJSTest_ege-panel-main-container .category-list .add-branching-container').each(function () {
            this.style.setProperty('display', 'none', 'important');
        });
    } else {
        mg$('.mgPlayerJSTest_ege-panel')[0]?.style?.removeProperty('background');
    }
};

rootScope.showBranchView = function(tour) {
    return GmCXt.containBranchStep(tour) && (!tour.isEditMode || (tour.isEditMode && tour.isBranchTour));
};

rootScope.handleStartPointFound = function(data) {
    rootScope.contTour.step = data.step;
    resumeGuide();
    const s = rootScope.contTour.step;
    GmCXt.log(33, "Start Point Found" + GmCXt.stepLog(s.step_id, s.tour_id));

    delete rootScope.startPoints;
    delete rootScope.searching_sp;
};

rootScope.handleNextStepFound = function() {
    rootScope.stepFound = true;

    const s = rootScope.contTour.step;
    GmCXt.log(33, "FOUND next step" + GmCXt.stepLog(s.step_id, s.tour_id));
    resumeGuide();

};

rootScope.handleStartPointNotFound = function() {
    if (rootScope.searching_sp < rootScope.startPoints.length - 1) {
        rootScope.searching_sp += 1;
        const data = {
            "tour_id": rootScope.contTour.tour_id,
            "startPoint": rootScope.startPoints[rootScope.searching_sp],
        };

        GmCXt.sendMessageToAllWindows('mgPlayerJSTest_action:started;task:search_start_point', data);

    } else if (rootScope.contTour.tour.steps[0].step_type !== "inline") {
        //For playing first step which is not inline in startpoint guides
        continuePlay(
            "",
            null,
            rootScope.contTour.tour,
            rootScope.contTour.source,
            rootScope.contTour.tour.category_title
        );
    }
};

/*global GmCXt,mg$*/


GmCXt.updateNotificationContentScript = function(toursClosedByUser, tourIdArray) {
    GmCXt.updNotifDataSidePanel(toursClosedByUser, tourIdArray);
};

GmCXt.closeNotificationPopupSidePanel = function(increaseSidePanel) {
    mg$('.mgPlayerJSTest_micro-player-resize').removeClass('mgPlayerJSTest_micro-player-resize');
    if (mg$(".mgPlayerJSTest_overlay-tours-popup").length) {
        GmCXt.removeNotif();
        GmCXt.showBeacons();
        GmCXt.showSmartTips();
        if (increaseSidePanel) {
            GmCXt.openSidePanelNotificaton();
        } else {
            GmCXt.openSidePanelNotificaton();
            GmCXt.handleCloseApp();
        }
    }
};

GmCXt.openSidePanelNotificaton = function() {
    GmCXt.reduceSidePanelWidth();
    mg$('.mgPlayerJSTest_ege-panel').css({
        'width': '100%',
        'transition': 'width 0s',
        'right': '0px'
    });
};

GmCXt.showNotificationHtml = function(isPageClicked, hideSidePandel) {
    GmCXt.increaseSidePanelWidth();
    mg$('.mgPlayerJSTest_micro-player-container').addClass("mgPlayerJSTest_micro-player-resize");
    if (!(GmCXt.getAppSetting('keep_player_panel_open') && !isPageClicked) || hideSidePandel || GmCXt.FT.creatorApp) {
        mg$('.mgPlayerJSTest_ege-panel').css({
            'width': '500px',
            'right': '-9550px'
        });
    }
};

GmCXt.getOverlayToursHtml = function(tour, index, isPreview) {
    let tourStr = '';
    let playClass = 'mgPlayerJSTest_push-notification-guide-info-overlay mgPlayerJSTest_single-guide-play-icon';
    let tooltipHTML = '';
    if (isPreview) {
        playClass += ' mgPlayerJSTest_forbidden';
        tooltipHTML = "<wmgPlayerJSTest_ class='mgPlayerJSTest_push-preview-tooltip'>" + rootScope.labels.notifGuidePlayWarning + "</wmgPlayerJSTest_>";
    }
    if (tour) {
        let tourTitle = tour.title || tour.tour_title;
        if (tourTitle.length > 200) {
            tourTitle = tourTitle.substr(0, 200) + " ...";
        }

        if (tour.thumbnail_url) {
            if (tour.thumbnail_url.indexOf('default_icon') >= 0) {
                GmCXt.getDefaultGuideIcon();
            } else if (tour.thumbnail_url.indexOf('default') < 0) {
                tour.thumbnail_url + GmCXt.getCdnSign();
            }
        }

        let ts = tour.tour_settings;
        let mode = ts.defaultPlayAction;

        if (mode === 'Default') {
            mode = GmCXt.getAppSetting('defaultPlayAction');
        }

        let playlabel = rootScope.labels.guideMe;

        if (mode === 'doitforme') {
            playlabel = rootScope.labels.doItForMe;
        } else if (mode === 'slideshow') {
            playlabel = rootScope.labels.showMe;
        }
		
        tourStr = "";
        tourStr += "<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-guide-info-wrapper'>" +
			"<button class='" + playClass + " mgPlayerJSTest_lbl-btn' tourIndex='" + index + "'>" +
			tooltipHTML +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-play-icon mgPlayerJSTest_position-center mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-center mgPlayerJSTest_font-size-16'>" +
			playlabel +
			"<wmgPlayerJSTest_ id='mgPlayerJSTest_push-not-play-icon-svg' class='mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_margin-lr-10'> </wmgPlayerJSTest_>" +
			" </wmgPlayerJSTest_>" +
			"</button>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-guide-title' aria-label='" + GmCXt.escapeHtml(tourTitle) + "' tabindex='0'>" + GmCXt.escapeHtml(tourTitle) + "</wmgPlayerJSTest_>" +
			"</wmgPlayerJSTest_>";
		
    }

    return tourStr;
};

GmCXt.loadGuideNotifications = function(tours, isPreview, taskObj, step, isPageClicked) {
    GmCXt.log(37, "LOAD NOTIFICATIONS", {
        tours: tours
    });
    if (!GmCXt.user) return;
    if (get_store_value(Gm.isNotificationReqd)) GmCXt.alreadyLoadedNotif = [];
    Gm.isNotificationReqd.set(false);
    let matchedTours = [];
    let toursClosedByUser = {};
    let tourIdArray = {};

    let isAutolaunchTriggered = false;
    GmCXt.filterDontShowSnoozeTour = [];
    let guideAutomationInProgress = false;

    if (isPreview) {
        matchedTours = tours;

        if (GmCXt.isOnboarding(tours[0])) {
            playOnboardingTour(0, tours[0], step, taskObj);
        } else {
            showNotification();
        }
    } else {
        GmCXt.storage()
            .get(['toursClosed', 'tourIdArray', 'testAuto'])
            .then(function(st) {
                tourIdArray = st.tourIdArray;
                toursClosedByUser = GmCXt.parseJSON(st.toursClosed);
                if (st.testAuto) {
                    guideAutomationInProgress = st.testAuto.automationInProgress;
                }
                GmCXt.log(37, 'STORAGE NOTIFICATIONS DATA', st);

                GmCXt.getDoNotShowTours(false).then(function(tour) {
                    GmCXt.doNotShowTours = tour;
                    process(tours);
                });

                GmCXt.displayFrequencyGuides = GmCXt.user.settings.display_frequency_guides ? GmCXt.user.settings.display_frequency_guides : {};
            });
    }

    function isAlreadyShown(tour) {
        let retVal = false;
        for (let i = 0; i < GmCXt.alreadyLoadedNotif.length; i++) {
            if (parseInt(GmCXt.alreadyLoadedNotif[i].tour_id) === parseInt(tour.tour_id)) {
                retVal = true;
                break;
            }
        }

        return retVal;
    }

    function filterMatchedTours(tours) {
        GmCXt.log(10, "ALREADY SHOWN TOURS ", GmCXt.alreadyLoadedNotif);
        if (GmCXt.alreadyLoadedNotif.length > 0) {
            tours = tours.filter(function(t) {
                if (!isAlreadyShown(t)) {
                    return t;
                }
            });
        }
        return tours;
    }

    function process(tours) {
        if (!tours || tours.length < 1) {
            return;
        }

        filterdoNotShowTours();

        GmCXt.log(10, "DO NOT SHOW filter: " + tours.length, tours);

        tours = filterSnoozedTours();
        GmCXt.log(10, "SNOOZED TOURS ", tours);

        tours = filterMatchedTours(tours);
        GmCXt.log(10, "AFTER FILTERING ALREADY SHOWN TOURS ", tours);

        if (guideAutomationInProgress) {
            GmCXt.auto.trackNotificationForAutomation({
                tours: toursClosedByUser,
                doNotShowTours: GmCXt.doNotShowTours,
                isVisible: false
            });
        }

        updateFilterNotification();

        if (GmCXt.inPlayer) {
            tours = GmCXt.sortToursByModifcationDate(tours);
        }

        tours = sortToursByAutoLaunch(tours);

        GmCXt.log(10, "SORTING BY auto launch first", tours);

        GmCXt.log(10, "SNOOZE filter: " + tours.length, tours);

        if (tours.length) {
            validateRules(tours);
        }
    }

    function updateFilterNotification() {
        GmCXt.updateNotificationContentScript(toursClosedByUser, tourIdArray);
    }

    function validateGuideRules(tours) {
        GmCXt.log(10, "VALIDATING GUIDE RULES");

        function queueRule(data, ruleDelayTime) {
            GmCXt.timeout(function() {
                GmCXt.ruleEngine.queue(data);
            }, ruleDelayTime);
        }

        function validRule(t, ruleDelayTime) {
            GmCXt.timeout(function() {
                onRulesProcessed({
                    tour: t,
                    valid: true
                });
            }, ruleDelayTime);
        }

        for (let i = 0, len = tours.length; i < len; i++) {

            let tour = tours[i];
            let s = tour.tour_settings;
            let rules = (s && s.rules && s.rules.length) ? s.rules : [];

            let waitTime = s.ruleDelayTime || 0;
            let timeout = GmCXt.t.ruleTimeOut25ms;
            if (GmCXt.checkTourCreatedBefore(s, 2021013001)) {
                timeout = GmCXt.t.ruleTimeOut10s;
            }

            if (tour.ruleValidated) { // useful in json player when the tours are returned after validation 
                validRule(tour, waitTime);
            } else {
                let obj = {
                    tour: tour,
                    rules: rules,
                    timeoutVal: timeout,
                    timeout: timeout,
                    cb: onRulesProcessed,
                    isTour: true,
                    initiator: 'notif'
                };
                GmCXt.log(37, "QUEUED", obj);

                queueRule(obj, waitTime);
            }
        }
    }

    function segmentCb(t) {
        if (!GmCXt.isEmpty(t)) {
            validateGuideRules([t]);
        }
    }

    function validateRules(tours) {

        if (GmCXt.organization.admin_settings.guide_segmentation) {

            GmCXt.log(10, "VALIDATING GUIDE SEGMENTATION RULES");

            GmCXt.checkGuidesBasedOnSegment(tours, segmentCb, "notiSeg");

        } else {
            validateGuideRules(tours);
        }
    }

    function isDispFreqLimitReached(tour) {
        let retVal = false;
        if (!GmCXt.isEmpty(GmCXt.displayFrequencyGuides)) {
            let countObj = GmCXt.displayFrequencyGuides[parseInt(tour.tour_id)];
            if (GmCXt.isDefined(countObj)) {
                if (parseInt(countObj.version) === parseInt(tour.version)) {
                    if (countObj.playedCount >= tour.tour_settings.displayFrequencyTimes) {
                        return true;
                    }
                }
            }
        }

        return retVal;
    }

    function sortToursByAutoLaunch(tours) {
        let autoArr = [];
        let otherArr = [];
        for (let i = 0; i < tours.length; i++) {
            let ts = tours[i].tour_settings;
            if (ts.isAutolaunch) {
                autoArr.push(tours[i]);
            } else {
                otherArr.push(tours[i]);
            }
        }

        return autoArr.concat(otherArr);
    }

    function filterSnoozedTours() {

        return tours.filter(function(tour) {

            if (toursClosedByUser[tour.tour_id]) {

                let tourCloseTime;
                let version = 1;
                let checkVersion = toursClosedByUser[tour.tour_id].toString().split(":");
                if (GmCXt.isDefined(checkVersion[1])) {
                    tourCloseTime = parseInt(checkVersion[0]);
                    version = parseInt(checkVersion[1]);
                } else {
                    tourCloseTime = parseInt(toursClosedByUser[tour.tour_id]);
                }
                let currentTime = new Date().getTime();
                let customExpirytime = GmCXt.t.notifExp24;
                let nt = GmCXt.getAppSetting('notificationsTime');

                if (nt) {

                    if (nt === '.5') nt = '0.5';

                    let snoozeTime = parseFloat(nt);

                    if (typeof nt !== 'number' && nt.includes("week")) {
                        snoozeTime = GmCXt.convertWeeksToHours(snoozeTime);
                    }

                    customExpirytime = snoozeTime * GmCXt.t.snoozeNotif;
                }

                let expiryTime = tourCloseTime + customExpirytime;

                if (expiryTime - currentTime <= 0 || parseInt(tour.version) > version) {
                    delete toursClosedByUser[tour.tour_id];
                    return tour;
                } else {
                    GmCXt.filterDontShowSnoozeTour.push(parseInt(tour.tour_id));
                }
            } else {
                return tour;
            }
        });
    }

    function filterdoNotShowTours() {
        tours = tours.filter(function(t) {
            if (GmCXt.doNotShowTours[t.tour_id]) {

                let oldGuideVer = GmCXt.doNotShowTours[t.tour_id];

                if (parseInt(t.version) > oldGuideVer) {
                    if (!t.tour_settings.oneTimeNotification) {
                        return t;
                    }
                }
            } else return t;

        });
    }

    function displayNoneElement(elem) {
        let elm = document.getElementsByClassName(elem.replace('.', ''));

        // Loop through all elements using a for loop
        for (let i = 0; i < elm.length; i++) {
            elm[i].style.display = 'none'; 
        }
    }

    function displayBlockElement(elem) {
        let elm = document.getElementsByClassName(elem.replace('.', ''));

        // Loop through all elements using a for loop
        for (let i = 0; i < elm.length; i++) {
            elm[i].style.display = 'block'; 
        }
    }

    function updateMatchedTours(t) {

        delete t.ruleValidated;

        matchedTours.push(t);
        GmCXt.alreadyLoadedNotif.push(t);
        showNotification();
        GmCXt.trackerV1.trackPushNotification(t, 'display');
    }

    function getStepIndexFromTour(tour, step) {
        let stepIndex = 0;
        for (let i = 0; i < tour.steps.length; i++) {
            if (tour.steps[i].step_id === step.step_id) {
                stepIndex = i;
                break;
            }
        }

        return stepIndex;
    }

    function playOnboardingTour(index, tour, step, taskObj) {
        if (tour.tour_settings.tutorial_tour_type === 'tutorial') {
            GmCXt.storage().set({
                'tutorial_steps': []
            });
        }

        let stepIndex = 0;
        if (tour.steps.length === 0) {
            let d = {
                tour_id: tour.tour_id,
                category_id: tour.category_id,
                isPublic: tour.isPublic
            };
            rootScope.getSteps(d).then(function(tour) {
                GmCXt.log(39, "visible OnBoarding guide details ", tour.steps);
                tours[0].steps = tour.steps;
                if (step) {
                    stepIndex = getStepIndexFromTour(tour, step);
                }
                showTutorialHtml(index, stepIndex, taskObj);
            });
        } else {
            GmCXt.isLastStepPlayedOnCreateTutGuide = false;
            GmCXt.pdfPlayedOnUploadTut = false;
            GmCXt.fullPdfPlayedOnUploadTutGuide = false;
            GmCXt.pdfPlayedOnUploadTutNewTab = false;

            if (step) {
                stepIndex = getStepIndexFromTour(tour, step);
            }
            showTutorialHtml(index, stepIndex, taskObj);
        }

    }

    function onRulesProcessed(r) {

        if (r.valid) {
            updateMatchedTours(r.tour);
        }
    }

    function showNotification() {
        // gss - notification - panel
        showPopup(0);

        if (matchedTours.length === 1) {
            displayNoneElement('.mgPlayerJSTest_btn-next');
            displayNoneElement('.mgPlayerJSTest_btn-prev');
        }

        if (matchedTours.length > 1) {
            displayBlockElement('.mgPlayerJSTest_btn-next');
            displayBlockElement('.mgPlayerJSTest_btn-prev');
            disableArrow('.mgPlayerJSTest_btn-prev');
        }
    }

    function showPopup(index) {

        GmCXt.log(10, "SHOWING notifications", matchedTours);

        let tour = matchedTours[index];

        let tourStr = GmCXt.getOverlayToursHtml(tour, index, isPreview);
        let autoPlayTour = false;

        if (matchedTours.length === 1) {
            let tourSetting = matchedTours[0].tour_settings;
            if (!guideAutomationInProgress) {
                autoPlayTour = tourSetting.isAutolaunch;
            }

            GmCXt.log(10, "IS AUTO LAUNCH? " + autoPlayTour);
        }

        if (!isAutolaunchTriggered) {
            localStorage.setItem(GmCXt.storagePrefix + 'autoLaunchTour', 0);

            if (autoPlayTour) {
                playAutoLaunch();
            } else {
                showNotifHtml(tourStr, index, 0);
                if (guideAutomationInProgress) {
                    GmCXt.auto.trackNotificationForAutomation({
                        tours: matchedTours,
                        isVisible: true
                    });
                }
            }
        }
    }

    function showNotifHtml(tourStr, index, stepIndex) {
        let ts = GmCXt.parseJSON(matchedTours[index].tour_settings);

        if ((ts.videoNotification && matchedTours[index].video_url) ||
			(matchedTours[index].videoNotification && isPreview)) {

            let videoUrl = matchedTours[index].video_url;

            let orgVideoUrl = videoUrl + GmCXt.getCdnSign();

            videoUrl = GmCXt.getUrlWithLang(videoUrl);

            GmCXt.checkAssetUrl(videoUrl, orgVideoUrl, function(url) {
                displayNotifHtml(tourStr, index, stepIndex, url);
            });
        } else {

            rootScope.getTourSteps(matchedTours[index], function(d) {
                matchedTours[index] = d;
                displayNotifHtml(tourStr, index, stepIndex, '', ts);
            });

        }

        GmCXt.timeout(function() {
            mg$("#mgPlayerJSTest_btn-single-notif-dont-show-again").focus();
        }, 500);

    }

    function displayNotifHtml(tourStr, index, stepIndex, videoUrl, ts) {
        GmCXt.showNotificationHtml(isPageClicked);
        let html = getNotifHtml(tourStr, index, stepIndex, videoUrl);

        // Let the Notifications render when automation is running
        if (GmCXt.stopNotification(isPreview) && !guideAutomationInProgress) {
            return;
        }

        GmCXt.removeNotif();
        mg$("body").append(html);
        mg$('.mgPlayerJSTest_overlay-tours-popup').focus();
		
        if (ts && ts.tutorial_tour_type === 'announcement') {
            mg$(".mgPlayerJSTest_push-notification-container").addClass("mgPlayerJSTest_ann-notification-container");
            mg$(".mgPlayerJSTest_push-notification-header").addClass("mgPlayerJSTest_ann-notification-header");
            mg$(".mgPlayerJSTest_push-notification-btn-wrapper").addClass("mgPlayerJSTest_ann-notification-btn-wrapper");
            mg$(".mgPlayerJSTest_push-notification-content-wrapper").addClass("mgPlayerJSTest_ann-notification-content-wrapper");
            mg$(".mgPlayerJSTest_push-notification-title").html(matchedTours[index].tour_title);
            mg$('.mgPlayerJSTest_push-notification-title').attr('tourIndex', index);

            if (matchedTours && matchedTours[index] && matchedTours[index].steps[0]) {
                mg$(".mgPlayerJSTest_ann-notification-content-wrapper").html(getAnnouncementContent(index, 0));
            }

            mg$(".mgPlayerJSTest_push-notification-brand-logo").hide();
            bindAnnouncementTheme();

        } else {
            mg$(".mgPlayerJSTest_push-notification-container").removeClass("mgPlayerJSTest_ann-notification-container");
            mg$(".mgPlayerJSTest_push-notification-header").removeClass("mgPlayerJSTest_ann-notification-header");
            mg$(".mgPlayerJSTest_push-notification-btn-wrapper").removeClass("mgPlayerJSTest_ann-notification-btn-wrapper");
            mg$(".mgPlayerJSTest_push-notification-content-wrapper").removeClass("mgPlayerJSTest_ann-notification-content-wrapper");
            bindThemeColor();
        }

        addEvents();
        mg$("#mgPlayerJSTest_single-guide-play-icon-svg").html(GmCXt.svgs.notification_guide_play);
        mg$("#mgPlayerJSTest_push-not-play-icon-svg").html(GmCXt.svgs.push_not_single_play);
        mg$(".mgPlayerJSTest_btn-prev").html(GmCXt.svgs.push_prev);
        mg$(".mgPlayerJSTest_btn-next").html(GmCXt.svgs.push_prev);
        mg$("#mgPlayerJSTest_push-not-overlay-close").html(GmCXt.svgs.overlay_tour_popup_close);

        addStepPrevNext(index, stepIndex);

        GmCXt.timeout(function() {
            mg$('.mgPlayerJSTest_btn-next').focus();
            if (GmCXt.accessibility) {
                mg$(".mgPlayerJSTest_push-notification-btn-wrapper").addClass("mgPlayerJSTest_accessibility-theme");
                mg$(".mgPlayerJSTest_single-guide-play-icon").addClass("mgPlayerJSTest_accessibility-theme");
                mg$(".mgPlayerJSTest_push-play-icon").addClass("mgPlayerJSTest_ass-default-btn");
            }

            if (matchedTours.length === 1) {
                displayNoneElement('.mgPlayerJSTest_btn-next');
                displayNoneElement('.mgPlayerJSTest_btn-prev');
            }
            if (index === 0) {
                disableArrow('.mgPlayerJSTest_btn-prev');
            }

            if (matchedTours.length-1 === index) {
                disableArrow('.mgPlayerJSTest_btn-next');
            }
        }, 500);
    }

    function downloadFile(url) {
        window.open(url, '_blank');
    }

    function showTutorialHtml(index, stepIndex, taskObj) {
        let tour = matchedTours[index];
        var stepSett = matchedTours[index].steps[stepIndex].step_settings;

        if (GmCXt.stopNotification(isPreview)) {
            return;
        }

        if (tour.tour_settings.tutorial_tour_type === 'upload') {
            stepSett.tutorialUploadUrl = GmCXt.restoreAssetSrc(stepSett.tutorialUploadUrl);
            if (stepSett.tutorialUploadMode === 'new_tab' || GmCXt.getURLMediaType(stepSett.tutorialUploadUrl) !== "pdf") {
                let tutUrl = stepSett.tutorialUploadUrl;
                if (tutUrl.indexOf(GmCXt.conf.cdn) !== -1 && tutUrl.indexOf(GmCXt.user.cdn_signature.split("=")[0]) === -1 ) {
                    tutUrl = stepSett.tutorialUploadUrl + GmCXt.getCdnSign();
                }
                downloadFile(tutUrl);
                GmCXt.showSurveyForTutorial(tour);
                GmCXt.closeNotificationPopupSidePanel();
                checkTaskListComplete(taskObj);
                let source = "push_notification";
                if (taskObj && taskObj.taskId) {
                    GmCXt.handleCloseApp();
                    source = "task_list";
                }
                GmCXt.pdfPlayedOnUploadTutNewTab = true;
                GmCXt.trackerV1.trackTutGuide(tour, "upload_tutorial_guide_new_tab", source, taskObj.taskId);

            } else {
                GmCXt.pdfPlayedOnUploadTut = true;
                GmCXt.openPdf(stepSett.tutorialUploadUrl, tour, taskObj);
                mg$('.mgPlayerJSTest_media-player-panel').attr('style', 'width: ' + stepSett.tutorialWidth + '% !important; height: ' + stepSett.tutorialHeight + '% !important; display: block !important;');
                if (taskObj && taskObj.taskId) {
                    mg$('.mgPlayerJSTest_media-player-panel').addClass("mgPlayerJSTest_play-from-task-player");
                }
            }
            markTaskListGuideComplete(taskObj);
        } else {
            GmCXt.showNotificationHtml(isPageClicked, true);

            let html = getTutorialNotifTemplateMG(index, stepIndex);

            GmCXt.removeNotif();

            mg$("body").append(html);

            var stepSett = matchedTours[index].steps[stepIndex].step_settings;

            if (stepSett.tutorialHeight && stepSett.tutorialWidth) {
                mg$('.mgPlayerJSTest_overlay-tours-popup').attr('style', 'width: ' + stepSett.tutorialWidth + '% !important; height: ' + stepSett.tutorialHeight + '% !important;');
            }

            mg$('.mgPlayerJSTest_push-notif-tg-bg').css('background', GmCXt.getAppSetting('tutorialBgColor'));

            let tutorialTheme = GmCXt.getAppSetting('tutorial_guide');

            if (tutorialTheme) {
                mg$('.mgPlayerJSTest_overlay-tours-popup.mgPlayerJSTest_push-notification-tg-container').css({
                    'background': GmCXt.getAppSetting('tutorialBgColor'),
                    'border-color': tutorialTheme.outerBox.border_color,
                    'border-radius': tutorialTheme.outerBox.border_radius + 'px ',
                    'border-width': tutorialTheme.outerBox.border_width + 'px '
                });

                if (tutorialTheme.outerBox.shadow.inset) {
                    mg$('.mgPlayerJSTest_push-notif-tg-bg').css({
                        'box-shadow': tutorialTheme.outerBox.shadow.color + ' ' + tutorialTheme.outerBox.shadow.horizontal + 'px ' + tutorialTheme.outerBox.shadow.vertical + 'px ' + tutorialTheme.outerBox.shadow.blur + 'px ' + tutorialTheme.outerBox.shadow.spreadRadius + 'px' + (tutorialTheme.outerBox.shadow.inset ? ' inset' : '')
                    });
                } else {
                    mg$('.mgPlayerJSTest_overlay-tours-popup.mgPlayerJSTest_push-notification-tg-container').css({
                        'box-shadow': tutorialTheme.outerBox.shadow.color + ' ' + tutorialTheme.outerBox.shadow.horizontal + 'px ' + tutorialTheme.outerBox.shadow.vertical + 'px ' + tutorialTheme.outerBox.shadow.blur + 'px ' + tutorialTheme.outerBox.shadow.spreadRadius + 'px'
                    });
                }

                mg$('.mgPlayerJSTest_push-notification-header').attr('style',
                    'background:' + tutorialTheme.titleBgColor + ' !important;' +
					'border-top-right-radius:' + tutorialTheme.outerBox.border_radius + 'px !important;' +
					'border-top-left-radius:' + tutorialTheme.outerBox.border_radius + 'px !important;' +
					'padding:' + '5px 20px;'
                );

                mg$('.mgPlayerJSTest_push-notif-tg-btn-wrapper').attr('style',
                    'border-bottom-right-radius:' + tutorialTheme.outerBox.border_radius + 'px !important;' +
					'border-bottom-left-radius:' + tutorialTheme.outerBox.border_radius + 'px !important;' +
					'padding:' + '5px 0px;'
                );

                mg$('.mgPlayerJSTest_btn-next-step').attr('style',
                    'background:' + tutorialTheme.nextBtn.bgColor + ' !important;' +
					'border-color:' + tutorialTheme.nextBtn.border_color + ' !important;' +
					'border-radius:' + tutorialTheme.nextBtn.border_radius + 'px !important;' +
					'border-width:' + tutorialTheme.nextBtn.border_width + 'px !important;' +
					'color:' + tutorialTheme.nextBtn.color + ' !important;' +
					'font-size:' + tutorialTheme.nextBtn.font_size + ' !important;' +
					'padding-bottom:' + tutorialTheme.nextBtn.padding.bottom + 'px !important;' +
					'padding-left:' + tutorialTheme.nextBtn.padding.left + 'px !important;' +
					'padding-right:' + tutorialTheme.nextBtn.padding.right + 'px !important;' +
					'padding-top:' + tutorialTheme.nextBtn.padding.top + 'px !important;'
                );

                mg$('.mgPlayerJSTest_btn-prev-step').attr('style',
                    'background:' + tutorialTheme.prevBtn.bgColor + ' !important;' +
					'border-color:' + tutorialTheme.prevBtn.border_color + ' !important;' +
					'border-radius:' + tutorialTheme.prevBtn.border_radius + 'px !important;' +
					'border-width:' + tutorialTheme.prevBtn.border_width + 'px !important;' +
					'color:' + tutorialTheme.prevBtn.color + ' !important;' +
					'font-size:' + tutorialTheme.prevBtn.font_size + ' !important;' +
					'padding-bottom:' + tutorialTheme.prevBtn.padding.bottom + 'px !important;' +
					'padding-left:' + tutorialTheme.prevBtn.padding.left + 'px !important;' +
					'padding-right:' + tutorialTheme.prevBtn.padding.right + 'px !important;' +
					'padding-top:' + tutorialTheme.prevBtn.padding.top + 'px !important;'
                );
            }

            mg$(".mgPlayerJSTest_tg-close-btn").html(GmCXt.svgs.overlay_tour_popup_close);
            mg$(".mgPlayerJSTest_push-notification-tutorial").html(GmCXt.svgs.tutorial);

            addEvents(taskObj);
            addStepPrevNext(index, stepIndex);

            GmCXt.timeout(function() {
                mg$(".mgPlayerJSTest_tg-close-btn").focus();
            }, 500);
        }

    }

    function addStepPrevNext(index, stepIndex) {
        let tour = matchedTours[index];
        if (GmCXt.isOnboarding(tour) && !rootScope.isAnnouncement(tour)) {
            let stepsLength = tour.steps.length;
            if (stepsLength === 1) {
                displayNoneElement('.mgPlayerJSTest_btn-prev-step');
                displayBlockElement('.mgPlayerJSTest_btn-next-step');
            }

            if (stepsLength > 1) {
                displayBlockElement('.mgPlayerJSTest_btn-next-step');
                displayBlockElement('.mgPlayerJSTest_btn-prev-step');
                disableButton('.mgPlayerJSTest_btn-prev-step');
            }
            if (stepIndex > 0) {
                enableButton('.mgPlayerJSTest_btn-prev-step');
            }
            if (stepsLength === stepIndex + 1) {
                GmCXt.isLastStepPlayedOnCreateTutGuide = true;
                mg$('.mgPlayerJSTest_btn-next-step').text(rootScope.labels.close);
            }
        }
    }

    function getNotifHtml(tStr, index, stepIndex, videoUrl) {
        let html = '';
        let ts = GmCXt.parseJSON(matchedTours[index].tour_settings);

        if ((ts.videoNotification && matchedTours[index].video_url) ||
			(matchedTours[index].videoNotification && isPreview)) {

            html = getSingleVideoNotifTemplateMG(index, videoUrl);
        } else {
            html = getSingleNotifTemplateMG(tStr, index);
        }

        return html;
    }

    function playAutoLaunch() {
        GmCXt.log(10, "AUTO LAUNCH guide");
        localStorage.setItem(GmCXt.storagePrefix + 'autoLaunchTour', matchedTours[0].tour_id);
        isAutolaunchTriggered = true;
        playGuide(null, 0);
    }

    function hidePopup() {
        mg$(".mgPlayerJSTest_overlay-tours-popup").hide();
        mg$(".mgPlayerJSTest_overlay-container").hide();
    }

    function getSingleNotifTemplateMG(tourStr, index) {
        let previewClass = '';
        let previewBtn = '';
        if (isPreview) {
            previewClass = ' mgPlayerJSTest_forbidden';
            previewBtn = "<button id='mgPlayerJSTest_push-not-overlay-close' class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_notification-common-btn mgPlayerJSTest_close-preview-btn' aria-label='push notification overlay close'></button>";
        }

        let html =
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-container'></wmgPlayerJSTest_>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-tours-popup mgPlayerJSTest_push-notification-container mgPlayerJSTest_push-notification-multi-guides' tabindex='0' role='dialog' aria-labelledby='" + rootScope.labels.notificationHeader + "'>" +
			previewBtn +
			"<button id='mgPlayerJSTest_btn-single-notif-prev' class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_btn-prev' aria-label='push notification previous button' ></button>" +
			"<button id='mgPlayerJSTest_btn-single-notif-next' class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_btn-next' aria-label='push notification next button'></button>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-header'>" +
			"<h3 class='mgPlayerJSTest_push-notification-title mgPlayerJSTest_no-margin mgPlayerJSTest_font-weight-normal' aria-label='" + rootScope.labels.notificationHeader + "' tabindex='0'>" + rootScope.labels.notificationHeader + "</h3>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-brand-logo' tabindex='0'>" + GmCXt.getPopupLogo() + "</wmgPlayerJSTest_>" +
			"</wmgPlayerJSTest_>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-content-wrapper mgPlayerJSTest_position-relative mgPlayerJSTest_position-center'>" +
			tourStr +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_multi-push-carousels-wrapper'></wmgPlayerJSTest_>" +
			"</wmgPlayerJSTest_>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-btn-wrapper'>";

        let ts = matchedTours[index].tour_settings;
        if (ts.displayFrequency && !isPreview) {
            html += "<button id='mgPlayerJSTest_btn-single-close' class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_notification-common-btn mgPlayerJSTest_btn-watch-close' tourIndex='" + index + "' tabindex='0' aria-label='push notification close button'>" +
				rootScope.labels.close + "</button>" +
				"</wmgPlayerJSTest_>";

        } else {
            html += "<button id='mgPlayerJSTest_btn-single-notif-dont-show-again' class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_notification-common-btn mgPlayerJSTest_btn-dont-show-again mgPlayerJSTest_never-show-again-button" + previewClass + "' aria-label='" + rootScope.labels.dontShowAgain + "'>" + rootScope.labels.dontShowAgain + "</button>" +
				"<button id='mgPlayerJSTest_btn-single-notif-watch-later' class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_notification-common-btn mgPlayerJSTest_btn-watch-later" + previewClass + "' aria-label='" + rootScope.labels.watchLater + "'>" + rootScope.labels.watchLater + "</button>" +
				"</wmgPlayerJSTest_>";
        }
        html += "</wmgPlayerJSTest_>";

        return html;
    }

    function getSingleVideoNotifTemplateMG(index, videoUrl) {
        let previewClass = '';
        let previewBtn = '';
        let poster_url = '';
        let src = '';
        if (isPreview) {
            previewClass = ' mgPlayerJSTest_forbidden';
            previewBtn = "<button id='mgPlayerJSTest_push-not-overlay-close' class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_close-preview-btn' aria-label='push notification overlay close'></button>";
            poster_url = GmCXt.getDefaultGuideIcon();
        }

        if (videoUrl) src = videoUrl;

        let html =
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-container'></wmgPlayerJSTest_>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-tours-popup mgPlayerJSTest_push-notification-container mgPlayerJSTest_push-notification-video-container' tabindex='0'>" +
			previewBtn +
			"<button id='mgPlayerJSTest_btn-single-vid-notif-prev' class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_btn-prev' aria-label='push notification previous button'></button>" +
			"<button id='mgPlayerJSTest_btn-single-vid-notif-next' class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_btn-next' aria-label='push notification next button'></button>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-header'>" +
			"<h3 class='mgPlayerJSTest_push-notification-title mgPlayerJSTest_no-margin mgPlayerJSTest_font-weight-normal' tabindex='0'>" + rootScope.labels.notificationHeader + "</h3>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-brand-logo mgPlayerJSTest_push-notification-guide-info-overlay' ' tourIndex='" + index + "'>" + GmCXt.getPopupLogo() + "</wmgPlayerJSTest_>" +
			"</wmgPlayerJSTest_>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-content-wrapper mgPlayerJSTest_position-relative mgPlayerJSTest_video-content-wrapper mgPlayerJSTest_position-center'>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-guide-info-wrapper mgPlayerJSTest_video-info-wrapper'>" +
			"<video controls autoplay controlsList='nodownload' disablePictureInPicture poster=" + poster_url + ">" +
			"<source src='" + src + "' type='video/mp4'>" +
			"</video>" +
			"</wmgPlayerJSTest_>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-video-title mgPlayerJSTest_inline-block-vm'>" + GmCXt.escapeHtml(matchedTours[index].tour_title) + "</wmgPlayerJSTest_>" +
			"</wmgPlayerJSTest_>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-btn-wrapper'>";

        let ts = matchedTours[index].tour_settings;
        if (ts.displayFrequency && !isPreview) {
            html += "<button id='mgPlayerJSTest_btn-close' class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_notification-common-btn mgPlayerJSTest_btn-watch-close' aria-label='push notification close button' tourIndex='" + index + "'>" + rootScope.labels.close + "</button>" +
				"</wmgPlayerJSTest_>";

        } else {
            html += "<button id='mgPlayerJSTest_btn-single-vid-notif-dont-show-again' class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_notification-common-btn mgPlayerJSTest_btn-dont-show-again mgPlayerJSTest_never-show-again-button" + previewClass + "' aria-label='" + rootScope.labels.dontShowAgain + "'>" + rootScope.labels.dontShowAgain + "</button>" +
				"<button id='mgPlayerJSTest_btn-single-vid-notif-watch-later' class='mgPlayerJSTest_lbl-btn mgPlayerJSTest_notification-common-btn mgPlayerJSTest_btn-watch-later" + previewClass + "' aria-label='" + rootScope.labels.watchLater + "'>" + rootScope.labels.watchLater + "</button>" +
				"</wmgPlayerJSTest_>";
        }

        html += "</wmgPlayerJSTest_>";

        return html;
    }

    function getTutorialStepBanner(step, poster_url) {
        let brandHtml = '';
        if (step.step_video > 0 && step && step.step_video_url) {
            brandHtml = "<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-guide-info-wrapper mgPlayerJSTest_video-info-wrapper mgPlayerJSTest_width-webkit-fill-available'>" +
				"<video controls autoplay controlsList='nodownload' disablePictureInPicture poster=" + poster_url + ">" +
				"<source src='" + step.step_video_url + GmCXt.getCdnSign() + "' type='video/mp4'>" +
				"</video></wmgPlayerJSTest_>";

        } else if (step.image_url.indexOf('default') < 0) {
            brandHtml = "<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-guide-info-wrapper mgPlayerJSTest_img-info-wrapper mgPlayerJSTest_width-webkit-fill-available'>" +
				"<img class='mgPlayerJSTest_push-notif-tg-image mgPlayerJSTest_width-90 mgPlayerJSTest_height-90' alt='" + step.step_title + "' src='" + step.image_url + GmCXt.getCdnSign() + "' /></wmgPlayerJSTest_>";
        }
        return brandHtml;
    }

    function getAnnouncementContent(index, stepIndex) {
        let poster_url = '';
        let tempClass = '';

        let tour = matchedTours[index];

        if (!GmCXt.isEmpty(tour) && GmCXt.isEmpty(tour.steps)) {
            tour = rootScope.getTourFromId(tour.tour_id, tour.category_id);
        }

        let step = tour.steps[stepIndex];

        if (GmCXt.isEmpty(step)) return "";

        let dynamicHtml = getTutorialStepBanner(step, poster_url);
        let stepText = GmCXt.replaceVariableWithValue(GmCXt.updateOrgAndAddSignature(step.step_description));

        if (dynamicHtml) {
            tempClass = 'mgPlayerJSTest_min-content-wrapper';
        }

        let html = dynamicHtml +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notif-tg-content-wrapper mgPlayerJSTest_inline-block-vm " + tempClass + "'>" + stepText + "</wmgPlayerJSTest_>";

        return html;
    }

    function getTutorialNotifTemplateMG(index, stepIndex) {
        let poster_url = '';
        let tempClass = '';

        let tour = matchedTours[index];
        let step = tour.steps[stepIndex];
        let dynamicHtml = getTutorialStepBanner(step, poster_url);
        let stepText = GmCXt.replaceVariableWithValue(GmCXt.updateOrgAndAddSignature(step.step_description));

        if (dynamicHtml) {
            tempClass = 'mgPlayerJSTest_min-content-wrapper';
        }

        if (!GmCXt.isEmpty(step.step_title)) {
            stepText = step.step_title + step.step_description;
        }

        let tourTitle = tour.tour_title;
        if (tourTitle.length > 45) {
            tourTitle = tourTitle.substr(0, 45) + " ...";
        }
        let html =
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-container'></wmgPlayerJSTest_>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_overlay-tours-popup mgPlayerJSTest_push-notification-container mgPlayerJSTest_push-notification-video-container mgPlayerJSTest_push-notification-tg-container' tabindex='0'>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-header mgPlayerJSTest_tutotial-notif-header'>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-title mgPlayerJSTest_push-notification-guide-info-overlay' ' tourIndex='" + index + "' ' stepIndex='" + stepIndex + "'>" +
			"<span id='mgPlayerJSTest_push-notification-tutorial' ></span>" + GmCXt.escapeHtml(tourTitle) +
			"</wmgPlayerJSTest_>" +
			"<button class='mgPlayerJSTest_tg-close-btn mgPlayerJSTest_lbl-btn' aria-label='tutorial guide close button'></button>" +
			"</wmgPlayerJSTest_>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notification-content-wrapper mgPlayerJSTest_position-relative mgPlayerJSTest_video-content-wrapper mgPlayerJSTest_height-auto mgPlayerJSTest_push-notif-tg-bg'>" +
			dynamicHtml +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notif-tg-content-wrapper mgPlayerJSTest_inline-block-vm " + tempClass + "'>" + stepText + "</wmgPlayerJSTest_>" +
			"</wmgPlayerJSTest_>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_push-notif-tg-btn-wrapper mgPlayerJSTest_display-flex mgPlayerJSTest_align-items-center mgPlayerJSTest_justify-content-space-around mgPlayerJSTest_push-notif-tg-bg'>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_step-count-wrapper'>" +
			"" + parseInt(stepIndex + 1) + "/" + tour.steps.length + "" +
			"</wmgPlayerJSTest_>" +
			"<wmgPlayerJSTest_ class='mgPlayerJSTest_common-btn-wrapper mgPlayerJSTest_display-flex'>" +
			"<button class='mgPlayerJSTest_btn-prev-step' aria-label='tutorial guide previous button'>" + rootScope.labels.btnPrevious + "</button>" +
			"<button class='mgPlayerJSTest_btn-next-step' aria-label='tutorial guide next button'>" + rootScope.labels.defaultNext + "</button>" +
			"</wmgPlayerJSTest_>" +
			"</wmgPlayerJSTest_>" +
			"</wmgPlayerJSTest_>";

        return html;
    }

    function addEvents(taskObj) {

        mg$(".mgPlayerJSTest_never-show-again-button").on("click", onDontShowAgainOneGuide);

        mg$(".mgPlayerJSTest_overlay-tour-box").on("click", playGuide);

        mg$(".mgPlayerJSTest_overlay-tour-box-small-thumbnails").on("click", playGuide);

        mg$(".mgPlayerJSTest_single-guide-play-icon").on("click", playGuide);

        mg$(".mgPlayerJSTest_overlay-tours-popup .mgPlayerJSTest_close-button").on("click", onClose);

        mg$(".mgPlayerJSTest_btn-watch-later").on("click", onClose);

        mg$(".mgPlayerJSTest_btn-prev").on('click', pushPrev);

        mg$(".mgPlayerJSTest_btn-next").on('click', pushNext);

        mg$(".mgPlayerJSTest_btn-prev-step").on('click', function(e) {
            pushPrevStep(e, taskObj);
        });

        mg$(".mgPlayerJSTest_btn-next-step").on('click', function(e) {
            pushNextStep(e, taskObj);
        });

        mg$(".mgPlayerJSTest_tg-close-btn").on("click", function(e) {
            closePreviewNotif(taskObj);
        });

        let tutorialContent = mg$(".mgPlayerJSTest_push-notif-tg-content-wrapper").html();

        if (tutorialContent && tutorialContent.indexOf("<a ") !== -1) {
            mg$('.mgPlayerJSTest_push-notif-tg-content-wrapper a').each(function() {
                mg$('.mgPlayerJSTest_push-notif-tg-content-wrapper a').on("click", function(e) {
                    if (e.currentTarget.target && e.currentTarget.target !== '_blank') {
                        e.preventDefault();
                        e.stopPropagation();
                        hidePopup();
                        GmCXt.isTutorialLink = true;
                        GmCXt.openPdf(e.currentTarget.href);
                    }
                });
            });
        }


        if (isPreview) {
            mg$(".mgPlayerJSTest_close-preview-btn").on('click', closePreviewNotif);
        }

        mg$(".mgPlayerJSTest_btn-watch-close").on("click", closeDisplayFrequencyNotif);
    }

    function playGuide(e, index) {
        if (guideAutomationInProgress) {
            GmCXt.auto.stop(true);
            return;
        }
        if (isPreview) {
            return;
        }

        if (index !== 0) {
            e.stopPropagation();
            index = this.attributes.tourIndex.value;
        }

        if (index < matchedTours.length) {

            let tour = matchedTours[index];

            if (tour.tour_settings.displayFrequency) {
                markDisplayFrequency(tour);
            }

            if (!GmCXt.isOnboarding(tour)) {
                GmCXt.trackerV1.trackPushNotification(tour, 'click');
            }

            let d = {
                tour_id: tour.tour_id,
                category_id: tour.category_id
            };

            rootScope.getSteps(d).then(function(_tour) {
                hidePopup();

                if (GmCXt.stopNotification(isPreview)) {
                    return;
                }
                if (!tour.tour_settings.displayFrequency) {
                    markAsDoNotShow(tour);
                }
                if (GmCXt.isOnboarding(_tour)) {
                    matchedTours[index].steps = _tour.steps;
                    playOnboardingTour(index, _tour);
                } else {
                    GmCXt.playLiveTour(_tour, 0, 'overlayTourPopup', isAutolaunchTriggered, 'live');
                }
            });
        }
    }

    function disableArrow(selector) {
        mg$(selector).css({
            "pointer-events": "none",
            "opacity": ".5"
        });
    }

    function enableArrow(selector) {
        mg$(selector).css({
            "pointer-events": "auto",
            "opacity": "1",
            "display": "block"
        });
    }

    function disableButton(selector) {
        mg$(selector).css({
            "pointer-events": "none",
            "opacity": ".5",
        });
    }

    function enableButton(selector) {
        mg$(selector).css({
            "pointer-events": "auto",
            "opacity": "1",
            "display": "block"
        });
    }

    function updateNotification(index, stepIndex) {
        let tour = matchedTours[index];
        let tourStr = GmCXt.getOverlayToursHtml(tour, index, isPreview);
        showNotifHtml(tourStr, index, stepIndex);

    }

    function pushNext(e) {
        let index = getCurrentindex() + 1;
        if (index > matchedTours.length - 1) {
            index = 0;
        }
        updateNotification(index, 0);
        mg$('.mgPlayerJSTest_btn-next')[0].removeAttribute('style');
        updateArrowOnNext(index);
        mg$('.mgPlayerJSTest_btn-next').focus();
    }

    function updateArrowOnNext(index) {
        if (matchedTours.length === index + 1) {
            mg$('.mgPlayerJSTest_btn-next').removeAttr("style");
            disableArrow('.mgPlayerJSTest_btn-next');
            mg$('.mgPlayerJSTest_btn-prev').focus();
        }
        mg$('.mgPlayerJSTest_btn-prev')[0].removeAttribute('style');
        enableArrow('.mgPlayerJSTest_btn-prev');
    }

    function pushPrev(e) {
        let index = getCurrentindex() - 1;
        if (index < 0) {
            index = 0;
        }
        updateNotification(index, 0);
        updateArrowOnPrev(index);
    }

    function updateArrowOnPrev(index) {
        if (index === 0) {
            mg$('.mgPlayerJSTest_btn-next').removeAttr("style");
            mg$('.mgPlayerJSTest_btn-prev').removeAttr("style");
            disableArrow('.mgPlayerJSTest_btn-prev');
            if (matchedTours.length > 1) {
                enableArrow('.mgPlayerJSTest_btn-next');
            }
        }
    }

    function pushNextStep(e, taskObj) {
        let tIndex = getCurrentindex();
        let stepIndex = getStepCurrentindex() + 1;
        let tour = matchedTours[tIndex];

        if (tour) {
            if (tour.steps.length === stepIndex) {
                markTaskListGuideComplete(taskObj);
                GmCXt.closeNotificationPopupSidePanel();
                if (GmCXt.isPlayer() && tour.tour_type.indexOf('onboarding_tour') !== -1 && tour.tour_settings.sentiment && tour.tour_settings.sentiment.sentimentCode) {
                    let data = {
                        tour: tour,
                        guideNotCompleted: false
                    };
                    GmCXt.handleCloseApp();
                    GmCXt.getSurveyScreen(data, false);
                }

                let source = "push_notification";
                if (taskObj && taskObj.taskId) {
                    source = "task_list";
                }

                recordEvent(tour.steps[tour.steps.length - 1]).then(function() {
                    GmCXt.trackerV1.trackTutGuide(tour, "create_tutorial_guide", source, taskObj.taskId);
                });
            } else {
                showTutorialHtml(tIndex, stepIndex, taskObj);
                recordEvent(tour.steps[stepIndex - 1]).then(function() {});
            }
        }

    }

    function recordEvent(step) {
        return new Promise(function(resolve, reject) {
            GmCXt.storage().get(['tutorial_steps']).then(function(st) {
                if (step) {
                    st.tutorial_steps.push(step);
                    GmCXt.storage().set({
                        'tutorial_steps': st.tutorial_steps
                    });
                }
                resolve();
            });
        });
    }

    function pushPrevStep(e, taskObj) {
        let tIndex = getCurrentindex();
        let stepIndex = getStepCurrentindex() - 1;
        showTutorialHtml(tIndex, stepIndex, taskObj);
    }

    function updateMatchedTour(index) {
        matchedTours.splice(index, 1);
        if (matchedTours.length === 0) {
            GmCXt.closeNotificationPopupSidePanel(true);
        } else {
            showNotification();
        }
    }

    function onDontShowAgainOneGuide() {
        if (guideAutomationInProgress) {
            GmCXt.auto.stop(true);
            return;
        }
        if (!isPreview) {
            let tIndex = getCurrentindex();

            if (matchedTours[tIndex].tour_settings.displayFrequency) {
                markDisplayFrequency(matchedTours[tIndex]);
            } else {
                markAsDoNotShow(matchedTours[tIndex]);
            }
            updateMatchedTour(tIndex);
        }
    }

    function markDisplayFrequency(tour) {

        if (tour) {
            if (GmCXt.displayFrequencyGuides[tour.tour_id] && parseInt(tour.version) === parseInt(GmCXt.displayFrequencyGuides[tour.tour_id].version)) {
                GmCXt.displayFrequencyGuides[tour.tour_id].playedCount++;
            } else {
                GmCXt.displayFrequencyGuides[tour.tour_id] = {};
                GmCXt.displayFrequencyGuides[tour.tour_id].version = parseInt(tour.version);
                GmCXt.displayFrequencyGuides[tour.tour_id].playedCount = 1;
            }

            GmCXt.updateGuideDisplayFrequency(GmCXt.displayFrequencyGuides);

            if (isDispFreqLimitReached(tour)) {
                markAsDoNotShow(tour);
            }
        }

    }

    function markAsDoNotShow(tour) {
        if (tour) {
            GmCXt.doNotShowTours[tour.tour_id] = parseInt(tour.version);
            GmCXt.updateNotification(GmCXt.doNotShowTours);
        }
    }

    function getCurrentindex() {
        return parseInt(mg$('.mgPlayerJSTest_push-notification-guide-info-overlay').attr('tourIndex')) ||
			parseInt(mg$('.mgPlayerJSTest_push-notification-title').attr('tourIndex')) || 0;
    }

    function getStepCurrentindex() {
        return parseInt(mg$('.mgPlayerJSTest_push-notification-guide-info-overlay').attr('stepIndex')) || 0;
    }

    function onClose() {
        if (guideAutomationInProgress) {
            GmCXt.auto.stop(true);
            return;
        }

        if (!isPreview) {
            let index = getCurrentindex();
            let tour = matchedTours[index];
            if (tour.tour_settings.oneTimeNotification) {
                onDontShowAgainOneGuide();
            } else {

                if (tour.tour_settings.displayFrequency) {
                    markDisplayFrequency(tour);

                } else {

                    let msg = rootScope.labels.pushSnoozeMsg + ' ';
                    GmCXt.setSnoozedTours(tour, msg);

                }
                updateMatchedTour(index);
            }
        }
    }

    function closePreviewNotif(taskObj) {
        let tIndex = getCurrentindex();
        let stepIndex = getStepCurrentindex() + 1;
        let tour = matchedTours[tIndex];
        checkTaskListComplete(taskObj);
        GmCXt.removeNotif();
        GmCXt.openSidePanelNotificaton();
        let source = "push_notification";
        if (taskObj && taskObj.taskId) {
            source = "task_list";
        }
        recordEvent(tour.steps[stepIndex - 1]).then(function() {
            GmCXt.trackerV1.trackTutGuide(tour, "create_tutorial_guide", source, taskObj.taskId);
        });
        let os = GmCXt.getOrgSettings();
        if (GmCXt.isPlayer() && stepIndex < tour.steps.length) {
            if (os && os.exitSentiment) {
                var data = {
                    tour: tour,
                    guideNotCompleted: true
                };
                GmCXt.handleCloseApp();
                GmCXt.getSurveyScreen(data, true);
            }
        } else if (GmCXt.isPlayer() && stepIndex === tour.steps.length) {
            if (tour.tour_type.indexOf('onboarding_tour') !== -1 && tour.tour_settings.sentiment && tour.tour_settings.sentiment.sentimentCode) {
                var data = {
                    tour: tour,
                    guideNotCompleted: false
                };
                GmCXt.handleCloseApp();
                GmCXt.getSurveyScreen(data, false);
            }
        }
    }

    function checkTaskListComplete(taskObj) {
        if (taskObj && taskObj.isComplete === '0') {
            let tIndex = getCurrentindex();
            let stepIndex = getStepCurrentindex() + 1;
            let tour = matchedTours[tIndex];
            if (tour.steps.length === stepIndex) {
                markTaskListGuideComplete(taskObj);
            }
        }
    }

    function markTaskListGuideComplete(taskObj) {
        if (taskObj && !taskObj.isComplete) {
            let index = getCurrentindex();
            let tour = matchedTours[index];
            let data = {
                taskListId: taskObj.taskId,
                tourId: tour.tour_id,
                complete_count: taskObj.complete_count,
                total_count: taskObj.total_count
            };

            rootScope.markTaskGuideComplete(data);
            taskObj = false;
        }
    }

    function bindAnnouncementTheme() {
        let nTheme = GmCXt.getAppSetting('notificationTheme');
        if (nTheme) {
            mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_push-notification-header").each(function() {
                if (nTheme.header.background) this.style.setProperty('background', nTheme.header.background, 'important');
            });


            mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_push-notification-header .mgPlayerJSTest_push-notification-title").each(function() {
                if (nTheme.header.color) this.style.setProperty('color', nTheme.header.color, 'important');
                if (nTheme.header.font) this.style.setProperty('font-family', nTheme.header.font, 'important');
            });
        }
    }

    function bindThemeColor() {
        let nTheme = GmCXt.getAppSetting('notificationTheme');

        if (nTheme) {
            if (isPreview) {
                GmCXt.timeout(function() {
                    mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_close-preview-btn svg polygon").each(function() {
                        if (nTheme.body.fill) this.style.setProperty('fill', nTheme.body.fill, 'important');
                    });
                }, 100);
            }

            mg$(".mgPlayerJSTest_push-notification-container").each(function() {
                if (nTheme.width) this.style.setProperty('width', nTheme.width + 'px', 'important');
                if (nTheme.height) this.style.setProperty('height', nTheme.height + 'px', 'important');
                if (nTheme.body && nTheme.body.background_color) this.style.setProperty('background', nTheme.body.background_color, 'important');
            });

            mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_push-notification-header").each(function() {
                if (nTheme.header.background) this.style.setProperty('background', nTheme.header.background, 'important');
            });


            mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_push-notification-header .mgPlayerJSTest_push-notification-title").each(function() {
                if (nTheme.header.color) this.style.setProperty('color', nTheme.header.color, 'important');
                if (nTheme.header.font) this.style.setProperty('font-family', nTheme.header.font, 'important');
            });

            mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_push-notification-content-wrapper").each(function() {
                if (nTheme.body.padding_top) this.style.setProperty('padding-top', nTheme.body.padding_top + 'px', 'important');
                if (nTheme.body.padding_right) this.style.setProperty('padding-right', nTheme.body.padding_right + 'px', 'important');
                if (nTheme.body.padding_bottom) this.style.setProperty('padding-bottom', nTheme.body.padding_bottom + 'px', 'important');
                if (nTheme.body.padding_left) this.style.setProperty('padding-left', nTheme.body.padding_left + 'px', 'important');
                if (nTheme.body.background_color) this.style.setProperty('background', nTheme.body.background_color, 'important');
            });

            mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_push-notification-content-wrapper .mgPlayerJSTest_push-notification-guide-info-wrapper .mgPlayerJSTest_push-notification-guide-title").each(function() {
                if (nTheme.body.title_color) this.style.setProperty('color', nTheme.body.title_color, 'important');
                if (nTheme.body.title_font_family) this.style.setProperty('font-family', nTheme.body.title_font_family, 'important');
                if (nTheme.body.title_font_size) this.style.setProperty('font-size', nTheme.body.title_font_size, 'important');
            });

            mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_push-notification-content-wrapper .mgPlayerJSTest_push-notification-video-title").each(function() {
                if (nTheme.body.title_color) this.style.setProperty('color', nTheme.body.title_color, 'important');
                if (nTheme.body.title_font_family) this.style.setProperty('font-family', nTheme.body.title_font_family, 'important');
                if (nTheme.body.title_font_size) this.style.setProperty('font-size', nTheme.body.title_font_size, 'important');
            });

            mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_push-notification-content-wrapper .mgPlayerJSTest_push-notification-guide-info-wrapper .mgPlayerJSTest_single-guide-play-icon .mgPlayerJSTest_push-play-icon").each(function() {
                if (nTheme.body.fill) this.style.setProperty('background', nTheme.body.fill, 'important');
            });

            mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_push-notification-btn-wrapper .mgPlayerJSTest_btn-dont-show-again").each(function() {
                if (nTheme.footer.primaryBtnBackground) this.style.setProperty('background', nTheme.footer.primaryBtnBackground, 'important');
                if (nTheme.footer.primaryBtnBorderColor) this.style.setProperty('border', '2px outset ' + nTheme.footer.primaryBtnBorderColor, 'important');
                if (nTheme.footer.primaryBtnFont) this.style.setProperty('font-family', nTheme.footer.primaryBtnFont, 'important');
                if (nTheme.footer.primaryBtnTextColor) this.style.setProperty('color', nTheme.footer.primaryBtnTextColor, 'important');
                if (nTheme.footer.primaryBtnTextSize) this.style.setProperty('font-size', nTheme.footer.primaryBtnTextSize, 'important');
            });

            mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_push-notification-btn-wrapper .mgPlayerJSTest_btn-watch-later").each(function() {
                if (nTheme.footer.secondaryBtnBackground) this.style.setProperty('background', nTheme.footer.secondaryBtnBackground, 'important');
                if (nTheme.footer.secondaryBtnBorderColor) this.style.setProperty('border', '2px outset ' + nTheme.footer.secondaryBtnBorderColor, 'important');
                if (nTheme.footer.secondaryBtnFont) this.style.setProperty('font-family', nTheme.footer.secondaryBtnFont, 'important');
                if (nTheme.footer.secondaryBtnTextColor) this.style.setProperty('color', nTheme.footer.secondaryBtnTextColor, 'important');
                if (nTheme.footer.secondaryBtnTextSize) this.style.setProperty('font-size', nTheme.footer.secondaryBtnTextSize, 'important');
            });

            mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_push-notification-btn-wrapper .mgPlayerJSTest_btn-watch-close").each(function() {
                if (nTheme.footer.primaryBtnBackground) this.style.setProperty('background', nTheme.footer.primaryBtnBackground, 'important');
                if (nTheme.footer.primaryBtnBorderColor) this.style.setProperty('border', '2px outset ' + nTheme.footer.primaryBtnBorderColor, 'important');
                if (nTheme.footer.primaryBtnFont) this.style.setProperty('font-family', nTheme.footer.primaryBtnFont, 'important');
                if (nTheme.footer.primaryBtnTextColor) this.style.setProperty('color', nTheme.footer.primaryBtnTextColor, 'important');
                if (nTheme.footer.primaryBtnTextSize) this.style.setProperty('font-size', nTheme.footer.primaryBtnTextSize, 'important');
            });

            GmCXt.timeout(function() {
                mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_btn-next path.st0").each(function() {
                    if (nTheme.body.fill) this.style.setProperty('fill', nTheme.body.fill, 'important');
                });

                mg$(".mgPlayerJSTest_push-notification-container .mgPlayerJSTest_btn-prev path.st0").each(function() {
                    if (nTheme.body.fill) this.style.setProperty('fill', nTheme.body.fill, 'important');
                });
            }, 100);
        }
    }

    function closeDisplayFrequencyNotif(e) {
        e.stopPropagation();
        let index = this.attributes.tourIndex.value;
        let tour = matchedTours[index];
        if (tour.tour_settings.displayFrequency) {
            markDisplayFrequency(tour);
        }
        updateMatchedTour(index);
    }
};

/*global GmCXt,mg$*/
let slideshow;
Gm.accessibility.subscribe((value) => {
    updateAccessibilityTheme(value);
    updatePlayerTheme(value);
    rootScope.setActivePage(get_store_value(Gm.activeView));
});

Gm.miniPlayer.subscribe((value) => {
    updateMiniPlayerTheme(value);
    updateMobileView(value);
});

GmCXt.onDapStoreInstanceReceived = function() {
    readStorage().then(() => {
  
        new App({
            target: document.getElementById('mgPlayerJSTest_ege-panel')
        });
  
        slideshow = new SlideShow({
            target: document.getElementById('mgPlayerJSTest_slideshow-panel')
        });
        Gm.slideshowInstance.set(slideshow);
        
        rootScope.subscribeEvents();
        rootScope.updateLabels();
        rootScope.reportInitialization();
  
    }).catch(error => {
        console.error("Initialization error:", error);
    });
};

Gm.activeView.set('signin');

function updateAccessibilityTheme(isAccessibility) {
    if (isAccessibility) {
        mg$('.mgPlayerJSTest_ege-panel').addClass('mgPlayerJSTest_accessibility-theme');
    } else {
        mg$('.mgPlayerJSTest_ege-panel').removeClass('mgPlayerJSTest_accessibility-theme');
    }
}

function updatePlayerTheme(isAccessibility) {
    if (GmCXt.FT.isPlayer && !isAccessibility) {
        mg$('.mgPlayerJSTest_ege-panel').addClass('mgPlayerJSTest_player-theme');
    } else {
        mg$('.mgPlayerJSTest_ege-panel').removeClass('mgPlayerJSTest_player-theme');
    }
}

function updateMobileView(isMicroPlayer) {
    if (!isMicroPlayer) {
        mg$('.mgPlayerJSTest_panel-body').addClass('mgPlayerJSTest_mobile-view');
    } else {
        mg$('.mgPlayerJSTest_panel-body').removeClass('mgPlayerJSTest_mobile-view');
    }
}

function updateMiniPlayerTheme(isMicroPlayer) {
    if(isMicroPlayer) {
        mg$('.mgPlayerJSTest_ege-panel').addClass('mgPlayerJSTest_micro-player-container mgPlayerJSTest_no-border mgPlayerJSTest_no-border-all');
    } else {
        mg$('.mgPlayerJSTest_ege-panel').removeClass('mgPlayerJSTest_micro-player-container mgPlayerJSTest_no-border mgPlayerJSTest_no-border-all');
    }
}

if(GmCXt.isClientJs()){
    GmCXt.onDapStoreInstanceReceived();
}
//# sourceMappingURL=sidepanel.js.map
